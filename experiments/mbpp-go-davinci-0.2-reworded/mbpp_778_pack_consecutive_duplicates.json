{
  "name": "mbpp_778_pack_consecutive_duplicates",
  "language": "go_test.go",
  "prompt": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_778_pack_consecutive_duplicates.py",
  "prompt_terminology": "reworded",
  "tests": "func TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result []interface{}\n        var temp []string\n        for i, v := range list {\n            if i == 0 {\n                temp = append(temp, v)\n            } else {\n                if v == list[i-1] {\n                    temp = append(temp, v)\n                } else {\n                    result = append(result, temp)\n                    temp = []string{v}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result []interface{}\n        var temp []int\n        for i, v := range list {\n            if i == 0 {\n                temp = append(temp, v)\n            } else {\n                if v == list[i-1] {\n                    temp = append(temp, v)\n                } else {\n                    result = append(result, temp)\n                    temp = []int{v}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result []interface{}\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 || sublist[len(sublist)-1] == list[i] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []string{list[i]}\n            }\n        }\n        if len(sublist) > 0 {\n            result = append(result, sublist)\n        }\n        return result\n    case []int:\n        list := list1.([]int)\n        var result []interface{}\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 || sublist[len(sublist)-1] == list[i] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []int{list[i]}\n            }\n        }\n        if len(sublist) > 0 {\n            result = append(result, sublist)\n        }\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = make([]string, 0)\n                    temp = append(temp, list[i])\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = make([]int, 0)\n                    temp = append(temp, list[i])\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result []interface{}\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result []interface{}\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var sublist []string\n        for i, v := range list {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = []string{v}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var sublist []int\n        for i, v := range list {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = []int{v}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 || sublist[0] == list[i] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        sublist := make([]string, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 || sublist[0] == list[i] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]string, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        sublist := make([]int, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 || sublist[0] == list[i] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]int, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        var result []interface{}\n        var temp []interface{}\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = nil\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        result := make([][]string, 0)\n        for i := 0; i < len(list); i++ {\n            sublist := make([]string, 0)\n            for j := i; j < len(list); j++ {\n                if list[i] == list[j] {\n                    sublist = append(sublist, list[j])\n                } else {\n                    break\n                }\n            }\n            result = append(result, sublist)\n            i += len(sublist) - 1\n        }\n        return result\n    case []int:\n        list := list1.([]int)\n        result := make([][]int, 0)\n        for i := 0; i < len(list); i++ {\n            sublist := make([]int, 0)\n            for j := i; j < len(list); j++ {\n                if list[i] == list[j] {\n                    sublist = append(sublist, list[j])\n                } else {\n                    break\n                }\n            }\n            result = append(result, sublist)\n            i += len(sublist) - 1\n        }\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        var result []interface{}\n        var sublist []interface{}\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []interface{}{}\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result []interface{}\n        var sublist []string\n        for i, v := range list {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = []string{v}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result []interface{}\n        var sublist []int\n        for i, v := range list {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = []int{v}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 {\n                sublist = append(sublist, list[i])\n            } else if sublist[0] == list[i] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if sublist[0] == list[i] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]interface{}, 0)\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if sublist[0] == list[i] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]interface{}, 0)\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        var sublist []string\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]string, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        var sublist []int\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]int, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    }\n    return nil\n}\n",
    "    var list2 []interface{}\n    var list3 []interface{}\n    var list4 []interface{}\n    var list5 []interface{}\n    var list6 []interface{}\n    var list7 []interface{}\n    var list8 []interface{}\n    var list9 []interface{}\n    var list10 []interface{}\n    var list11 []interface{}\n    var list12 []interface{}\n    var list13 []interface{}\n    var list14 []interface{}\n    var list15 []interface{}\n    var list16 []interface{}\n    var list17 []interface{}\n    var list18 []interface{}\n    var list19 []interface{}\n    var list20 []interface{}\n    var list21 []interface{}\n    var list22 []interface{}\n    var list23 []interface{}\n    var list24 []interface{}\n    var list25 []interface{}\n    var list26 []interface{}\n    var list27 []interface{}\n    var list28 []interface{}\n    var list29 []interface{}\n    var list30 []interface{}\n    var list31 []interface{}\n    var list32 []interface{}\n    var list33 []interface{}\n    var list34 []interface{}\n    var list35 []interface{}\n    var list36 []interface{}\n    var list37 []interface{}\n    var list38 []interface{}\n    var list39 []interface{}\n    var list40 []interface{}\n    var list41 []interface{}\n    var list42 []interface{}\n    var list43 []interface{}\n    var list44 []interface{}\n    var list45 []interface{}\n    var list46 []interface{}\n    var list47 []interface{}\n    var list48 []interface{}\n    var list49 []interface{}\n    var list50 []interface{}\n    var list51 []interface{}\n    var list52 []interface{}\n    var list53 []interface{}\n    var list54 []interface{}\n    var list55 []interface{}\n    var list56 []interface{}\n    var list57 []interface{}\n    var list58 []interface{",
    "    switch list1.(type) {\n    case []interface{}:\n        var list2 []interface{}\n        var list3 []interface{}\n        for _, v := range list1.([]interface{}) {\n            if len(list3) == 0 || list3[0] == v {\n                list3 = append(list3, v)\n            } else {\n                list2 = append(list2, list3)\n                list3 = []interface{}{v}\n            }\n        }\n        if len(list3) > 0 {\n            list2 = append(list2, list3)\n        }\n        return list2\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 {\n                sublist = append(sublist, list[i])\n            } else if sublist[0] == list[i] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    var list2 []interface{}\n    var list3 []interface{}\n    var list4 []interface{}\n    var list5 []interface{}\n    var list6 []interface{}\n    var list7 []interface{}\n    var list8 []interface{}\n    var list9 []interface{}\n    var list10 []interface{}\n    var list11 []interface{}\n    var list12 []interface{}\n    var list13 []interface{}\n    var list14 []interface{}\n    var list15 []interface{}\n    var list16 []interface{}\n    var list17 []interface{}\n    var list18 []interface{}\n    var list19 []interface{}\n    var list20 []interface{}\n    var list21 []interface{}\n    var list22 []interface{}\n    var list23 []interface{}\n    var list24 []interface{}\n    var list25 []interface{}\n    var list26 []interface{}\n    var list27 []interface{}\n    var list28 []interface{}\n    var list29 []interface{}\n    var list30 []interface{}\n    var list31 []interface{}\n    var list32 []interface{}\n    var list33 []interface{}\n    var list34 []interface{}\n    var list35 []interface{}\n    var list36 []interface{}\n    var list37 []interface{}\n    var list38 []interface{}\n    var list39 []interface{}\n    var list40 []interface{}\n    var list41 []interface{}\n    var list42 []interface{}\n    var list43 []interface{}\n    var list44 []interface{}\n    var list45 []interface{}\n    var list46 []interface{}\n    var list47 []interface{}\n    var list48 []interface{}\n    var list49 []interface{}\n    var list50 []interface{}\n    var list51 []interface{}\n    var list52 []interface{}\n    var list53 []interface{}\n    var list54 []interface{}\n    var list55 []interface{}\n    var list56 []interface{}\n    var list57 []interface{}\n    var list58 []interface{",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result []interface{}\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = []string{list[i]}\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result []interface{}\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = []int{list[i]}\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        var result []interface{}\n        var sublist []interface{}\n        var prev interface{}\n        for _, item := range list {\n            if prev == nil {\n                sublist = append(sublist, item)\n            } else if prev == item {\n                sublist = append(sublist, item)\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{item}\n            }\n            prev = item\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result []string\n        var temp string\n        for i, v := range list {\n            if i == 0 {\n                temp = v\n            } else {\n                if v == temp {\n                    temp = temp + v\n                } else {\n                    result = append(result, temp)\n                    temp = v\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result []int\n        var temp int\n        for i, v := range list {\n            if i == 0 {\n                temp = v\n            } else {\n                if v == temp {\n                    temp = temp + v\n                } else {\n                    result = append(result, temp)\n                    temp = v\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 {\n                sublist = append(sublist, list[i])\n            } else if sublist[0] == list[i] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        var prev interface{}\n        for _, item := range list {\n            if prev == nil {\n                prev = item\n                sublist = append(sublist, item)\n            } else if prev == item {\n                sublist = append(sublist, item)\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{item}\n                prev = item\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result []interface{}\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result []interface{}\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []int{}\n                    temp = append(temp, list[i])\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []string{}\n                    temp = append(temp, list[i])\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        for i := 0; i < len(list); {\n            j := i + 1\n            for ; j < len(list); j++ {\n                if list[i] != list[j] {\n                    break\n                }\n            }\n            result = append(result, list[i:j])\n            i = j\n        }\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        for i := 0; i < len(list); {\n            j := i + 1\n            for ; j < len(list); j++ {\n                if list[i] != list[j] {\n                    break\n                }\n            }\n            result = append(result, list[i:j])\n            i = j\n        }\n        return result\n    default:\n        panic(\"Unsupported type\")\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result []interface{}\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []string{}\n                    temp = append(temp, list[i])\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result []interface{}\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []int{}\n                    temp = append(temp, list[i])\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := []interface{}{}\n        sublist := []interface{}{list[0]}\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        for i, v := range list {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = []interface{}{v}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        for i := 0; i < len(list); {\n            j := i + 1\n            for ; j < len(list); j++ {\n                if list[i] != list[j] {\n                    break\n                }\n            }\n            result = append(result, list[i:j])\n            i = j\n        }\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]interface{}, 0)\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    var list2 []interface{}\n    var list3 []interface{}\n    switch list1.(type) {\n    case []string:\n        list2 = list1.([]string)\n        for i := 0; i < len(list2); i++ {\n            if i == 0 {\n                list3 = append(list3, list2[i])\n            } else {\n                if list2[i] == list2[i-1] {\n                    list3 = append(list3, list2[i])\n                } else {\n                    list3 = append(list3, []string{list2[i]})\n                }\n            }\n        }\n    case []int:\n        list2 = list1.([]int)\n        for i := 0; i < len(list2); i++ {\n            if i == 0 {\n                list3 = append(list3, list2[i])\n            } else {\n                if list2[i] == list2[i-1] {\n                    list3 = append(list3, list2[i])\n                } else {\n                    list3 = append(list3, []int{list2[i]})\n                }\n            }\n        }\n    }\n    return list3\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        for i := 0; i < len(list); {\n            j := i + 1\n            for ; j < len(list); j++ {\n                if list[j] != list[i] {\n                    break\n                }\n            }\n            result = append(result, list[i:j])\n            i = j\n        }\n        return result\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        for i := 0; i < len(list); {\n            j := i + 1\n            for ; j < len(list); j++ {\n                if list[j] != list[i] {\n                    break\n                }\n            }\n            result = append(result, list[i:j])\n            i = j\n        }\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        sublist := make([]string, 0)\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]string, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        sublist := make([]int, 0)\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]int, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == sublist[0] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := []interface{}{}\n        sublist := []interface{}{list[0]}\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := []interface{}{}\n        current := []interface{}{}\n        for i := 0; i < len(list); i++ {\n            if len(current) == 0 {\n                current = append(current, list[i])\n            } else if current[0] == list[i] {\n                current = append(current, list[i])\n            } else {\n                result = append(result, current)\n                current = []interface{}{}\n                current = append(current, list[i])\n            }\n        }\n        result = append(result, current)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := []interface{}{}\n        sublist := []interface{}{list[0]}\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]interface{}, 0)\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        temp := make([]string, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]string, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        temp := make([]int, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]int, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        var prev interface{}\n        for _, item := range list {\n            if prev == nil || prev == item {\n                sublist = append(sublist, item)\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{item}\n            }\n            prev = item\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        result := make([][]string, 0)\n        for i := 0; i < len(list); i++ {\n            sublist := make([]string, 0)\n            sublist = append(sublist, list[i])\n            for j := i + 1; j < len(list); j++ {\n                if list[i] == list[j] {\n                    sublist = append(sublist, list[j])\n                    i++\n                } else {\n                    break\n                }\n            }\n            result = append(result, sublist)\n        }\n        return result\n    case []int:\n        list := list1.([]int)\n        result := make([][]int, 0)\n        for i := 0; i < len(list); i++ {\n            sublist := make([]int, 0)\n            sublist = append(sublist, list[i])\n            for j := i + 1; j < len(list); j++ {\n                if list[i] == list[j] {\n                    sublist = append(sublist, list[j])\n                    i++\n                } else {\n                    break\n                }\n            }\n            result = append(result, sublist)\n        }\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        var list2 []interface{}\n        var list3 []interface{}\n        for _, v := range list1.([]interface{}) {\n            if len(list3) == 0 || list3[0] == v {\n                list3 = append(list3, v)\n            } else {\n                list2 = append(list2, list3)\n                list3 = []interface{}{v}\n            }\n        }\n        if len(list3) > 0 {\n            list2 = append(list2, list3)\n        }\n        return list2\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        var result [][]string\n        var sublist []string\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = nil\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        var result [][]int\n        var sublist []int\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = nil\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        var prev int\n        for i, v := range list {\n            if i == 0 {\n                temp = append(temp, v)\n            } else {\n                if v == prev {\n                    temp = append(temp, v)\n                } else {\n                    result = append(result, temp)\n                    temp = []int{v}\n                }\n            }\n            prev = v\n        }\n        result = append(result, temp)\n        return result\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        var prev string\n        for i, v := range list {\n            if i == 0 {\n                temp = append(temp, v)\n            } else {\n                if v == prev {\n                    temp = append(temp, v)\n                } else {\n                    result = append(result, temp)\n                    temp = []string{v}\n                }\n            }\n            prev = v\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    var list2 []interface{}\n    var sublist []interface{}\n    var prev interface{}\n    for _, v := range list1.([]interface{}) {\n        if v != prev {\n            if sublist != nil {\n                list2 = append(list2, sublist)\n            }\n            sublist = []interface{}{v}\n        } else {\n            sublist = append(sublist, v)\n        }\n        prev = v\n    }\n    if sublist != nil {\n        list2 = append(list2, sublist)\n    }\n    return list2\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := []interface{}{}\n        sublist := []interface{}{list[0]}\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case string:\n        str := list1.(string)\n        if len(str) == 0 {\n            return str\n        }\n        result := \"\"\n        sublist := string(str[0])\n        for i := 1; i < len(str); i++ {\n            if str[i] == str[i-1] {\n                sublist += string(str[i])\n            } else {\n                result += sublist\n                sublist = string(str[i])\n            }\n        }\n        result += sublist\n        return result\n    default:\n        panic(\"Unsupported type\")\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        current := make([]interface{}, 0)\n        current = append(current, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                current = append(current, list[i])\n            } else {\n                result = append(result, current)\n                current = make([]interface{}, 0)\n                current = append(current, list[i])\n            }\n        }\n        result = append(result, current)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 {\n                sublist = append(sublist, list[i])\n            } else if sublist[0] == list[i] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return []interface{}{}\n        }\n        result := []interface{}{}\n        current := []interface{}{list[0]}\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                current = append(current, list[i])\n            } else {\n                result = append(result, current)\n                current = []interface{}{list[i]}\n            }\n        }\n        result = append(result, current)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []interface{}{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        new_list := make([]interface{}, 0)\n        current_element := list[0]\n        current_list := make([]interface{}, 0)\n        for _, element := range list {\n            if element == current_element {\n                current_list = append(current_list, element)\n            } else {\n                new_list = append(new_list, current_list)\n                current_list = make([]interface{}, 0)\n                current_list = append(current_list, element)\n                current_element = element\n            }\n        }\n        new_list = append(new_list, current_list)\n        return new_list\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if sublist[0] == list[i] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]interface{}, 0)\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case string:\n        list := list1.(string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([]string, 0)\n        sublist := \"\"\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 {\n                sublist = string(list[i])\n            } else {\n                if sublist[0] == list[i] {\n                    sublist = sublist + string(list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = \"\"\n                    sublist = string(list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return []interface{}{}\n        }\n        result := []interface{}{}\n        sublist := []int{list[0]}\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []int{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return []interface{}{}\n        }\n        result := []interface{}{}\n        sublist := []string{list[0]}\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []string{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result []string\n        var temp string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = list[i]\n            } else {\n                if list[i] == temp {\n                    temp = temp + list[i]\n                } else {\n                    result = append(result, temp)\n                    temp = list[i]\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result []int\n        var temp int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = list[i]\n            } else {\n                if list[i] == temp {\n                    temp = temp + list[i]\n                } else {\n                    result = append(result, temp)\n                    temp = list[i]\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        result := []interface{}{}\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                result = append(result, []string{list[i]})\n            } else {\n                if list[i] == list[i-1] {\n                    result[len(result)-1] = append(result[len(result)-1].([]string), list[i])\n                } else {\n                    result = append(result, []string{list[i]})\n                }\n            }\n        }\n        return result\n    case []int:\n        list := list1.([]int)\n        result := []interface{}{}\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                result = append(result, []int{list[i]})\n            } else {\n                if list[i] == list[i-1] {\n                    result[len(result)-1] = append(result[len(result)-1].([]int), list[i])\n                } else {\n                    result = append(result, []int{list[i]})\n                }\n            }\n        }\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result []string\n        var temp string\n        for i, v := range list {\n            if i == 0 {\n                temp = v\n            } else if v == list[i-1] {\n                temp += v\n            } else {\n                result = append(result, temp)\n                temp = v\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result []int\n        var temp int\n        for i, v := range list {\n            if i == 0 {\n                temp = v\n            } else if v == list[i-1] {\n                temp += v\n            } else {\n                result = append(result, temp)\n                temp = v\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    list2 := []interface{}{}\n    list3 := []interface{}{}\n    for _, v := range list1.([]interface{}) {\n        if len(list3) == 0 {\n            list3 = append(list3, v)\n        } else if v == list3[0] {\n            list3 = append(list3, v)\n        } else {\n            list2 = append(list2, list3)\n            list3 = []interface{}{v}\n        }\n    }\n    list2 = append(list2, list3)\n    return list2\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        var prev interface{}\n        for _, item := range list {\n            if prev == nil {\n                sublist = append(sublist, item)\n            } else if item == prev {\n                sublist = append(sublist, item)\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{item}\n            }\n            prev = item\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        var prev interface{}\n        for _, v := range list {\n            if prev == nil {\n                prev = v\n                sublist = append(sublist, v)\n                continue\n            }\n            if prev == v {\n                sublist = append(sublist, v)\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{v}\n            }\n            prev = v\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        var list2 []interface{}\n        var list3 []interface{}\n        for i, v := range list1.([]interface{}) {\n            if i == 0 {\n                list3 = append(list3, v)\n            } else {\n                if v == list1.([]interface{})[i-1] {\n                    list3 = append(list3, v)\n                } else {\n                    list2 = append(list2, list3)\n                    list3 = []interface{}{v}\n                }\n            }\n        }\n        list2 = append(list2, list3)\n        return list2\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list2 := list1.([]interface{})\n        list3 := make([]interface{}, 0)\n        for i := 0; i < len(list2); i++ {\n            list4 := make([]interface{}, 0)\n            list4 = append(list4, list2[i])\n            for j := i + 1; j < len(list2); j++ {\n                if list2[i] == list2[j] {\n                    list4 = append(list4, list2[j])\n                    i++\n                } else {\n                    break\n                }\n            }\n            list3 = append(list3, list4)\n        }\n        return list3\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list2 := list1.([]interface{})\n        list3 := make([]interface{}, 0)\n        for i := 0; i < len(list2); i++ {\n            if i == 0 {\n                list3 = append(list3, []interface{}{list2[i]})\n            } else {\n                if list2[i] == list2[i-1] {\n                    list3[len(list3)-1] = append(list3[len(list3)-1].([]interface{}), list2[i])\n                } else {\n                    list3 = append(list3, []interface{}{list2[i]})\n                }\n            }\n        }\n        return list3\n    case string:\n        list2 := list1.(string)\n        list3 := make([]interface{}, 0)\n        for i := 0; i < len(list2); i++ {\n            if i == 0 {\n                list3 = append(list3, []interface{}{list2[i]})\n            } else {\n                if list2[i] == list2[i-1] {\n                    list3[len(list3)-1] = append(list3[len(list3)-1].([]interface{}), list2[i])\n                } else {\n                    list3 = append(list3, []interface{}{list2[i]})\n                }\n            }\n        }\n        return list3\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = []string{list[i]}\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = []int{list[i]}\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result []interface{}\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result []interface{}\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        result := []interface{}{}\n        sublist := []int{}\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 || sublist[len(sublist)-1] == list[i] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []int{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []string:\n        list := list1.([]string)\n        result := []interface{}{}\n        sublist := []string{}\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 || sublist[len(sublist)-1] == list[i] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []string{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := []interface{}{}\n        sublist := []interface{}{list[0]}\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    var list2 []interface{}\n    var list3 []interface{}\n    var list4 interface{}\n    var list5 interface{}\n    var list6 interface{}\n    var list7 interface{}\n    var list8 interface{}\n    var list9 interface{}\n    var list10 interface{}\n    var list11 interface{}\n    var list12 interface{}\n    var list13 interface{}\n    var list14 interface{}\n    var list15 interface{}\n    var list16 interface{}\n    var list17 interface{}\n    var list18 interface{}\n    var list19 interface{}\n    var list20 interface{}\n    var list21 interface{}\n    var list22 interface{}\n    var list23 interface{}\n    var list24 interface{}\n    var list25 interface{}\n    var list26 interface{}\n    var list27 interface{}\n    var list28 interface{}\n    var list29 interface{}\n    var list30 interface{}\n    var list31 interface{}\n    var list32 interface{}\n    var list33 interface{}\n    var list34 interface{}\n    var list35 interface{}\n    var list36 interface{}\n    var list37 interface{}\n    var list38 interface{}\n    var list39 interface{}\n    var list40 interface{}\n    var list41 interface{}\n    var list42 interface{}\n    var list43 interface{}\n    var list44 interface{}\n    var list45 interface{}\n    var list46 interface{}\n    var list47 interface{}\n    var list48 interface{}\n    var list49 interface{}\n    var list50 interface{}\n    var list51 interface{}\n    var list52 interface{}\n    var list53 interface{}\n    var list54 interface{}\n    var list55 interface{}\n    var list56 interface{}\n    var list57 interface{}\n    var list58 interface{}\n    var list59 interface{}\n    var list60 interface{}\n    var list61 interface{}\n    var list62 interface{}\n    var list63 interface{}\n    var list64 interface{}\n    var list65 interface",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        var last interface{}\n        for _, item := range list {\n            if last == nil {\n                last = item\n                sublist = append(sublist, item)\n            } else if item == last {\n                sublist = append(sublist, item)\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{item}\n                last = item\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        var result [][]int\n        var sublist []int\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i - 1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = nil\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        var result [][]string\n        var sublist []string\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i - 1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = nil\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = nil\n                    temp = append(temp, list[i])\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = nil\n                    temp = append(temp, list[i])\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return []interface{}{}\n        }\n        result := []interface{}{}\n        sublist := []interface{}{list[0]}\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i - 1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := []string{list[0]}\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                result[len(result)-1] += list[i]\n            } else {\n                result = append(result, list[i])\n            }\n        }\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := []int{list[0]}\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                result[len(result)-1] += list[i]\n            } else {\n                result = append(result, list[i])\n            }\n        }\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        current := make([]interface{}, 0)\n        current = append(current, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                current = append(current, list[i])\n            } else {\n                result = append(result, current)\n                current = make([]interface{}, 0)\n                current = append(current, list[i])\n            }\n        }\n        result = append(result, current)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list1_ := list1.([]interface{})\n        if len(list1_) == 0 {\n            return []interface{}{}\n        }\n        if len(list1_) == 1 {\n            return []interface{}{list1_}\n        }\n        list2 := []interface{}{}\n        list3 := []interface{}{}\n        for _, item := range list1_ {\n            if len(list3) == 0 {\n                list3 = append(list3, item)\n            } else {\n                if list3[0] == item {\n                    list3 = append(list3, item)\n                } else {\n                    list2 = append(list2, list3)\n                    list3 = []interface{}{item}\n                }\n            }\n        }\n        list2 = append(list2, list3)\n        return list2\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        result := make([][]string, 0)\n        temp := make([]string, 0)\n        for i := 0; i < len(list); i++ {\n            if len(temp) == 0 || temp[len(temp)-1] == list[i] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]string, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        result := make([][]int, 0)\n        temp := make([]int, 0)\n        for i := 0; i < len(list); i++ {\n            if len(temp) == 0 || temp[len(temp)-1] == list[i] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]int, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := []interface{}{}\n        current := list[0]\n        count := 0\n        for _, v := range list {\n            if v == current {\n                count++\n            } else {\n                result = append(result, []interface{}{current, count})\n                current = v\n                count = 1\n            }\n        }\n        result = append(result, []interface{}{current, count})\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result []interface{}\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if len(temp) == 0 || temp[len(temp)-1] == list[i] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = []string{list[i]}\n            }\n        }\n        if len(temp) > 0 {\n            result = append(result, temp)\n        }\n        return result\n    case []int:\n        list := list1.([]int)\n        var result []interface{}\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if len(temp) == 0 || temp[len(temp)-1] == list[i] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = []int{list[i]}\n            }\n        }\n        if len(temp) > 0 {\n            result = append(result, temp)\n        }\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        result := []interface{}{}\n        for i := 0; i < len(list); i++ {\n            sublist := []string{}\n            for j := i; j < len(list); j++ {\n                if list[i] == list[j] {\n                    sublist = append(sublist, list[j])\n                } else {\n                    break\n                }\n            }\n            result = append(result, sublist)\n            i += len(sublist) - 1\n        }\n        return result\n    case []int:\n        list := list1.([]int)\n        result := []interface{}{}\n        for i := 0; i < len(list); i++ {\n            sublist := []int{}\n            for j := i; j < len(list); j++ {\n                if list[i] == list[j] {\n                    sublist = append(sublist, list[j])\n                } else {\n                    break\n                }\n            }\n            result = append(result, sublist)\n            i += len(sublist) - 1\n        }\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        current := make([]interface{}, 0)\n        current = append(current, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                current = append(current, list[i])\n            } else {\n                result = append(result, current)\n                current = make([]interface{}, 0)\n                current = append(current, list[i])\n            }\n        }\n        result = append(result, current)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    var list2 []interface{}\n    var sublist []interface{}\n    var prev interface{}\n    var i int\n    for i, v := range list1.([]interface{}) {\n        if i == 0 {\n            sublist = append(sublist, v)\n        } else if v == prev {\n            sublist = append(sublist, v)\n        } else {\n            list2 = append(list2, sublist)\n            sublist = []interface{}{v}\n        }\n        prev = v\n    }\n    list2 = append(list2, sublist)\n    return list2\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    list := list1.([]interface{})\n    if len(list) == 0 {\n        return list\n    }\n    var result []interface{}\n    var sublist []interface{}\n    for i, v := range list {\n        if i == 0 {\n            sublist = append(sublist, v)\n        } else if v == list[i-1] {\n            sublist = append(sublist, v)\n        } else {\n            result = append(result, sublist)\n            sublist = []interface{}{v}\n        }\n    }\n    result = append(result, sublist)\n    return result\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        var prev interface{}\n        for _, item := range list {\n            if prev == nil {\n                sublist = append(sublist, item)\n            } else if prev == item {\n                sublist = append(sublist, item)\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{item}\n            }\n            prev = item\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        var result [][]int\n        var sublist []int\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []int{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        var result [][]string\n        var sublist []string\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []string{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        var list2 []interface{}\n        var list3 []interface{}\n        for _, v := range list1.([]interface{}) {\n            if len(list3) == 0 || list3[0] == v {\n                list3 = append(list3, v)\n            } else {\n                list2 = append(list2, list3)\n                list3 = []interface{}{v}\n            }\n        }\n        list2 = append(list2, list3)\n        return list2\n    case string:\n        var list2 []interface{}\n        var list3 []interface{}\n        for _, v := range list1.(string) {\n            if len(list3) == 0 || list3[0] == v {\n                list3 = append(list3, v)\n            } else {\n                list2 = append(list2, list3)\n                list3 = []interface{}{v}\n            }\n        }\n        list2 = append(list2, list3)\n        return list2\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if len(temp) == 0 {\n                temp = append(temp, list[i])\n            } else if temp[len(temp)-1] == list[i] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = []int{list[i]}\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if len(temp) == 0 {\n                temp = append(temp, list[i])\n            } else if temp[len(temp)-1] == list[i] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = []string{list[i]}\n            }\n        }\n        result = append(result, temp)\n        return result\n    }\n    return nil\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []int{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []string{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := []interface{}{}\n        sublist := []interface{}{}\n        for i, v := range list {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = []interface{}{}\n                    sublist = append(sublist, v)\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]interface{}, 0)\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := []interface{}{}\n        sublist := []interface{}{list[0]}\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        var last interface{}\n        for _, item := range list {\n            if last == nil {\n                last = item\n                sublist = append(sublist, item)\n            } else if last == item {\n                sublist = append(sublist, item)\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{item}\n                last = item\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return []interface{}{}\n        }\n        if len(list) == 1 {\n            return []interface{}{list}\n        }\n        if list[0] == list[1] {\n            return append([]interface{}{[]interface{}{list[0]}}, pack_consecutive_duplicates(list[1:]).([]interface{})...)\n        }\n        return append([]interface{}{[]interface{}{list[0]}}, pack_consecutive_duplicates(list[1:]).([]interface{})...)\n    case int:\n        return []interface{}{[]interface{}{list1}}\n    case string:\n        return []interface{}{[]interface{}{list1}}\n    default:\n        return []interface{}{}\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        var last interface{}\n        for _, item := range list {\n            if last == nil {\n                last = item\n                sublist = append(sublist, item)\n            } else if last == item {\n                sublist = append(sublist, item)\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{item}\n                last = item\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        current := make([]interface{}, 0)\n        current = append(current, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                current = append(current, list[i])\n            } else {\n                result = append(result, current)\n                current = make([]interface{}, 0)\n                current = append(current, list[i])\n            }\n        }\n        result = append(result, current)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result []interface{}\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result []interface{}\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if len(temp) == 0 || temp[len(temp)-1] == list[i] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = []string{list[i]}\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if len(temp) == 0 || temp[len(temp)-1] == list[i] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = []int{list[i]}\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    var list2 []interface{}\n    var sublist []interface{}\n    var prev interface{}\n    for _, v := range list1.([]interface{}) {\n        if v != prev {\n            if len(sublist) > 0 {\n                list2 = append(list2, sublist)\n            }\n            sublist = []interface{}{v}\n        } else {\n            sublist = append(sublist, v)\n        }\n        prev = v\n    }\n    if len(sublist) > 0 {\n        list2 = append(list2, sublist)\n    }\n    return list2\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i, v := range list {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]interface{}, 0)\n                    sublist = append(sublist, v)\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var sublist []string\n        for i, v := range list {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = []string{v}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var sublist []int\n        for i, v := range list {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = []int{v}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = []string{}\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = []int{}\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return []interface{}{}\n        }\n        result := []interface{}{}\n        sublist := []interface{}{list[0]}\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return []interface{}{}\n        }\n        if len(list) == 1 {\n            return []interface{}{list}\n        }\n        var result []interface{}\n        var sublist []interface{}\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []interface{}{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i, v := range list {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]interface{}, 0)\n                    sublist = append(sublist, v)\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = nil\n                    temp = append(temp, list[i])\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = nil\n                    temp = append(temp, list[i])\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    }\n    return nil\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := []interface{}{}\n        sublist := []interface{}{list[0]}\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []interface{}{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []interface{}{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = nil\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = nil\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var sublist []string\n        for i, v := range list {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = []string{v}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var sublist []int\n        for i, v := range list {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = []int{v}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = nil\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = nil\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        var result [][]int\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        var result [][]string\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]interface{}, 0)\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case string:\n        str := list1.(string)\n        if len(str) == 0 {\n            return str\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(str); i++ {\n            if i == 0 {\n                sublist = append(sublist, string(str[i]))\n            } else {\n                if string(str[i]) == string(str[i-1]) {\n                    sublist = append(sublist, string(str[i]))\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]interface{}, 0)\n                    sublist = append(sublist, string(str[i]))\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == sublist[0] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        var result [][]string\n        var sublist []string\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = nil\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        var result [][]int\n        var sublist []int\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = nil\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        var result []interface{}\n        var sublist []interface{}\n        for i, v := range list {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = []interface{}{v}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        var list2 []interface{}\n        var sublist []interface{}\n        for i, v := range list1.([]interface{}) {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list1.([]interface{})[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    list2 = append(list2, sublist)\n                    sublist = nil\n                    sublist = append(sublist, v)\n                }\n            }\n        }\n        list2 = append(list2, sublist)\n        return list2\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == sublist[0] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        var last interface{}\n        var sublist []interface{}\n        for _, item := range list {\n            if last == nil {\n                last = item\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, item)\n            } else if last == item {\n                sublist = append(sublist, item)\n            } else {\n                result = append(result, sublist)\n                last = item\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, item)\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        current := make([]interface{}, 0)\n        current = append(current, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                current = append(current, list[i])\n            } else {\n                result = append(result, current)\n                current = make([]interface{}, 0)\n                current = append(current, list[i])\n            }\n        }\n        result = append(result, current)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        current := make([]interface{}, 0)\n        current = append(current, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                current = append(current, list[i])\n            } else {\n                result = append(result, current)\n                current = make([]interface{}, 0)\n                current = append(current, list[i])\n            }\n        }\n        result = append(result, current)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    var list2 interface{}\n    var list3 interface{}\n    var list4 interface{}\n    var list5 interface{}\n    var list6 interface{}\n    var list7 interface{}\n    var list8 interface{}\n    var list9 interface{}\n    var list10 interface{}\n    var list11 interface{}\n    var list12 interface{}\n    var list13 interface{}\n    var list14 interface{}\n    var list15 interface{}\n    var list16 interface{}\n    var list17 interface{}\n    var list18 interface{}\n    var list19 interface{}\n    var list20 interface{}\n    var list21 interface{}\n    var list22 interface{}\n    var list23 interface{}\n    var list24 interface{}\n    var list25 interface{}\n    var list26 interface{}\n    var list27 interface{}\n    var list28 interface{}\n    var list29 interface{}\n    var list30 interface{}\n    var list31 interface{}\n    var list32 interface{}\n    var list33 interface{}\n    var list34 interface{}\n    var list35 interface{}\n    var list36 interface{}\n    var list37 interface{}\n    var list38 interface{}\n    var list39 interface{}\n    var list40 interface{}\n    var list41 interface{}\n    var list42 interface{}\n    var list43 interface{}\n    var list44 interface{}\n    var list45 interface{}\n    var list46 interface{}\n    var list47 interface{}\n    var list48 interface{}\n    var list49 interface{}\n    var list50 interface{}\n    var list51 interface{}\n    var list52 interface{}\n    var list53 interface{}\n    var list54 interface{}\n    var list55 interface{}\n    var list56 interface{}\n    var list57 interface{}\n    var list58 interface{}\n    var list59 interface{}\n    var list60 interface{}\n    var list61 interface{}\n    var list62 interface{}\n    var list63 interface{}\n    var list64 interface{}\n    var list65 interface{}",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    var list2 []interface{}\n    var sublist []interface{}\n    var prev interface{}\n    for _, e := range list1.([]interface{}) {\n        if prev == nil {\n            sublist = append(sublist, e)\n        } else if prev == e {\n            sublist = append(sublist, e)\n        } else {\n            list2 = append(list2, sublist)\n            sublist = []interface{}{e}\n        }\n        prev = e\n    }\n    list2 = append(list2, sublist)\n    return list2\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        } else {\n            var result []interface{}\n            var sublist []interface{}\n            var prev interface{}\n            for _, v := range list {\n                if prev == nil {\n                    prev = v\n                    sublist = append(sublist, v)\n                } else if prev == v {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = []interface{}{v}\n                    prev = v\n                }\n            }\n            result = append(result, sublist)\n            return result\n        }\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        for i := 0; i < len(list); {\n            j := i + 1\n            for j < len(list) && list[i] == list[j] {\n                j++\n            }\n            result = append(result, list[i:j])\n            i = j\n        }\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 || sublist[len(sublist)-1] == list[i] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []int{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 || sublist[len(sublist)-1] == list[i] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []string{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []int{}\n                    temp = append(temp, list[i])\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []string{}\n                    temp = append(temp, list[i])\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        temp := make([]interface{}, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]interface{}, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    list2 := []interface{}{}\n    sublist := []interface{}{}\n    for _, v := range list1.([]interface{}) {\n        if len(sublist) == 0 || sublist[0] == v {\n            sublist = append(sublist, v)\n        } else {\n            list2 = append(list2, sublist)\n            sublist = []interface{}{v}\n        }\n    }\n    list2 = append(list2, sublist)\n    return list2\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{}\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 {\n                sublist = append(sublist, list[i])\n            } else if sublist[0] == list[i] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result []interface{}\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result []interface{}\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    list2 := []interface{}{}\n    list3 := []interface{}{}\n    for _, v := range list1.([]interface{}) {\n        if len(list3) == 0 {\n            list3 = append(list3, v)\n        } else if v == list3[0] {\n            list3 = append(list3, v)\n        } else {\n            list2 = append(list2, list3)\n            list3 = []interface{}{}\n            list3 = append(list3, v)\n        }\n    }\n    list2 = append(list2, list3)\n    return list2\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        if len(list) == 1 {\n            return []interface{}{list}\n        }\n        result := []interface{}{}\n        sublist := []interface{}{list[0]}\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result []interface{}\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result []interface{}\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if sublist[0] == list[i] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]interface{}, 0)\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = []string{list[i]}\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = []int{list[i]}\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        var current []string\n        current = append(current, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                current = append(current, list[i])\n            } else {\n                result = append(result, current)\n                current = make([]string, 0)\n                current = append(current, list[i])\n            }\n        }\n        result = append(result, current)\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        var current []int\n        current = append(current, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                current = append(current, list[i])\n            } else {\n                result = append(result, current)\n                current = make([]int, 0)\n                current = append(current, list[i])\n            }\n        }\n        result = append(result, current)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := []interface{}{}\n        sublist := []interface{}{list[0]}\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case string:\n        list := list1.(string)\n        if len(list) == 0 {\n            return list\n        }\n        result := \"\"\n        sublist := string(list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = sublist + string(list[i])\n            } else {\n                result = result + sublist\n                sublist = string(list[i])\n            }\n        }\n        result = result + sublist\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        var result [][]int\n        var sublist []int\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []int{}\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        var result [][]string\n        var sublist []string\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []string{}\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result []interface{}\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = []string{list[i]}\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result []interface{}\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = []int{list[i]}\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i - 1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return []interface{}{}\n        }\n        if len(list) == 1 {\n            return []interface{}{list}\n        }\n        result := []interface{}{}\n        sublist := []interface{}{list[0]}\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        for i, v := range list {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = []interface{}{v}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        var result [][]int\n        var sublist []int\n        var last int = list[0]\n        for _, v := range list {\n            if v == last {\n                sublist = append(sublist, v)\n            } else {\n                result = append(result, sublist)\n                sublist = []int{v}\n                last = v\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        var result [][]string\n        var sublist []string\n        var last string = list[0]\n        for _, v := range list {\n            if v == last {\n                sublist = append(sublist, v)\n            } else {\n                result = append(result, sublist)\n                sublist = []string{v}\n                last = v\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := []interface{}{}\n        current := list[0]\n        count := 1\n        for i := 1; i < len(list); i++ {\n            if list[i] == current {\n                count++\n            } else {\n                result = append(result, []interface{}{current, count})\n                current = list[i]\n                count = 1\n            }\n        }\n        result = append(result, []interface{}{current, count})\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        for i := 0; i < len(list); {\n            j := i + 1\n            for ; j < len(list); j++ {\n                if list[i] != list[j] {\n                    break\n                }\n            }\n            result = append(result, list[i:j])\n            i = j\n        }\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        for i, v := range list {\n            if i == 0 {\n                temp = append(temp, v)\n            } else {\n                if v == list[i-1] {\n                    temp = append(temp, v)\n                } else {\n                    result = append(result, temp)\n                    temp = []string{v}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        for i, v := range list {\n            if i == 0 {\n                temp = append(temp, v)\n            } else {\n                if v == list[i-1] {\n                    temp = append(temp, v)\n                } else {\n                    result = append(result, temp)\n                    temp = []int{v}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        var result []interface{}\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []int{}\n                    temp = append(temp, list[i])\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []string:\n        list := list1.([]string)\n        var result []interface{}\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []string{}\n                    temp = append(temp, list[i])\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []int:\n        return pack_consecutive_duplicates_int(list1.([]int))\n    case []string:\n        return pack_consecutive_duplicates_string(list1.([]string))\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i, v := range list {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]interface{}, 0)\n                    sublist = append(sublist, v)\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        sublist := make([]int, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 || sublist[0] == list[i] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]int, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        sublist := make([]string, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 || sublist[0] == list[i] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]string, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        result := make([][]string, 0)\n        for i := 0; i < len(list); {\n            j := i + 1\n            for ; j < len(list) && list[j] == list[i]; j++ {}\n            result = append(result, list[i:j])\n            i = j\n        }\n        return result\n    case []int:\n        list := list1.([]int)\n        result := make([][]int, 0)\n        for i := 0; i < len(list); {\n            j := i + 1\n            for ; j < len(list) && list[j] == list[i]; j++ {}\n            result = append(result, list[i:j])\n            i = j\n        }\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result []interface{}\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []string{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result []interface{}\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []int{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result []interface{}\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result []interface{}\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []string:\n        list2 = []string{}\n        for _, v := range list1.([]string) {\n            if len(list2.([]string)) == 0 || list2.([]string)[len(list2.([]string))-1] != v {\n                list2 = append(list2.([]string), v)\n            }\n        }\n    case []int:\n        list2 = []int{}\n        for _, v := range list1.([]int) {\n            if len(list2.([]int)) == 0 || list2.([]int)[len(list2.([]int))-1] != v {\n                list2 = append(list2.([]int), v)\n            }\n        }\n    }\n    return list2\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []int{}\n                    temp = append(temp, list[i])\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []string{}\n                    temp = append(temp, list[i])\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        sublist := make([]int, 0)\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]int, 0)\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        sublist := make([]string, 0)\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]string, 0)\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        var last interface{}\n        for _, item := range list {\n            if last == nil {\n                last = item\n                sublist = append(sublist, item)\n            } else if last == item {\n                sublist = append(sublist, item)\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{item}\n                last = item\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        current := make([]string, 0)\n        current = append(current, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                current = append(current, list[i])\n            } else {\n                result = append(result, current)\n                current = make([]string, 0)\n                current = append(current, list[i])\n            }\n        }\n        result = append(result, current)\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        current := make([]int, 0)\n        current = append(current, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                current = append(current, list[i])\n            } else {\n                result = append(result, current)\n                current = make([]int, 0)\n                current = append(current, list[i])\n            }\n        }\n        result = append(result, current)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        temp := make([]string, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]string, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        temp := make([]int, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]int, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        for i, v := range list {\n            if i == 0 {\n                sublist = append(sublist, v)\n                continue\n            }\n            if v == list[i-1] {\n                sublist = append(sublist, v)\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{v}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        sublist := make([]string, 0)\n        for i, v := range list {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]string, 0)\n                    sublist = append(sublist, v)\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        sublist := make([]int, 0)\n        for i, v := range list {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]int, 0)\n                    sublist = append(sublist, v)\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    var list2 []interface{}\n    var list3 []interface{}\n    var list4 []interface{}\n    var list5 []interface{}\n    var list6 []interface{}\n    var list7 []interface{}\n    var list8 []interface{}\n    var list9 []interface{}\n    var list10 []interface{}\n    var list11 []interface{}\n    var list12 []interface{}\n    var list13 []interface{}\n    var list14 []interface{}\n    var list15 []interface{}\n    var list16 []interface{}\n    var list17 []interface{}\n    var list18 []interface{}\n    var list19 []interface{}\n    var list20 []interface{}\n    var list21 []interface{}\n    var list22 []interface{}\n    var list23 []interface{}\n    var list24 []interface{}\n    var list25 []interface{}\n    var list26 []interface{}\n    var list27 []interface{}\n    var list28 []interface{}\n    var list29 []interface{}\n    var list30 []interface{}\n    var list31 []interface{}\n    var list32 []interface{}\n    var list33 []interface{}\n    var list34 []interface{}\n    var list35 []interface{}\n    var list36 []interface{}\n    var list37 []interface{}\n    var list38 []interface{}\n    var list39 []interface{}\n    var list40 []interface{}\n    var list41 []interface{}\n    var list42 []interface{}\n    var list43 []interface{}\n    var list44 []interface{}\n    var list45 []interface{}\n    var list46 []interface{}\n    var list47 []interface{}\n    var list48 []interface{}\n    var list49 []interface{}\n    var list50 []interface{}\n    var list51 []interface{}\n    var list52 []interface{}\n    var list53 []interface{}\n    var list54 []interface{}\n    var list55 []interface{}\n    var list56 []interface{}\n    var list57 []interface{}\n    var list58 []interface{",
    "    list := list1.([]interface{})\n    if len(list) == 0 {\n        return list\n    }\n    var result []interface{}\n    var sublist []interface{}\n    for i, v := range list {\n        if i == 0 {\n            sublist = append(sublist, v)\n        } else {\n            if v == list[i-1] {\n                sublist = append(sublist, v)\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{v}\n            }\n        }\n    }\n    result = append(result, sublist)\n    return result\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := []interface{}{}\n        sublist := []interface{}{list[0]}\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case string:\n        list := list1.(string)\n        if len(list) == 0 {\n            return list\n        }\n        result := \"\"\n        sublist := string(list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist += string(list[i])\n            } else {\n                result += sublist\n                sublist = string(list[i])\n            }\n        }\n        result += sublist\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        var list2 [][]string\n        var sublist []string\n        for _, value := range list1.([]string) {\n            if len(sublist) == 0 || sublist[len(sublist)-1] == value {\n                sublist = append(sublist, value)\n            } else {\n                list2 = append(list2, sublist)\n                sublist = []string{value}\n            }\n        }\n        list2 = append(list2, sublist)\n        return list2\n    case []int:\n        var list2 [][]int\n        var sublist []int\n        for _, value := range list1.([]int) {\n            if len(sublist) == 0 || sublist[len(sublist)-1] == value {\n                sublist = append(sublist, value)\n            } else {\n                list2 = append(list2, sublist)\n                sublist = []int{value}\n            }\n        }\n        list2 = append(list2, sublist)\n        return list2\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var sublist []string\n        for i, v := range list {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = []string{v}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var sublist []int\n        for i, v := range list {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = []int{v}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if sublist[0] == list[i] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]interface{}, 0)\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    var list2 []interface{}\n    var list3 []interface{}\n    var list4 []interface{}\n    var list5 []interface{}\n    var list6 []interface{}\n    var list7 []interface{}\n    var list8 []interface{}\n    var list9 []interface{}\n    var list10 []interface{}\n    var list11 []interface{}\n    var list12 []interface{}\n    var list13 []interface{}\n    var list14 []interface{}\n    var list15 []interface{}\n    var list16 []interface{}\n    var list17 []interface{}\n    var list18 []interface{}\n    var list19 []interface{}\n    var list20 []interface{}\n    var list21 []interface{}\n    var list22 []interface{}\n    var list23 []interface{}\n    var list24 []interface{}\n    var list25 []interface{}\n    var list26 []interface{}\n    var list27 []interface{}\n    var list28 []interface{}\n    var list29 []interface{}\n    var list30 []interface{}\n    var list31 []interface{}\n    var list32 []interface{}\n    var list33 []interface{}\n    var list34 []interface{}\n    var list35 []interface{}\n    var list36 []interface{}\n    var list37 []interface{}\n    var list38 []interface{}\n    var list39 []interface{}\n    var list40 []interface{}\n    var list41 []interface{}\n    var list42 []interface{}\n    var list43 []interface{}\n    var list44 []interface{}\n    var list45 []interface{}\n    var list46 []interface{}\n    var list47 []interface{}\n    var list48 []interface{}\n    var list49 []interface{}\n    var list50 []interface{}\n    var list51 []interface{}\n    var list52 []interface{}\n    var list53 []interface{}\n    var list54 []interface{}\n    var list55 []interface{}\n    var list56 []interface{}\n    var list57 []interface{}\n    var list58 []interface{",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        temp := make([]interface{}, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]interface{}, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n        case []interface{}:\n            var list2 []interface{}\n            var list3 []interface{}\n            for _, v := range list1.([]interface{}) {\n                if len(list3) == 0 || list3[0] == v {\n                    list3 = append(list3, v)\n                } else {\n                    list2 = append(list2, list3)\n                    list3 = []interface{}{v}\n                }\n            }\n            if len(list3) > 0 {\n                list2 = append(list2, list3)\n            }\n            return list2\n        default:\n            return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = nil\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        result := make([][]string, 0)\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if len(temp) == 0 || temp[0] == list[i] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = []string{list[i]}\n            }\n        }\n        if len(temp) > 0 {\n            result = append(result, temp)\n        }\n        return result\n    case []int:\n        list := list1.([]int)\n        result := make([][]int, 0)\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if len(temp) == 0 || temp[0] == list[i] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = []int{list[i]}\n            }\n        }\n        if len(temp) > 0 {\n            result = append(result, temp)\n        }\n        return result\n    }\n    return nil\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        sublist := make([]int, 0)\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]int, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        sublist := make([]string, 0)\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]string, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        sublist := make([]string, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 || sublist[0] == list[i] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]string, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        sublist := make([]int, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 || sublist[0] == list[i] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]int, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 || sublist[0] == list[i] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        result := []interface{}{}\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                result = append(result, []interface{}{list[i]})\n            } else {\n                if list[i] == list[i-1] {\n                    result[len(result)-1] = append(result[len(result)-1].([]interface{}), list[i])\n                } else {\n                    result = append(result, []interface{}{list[i]})\n                }\n            }\n        }\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := []string{list[0]}\n        for i := 1; i < len(list); i++ {\n            if list[i] == result[len(result)-1] {\n                result[len(result)-1] = result[len(result)-1] + list[i]\n            } else {\n                result = append(result, list[i])\n            }\n        }\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := []int{list[0]}\n        for i := 1; i < len(list); i++ {\n            if list[i] == result[len(result)-1] {\n                result[len(result)-1] = result[len(result)-1] + list[i]\n            } else {\n                result = append(result, list[i])\n            }\n        }\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == sublist[0] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result []interface{}\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result []interface{}\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    var list2 []interface{}\n    var list3 []interface{}\n    var list4 []interface{}\n    var list5 []interface{}\n    var list6 []interface{}\n    var list7 []interface{}\n    var list8 []interface{}\n    var list9 []interface{}\n    var list10 []interface{}\n    var list11 []interface{}\n    var list12 []interface{}\n    var list13 []interface{}\n    var list14 []interface{}\n    var list15 []interface{}\n    var list16 []interface{}\n    var list17 []interface{}\n    var list18 []interface{}\n    var list19 []interface{}\n    var list20 []interface{}\n    var list21 []interface{}\n    var list22 []interface{}\n    var list23 []interface{}\n    var list24 []interface{}\n    var list25 []interface{}\n    var list26 []interface{}\n    var list27 []interface{}\n    var list28 []interface{}\n    var list29 []interface{}\n    var list30 []interface{}\n    var list31 []interface{}\n    var list32 []interface{}\n    var list33 []interface{}\n    var list34 []interface{}\n    var list35 []interface{}\n    var list36 []interface{}\n    var list37 []interface{}\n    var list38 []interface{}\n    var list39 []interface{}\n    var list40 []interface{}\n    var list41 []interface{}\n    var list42 []interface{}\n    var list43 []interface{}\n    var list44 []interface{}\n    var list45 []interface{}\n    var list46 []interface{}\n    var list47 []interface{}\n    var list48 []interface{}\n    var list49 []interface{}\n    var list50 []interface{}\n    var list51 []interface{}\n    var list52 []interface{}\n    var list53 []interface{}\n    var list54 []interface{}\n    var list55 []interface{}\n    var list56 []interface{}\n    var list57 []interface{}\n    var list58 []interface{",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result []interface{}\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result []interface{}\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    }\n    return nil\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        var previous interface{}\n        for _, item := range list {\n            if previous == nil {\n                sublist = append(sublist, item)\n            } else if item == previous {\n                sublist = append(sublist, item)\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{item}\n            }\n            previous = item\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 1)\n        result[0] = []string{list[0]}\n        for i := 1; i < len(list); i++ {\n            if list[i] == result[len(result)-1][0] {\n                result[len(result)-1] = append(result[len(result)-1], list[i])\n            } else {\n                result = append(result, []string{list[i]})\n            }\n        }\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 1)\n        result[0] = []int{list[0]}\n        for i := 1; i < len(list); i++ {\n            if list[i] == result[len(result)-1][0] {\n                result[len(result)-1] = append(result[len(result)-1], list[i])\n            } else {\n                result = append(result, []int{list[i]})\n            }\n        }\n        return result\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == sublist[0] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n"
  ]
}