{
  "name": "mbpp_785_tuple_str_int",
  "language": "go_test.go",
  "prompt": "package tuple_str_int_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert list string to integer list.\nfunc tuple_str_int(test_str string) []interface{} {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_785_tuple_str_int.py",
  "prompt_terminology": "reworded",
  "tests": "func TestTuple_Str_Int(t *testing.T) {\n  candidate := tuple_str_int\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(7, 8, 9)\"), expected: []interface{}{7, 8, 9} },\n     { actual: candidate(\"(1, 2, 3)\"), expected: []interface{}{1, 2, 3} },\n     { actual: candidate(\"(4, 5, 6)\"), expected: []interface{}{4, 5, 6} },\n     { actual: candidate(\"(7, 81, 19)\"), expected: []interface{}{7, 81, 19} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    var result []interface{}\n    for _, v := range test_str {\n        result = append(result, string(v))\n    }\n    return result\n}\n",
    "    var result []interface{}\n    for _, v := range test_str {\n        result = append(result, string(v))\n    }\n    return result\n}\n",
    "    var result []interface{}\n    var temp_str string\n    var temp_int int\n    var temp_float float64\n    var temp_bool bool\n    var temp_char rune\n    var temp_interface interface{}\n    for _, char := range test_str {\n        switch char {\n            case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n                temp_str += string(char)\n            case ' ':\n                if temp_str != \"\" {\n                    fmt.Sscanf(temp_str, \"%d\", &temp_int)\n                    temp_interface = temp_int\n                    result = append(result, temp_interface)\n                    temp_str = \"\"\n                }\n            case '.':\n                if temp_str != \"\" {\n                    fmt.Sscanf(temp_str, \"%f\", &temp_float)\n                    temp_interface = temp_float\n                    result = append(result, temp_interface)\n                    temp_str = \"\"\n                }\n            case 't', 'f':\n                if temp_str != \"\" {\n                    fmt.Sscanf(temp_str, \"%t\", &temp_bool)\n                    temp_interface = temp_bool\n                    result = append(result, temp_interface)\n                    temp_str = \"\"\n                }\n            case '\\'':\n                if temp_str != \"\" {\n                    fmt.Sscanf(temp_str, \"%c\", &temp_char)\n                    temp_interface = temp_char\n                    result = append(result, temp_interface)\n                    temp_str = \"\"\n                }\n        }\n    }\n    if temp_str != \"\" {\n        fmt.Sscanf(temp_str, \"%d\", &temp_int)\n        temp_interface = temp_int\n        result = append(result, temp_interface)\n        temp_str = \"\"\n    }\n    return result\n}\n",
    "    var result []interface{}\n    for _, v := range test_str {\n        result = append(result, string(v))\n    }\n    return result\n}\n",
    "    var result []interface{}\n    for _, v := range test_str {\n        result = append(result, int(v))\n    }\n    return result\n}\n",
    "    var result []interface{}\n    for _, v := range test_str {\n        result = append(result, v)\n    }\n    return result\n}\n",
    "    var tuple_str_int []interface{}\n    for _, v := range test_str {\n        tuple_str_int = append(tuple_str_int, string(v))\n    }\n    return tuple_str_int\n}\n",
    "    var result []interface{}\n    for _, v := range test_str {\n        result = append(result, v)\n    }\n    return result\n}\n",
    "    var result []interface{}\n    for _, v := range test_str {\n        result = append(result, v)\n    }\n    return result\n}\n",
    "    var result []interface{}\n    for _, v := range test_str {\n        result = append(result, int(v))\n    }\n    return result\n}\n",
    "    var result []interface{}\n    for _, v := range test_str {\n        result = append(result, string(v))\n    }\n    return result\n}\n",
    "    var result []interface{}\n    for _, v := range test_str {\n        result = append(result, int(v))\n    }\n    return result\n}\n",
    "    var result []interface{}\n    for _, value := range test_str {\n        result = append(result, string(value))\n    }\n    return result\n}\n",
    "    var result []interface{}\n    for _, v := range test_str {\n        result = append(result, string(v))\n    }\n    return result\n}\n",
    "    var result []interface{}\n    var temp_str string\n    var temp_int int\n    var temp_bool bool\n    for i := 0; i < len(test_str); i++ {\n        if test_str[i] == ',' {\n            temp_int, temp_bool = str_to_int(temp_str)\n            if temp_bool {\n                result = append(result, temp_int)\n            } else {\n                result = append(result, temp_str)\n            }\n            temp_str = \"\"\n        } else {\n            temp_str += string(test_str[i])\n        }\n    }\n    temp_int, temp_bool = str_to_int(temp_str)\n    if temp_bool {\n        result = append(result, temp_int)\n    } else {\n        result = append(result, temp_str)\n    }\n    return result\n}\n",
    "    var result []interface{}\n    for _, c := range test_str {\n        result = append(result, string(c))\n    }\n    return result\n}\n",
    "    var result []interface{}\n    for _, v := range test_str {\n        result = append(result, v)\n    }\n    return result\n}\n",
    "    var tuple_str_int []interface{}\n    for _, value := range test_str {\n        tuple_str_int = append(tuple_str_int, value)\n    }\n    return tuple_str_int\n}\n",
    "    var result []interface{}\n    for _, v := range test_str {\n        result = append(result, string(v))\n    }\n    return result\n}\n",
    "    var result []interface{}\n    for _, i := range test_str {\n        result = append(result, i)\n    }\n    return result\n}\n"
  ]
}