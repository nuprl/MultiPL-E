{
  "name": "mbpp_4_heap_queue_largest",
  "language": "go_test.go",
  "prompt": "package heap_queue_largest_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the n largest integers from a given list of numbers, returned in descending order.\nfunc heap_queue_largest(nums []int, n int) []int {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_4_heap_queue_largest.py",
  "prompt_terminology": "reworded",
  "tests": "func TestHeap_Queue_Largest(t *testing.T) {\n  candidate := heap_queue_largest\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{25, 35, 22, 85, 14, 65, 75, 22, 58}, 3), expected: []int{85, 75, 65} },\n     { actual: candidate([]int{25, 35, 22, 85, 14, 65, 75, 22, 58}, 2), expected: []int{85, 75} },\n     { actual: candidate([]int{25, 35, 22, 85, 14, 65, 75, 22, 58}, 5), expected: []int{85, 75, 65, 58, 35} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    if len(nums) == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    if n == 1 {\n        return []int{max(nums)}\n    }\n    if n == len(nums) {\n        return nums\n    }\n    // build heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2; i >= 0; i-- {\n        heap = heapify(heap, i)\n    }\n    // heapify\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heap = heapify(heap, 0)\n        }\n    }\n    // sort\n    for i := n - 1; i > 0; i-- {\n        heap[0], heap[i] = heap[i], heap[0]\n        heap = heapify(heap[:i], 0)\n    }\n    return heap\n}\n",
    "    if len(nums) == 0 || n <= 0 {\n        return []int{}\n    }\n\n    if n > len(nums) {\n        n = len(nums)\n    }\n\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // extract the top n elements\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums, 0, len(nums)-1-i)\n    }\n\n    return nums[len(nums)-n:]\n}\n",
    "    if len(nums) < n {\n        return nums\n    }\n\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // pop n largest numbers\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums) - 1 - i] = nums[len(nums) - 1 - i], nums[0]\n        heapify(nums, 0, len(nums) - 1 - i)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        return nums\n    }\n    // build heap\n    heap := make([]int, n)\n    for i, v := range nums {\n        if i < n {\n            heap[i] = v\n        } else {\n            if v > heap[0] {\n                heap[0] = v\n            }\n        }\n        if i >= n {\n            heapify(heap, 0)\n        }\n    }\n    // sort heap\n    for i := n - 1; i > 0; i-- {\n        heap[0], heap[i] = heap[i], heap[0]\n        heapify(heap[:i], 0)\n    }\n    return heap\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    // build a max heap\n    heap := make([]int, n)\n    heap[0] = nums[0]\n    for i := 1; i < n; i++ {\n        heap[i] = nums[i]\n        j := i\n        for j > 0 {\n            if heap[j] > heap[(j-1)/2] {\n                heap[j], heap[(j-1)/2] = heap[(j-1)/2], heap[j]\n                j = (j-1)/2\n            } else {\n                break\n            }\n        }\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            j := 0\n            for j < n {\n                if j*2+1 < n && heap[j*2+1] > heap[j] {\n                    heap[j], heap[j*2+1] = heap[j*2+1], heap[j]\n                    j = j*2+1\n                } else if j*2+2 < n && heap[j*2+2] > heap[j] {\n                    heap[j], heap[j*2+2] = heap[j*2+2], heap[j]\n                    j = j*2+2\n                } else {\n                    break\n                }\n            }\n        }\n    }\n    return heap\n}\n",
    "    if n < 1 {\n        return []int{}\n    }\n\n    if n > len(nums) {\n        n = len(nums)\n    }\n\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // pop the top n elements\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums) - 1 - i] = nums[len(nums) - 1 - i], nums[0]\n        heapify(nums, 0, len(nums) - 1 - i)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    if n <= 0 || len(nums) < n {\n        return nil\n    }\n    heap := make([]int, n)\n    copy(heap, nums[:n])\n    build_heap(heap)\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0)\n        }\n    }\n    return heap\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    // build a max heap\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(nums, i, n)\n    }\n    // sort\n    for i := n; i < len(nums); i++ {\n        if nums[i] > nums[0] {\n            nums[i], nums[0] = nums[0], nums[i]\n            heapify(nums, 0, n)\n        }\n    }\n    return nums[:n]\n}\n",
    "    if n <= 0 {\n        return nil\n    }\n    if len(nums) <= n {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2; i >= 0; i-- {\n        heapify(heap, i)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0)\n        }\n    }\n    return heap\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n\n    if n > len(nums) {\n        n = len(nums)\n    }\n\n    // build max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // extract max n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums) - 1 - i] = nums[len(nums) - 1 - i], nums[0]\n        heapify(nums, 0, len(nums) - 1 - i)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    if len(nums) == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    result := make([]int, n)\n    for i := 0; i < n; i++ {\n        result[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(result, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > result[0] {\n            result[0] = nums[i]\n            heapify(result, 0, n)\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    // build heap\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(nums, i, n)\n    }\n    // heap sort\n    for i := n; i < len(nums); i++ {\n        if nums[i] > nums[0] {\n            nums[0], nums[i] = nums[i], nums[0]\n            heapify(nums, 0, n)\n        }\n    }\n    return nums[:n]\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n\n    if n >= len(nums) {\n        return nums\n    }\n\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n\n    for i := n / 2; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n\n    return heap\n}\n",
    "    if n <= 0 || n > len(nums) {\n        return nil\n    }\n\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // pop n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums) - 1 - i] = nums[len(nums) - 1 - i], nums[0]\n        heapify(nums, 0, len(nums) - 1 - i)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    if len(nums) == 0 {\n        return []int{}\n    }\n    if len(nums) < n {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0)\n        }\n    }\n    return heap\n}\n",
    "    if n > len(nums) {\n        n = len(nums)\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heap_queue_largest_heapify(nums, n, i)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > nums[0] {\n            nums[0], nums[i] = nums[i], nums[0]\n            heap_queue_largest_heapify(nums, n, 0)\n        }\n    }\n    return nums[:n]\n}\n",
    "    if len(nums) < n {\n        return nums\n    }\n\n    // build a max heap\n    for i := len(nums)/2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // pop n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums, 0, len(nums)-1-i)\n    }\n\n    return nums[len(nums)-n:]\n}\n",
    "    if len(nums) < n {\n        return nil\n    }\n\n    // Build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // Extract the largest n elements\n    for i := len(nums) - 1; i >= len(nums) - n; i-- {\n        nums[0], nums[i] = nums[i], nums[0]\n        heapify(nums, 0, i)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    var heap []int\n    for _, num := range nums {\n        if len(heap) < n {\n            heap = append(heap, num)\n            if len(heap) == n {\n                heapify(heap)\n            }\n        } else {\n            if num > heap[0] {\n                heap[0] = num\n                heapify(heap)\n            }\n        }\n    }\n    return heap\n}\n"
  ]
}