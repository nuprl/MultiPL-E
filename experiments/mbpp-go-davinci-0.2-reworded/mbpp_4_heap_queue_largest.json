{
  "name": "mbpp_4_heap_queue_largest",
  "language": "go_test.go",
  "prompt": "package heap_queue_largest_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the n largest integers from a given list of numbers, returned in descending order.\nfunc heap_queue_largest(nums []int, n int) []int {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_4_heap_queue_largest.py",
  "prompt_terminology": "reworded",
  "tests": "func TestHeap_Queue_Largest(t *testing.T) {\n  candidate := heap_queue_largest\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{25, 35, 22, 85, 14, 65, 75, 22, 58}, 3), expected: []int{85, 75, 65} },\n     { actual: candidate([]int{25, 35, 22, 85, 14, 65, 75, 22, 58}, 2), expected: []int{85, 75} },\n     { actual: candidate([]int{25, 35, 22, 85, 14, 65, 75, 22, 58}, 5), expected: []int{85, 75, 65, 58, 35} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    if len(nums) == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    if n == 1 {\n        return []int{max(nums)}\n    }\n    if n == len(nums) {\n        return nums\n    }\n    // build heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2; i >= 0; i-- {\n        heap = heapify(heap, i)\n    }\n    // heapify\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heap = heapify(heap, 0)\n        }\n    }\n    // sort\n    for i := n - 1; i > 0; i-- {\n        heap[0], heap[i] = heap[i], heap[0]\n        heap = heapify(heap[:i], 0)\n    }\n    return heap\n}\n",
    "    if len(nums) == 0 || n <= 0 {\n        return []int{}\n    }\n\n    if n > len(nums) {\n        n = len(nums)\n    }\n\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // extract the top n elements\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums, 0, len(nums)-1-i)\n    }\n\n    return nums[len(nums)-n:]\n}\n",
    "    if len(nums) < n {\n        return nums\n    }\n\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // pop n largest numbers\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums) - 1 - i] = nums[len(nums) - 1 - i], nums[0]\n        heapify(nums, 0, len(nums) - 1 - i)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        return nums\n    }\n    // build heap\n    heap := make([]int, n)\n    for i, v := range nums {\n        if i < n {\n            heap[i] = v\n        } else {\n            if v > heap[0] {\n                heap[0] = v\n            }\n        }\n        if i >= n {\n            heapify(heap, 0)\n        }\n    }\n    // sort heap\n    for i := n - 1; i > 0; i-- {\n        heap[0], heap[i] = heap[i], heap[0]\n        heapify(heap[:i], 0)\n    }\n    return heap\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    // build a max heap\n    heap := make([]int, n)\n    heap[0] = nums[0]\n    for i := 1; i < n; i++ {\n        heap[i] = nums[i]\n        j := i\n        for j > 0 {\n            if heap[j] > heap[(j-1)/2] {\n                heap[j], heap[(j-1)/2] = heap[(j-1)/2], heap[j]\n                j = (j-1)/2\n            } else {\n                break\n            }\n        }\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            j := 0\n            for j < n {\n                if j*2+1 < n && heap[j*2+1] > heap[j] {\n                    heap[j], heap[j*2+1] = heap[j*2+1], heap[j]\n                    j = j*2+1\n                } else if j*2+2 < n && heap[j*2+2] > heap[j] {\n                    heap[j], heap[j*2+2] = heap[j*2+2], heap[j]\n                    j = j*2+2\n                } else {\n                    break\n                }\n            }\n        }\n    }\n    return heap\n}\n",
    "    if n < 1 {\n        return []int{}\n    }\n\n    if n > len(nums) {\n        n = len(nums)\n    }\n\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // pop the top n elements\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums) - 1 - i] = nums[len(nums) - 1 - i], nums[0]\n        heapify(nums, 0, len(nums) - 1 - i)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    if n <= 0 || len(nums) < n {\n        return nil\n    }\n    heap := make([]int, n)\n    copy(heap, nums[:n])\n    build_heap(heap)\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0)\n        }\n    }\n    return heap\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    // build a max heap\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(nums, i, n)\n    }\n    // sort\n    for i := n; i < len(nums); i++ {\n        if nums[i] > nums[0] {\n            nums[i], nums[0] = nums[0], nums[i]\n            heapify(nums, 0, n)\n        }\n    }\n    return nums[:n]\n}\n",
    "    if n <= 0 {\n        return nil\n    }\n    if len(nums) <= n {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2; i >= 0; i-- {\n        heapify(heap, i)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0)\n        }\n    }\n    return heap\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n\n    if n > len(nums) {\n        n = len(nums)\n    }\n\n    // build max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // extract max n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums) - 1 - i] = nums[len(nums) - 1 - i], nums[0]\n        heapify(nums, 0, len(nums) - 1 - i)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    if len(nums) == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    result := make([]int, n)\n    for i := 0; i < n; i++ {\n        result[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(result, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > result[0] {\n            result[0] = nums[i]\n            heapify(result, 0, n)\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    // build heap\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(nums, i, n)\n    }\n    // heap sort\n    for i := n; i < len(nums); i++ {\n        if nums[i] > nums[0] {\n            nums[0], nums[i] = nums[i], nums[0]\n            heapify(nums, 0, n)\n        }\n    }\n    return nums[:n]\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n\n    if n >= len(nums) {\n        return nums\n    }\n\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n\n    for i := n / 2; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n\n    return heap\n}\n",
    "    if n <= 0 || n > len(nums) {\n        return nil\n    }\n\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // pop n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums) - 1 - i] = nums[len(nums) - 1 - i], nums[0]\n        heapify(nums, 0, len(nums) - 1 - i)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    if len(nums) == 0 {\n        return []int{}\n    }\n    if len(nums) < n {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0)\n        }\n    }\n    return heap\n}\n",
    "    if n > len(nums) {\n        n = len(nums)\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heap_queue_largest_heapify(nums, n, i)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > nums[0] {\n            nums[0], nums[i] = nums[i], nums[0]\n            heap_queue_largest_heapify(nums, n, 0)\n        }\n    }\n    return nums[:n]\n}\n",
    "    if len(nums) < n {\n        return nums\n    }\n\n    // build a max heap\n    for i := len(nums)/2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // pop n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums, 0, len(nums)-1-i)\n    }\n\n    return nums[len(nums)-n:]\n}\n",
    "    if len(nums) < n {\n        return nil\n    }\n\n    // Build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // Extract the largest n elements\n    for i := len(nums) - 1; i >= len(nums) - n; i-- {\n        nums[0], nums[i] = nums[i], nums[0]\n        heapify(nums, 0, i)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    var heap []int\n    for _, num := range nums {\n        if len(heap) < n {\n            heap = append(heap, num)\n            if len(heap) == n {\n                heapify(heap)\n            }\n        } else {\n            if num > heap[0] {\n                heap[0] = num\n                heapify(heap)\n            }\n        }\n    }\n    return heap\n}\n",
    "    if n <= 0 || len(nums) == 0 {\n        return []int{}\n    }\n\n    if n >= len(nums) {\n        return nums\n    }\n\n    var result []int\n    for i := 0; i < n; i++ {\n        result = append(result, nums[i])\n    }\n\n    for i := n / 2; i >= 0; i-- {\n        heapify(result, i, n)\n    }\n\n    for i := n; i < len(nums); i++ {\n        if nums[i] > result[0] {\n            result[0] = nums[i]\n            heapify(result, 0, n)\n        }\n    }\n\n    return result\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        return nums\n    }\n    h := make([]int, 0)\n    for i := 0; i < n; i++ {\n        h = append(h, nums[i])\n    }\n    heapify(h)\n    for i := n; i < len(nums); i++ {\n        if nums[i] > h[0] {\n            h[0] = nums[i]\n            heapify(h)\n        }\n    }\n    return h\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    // build a max heap\n    for i := len(nums)/2 - 1; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n    // extract the top n elements\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums, 0, len(nums)-1-i)\n    }\n    return nums[len(nums)-n:]\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    result := make([]int, n)\n    for i := 0; i < n; i++ {\n        result[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(result, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > result[0] {\n            result[0] = nums[i]\n            heapify(result, 0, n)\n        }\n    }\n    return result\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n    // build heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n    // pop n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums) - 1 - i] = nums[len(nums) - 1 - i], nums[0]\n        heapify(nums, 0, len(nums) - 1 - i)\n    }\n    return nums[len(nums) - n:]\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n\n    // build a max heap\n    for i := len(nums)/2 - 1; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // pop the largest n elements\n    for i := len(nums) - 1; i >= len(nums) - n; i-- {\n        nums[0], nums[i] = nums[i], nums[0]\n        heapify(nums, 0, i)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    // build a max heap\n    for i := len(nums)/2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n    // pop n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums, 0, len(nums)-1-i)\n    }\n    return nums[len(nums)-n:]\n}\n",
    "    if len(nums) < n {\n        return nums\n    }\n    // build a min heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    // build a max heap\n    for i := len(nums)/2 - 1; i >= 0; i-- {\n        heap_queue_largest_heapify(nums, i, len(nums))\n    }\n    // extract the top n elements\n    for i := 0; i < n; i++ {\n        heap_queue_largest_swap(nums, 0, len(nums)-1-i)\n        heap_queue_largest_heapify(nums, 0, len(nums)-1-i)\n    }\n    return nums[len(nums)-n:]\n}\n",
    "    if len(nums) == 0 || n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    // build a max heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    // compare the rest of the elements\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    // sort the heap\n    for i := n - 1; i > 0; i-- {\n        heap[0], heap[i] = heap[i], heap[0]\n        heapify(heap, 0, i)\n    }\n    return heap\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n == 0 {\n        return nil\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    heap := make([]int, n)\n    copy(heap, nums[:n])\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if len(nums) == 0 || n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    result := make([]int, n)\n    for i := 0; i < n; i++ {\n        result[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(result, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > result[0] {\n            result[0] = nums[i]\n            heapify(result, 0, n)\n        }\n    }\n    return result\n}\n",
    "    if n < 1 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heap_adjust(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heap_adjust(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    var heap []int\n    for _, num := range nums {\n        if len(heap) < n {\n            heap = append(heap, num)\n            if len(heap) == n {\n                heapify(heap)\n            }\n        } else {\n            if num > heap[0] {\n                heap[0] = num\n                heapify(heap)\n            }\n        }\n    }\n    return heap\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n\n    if n > len(nums) {\n        n = len(nums)\n    }\n\n    // build a max heap\n    for i := len(nums)/2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // pop the top n elements\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums, 0, len(nums)-1-i)\n    }\n\n    return nums[len(nums)-n:]\n}\n",
    "    if n > len(nums) {\n        n = len(nums)\n    }\n    if n == 0 {\n        return []int{}\n    }\n    if n == 1 {\n        return []int{nums[0]}\n    }\n    if n == len(nums) {\n        return nums\n    }\n\n    // build max heap\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(nums, i, n)\n    }\n\n    for i := n; i < len(nums); i++ {\n        if nums[i] > nums[0] {\n            nums[0], nums[i] = nums[i], nums[0]\n            heapify(nums, 0, n)\n        }\n    }\n\n    return nums[:n]\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := nums[:n]\n    for i := n/2 - 1; i >= 0; i-- {\n        heap_adjust(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heap_adjust(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n    if n == len(nums) {\n        return nums\n    }\n    if n == 0 {\n        return []int{}\n    }\n    result := make([]int, n)\n    for i := 0; i < n; i++ {\n        result[i] = nums[i]\n    }\n    for i := n / 2; i >= 0; i-- {\n        heapify(result, i)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > result[0] {\n            result[0] = nums[i]\n            heapify(result, 0)\n        }\n    }\n    return result\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // extract the max element n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums, 0, len(nums)-1-i)\n    }\n\n    return nums[len(nums)-n:]\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    // build a max heap\n    for i := len(nums)/2 - 1; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n    // pop the root n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums, 0, len(nums)-1-i)\n    }\n    return nums[len(nums)-n:]\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if len(nums) == 0 || n == 0 {\n        return []int{}\n    }\n\n    // build a min heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n\n    // compare the rest of the numbers with the min of the heap\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n\n    // sort the heap\n    for i := n - 1; i > 0; i-- {\n        heap[0], heap[i] = heap[i], heap[0]\n        heapify(heap, 0, i)\n    }\n\n    return heap\n}\n",
    "    if len(nums) <= n {\n        return nums\n    }\n\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // extract the top n elements\n    for i := len(nums) - 1; i >= len(nums) - n; i-- {\n        nums[0], nums[i] = nums[i], nums[0]\n        heapify(nums, 0, i)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    // build a max heap\n    for i := len(nums)/2 - 1; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n    // pop the max element from the heap\n    for i := len(nums) - 1; i >= len(nums) - n; i-- {\n        nums[0], nums[i] = nums[i], nums[0]\n        heapify(nums, 0, i)\n    }\n    return nums[len(nums)-n:]\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2; i >= 0; i-- {\n        heap_down(heap, i)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heap_down(heap, 0)\n        }\n    }\n    return heap\n}\n",
    "    if n < 1 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2; i >= 0; i-- {\n        heap_queue_largest_heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heap_queue_largest_heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n\n    if n > len(nums) {\n        n = len(nums)\n    }\n\n    // Build a max heap\n    for i := len(nums)/2 - 1; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // Extract the top n elements\n    for i := len(nums) - 1; i >= len(nums) - n; i-- {\n        nums[0], nums[i] = nums[i], nums[0]\n        heapify(nums, 0, i)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    if len(nums) == 0 {\n        return []int{}\n    }\n    if n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    // build a min heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    // sort the heap\n    for i := n - 1; i > 0; i-- {\n        heap[0], heap[i] = heap[i], heap[0]\n        heapify(heap, 0, i)\n    }\n    return heap\n}\n",
    "    if len(nums) == 0 || n == 0 {\n        return []int{}\n    }\n\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        max_heapify(nums, i, len(nums))\n    }\n\n    // extract the max n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums) - 1 - i] = nums[len(nums) - 1 - i], nums[0]\n        max_heapify(nums, 0, len(nums) - 1 - i)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    // build min heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        min_heapify(nums, i, len(nums))\n    }\n    // pop n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        min_heapify(nums, 0, len(nums)-1-i)\n    }\n    return nums[len(nums)-n:]\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n\n    if n >= len(nums) {\n        return nums\n    }\n\n    var result []int\n    for i := 0; i < n; i++ {\n        result = append(result, nums[i])\n    }\n\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(result, i, n)\n    }\n\n    for i := n; i < len(nums); i++ {\n        if nums[i] > result[0] {\n            result[0] = nums[i]\n            heapify(result, 0, n)\n        }\n    }\n\n    return result\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n    if n == len(nums) {\n        return heap_sort(nums)\n    }\n    // build a min heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    // compare the rest of the elements with the root of the heap\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap_sort(heap)\n}\n",
    "    if len(nums) < n {\n        return nil\n    }\n    if n == 0 {\n        return []int{}\n    }\n    if n == 1 {\n        return []int{nums[0]}\n    }\n    if n == 2 {\n        if nums[0] > nums[1] {\n            return []int{nums[0], nums[1]}\n        } else {\n            return []int{nums[1], nums[0]}\n        }\n    }\n    if n == 3 {\n        if nums[0] > nums[1] {\n            if nums[0] > nums[2] {\n                if nums[1] > nums[2] {\n                    return []int{nums[0], nums[1], nums[2]}\n                } else {\n                    return []int{nums[0], nums[2], nums[1]}\n                }\n            } else {\n                return []int{nums[2], nums[0], nums[1]}\n            }\n        } else {\n            if nums[1] > nums[2] {\n                if nums[0] > nums[2] {\n                    return []int{nums[1], nums[0], nums[2]}\n                } else {\n                    return []int{nums[1], nums[2], nums[0]}\n                }\n            } else {\n                return []int{nums[2], nums[1], nums[0]}\n            }\n        }\n    }\n    if n == 4 {\n        if nums[0] > nums[1] {\n            if nums[0] > nums[2] {\n                if nums[0] > nums[3] {\n                    if nums[1] > nums[2] {\n                        if nums[1] > nums[3] {\n                            if nums[2] > nums[3] {\n                                return []int{nums[0], nums[1], nums[2], nums[3]}\n                            } else {\n                                return []int{nums",
    "    if n > len(nums) {\n        return nums\n    }\n\n    // build a max heap\n    for i := len(nums)/2 - 1; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // pop the largest n elements\n    for i := len(nums)-1; i >= len(nums)-n; i-- {\n        nums[0], nums[i] = nums[i], nums[0]\n        heapify(nums, 0, i)\n    }\n\n    return nums[len(nums)-n:]\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    result := make([]int, n)\n    for i := 0; i < n; i++ {\n        result[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(result, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > result[0] {\n            result[0] = nums[i]\n            heapify(result, 0, n)\n        }\n    }\n    return result\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n    if n == len(nums) {\n        return nums\n    }\n    if n == 0 {\n        return []int{}\n    }\n    // build heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i)\n    }\n    // extract max\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums[:len(nums)-1-i], 0)\n    }\n    return nums[len(nums)-n:]\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n == 1 {\n        return []int{nums[0]}\n    }\n    if n == len(nums) {\n        return nums\n    }\n    if n > len(nums) {\n        return nums\n    }\n    // build heap\n    heap := make([]int, n)\n    copy(heap, nums[:n])\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i)\n    }\n    // insert new element\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0)\n        }\n    }\n    return heap\n}\n",
    "    if len(nums) < n {\n        return nil\n    }\n\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // pop the top n elements\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums) - 1 - i] = nums[len(nums) - 1 - i], nums[0]\n        heapify(nums, 0, len(nums) - 1 - i)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    if len(nums) == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    var heap []int\n    for i := 0; i < n; i++ {\n        heap = append(heap, nums[i])\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heap = heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heap = heapify(heap, 0, n)\n        }\n    }\n    for i := n - 1; i > 0; i-- {\n        heap[0], heap[i] = heap[i], heap[0]\n        heap = heapify(heap, 0, i)\n    }\n    return heap\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    // build a max heap\n    heap := make([]int, 0)\n    for _, num := range nums {\n        heap = append(heap, num)\n        i := len(heap) - 1\n        for i > 0 {\n            parent := (i - 1) / 2\n            if heap[i] > heap[parent] {\n                heap[i], heap[parent] = heap[parent], heap[i]\n                i = parent\n            } else {\n                break\n            }\n        }\n    }\n\n    // pop n largest numbers\n    result := make([]int, 0)\n    for i := 0; i < n; i++ {\n        result = append(result, heap[0])\n        heap[0] = heap[len(heap) - 1]\n        heap = heap[:len(heap) - 1]\n        j := 0\n        for j < len(heap) {\n            left := 2 * j + 1\n            right := 2 * j + 2\n            if left >= len(heap) {\n                break\n            }\n            if right >= len(heap) {\n                if heap[j] < heap[left] {\n                    heap[j], heap[left] = heap[left], heap[j]\n                }\n                break\n            }\n            if heap[j] < heap[left] || heap[j] < heap[right] {\n                if heap[left] > heap[right] {\n                    heap[j], heap[left] = heap[left], heap[j]\n                    j = left\n                } else {\n                    heap[j], heap[right] = heap[right], heap[j]\n                    j = right\n                }\n            } else {\n                break\n            }\n        }\n    }\n    return result\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    // build a min heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := nums[:n]\n    for i := n / 2; i >= 0; i-- {\n        heap_queue_largest_heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heap_queue_largest_heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n\n    if len(nums) == 0 {\n        return []int{}\n    }\n\n    if n > len(nums) {\n        n = len(nums)\n    }\n\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // pop n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums) - 1 - i] = nums[len(nums) - 1 - i], nums[0]\n        heapify(nums, 0, len(nums) - 1 - i)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    // build heap\n    for i := len(nums)/2 - 1; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n    // extract n largest\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums, 0, len(nums)-1-i)\n    }\n    return nums[len(nums)-n:]\n}\n",
    "    if len(nums) < n {\n        return nil\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2; i >= 0; i-- {\n        heap_queue_largest_heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heap_queue_largest_heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        return nums\n    }\n    // build a max heap\n    for i := len(nums)/2; i >= 0; i-- {\n        heapify(nums, i)\n    }\n    // pop n elements\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums[:len(nums)-1-i], 0)\n    }\n    return nums[len(nums)-n:]\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n    // pop the largest n elements\n    for i := len(nums) - 1; i >= len(nums) - n; i-- {\n        nums[0], nums[i] = nums[i], nums[0]\n        heapify(nums, 0, i)\n    }\n    return nums[len(nums) - n:]\n}\n",
    "    if n <= 0 {\n        return nil\n    }\n    if n >= len(nums) {\n        return nums\n    }\n\n    // build a min heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n\n    // sort the heap\n    for i := n - 1; i > 0; i-- {\n        heap[0], heap[i] = heap[i], heap[0]\n        heapify(heap, 0, i)\n    }\n\n    return heap\n}\n",
    "    if len(nums) < n {\n        return nil\n    }\n\n    // build a max heap\n    for i := len(nums)/2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // pop the largest n elements\n    for i := len(nums)-1; i >= len(nums)-n; i-- {\n        nums[0], nums[i] = nums[i], nums[0]\n        heapify(nums, 0, i)\n    }\n\n    return nums[len(nums)-n:]\n}\n",
    "    if len(nums) < n {\n        return nil\n    }\n\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // swap the first and the last, and heapify the first n-1 numbers\n    for i := len(nums) - 1; i >= len(nums) - n; i-- {\n        nums[0], nums[i] = nums[i], nums[0]\n        heapify(nums, 0, i)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if len(nums) < n {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if len(nums) < n {\n        return nums\n    }\n\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        max_heapify(nums, i, len(nums))\n    }\n\n    // extract the largest n elements\n    for i := len(nums) - 1; i >= len(nums) - n; i-- {\n        nums[0], nums[i] = nums[i], nums[0]\n        max_heapify(nums, 0, i)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    var heap []int\n    for _, num := range nums {\n        heap = append(heap, num)\n        if len(heap) > n {\n            heap = heap[1:]\n        }\n        heap = heapify(heap)\n    }\n    return heap\n}\n",
    "    if len(nums) == 0 || n <= 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    // build heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i)\n    }\n    // find n largest\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0)\n        }\n    }\n    // sort\n    for i := n - 1; i >= 0; i-- {\n        heap[0], heap[i] = heap[i], heap[0]\n        heapify(heap[:i], 0)\n    }\n    return heap\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n    if n == len(nums) {\n        return nums\n    }\n    if n == 0 {\n        return []int{}\n    }\n    if n == 1 {\n        max := nums[0]\n        for _, num := range nums {\n            if num > max {\n                max = num\n            }\n        }\n        return []int{max}\n    }\n    // build a min heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if len(nums) < n {\n        return nil\n    }\n\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n\n    return heap\n}\n",
    "    if len(nums) == 0 || n <= 0 {\n        return []int{}\n    }\n    if len(nums) <= n {\n        return nums\n    }\n    var heap []int\n    for _, num := range nums {\n        if len(heap) < n {\n            heap = append(heap, num)\n            if len(heap) == n {\n                heap_build(heap)\n            }\n        } else {\n            if num > heap[0] {\n                heap[0] = num\n                heap_adjust(heap, 0)\n            }\n        }\n    }\n    return heap\n}\n",
    "    // Build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // Extract the top n elements\n    for i := len(nums) - 1; i >= len(nums) - n; i-- {\n        nums[0], nums[i] = nums[i], nums[0]\n        heapify(nums, 0, i)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    if len(nums) == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2; i >= 0; i-- {\n        heap_queue_largest_heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heap_queue_largest_heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if len(nums) == 0 {\n        return []int{}\n    }\n\n    if n > len(nums) {\n        n = len(nums)\n    }\n\n    // build a heap\n    for i := len(nums)/2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // extract the largest n elements\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums, 0, len(nums)-1-i)\n    }\n\n    return nums[len(nums)-n:]\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n\n    if n > len(nums) {\n        n = len(nums)\n    }\n\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // extract the max n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums) - 1 - i] = nums[len(nums) - 1 - i], nums[0]\n        heapify(nums, 0, len(nums) - 1 - i)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    var result []int\n    if n > len(nums) {\n        return result\n    }\n    for i := 0; i < n; i++ {\n        result = append(result, nums[i])\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > result[0] {\n            result[0] = nums[i]\n            heapify(result, 0, n)\n        }\n    }\n    return result\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := make([]int, n)\n    copy(heap, nums[:n])\n    for i := n / 2; i >= 0; i-- {\n        heap_adjust(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heap_adjust(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if len(nums) < n {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if len(nums) < n {\n        return nil\n    }\n    if len(nums) == n {\n        return nums\n    }\n    var heap []int\n    for i := 0; i < n; i++ {\n        heap = append(heap, nums[i])\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heap = heapify(heap, 0)\n        }\n    }\n    return heap\n}\n",
    "    if n <= 0 {\n        return nil\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    heap := make([]int, n)\n    copy(heap, nums[:n])\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2; i >= 0; i-- {\n        heapify(heap, i)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0)\n        }\n    }\n    return heap\n}\n",
    "    if len(nums) == 0 {\n        return []int{}\n    }\n    if len(nums) < n {\n        return nums\n    }\n    if n == 0 {\n        return []int{}\n    }\n    // build a max heap\n    heap := build_max_heap(nums)\n    // pop n times\n    for i := 0; i < n; i++ {\n        heap[0], heap[len(heap)-1] = heap[len(heap)-1], heap[0]\n        heap = heap[:len(heap)-1]\n        heap = max_heapify(heap, 0)\n    }\n    return heap\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    var heap []int\n    for _, num := range nums {\n        if len(heap) < n {\n            heap = append(heap, num)\n            heapify_up(heap, len(heap) - 1)\n        } else if num > heap[0] {\n            heap[0] = num\n            heapify_down(heap, 0)\n        }\n    }\n    return heap\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n\n    if n >= len(nums) {\n        return nums\n    }\n\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // pop n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums) - 1 - i] = nums[len(nums) - 1 - i], nums[0]\n        heapify(nums, 0, len(nums) - 1 - i)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    if len(nums) < n {\n        return nil\n    }\n    if n == 0 {\n        return []int{}\n    }\n    if n == 1 {\n        return []int{nums[0]}\n    }\n    if n == 2 {\n        if nums[0] > nums[1] {\n            return []int{nums[0], nums[1]}\n        } else {\n            return []int{nums[1], nums[0]}\n        }\n    }\n    if n == 3 {\n        if nums[0] > nums[1] {\n            if nums[1] > nums[2] {\n                return []int{nums[0], nums[1], nums[2]}\n            } else if nums[0] > nums[2] {\n                return []int{nums[0], nums[2], nums[1]}\n            } else {\n                return []int{nums[2], nums[0], nums[1]}\n            }\n        } else {\n            if nums[0] > nums[2] {\n                return []int{nums[1], nums[0], nums[2]}\n            } else if nums[1] > nums[2] {\n                return []int{nums[1], nums[2], nums[0]}\n            } else {\n                return []int{nums[2], nums[1], nums[0]}\n            }\n        }\n    }\n\n    // n >= 4\n    // build heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heap_queue_largest_heapify(heap, i, n)\n    }\n\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heap_queue_largest_heapify(heap, 0, n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    build_heap(heap)\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0)\n        }\n    }\n    return heap\n}\n",
    "    if len(nums) < n {\n        return nil\n    }\n\n    // build a min heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        min_heapify(heap, i, n)\n    }\n\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            min_heapify(heap, 0, n)\n        }\n    }\n\n    return heap\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    // build heap\n    for i := n / 2; i >= 0; i-- {\n        heap_queue_largest_heapify(nums, i, n)\n    }\n    // heap sort\n    for i := n; i < len(nums); i++ {\n        if nums[i] > nums[0] {\n            nums[0], nums[i] = nums[i], nums[0]\n            heap_queue_largest_heapify(nums, 0, n)\n        }\n    }\n    return nums[:n]\n}\n",
    "    if len(nums) == 0 || n == 0 {\n        return nil\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    // build a max heap\n    for i := len(nums)/2 - 1; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n    // pop n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums, 0, len(nums)-1-i)\n    }\n    return nums[len(nums)-n:]\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heap_adjust(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heap_adjust(heap, 0, n)\n        }\n    }\n    for i := n - 1; i > 0; i-- {\n        heap[0], heap[i] = heap[i], heap[0]\n        heap_adjust(heap, 0, i)\n    }\n    return heap\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n\n    // build max heap\n    for i := len(nums)/2; i >= 0; i-- {\n        max_heapify(nums, i)\n    }\n\n    // extract max n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        max_heapify(nums[:len(nums)-1-i], 0)\n    }\n\n    return nums[len(nums)-n:]\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    // build heap\n    for i := len(nums)/2 - 1; i >= 0; i-- {\n        heap_queue_largest_heapify(nums, i, len(nums))\n    }\n    // pop n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heap_queue_largest_heapify(nums, 0, len(nums)-1-i)\n    }\n    return nums[len(nums)-n:]\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    var heap []int\n    for i := 0; i < n; i++ {\n        heap = append(heap, nums[i])\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heap = heapify(heap, 0)\n        }\n    }\n    return heap\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(heap, i)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0)\n        }\n    }\n    return heap\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    build_heap(heap)\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0)\n        }\n    }\n    return heap\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n\n    // heapify\n    for i := len(nums)/2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // pop n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums, 0, len(nums)-1-i)\n    }\n\n    return nums[len(nums)-n:]\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    var heap []int\n    for i := 0; i < n; i++ {\n        heap = append(heap, nums[i])\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0)\n        }\n    }\n    return heap\n}\n",
    "    if len(nums) == 0 || n == 0 {\n        return nil\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    // build a heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n    // pop n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums) - i - 1] = nums[len(nums) - i - 1], nums[0]\n        heapify(nums, 0, len(nums) - i - 1)\n    }\n    return nums[len(nums) - n:]\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    // build a min heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        min_heapify(nums, i)\n    }\n    // extract the root n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums) - 1 - i] = nums[len(nums) - 1 - i], nums[0]\n        min_heapify(nums[:len(nums) - 1 - i], 0)\n    }\n    return nums[len(nums) - n:]\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n\n    // build a max heap\n    for i := len(nums)/2 - 1; i >= 0; i-- {\n        heap_queue_largest_heapify(nums, i, len(nums))\n    }\n\n    // extract the largest n elements\n    for i := len(nums) - 1; i >= len(nums) - n; i-- {\n        nums[0], nums[i] = nums[i], nums[0]\n        heap_queue_largest_heapify(nums, 0, i)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    if len(nums) < n {\n        return nil\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(heap, i)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0)\n        }\n    }\n    return heap\n}\n",
    "    if n <= 0 || len(nums) == 0 {\n        return []int{}\n    }\n\n    if n >= len(nums) {\n        return nums\n    }\n\n    // build a max heap\n    for i := len(nums)/2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // extract the top n elements\n    for i := len(nums)-1; i >= len(nums)-n; i-- {\n        nums[0], nums[i] = nums[i], nums[0]\n        heapify(nums, 0, i)\n    }\n\n    return nums[len(nums)-n:]\n}\n",
    "    if len(nums) < n {\n        return nums\n    }\n\n    heap := make([]int, n)\n    copy(heap, nums[:n])\n\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n\n    return heap\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heap_adjust(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heap_adjust(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n    // pop the top n elements\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums, 0, len(nums)-1-i)\n    }\n    return nums[len(nums)-n:]\n}\n",
    "    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // extract the top n elements\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums) - 1 - i] = nums[len(nums) - 1 - i], nums[0]\n        heapify(nums, 0, len(nums) - 1 - i)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n    // build a max heap\n    for i := len(nums)/2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n    // pop n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums, 0, len(nums)-1-i)\n    }\n    return nums[len(nums)-n:]\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // pop n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums) - i - 1] = nums[len(nums) - i - 1], nums[0]\n        heapify(nums, 0, len(nums) - i - 1)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    // build a max heap\n    heap := make([]int, 0)\n    for _, num := range nums {\n        heap = append(heap, num)\n        heapify_up(heap)\n    }\n\n    // pop n times\n    result := make([]int, 0)\n    for i := 0; i < n; i++ {\n        result = append(result, heap[0])\n        heap[0] = heap[len(heap)-1]\n        heap = heap[:len(heap)-1]\n        heapify_down(heap)\n    }\n\n    return result\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heap_queue_largest_heapify(nums, i, len(nums))\n    }\n    // extract the top n elements\n    for i := len(nums) - 1; i >= len(nums) - n; i-- {\n        nums[0], nums[i] = nums[i], nums[0]\n        heap_queue_largest_heapify(nums, 0, i)\n    }\n    return nums[len(nums) - n:]\n}\n",
    "    if len(nums) == 0 || n <= 0 {\n        return []int{}\n    }\n\n    if len(nums) <= n {\n        return nums\n    }\n\n    // build a min heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n\n    // insert the rest of the numbers into the heap\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n\n    // sort the heap\n    for i := n - 1; i > 0; i-- {\n        heap[0], heap[i] = heap[i], heap[0]\n        heapify(heap, 0, i)\n    }\n\n    return heap\n}\n",
    "    if len(nums) == 0 || n == 0 {\n        return []int{}\n    }\n\n    // build a max heap\n    for i := len(nums)/2 - 1; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // pop the largest element from the heap\n    for i := len(nums) - 1; i >= len(nums) - n; i-- {\n        nums[0], nums[i] = nums[i], nums[0]\n        heapify(nums, 0, i)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    // build heap\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(nums, i, n)\n    }\n    // heap sort\n    for i := n; i < len(nums); i++ {\n        if nums[i] > nums[0] {\n            nums[0], nums[i] = nums[i], nums[0]\n            heapify(nums, 0, n)\n        }\n    }\n    return nums[:n]\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    // build a max heap\n    for i := len(nums)/2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n    // pop n elements\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums, 0, len(nums)-1-i)\n    }\n    return nums[len(nums)-n:]\n}\n",
    "    if n < 1 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    // build a min heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    // insert the rest of the numbers into the heap\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    // sort the heap\n    for i := n-1; i > 0; i-- {\n        heap[0], heap[i] = heap[i], heap[0]\n        heapify(heap, 0, i)\n    }\n    return heap\n}\n",
    "    if len(nums) == 0 || n == 0 {\n        return []int{}\n    }\n    if len(nums) < n {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    build_heap(heap)\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0)\n        }\n    }\n    return heap\n}\n",
    "    if len(nums) < n {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n    if n <= 0 {\n        return []int{}\n    }\n    heap := nums[:n]\n    for i := n / 2; i >= 0; i-- {\n        heapify(heap, i)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0)\n        }\n    }\n    return heap\n}\n",
    "    if n <= 0 {\n        return nil\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    result := make([]int, n)\n    for i := 0; i < n; i++ {\n        result[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heap_queue_largest_heapify(result, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > result[0] {\n            result[0] = nums[i]\n            heap_queue_largest_heapify(result, 0, n)\n        }\n    }\n    return result\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n\n    if n >= len(nums) {\n        return nums\n    }\n\n    // build a max heap\n    for i := len(nums)/2 - 1; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // pop the top n elements\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums, 0, len(nums)-1-i)\n    }\n\n    return nums[len(nums)-n:]\n}\n",
    "    if len(nums) < n {\n        return nums\n    }\n\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // pop the largest n elements\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums, 0, len(nums)-1-i)\n    }\n\n    return nums[len(nums)-n:]\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n == 1 {\n        return []int{max(nums)}\n    }\n    if n == len(nums) {\n        return nums\n    }\n    if n > len(nums) {\n        return nums\n    }\n    var result []int\n    result = append(result, max(nums))\n    for i := 0; i < n - 1; i++ {\n        result = append(result, max(nums[:len(nums) - 1]))\n        nums = nums[:len(nums) - 1]\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    // build heap\n    for i := n/2; i >= 0; i-- {\n        heap_queue_largest_heapify(nums, i, n)\n    }\n    // extract max\n    for i := n; i < len(nums); i++ {\n        if nums[i] > nums[0] {\n            nums[0], nums[i] = nums[i], nums[0]\n            heap_queue_largest_heapify(nums, 0, n)\n        }\n    }\n    return nums[:n]\n}\n",
    "    if len(nums) < n {\n        return nil\n    }\n\n    // build heap\n    for i := len(nums)/2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // pop n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums, 0, len(nums)-1-i)\n    }\n\n    return nums[len(nums)-n:]\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heap_queue_largest_heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heap_queue_largest_heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        return nums\n    }\n    var result []int\n    for i := 0; i < n; i++ {\n        result = append(result, nums[i])\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heap_adjust(result, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > result[0] {\n            result[0] = nums[i]\n            heap_adjust(result, 0, n)\n        }\n    }\n    return result\n}\n",
    "    if len(nums) == 0 {\n        return []int{}\n    }\n\n    if n > len(nums) {\n        n = len(nums)\n    }\n\n    // build heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // pop n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums) - 1 - i] = nums[len(nums) - 1 - i], nums[0]\n        heapify(nums, 0, len(nums) - 1 - i)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    // create a max heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := (n - 1) / 2; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n <= 0 || n > len(nums) {\n        return nil\n    }\n\n    // build heap\n    for i := len(nums) / 2 - 1; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // pop n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums) - 1 - i] = nums[len(nums) - 1 - i], nums[0]\n        heapify(nums, 0, len(nums) - 1 - i)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    if n > len(nums) {\n        return nil\n    }\n    if n == len(nums) {\n        return nums\n    }\n    if n == 1 {\n        max := nums[0]\n        for _, num := range nums {\n            if num > max {\n                max = num\n            }\n        }\n        return []int{max}\n    }\n    // heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if len(nums) == 0 || n == 0 {\n        return []int{}\n    }\n\n    // build heap\n    for i := len(nums)/2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // pop n largest\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums, 0, len(nums)-1-i)\n    }\n\n    return nums[len(nums)-n:]\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n\n    return heap\n}\n",
    "    if len(nums) < n {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0)\n        }\n    }\n    return heap\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n\n    var heap []int\n    for _, num := range nums {\n        heap = append(heap, num)\n        if len(heap) > n {\n            heap = heap[1:]\n        }\n        heap = heapify(heap)\n    }\n\n    return heap\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n\n    if n > len(nums) {\n        n = len(nums)\n    }\n\n    // build a min heap\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(nums, n, i)\n    }\n\n    // extract the top n elements\n    for i := n; i < len(nums); i++ {\n        if nums[i] > nums[0] {\n            nums[0], nums[i] = nums[i], nums[0]\n            heapify(nums, n, 0)\n        }\n    }\n\n    return nums[:n]\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // pop the top n elements\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums) - 1 - i] = nums[len(nums) - 1 - i], nums[0]\n        heapify(nums, 0, len(nums) - 1 - i)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    // heapify\n    for i := len(nums) / 2 - 1; i >= 0; i-- {\n        heap_queue_largest_heapify(nums, i, len(nums))\n    }\n    // pop n times\n    for i := 0; i < n; i++ {\n        heap_queue_largest_pop(nums, len(nums) - i - 1)\n    }\n    return nums[len(nums) - n:]\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heap_adjust(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heap_adjust(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if len(nums) == 0 {\n        return nil\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if len(nums) == 0 || n <= 0 {\n        return nil\n    }\n    if len(nums) <= n {\n        return nums\n    }\n    // build heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n    // pop n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums, 0, len(nums)-1-i)\n    }\n    return nums[len(nums)-n:]\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n    // build heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n    // extract n largest\n    for i := len(nums) - 1; i >= len(nums) - n; i-- {\n        nums[0], nums[i] = nums[i], nums[0]\n        heapify(nums, 0, i)\n    }\n    return nums[len(nums) - n:]\n}\n",
    "    if len(nums) == 0 || n == 0 {\n        return []int{}\n    }\n    if len(nums) < n {\n        return nums\n    }\n    // build a max heap\n    heap := build_max_heap(nums)\n    // pop n times\n    for i := 0; i < n; i++ {\n        heap = pop(heap)\n    }\n    return heap\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        max_heapify(nums, i, len(nums))\n    }\n    // extract the top n elements\n    for i := len(nums) - 1; i >= len(nums) - n; i-- {\n        nums[0], nums[i] = nums[i], nums[0]\n        max_heapify(nums, 0, i)\n    }\n    return nums[len(nums) - n:]\n}\n",
    "    if len(nums) < n {\n        return nil\n    }\n    // build a heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n    // pop n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums, 0, len(nums)-1-i)\n    }\n    return nums[len(nums)-n:]\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n\n    // build a max heap\n    for i := len(nums)/2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // pop the top n elements\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-i-1] = nums[len(nums)-i-1], nums[0]\n        heapify(nums, 0, len(nums)-i-1)\n    }\n\n    return nums[len(nums)-n:]\n}\n",
    "    if n < 1 || len(nums) < n {\n        return []int{}\n    }\n\n    // build a max heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := (n - 2) / 2; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n\n    // insert the rest of the numbers into the heap\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n\n    // sort the heap\n    for i := n - 1; i > 0; i-- {\n        heap[0], heap[i] = heap[i], heap[0]\n        heapify(heap, 0, i)\n    }\n\n    return heap\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    var result []int\n    if len(nums) < n {\n        return result\n    }\n\n    // build a max heap\n    for i := len(nums)/2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // extract the top n elements\n    for i := 0; i < n; i++ {\n        result = append(result, nums[0])\n        nums[0] = nums[len(nums)-1]\n        nums = nums[:len(nums)-1]\n        heapify(nums, 0, len(nums))\n    }\n\n    return result\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    // build a max heap\n    for i := len(nums)/2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n    // pop the top n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-i-1] = nums[len(nums)-i-1], nums[0]\n        heapify(nums, 0, len(nums)-i-1)\n    }\n    return nums[len(nums)-n:]\n}\n",
    "    if len(nums) < n {\n        return nil\n    }\n\n    // initialize the heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n\n    // insert the rest of the elements\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n\n    // sort the heap\n    for i := n - 1; i > 0; i-- {\n        heap[0], heap[i] = heap[i], heap[0]\n        heapify(heap, 0, i)\n    }\n\n    return heap\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n\n    if n >= len(nums) {\n        return nums\n    }\n\n    // Build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i)\n    }\n\n    // Extract the top n elements\n    for i := len(nums) - 1; i >= len(nums) - n; i-- {\n        nums[0], nums[i] = nums[i], nums[0]\n        heapify(nums[:i], 0)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    // create a min heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n <= 0 || n > len(nums) {\n        return nil\n    }\n\n    var heap []int\n    for _, num := range nums {\n        if len(heap) < n {\n            heap = append(heap, num)\n            heap_up(heap, len(heap) - 1)\n        } else if num > heap[0] {\n            heap[0] = num\n            heap_down(heap, 0)\n        }\n    }\n\n    return heap\n}\n",
    "    if len(nums) < n {\n        return nil\n    }\n\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        max_heapify(nums, i, len(nums))\n    }\n\n    // extract the largest n elements\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        max_heapify(nums, 0, len(nums)-1-i)\n    }\n\n    return nums[len(nums)-n:]\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n\n    // Build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // Extract the top n elements\n    for i := len(nums) - 1; i >= len(nums) - n; i-- {\n        nums[0], nums[i] = nums[i], nums[0]\n        heapify(nums, 0, i)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(heap, i)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0)\n        }\n    }\n    return heap\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n\n    var heap []int\n    for _, num := range nums {\n        heap = append(heap, num)\n        if len(heap) > n {\n            heap = heap[1:]\n        }\n        heap = heapify(heap)\n    }\n\n    return heap\n}\n",
    "    if n <= 0 {\n        return nil\n    }\n\n    if n >= len(nums) {\n        return nums\n    }\n\n    // build a min heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        min_heapify(heap, i)\n    }\n\n    // insert the rest of the numbers into the heap\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            min_heapify(heap, 0)\n        }\n    }\n\n    // sort the heap\n    for i := n - 1; i > 0; i-- {\n        heap[0], heap[i] = heap[i], heap[0]\n        min_heapify(heap[:i], 0)\n    }\n\n    return heap\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    heap := make([]int, n)\n    copy(heap, nums[:n])\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n\n    if n >= len(nums) {\n        return nums\n    }\n\n    // build a max heap\n    for i := len(nums)/2 - 1; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // extract the max n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums, 0, len(nums)-1-i)\n    }\n\n    return nums[len(nums)-n:]\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n    if n == len(nums) {\n        return nums\n    }\n    if n == 0 {\n        return []int{}\n    }\n    var heap []int\n    for _, num := range nums {\n        if len(heap) < n {\n            heap = append(heap, num)\n            if len(heap) == n {\n                heap = heapify(heap)\n            }\n        } else {\n            if num > heap[0] {\n                heap[0] = num\n                heap = heapify(heap)\n            }\n        }\n    }\n    return heap\n}\n",
    "    if len(nums) == 0 || n == 0 {\n        return []int{}\n    }\n\n    if n > len(nums) {\n        n = len(nums)\n    }\n\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // extract the top n elements\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums) - 1 - i] = nums[len(nums) - 1 - i], nums[0]\n        heapify(nums, 0, len(nums) - 1 - i)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    if len(nums) < n {\n        return nums\n    }\n    var heap []int\n    for i := 0; i < n; i++ {\n        heap = append(heap, nums[i])\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0)\n        }\n    }\n    return heap\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n\n    if n >= len(nums) {\n        return nums\n    }\n\n    // init heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n\n    // insert\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n\n    return heap\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n    if n == len(nums) {\n        return nums\n    }\n    if n == 0 {\n        return []int{}\n    }\n\n    // build a min heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n\n    // sort the heap\n    for i := n - 1; i >= 0; i-- {\n        heap[0], heap[i] = heap[i], heap[0]\n        heapify(heap, 0, i)\n    }\n\n    return heap\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2; i >= 0; i-- {\n        heap_queue_largest_heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heap_queue_largest_heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if len(nums) < n {\n        return nums\n    }\n\n    // build a max heap\n    for i := len(nums)/2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // extract the max n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums, 0, len(nums)-1-i)\n    }\n\n    return nums[len(nums)-n:]\n}\n",
    "    if len(nums) < n {\n        return nil\n    }\n    if len(nums) == n {\n        return nums\n    }\n\n    // build a min heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n\n    return heap\n}\n",
    "    if len(nums) == 0 || n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if len(nums) <= n {\n        return nums\n    }\n\n    // build heap\n    for i := len(nums)/2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // pop n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums, 0, len(nums)-1-i)\n    }\n\n    return nums[len(nums)-n:]\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    // build a max heap\n    for i := len(nums)/2 - 1; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n    // pop n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums, 0, len(nums)-1-i)\n    }\n    return nums[len(nums)-n:]\n}\n",
    "    if n > len(nums) {\n        return nil\n    }\n\n    // build heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // swap root with last element\n    for i := len(nums) - 1; i >= len(nums) - n; i-- {\n        nums[0], nums[i] = nums[i], nums[0]\n        heapify(nums, 0, i)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    if n > len(nums) {\n        return nil\n    }\n    if n == len(nums) {\n        return nums\n    }\n    // build heap\n    for i := n/2 - 1; i >= 0; i-- {\n        heap_queue_largest_heapify(nums, i, n)\n    }\n    // heap sort\n    for i := n; i < len(nums); i++ {\n        if nums[i] > nums[0] {\n            nums[0], nums[i] = nums[i], nums[0]\n            heap_queue_largest_heapify(nums, 0, n)\n        }\n    }\n    return nums[:n]\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if len(nums) <= n {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n    var heap []int\n    for _, num := range nums {\n        if len(heap) < n {\n            heap = append(heap, num)\n            if len(heap) == n {\n                heap = build_heap(heap)\n            }\n        } else {\n            if num > heap[0] {\n                heap[0] = num\n                heap = heapify(heap, 0)\n            }\n        }\n    }\n    return heap\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n <= 0 || len(nums) == 0 {\n        return []int{}\n    }\n\n    if n >= len(nums) {\n        return nums\n    }\n\n    // build a min heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n\n    return heap\n}\n"
  ]
}