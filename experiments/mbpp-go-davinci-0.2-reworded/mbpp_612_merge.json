{
  "name": "mbpp_612_merge",
  "language": "go_test.go",
  "prompt": "package merge_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function which takes a list of lists, where each sublist has two elements, and returns a list of two lists where the first list has the first element of each sublist and the second one has the second.\nfunc merge(lst interface{}) interface{} {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_612_merge.py",
  "prompt_terminology": "reworded",
  "tests": "func TestMerge(t *testing.T) {\n  candidate := merge\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]string{\"x\", \"y\"}, []string{\"a\", \"b\"}, []string{\"m\", \"n\"}}), expected: [][]int{[]string{\"x\", \"a\", \"m\"}, []string{\"y\", \"b\", \"n\"}} },\n     { actual: candidate([][]int{[]int{1, 2}, []int{3, 4}, []int{5, 6}, []int{7, 8}}), expected: [][]int{[]int{1, 3, 5, 7}, []int{2, 4, 6, 8}} },\n     { actual: candidate([][]int{[]string{\"x\", \"y\", \"z\"}, []string{\"a\", \"b\", \"c\"}, []string{\"m\", \"n\", \"o\"}}), expected: [][]int{[]string{\"x\", \"a\", \"m\"}, []string{\"y\", \"b\", \"n\"}, []string{\"z\", \"c\", \"o\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    var result [][]int\n    switch lst.(type) {\n    case []interface{}:\n        for _, v := range lst.([]interface{}) {\n            result = append(result, merge(v).([]int))\n        }\n    case []int:\n        return lst.([]int)\n    }\n    return result\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: %v is not a list\", lst))\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: %v is not a list\", lst))\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: expected list, got %T\", lst))\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        l := lst.([]interface{})\n        if len(l) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(l) == 1 {\n            return []interface{}{[]interface{}{l[0].([]interface{})[0]}, []interface{}{l[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{l[0].([]interface{})[0]}, merge(l[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{l[0].([]interface{})[1]}, merge(l[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(\"Invalid input\")\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: expected list, got %T\", lst))\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: expected []interface{}, got %T\", lst))\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        l := lst.([]interface{})\n        if len(l) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(l) == 1 {\n            return []interface{}{[]interface{}{l[0].([]interface{})[0]}, []interface{}{l[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{l[0].([]interface{})[0]}, merge(l[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{l[0].([]interface{})[1]}, merge(l[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(\"Not a list\")\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: expected []interface{}, got %T\", lst))\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: expected []interface{}, got %T\", lst))\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return nil\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        } else {\n            if len(lst) == 1 {\n                return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n            } else {\n                return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n            }\n        }\n    default:\n        panic(fmt.Sprintf(\"merge: expected list, got %T\", lst))\n    }\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            lst := lst.([]interface{})\n            if len(lst) == 0 {\n                return []interface{}{[]interface{}{}, []interface{}{}}\n            }\n            if len(lst) == 1 {\n                return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n            }\n            return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n        default:\n            panic(\"Not a list\")\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        } else {\n            first := merge(lst[0]).([]interface{})\n            rest := merge(lst[1:]).([]interface{})\n            return []interface{}{append(first[0].([]interface{}), rest[0].([]interface{})...), append(first[1].([]interface{}), rest[1].([]interface{})...)}\n        }\n    case []int:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        } else {\n            first := merge(lst[0]).([]interface{})\n            rest := merge(lst[1:]).([]interface{})\n            return []interface{}{append(first[0].([]interface{}), rest[0].([]interface{})...), append(first[1].([]interface{}), rest[1].([]interface{})...)}\n        }\n    case [][]int:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        } else {\n            first := merge(lst[0]).([]interface{})\n            rest := merge(lst[1:]).([]interface{})\n            return []interface{}{append(first[0].([]interface{}), rest[0].([]interface{})...), append(first[1].([]interface{}), rest[1].([]interface{})...)}\n        }\n    case [][]interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        } else {\n            first := merge(lst[0]).([]interface{})\n            rest := merge(lst[1:]).([]interface{})\n            return []interface{}{append(first[0].([]interface{}), rest[0].([]interface{})...), append(first[1].([]",
    "    switch lst.(type) {\n    case []interface{}:\n        var lst1, lst2 []interface{}\n        for _, sub := range lst.([]interface{}) {\n            switch sub.(type) {\n            case []interface{}:\n                lst1 = append(lst1, sub.([]interface{})[0])\n                lst2 = append(lst2, sub.([]interface{})[1])\n            }\n        }\n        return []interface{}{lst1, lst2}\n    }\n    return nil\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: expected list, got %T\", lst))\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: %v is not a list\", lst))\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        l := lst.([]interface{})\n        if len(l) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(l) == 1 {\n            return []interface{}{[]interface{}{l[0].([]interface{})[0]}, []interface{}{l[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{l[0].([]interface{})[0]}, merge(l[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{l[0].([]interface{})[1]}, merge(l[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: expected []interface{}, got %T\", lst))\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        } else {\n            var first, second []interface{}\n            for _, sublist := range lst {\n                switch sublist := sublist.(type) {\n                case []interface{}:\n                    if len(sublist) == 2 {\n                        first = append(first, sublist[0])\n                        second = append(second, sublist[1])\n                    }\n                }\n            }\n            return []interface{}{first, second}\n        }\n    }\n    return nil\n}\n",
    "    return nil\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first []interface{}\n        var second []interface{}\n        for _, sublist := range lst.([]interface{}) {\n            if sublist.([]interface{})[0] != nil {\n                first = append(first, sublist.([]interface{})[0])\n            }\n            if sublist.([]interface{})[1] != nil {\n                second = append(second, sublist.([]interface{})[1])\n            }\n        }\n        return []interface{}{first, second}\n    default:\n        return nil\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: expected a list of lists, got %v\", lst))\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first, second []interface{}\n        for _, sublist := range lst.([]interface{}) {\n            switch sublist.(type) {\n            case []interface{}:\n                if len(sublist.([]interface{})) != 2 {\n                    panic(\"Sublist must have two elements\")\n                }\n                first = append(first, sublist.([]interface{})[0])\n                second = append(second, sublist.([]interface{})[1])\n            default:\n                panic(\"Sublist must be a list\")\n            }\n        }\n        return []interface{}{first, second}\n    default:\n        panic(\"List must be a list\")\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first []interface{}\n        var second []interface{}\n        for _, sublist := range lst.([]interface{}) {\n            switch sublist.(type) {\n            case []interface{}:\n                if len(sublist.([]interface{})) != 2 {\n                    panic(\"sublist must have two elements\")\n                }\n                first = append(first, sublist.([]interface{})[0])\n                second = append(second, sublist.([]interface{})[1])\n            default:\n                panic(\"sublist must be a list\")\n            }\n        }\n        return []interface{}{first, second}\n    default:\n        panic(\"list must be a list\")\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{\n            append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...),\n            append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...),\n        }\n    default:\n        panic(fmt.Sprintf(\"merge: expected []interface{}, got %T\", lst))\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append(lst[0].([]interface{}), merge(lst[1:]).([]interface{})[0].([]interface{})...), append(lst[0].([]interface{}), merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: %v is not a list\", lst))\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        var first []interface{}\n        var second []interface{}\n        for _, v := range lst {\n            switch v := v.(type) {\n            case []interface{}:\n                if len(v) != 2 {\n                    panic(\"merge: sublist must have exactly two elements\")\n                }\n                first = append(first, v[0])\n                second = append(second, v[1])\n            default:\n                panic(\"merge: list must contain only sublists\")\n            }\n        }\n        return []interface{}{first, second}\n    default:\n        panic(\"merge: argument must be a list\")\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first, second []interface{}\n        for _, sub := range lst.([]interface{}) {\n            switch sub.(type) {\n            case []interface{}:\n                if len(sub.([]interface{})) != 2 {\n                    panic(\"sublist must have two elements\")\n                }\n                first = append(first, sub.([]interface{})[0])\n                second = append(second, sub.([]interface{})[1])\n            default:\n                panic(\"sublist must be a list\")\n            }\n        }\n        return []interface{}{first, second}\n    default:\n        panic(\"list must be a list\")\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(\"Invalid input\")\n    }\n}\n",
    "    var result [][]int\n    switch lst.(type) {\n    case [][]int:\n        for _, sublist := range lst.([][]int) {\n            if len(sublist) != 2 {\n                panic(\"Sublist has not two elements\")\n            }\n            if len(result) == 0 {\n                result = append(result, []int{sublist[0]})\n                result = append(result, []int{sublist[1]})\n            } else {\n                result[0] = append(result[0], sublist[0])\n                result[1] = append(result[1], sublist[1])\n            }\n        }\n    default:\n        panic(\"Invalid type\")\n    }\n    return result\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: expected []interface{}, got %T\", lst))\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: expected a list of lists, got %v\", lst))\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return lst\n        }\n        switch lst[0].(type) {\n        case []interface{}:\n            return merge(lst[0]).([]interface{})\n        default:\n            return lst\n        }\n    default:\n        return lst\n    }\n}\n",
    "    if lst == nil {\n        return nil\n    }\n    switch lst.(type) {\n    case []interface{}:\n        l := lst.([]interface{})\n        if len(l) == 0 {\n            return nil\n        }\n        if len(l) == 1 {\n            return merge(l[0])\n        }\n        return merge([]interface{}{merge(l[0]), merge(l[1:])})\n    case []int:\n        l := lst.([]int)\n        if len(l) == 0 {\n            return nil\n        }\n        if len(l) == 1 {\n            return l[0]\n        }\n        return []int{l[0], merge(l[1:])}\n    case []string:\n        l := lst.([]string)\n        if len(l) == 0 {\n            return nil\n        }\n        if len(l) == 1 {\n            return l[0]\n        }\n        return []string{l[0], merge(l[1:])}\n    case [][]int:\n        l := lst.([][]int)\n        if len(l) == 0 {\n            return nil\n        }\n        if len(l) == 1 {\n            return merge(l[0])\n        }\n        return [][]int{merge(l[0]), merge(l[1:])}\n    case [][]string:\n        l := lst.([][]string)\n        if len(l) == 0 {\n            return nil\n        }\n        if len(l) == 1 {\n            return merge(l[0])\n        }\n        return [][]string{merge(l[0]), merge(l[1:])}\n    default:\n        return nil\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        if len(lst) > 1 {\n            return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n        }\n    }\n    return nil\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: expected []interface{}, got %T\", lst))\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        } else {\n            first := lst[0].([]interface{})\n            rest := merge(lst[1:]).([]interface{})\n            return []interface{}{append(first[:1], rest[0].([]interface{})...), append(first[1:], rest[1].([]interface{})...)}\n        }\n    default:\n        panic(fmt.Sprintf(\"merge: expected []interface{}, got %T\", lst))\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        first := lst[0].([]interface{})\n        rest := merge(lst[1:]).([]interface{})\n        return []interface{}{append(first, rest[0].([]interface{})...), append(first, rest[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        switch lst.([]interface{})[0].(type) {\n        case []interface{}:\n            return merge(lst.([]interface{})[0].([]interface{}))\n        default:\n            return lst\n        }\n    default:\n        return lst\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append(lst[0].([]interface{}), merge(lst[1:]).([]interface{})[0].([]interface{})...), append(lst[0].([]interface{})[1:], merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: expected []interface{}, got %T\", lst))\n    }\n}\n",
    "    var res [][]int\n    res = make([][]int, 2)\n    res[0] = make([]int, 0)\n    res[1] = make([]int, 0)\n    switch lst.(type) {\n    case [][]int:\n        for _, v := range lst.([][]int) {\n            res[0] = append(res[0], v[0])\n            res[1] = append(res[1], v[1])\n        }\n    }\n    return res\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: expected a list, got %T\", lst))\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return lst\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        if len(lst) == 2 {\n            return merge2(lst[0], lst[1])\n        }\n        return merge2(merge(lst[:len(lst)/2]), merge(lst[len(lst)/2:]))\n    default:\n        return lst\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        } else {\n            switch lst[0].(type) {\n            case []interface{}:\n                if len(lst[0].([]interface{})) == 2 {\n                    var lst1 []interface{}\n                    var lst2 []interface{}\n                    lst1 = append(lst1, lst[0].([]interface{})[0])\n                    lst2 = append(lst2, lst[0].([]interface{})[1])\n                    for _, v := range lst[1:] {\n                        switch v.(type) {\n                        case []interface{}:\n                            if len(v.([]interface{})) == 2 {\n                                lst1 = append(lst1, v.([]interface{})[0])\n                                lst2 = append(lst2, v.([]interface{})[1])\n                            } else {\n                                return nil\n                            }\n                        default:\n                            return nil\n                        }\n                    }\n                    return []interface{}{lst1, lst2}\n                } else {\n                    return nil\n                }\n            default:\n                return nil\n            }\n        }\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first []interface{}\n        var second []interface{}\n        for _, sublst := range lst.([]interface{}) {\n            if sublst.([]interface{})[0] != nil {\n                first = append(first, sublst.([]interface{})[0])\n            }\n            if sublst.([]interface{})[1] != nil {\n                second = append(second, sublst.([]interface{})[1])\n            }\n        }\n        return []interface{}{first, second}\n    default:\n        return nil\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: expected a list of lists, got %T\", lst))\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        return merge_list(lst.([]interface{}))\n    default:\n        panic(fmt.Sprintf(\"merge: expected list, got %T\", lst))\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first []interface{}\n        var second []interface{}\n        for _, item := range lst.([]interface{}) {\n            switch item.(type) {\n            case []interface{}:\n                first = append(first, item.([]interface{})[0])\n                second = append(second, item.([]interface{})[1])\n            }\n        }\n        return []interface{}{first, second}\n    }\n    return nil\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        } else {\n            return merge(lst[1:]).([]interface{})\n        }\n    default:\n        panic(fmt.Sprintf(\"merge: expected list, got %T\", lst))\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        return merge_list(lst.([]interface{}))\n    default:\n        return lst\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: expected list, got %T\", lst))\n    }\n}\n",
    "    var result [][]interface{}\n    var first []interface{}\n    var second []interface{}\n    for _, sublist := range lst.([][]interface{}) {\n        first = append(first, sublist[0])\n        second = append(second, sublist[1])\n    }\n    result = append(result, first)\n    result = append(result, second)\n    return result\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        l := lst.([]interface{})\n        if len(l) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(l) == 1 {\n            return []interface{}{[]interface{}{l[0].([]interface{})[0]}, []interface{}{l[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{l[0].([]interface{})[0]}, merge(l[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{l[0].([]interface{})[1]}, merge(l[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    if lst == nil {\n        return nil\n    }\n    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return nil\n        }\n        if len(lst) == 1 {\n            return merge(lst[0])\n        }\n        return []interface{}{merge(lst[0]), merge(lst[1:])}\n    case []int:\n        lst := lst.([]int)\n        if len(lst) == 0 {\n            return nil\n        }\n        if len(lst) == 1 {\n            return merge(lst[0])\n        }\n        return []int{merge(lst[0]), merge(lst[1:])}\n    case int:\n        return lst\n    default:\n        panic(fmt.Sprintf(\"merge: unsupported type %T\", lst))\n    }\n}\n",
    "    var result []interface{}\n    switch lst.(type) {\n    case []interface{}:\n        for _, sublst := range lst.([]interface{}) {\n            switch sublst.(type) {\n            case []interface{}:\n                if len(sublst.([]interface{})) != 2 {\n                    panic(\"Each sublist must have two elements\")\n                }\n                if len(result) == 0 {\n                    result = append(result, []interface{}{sublst.([]interface{})[0]})\n                    result = append(result, []interface{}{sublst.([]interface{})[1]})\n                } else {\n                    result[0] = append(result[0].([]interface{}), sublst.([]interface{})[0])\n                    result[1] = append(result[1].([]interface{}), sublst.([]interface{})[1])\n                }\n            default:\n                panic(\"Each sublist must be a list\")\n            }\n        }\n    default:\n        panic(\"The argument must be a list\")\n    }\n    return result\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var res []interface{}\n        for _, v := range lst.([]interface{}) {\n            switch v.(type) {\n            case []interface{}:\n                if len(v.([]interface{})) != 2 {\n                    panic(\"merge: sublist must have two elements\")\n                }\n                res = append(res, v.([]interface{})[0])\n                res = append(res, v.([]interface{})[1])\n            default:\n                panic(\"merge: list must contain sublists\")\n            }\n        }\n        return res\n    default:\n        panic(\"merge: argument must be a list\")\n    }\n}\n",
    "    lst_of_lsts := lst.([]interface{})\n    lst1 := make([]interface{}, len(lst_of_lsts))\n    lst2 := make([]interface{}, len(lst_of_lsts))\n    for i, lst := range lst_of_lsts {\n        lst_of_lsts[i] = lst.([]interface{})\n        lst1[i] = lst_of_lsts[i][0]\n        lst2[i] = lst_of_lsts[i][1]\n    }\n    return []interface{}{lst1, lst2}\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: expected list, got %v\", lst))\n    }\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        l := lst.([]interface{})\n        if len(l) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(l) == 1 {\n            return []interface{}{[]interface{}{l[0].([]interface{})[0]}, []interface{}{l[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{l[0].([]interface{})[0]}, merge(l[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{l[0].([]interface{})[1]}, merge(l[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var lst1 []interface{}\n        var lst2 []interface{}\n        for _, v := range lst.([]interface{}) {\n            if v.([]interface{})[0] != nil {\n                lst1 = append(lst1, v.([]interface{})[0])\n            }\n            if v.([]interface{})[1] != nil {\n                lst2 = append(lst2, v.([]interface{})[1])\n            }\n        }\n        return []interface{}{lst1, lst2}\n    default:\n        return nil\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: expected list, got %T\", lst))\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return lst\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        if len(lst) == 2 {\n            return lst\n        }\n        return merge([]interface{}{merge(lst[0:len(lst)/2]), merge(lst[len(lst)/2:])})\n    case [][]interface{}:\n        if len(lst) == 0 {\n            return lst\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        if len(lst) == 2 {\n            return [][]interface{}{[]interface{}{lst[0][0], lst[1][0]}, []interface{}{lst[0][1], lst[1][1]}}\n        }\n        return merge([][]interface{}{merge(lst[0:len(lst)/2]).([][]interface{}), merge(lst[len(lst)/2:]).([][]interface{})})\n    default:\n        panic(fmt.Sprintf(\"merge: %v\", lst))\n    }\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            lst := lst.([]interface{})\n            if len(lst) == 0 {\n                return []interface{}{[]interface{}{}, []interface{}{}}\n            }\n            if len(lst) == 1 {\n                return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n            }\n            if len(lst) > 1 {\n                return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n            }\n    }\n    return nil\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first, second []interface{}\n        for _, sub := range lst.([]interface{}) {\n            switch sub.(type) {\n            case []interface{}:\n                if len(sub.([]interface{})) != 2 {\n                    panic(\"sublist must have two elements\")\n                }\n                first = append(first, sub.([]interface{})[0])\n                second = append(second, sub.([]interface{})[1])\n            default:\n                panic(\"sublist must be a list\")\n            }\n        }\n        return []interface{}{first, second}\n    default:\n        panic(\"list must be a list\")\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: expected []interface{}, got %T\", lst))\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first, second []interface{}\n        for _, v := range lst.([]interface{}) {\n            switch v.(type) {\n            case []interface{}:\n                if len(v.([]interface{})) != 2 {\n                    panic(\"Invalid input\")\n                }\n                first = append(first, v.([]interface{})[0])\n                second = append(second, v.([]interface{})[1])\n            default:\n                panic(\"Invalid input\")\n            }\n        }\n        return []interface{}{first, second}\n    default:\n        panic(\"Invalid input\")\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: expected []interface{}, got %T\", lst))\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: %v is not a list\", lst))\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append(lst[0].([]interface{}), merge(lst[1:]).([]interface{})[0].([]interface{})...), append(lst[0].([]interface{}), merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        l := lst.([]interface{})\n        if len(l) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(l) == 1 {\n            return []interface{}{[]interface{}{l[0].([]interface{})[0]}, []interface{}{l[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{l[0].([]interface{})[0]}, merge(l[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{l[0].([]interface{})[1]}, merge(l[1:]).([]interface{})[1].([]interface{})...)}\n    }\n    return nil\n}\n",
    "    var result [][]int\n    switch lst.(type) {\n    case []interface{}:\n        for _, v := range lst.([]interface{}) {\n            result = append(result, merge(v).([]int))\n        }\n    case []int:\n        return lst.([]int)\n    }\n    return result\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first, second []interface{}\n        for _, sub := range lst.([]interface{}) {\n            switch sub.(type) {\n            case []interface{}:\n                first = append(first, sub.([]interface{})[0])\n                second = append(second, sub.([]interface{})[1])\n            }\n        }\n        return []interface{}{first, second}\n    }\n    return nil\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: %v is not a list\", lst))\n    }\n}\n",
    "    var result []interface{}\n    var first []interface{}\n    var second []interface{}\n    for _, sublst := range lst.([]interface{}) {\n        first = append(first, sublst.([]interface{})[0])\n        second = append(second, sublst.([]interface{})[1])\n    }\n    result = append(result, first)\n    result = append(result, second)\n    return result\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: %v is not a list\", lst))\n    }\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            l := lst.([]interface{})\n            if len(l) == 0 {\n                return []interface{}{[]interface{}{}, []interface{}{}}\n            }\n            if len(l) == 1 {\n                return []interface{}{[]interface{}{l[0].([]interface{})[0]}, []interface{}{l[0].([]interface{})[1]}}\n            }\n            return []interface{}{append([]interface{}{l[0].([]interface{})[0]}, merge(l[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{l[0].([]interface{})[1]}, merge(l[1:]).([]interface{})[1].([]interface{})...)}\n        default:\n            panic(\"merge: not a list\")\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: expected []interface{}, got %T\", lst))\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var lst1 []interface{}\n        var lst2 []interface{}\n        for _, item := range lst.([]interface{}) {\n            switch item.(type) {\n            case []interface{}:\n                lst1 = append(lst1, item.([]interface{})[0])\n                lst2 = append(lst2, item.([]interface{})[1])\n            default:\n                return nil\n            }\n        }\n        return []interface{}{lst1, lst2}\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        l := lst.([]interface{})\n        if len(l) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(l) == 1 {\n            return []interface{}{[]interface{}{l[0].([]interface{})[0]}, []interface{}{l[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{l[0].([]interface{})[0]}, merge(l[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{l[0].([]interface{})[1]}, merge(l[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        l := lst.([]interface{})\n        if len(l) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(l) == 1 {\n            return []interface{}{[]interface{}{l[0].([]interface{})[0]}, []interface{}{l[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{l[0].([]interface{})[0]}, merge(l[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{l[0].([]interface{})[1]}, merge(l[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: expected []interface{}, got %T\", lst))\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: expected []interface{}, got %T\", lst))\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        l := lst.([]interface{})\n        if len(l) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(l) == 1 {\n            return []interface{}{[]interface{}{l[0].([]interface{})[0]}, []interface{}{l[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{l[0].([]interface{})[0]}, merge(l[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{l[0].([]interface{})[1]}, merge(l[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(\"merge: not a list\")\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first, second []interface{}\n        for _, sublist := range lst.([]interface{}) {\n            switch sublist.(type) {\n            case []interface{}:\n                if len(sublist.([]interface{})) == 2 {\n                    first = append(first, sublist.([]interface{})[0])\n                    second = append(second, sublist.([]interface{})[1])\n                }\n            }\n        }\n        return []interface{}{first, second}\n    }\n    return nil\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: expected a list of lists, got %T\", lst))\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        } else {\n            first, second := merge(lst[1:]).([][]interface{})\n            return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, first...), append([]interface{}{lst[0].([]interface{})[1]}, second...)}\n        }\n    default:\n        panic(\"merge: invalid argument\")\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        } else {\n            var first, second []interface{}\n            for _, sublist := range lst {\n                switch sublist := sublist.(type) {\n                case []interface{}:\n                    if len(sublist) == 2 {\n                        first = append(first, sublist[0])\n                        second = append(second, sublist[1])\n                    }\n                }\n            }\n            return []interface{}{first, second}\n        }\n    }\n    return nil\n}\n",
    "    lst_of_lsts := lst.([]interface{})\n    lst1 := make([]interface{}, len(lst_of_lsts))\n    lst2 := make([]interface{}, len(lst_of_lsts))\n    for i, lst := range lst_of_lsts {\n        lst_of_lst := lst.([]interface{})\n        lst1[i] = lst_of_lst[0]\n        lst2[i] = lst_of_lst[1]\n    }\n    return []interface{}{lst1, lst2}\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first, second []interface{}\n        for _, sublist := range lst.([]interface{}) {\n            switch sublist.(type) {\n            case []interface{}:\n                if len(sublist.([]interface{})) != 2 {\n                    panic(\"Sublist must have two elements\")\n                }\n                first = append(first, sublist.([]interface{})[0])\n                second = append(second, sublist.([]interface{})[1])\n            default:\n                panic(\"Sublist must be a list\")\n            }\n        }\n        return []interface{}{first, second}\n    default:\n        panic(\"List must be a list\")\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return lst\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        if len(lst) == 2 {\n            return lst\n        }\n        return merge([]interface{}{merge(lst[0:2]), merge(lst[2:])})\n    case []int:\n        if len(lst) == 0 {\n            return lst\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        if len(lst) == 2 {\n            return lst\n        }\n        return merge([]int{merge(lst[0:2]).([]int), merge(lst[2:]).([]int)})\n    case []string:\n        if len(lst) == 0 {\n            return lst\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        if len(lst) == 2 {\n            return lst\n        }\n        return merge([]string{merge(lst[0:2]).([]string), merge(lst[2:]).([]string)})\n    case [][]int:\n        if len(lst) == 0 {\n            return lst\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        if len(lst) == 2 {\n            return lst\n        }\n        return merge([][]int{merge(lst[0:2]).([][]int), merge(lst[2:]).([][]int)})\n    case [][]string:\n        if len(lst) == 0 {\n            return lst\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        if len(lst) == 2 {\n            return lst\n        }\n        return merge([][]string{merge(lst[0:2]).([][]string), merge(lst[",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return lst\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        if len(lst) == 2 {\n            return merge(lst[0], lst[1])\n        }\n        return merge(merge(lst[0], lst[1]), lst[2:])\n    case [][]interface{}:\n        if len(lst) == 0 {\n            return lst\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        if len(lst) == 2 {\n            return merge(lst[0], lst[1])\n        }\n        return merge(merge(lst[0], lst[1]), lst[2:])\n    case []int:\n        if len(lst) == 0 {\n            return lst\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        if len(lst) == 2 {\n            return merge(lst[0], lst[1])\n        }\n        return merge(merge(lst[0], lst[1]), lst[2:])\n    case [][]int:\n        if len(lst) == 0 {\n            return lst\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        if len(lst) == 2 {\n            return merge(lst[0], lst[1])\n        }\n        return merge(merge(lst[0], lst[1]), lst[2:])\n    case []string:\n        if len(lst) == 0 {\n            return lst\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        if len(lst) == 2 {\n            return merge(lst[0], lst[1])\n        }\n        return merge(merge(lst[0], lst[1]),",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{}\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        if len(lst) == 2 {\n            return merge2(lst[0], lst[1])\n        }\n        return merge2(merge(lst[:len(lst)/2]), merge(lst[len(lst)/2:]))\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first, second []interface{}\n        for _, sublist := range lst.([]interface{}) {\n            switch sublist.(type) {\n            case []interface{}:\n                if len(sublist.([]interface{})) != 2 {\n                    panic(\"Sublist must have two elements\")\n                }\n                first = append(first, sublist.([]interface{})[0])\n                second = append(second, sublist.([]interface{})[1])\n            default:\n                panic(\"Sublist must be a list\")\n            }\n        }\n        return []interface{}{first, second}\n    default:\n        panic(\"List must be a list\")\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        if len(lst) > 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0], lst[1].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1], lst[1].([]interface{})[1]}}\n        }\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n    return []interface{}{[]interface{}{}, []interface{}{}}\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    var result [][]int\n    switch lst.(type) {\n    case [][]int:\n        for _, sublist := range lst.([][]int) {\n            result = append(result, sublist)\n        }\n    }\n    return result\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        if len(lst) > 1 {\n            return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n        }\n    }\n    return nil\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        switch lst.([]interface{})[0].(type) {\n        case []interface{}:\n            return merge(lst.([]interface{})[0].([]interface{}))\n        case int:\n            return lst.([]interface{})[0].(int)\n        }\n    case int:\n        return lst.(int)\n    }\n    return nil\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append(lst[0].([]interface{}), merge(lst[1:]).([]interface{})[0].([]interface{})...), append(lst[0].([]interface{}), merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: unexpected type %T\", lst))\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: %v is not a list\", lst))\n    }\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        } else {\n            switch lst[0].(type) {\n            case []interface{}:\n                if len(lst[0].([]interface{})) == 2 {\n                    return merge(lst[1:]).([]interface{})\n                } else {\n                    return []interface{}{[]interface{}{}, []interface{}{}}\n                }\n            default:\n                return []interface{}{[]interface{}{}, []interface{}{}}\n            }\n        }\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first, second []interface{}\n        for _, item := range lst.([]interface{}) {\n            switch item.(type) {\n            case []interface{}:\n                first = append(first, item.([]interface{})[0])\n                second = append(second, item.([]interface{})[1])\n            }\n        }\n        return []interface{}{first, second}\n    }\n    return nil\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        if len(lst) > 1 {\n            return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n        }\n    }\n    return nil\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        } else {\n            return merge(lst[1:]).([]interface{})\n        }\n    case [][]interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        } else {\n            return merge(lst[1:]).([]interface{})\n        }\n    default:\n        panic(fmt.Sprintf(\"merge: unsupported type %T\", lst))\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first []interface{}\n        var second []interface{}\n        for _, sublist := range lst.([]interface{}) {\n            if sublist.([]interface{})[0] != nil {\n                first = append(first, sublist.([]interface{})[0])\n            }\n            if sublist.([]interface{})[1] != nil {\n                second = append(second, sublist.([]interface{})[1])\n            }\n        }\n        return []interface{}{first, second}\n    default:\n        return nil\n    }\n}\n",
    "    var result [][]interface{}\n    for _, sublist := range lst.([][]interface{}) {\n        for i, item := range sublist {\n            if len(result) <= i {\n                result = append(result, []interface{}{})\n            }\n            result[i] = append(result[i], item)\n        }\n    }\n    return result\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        if len(lst) == 2 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0], lst[1].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1], lst[1].([]interface{})[1]}}\n        }\n        return []interface{}{[]interface{}{lst[0].([]interface{})[0], lst[1].([]interface{})[0], lst[2].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1], lst[1].([]interface{})[1], lst[2].([]interface{})[1]}}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return lst\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        if len(lst) == 2 {\n            return merge2(lst[0], lst[1])\n        }\n        return merge2(merge(lst[:len(lst)/2]), merge(lst[len(lst)/2:]))\n    default:\n        return lst\n    }\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first []interface{}\n        var second []interface{}\n        for _, sublst := range lst.([]interface{}) {\n            switch sublst.(type) {\n            case []interface{}:\n                if len(sublst.([]interface{})) != 2 {\n                    panic(\"Sublist must have exactly two elements\")\n                }\n                first = append(first, sublst.([]interface{})[0])\n                second = append(second, sublst.([]interface{})[1])\n            default:\n                panic(\"Sublist must be a list\")\n            }\n        }\n        return []interface{}{first, second}\n    default:\n        panic(\"List must be a list\")\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(\"Invalid type\")\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        l := lst.([]interface{})\n        if len(l) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(l) == 1 {\n            return []interface{}{[]interface{}{l[0].([]interface{})[0]}, []interface{}{l[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{l[0].([]interface{})[0]}, merge(l[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{l[0].([]interface{})[1]}, merge(l[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    var result []interface{}\n    var first []interface{}\n    var second []interface{}\n    for _, v := range lst.([]interface{}) {\n        first = append(first, v.([]interface{})[0])\n        second = append(second, v.([]interface{})[1])\n    }\n    result = append(result, first)\n    result = append(result, second)\n    return result\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first, second []interface{}\n        for _, sublist := range lst.([]interface{}) {\n            switch sublist.(type) {\n            case []interface{}:\n                if len(sublist.([]interface{})) == 2 {\n                    first = append(first, sublist.([]interface{})[0])\n                    second = append(second, sublist.([]interface{})[1])\n                }\n            }\n        }\n        return []interface{}{first, second}\n    }\n    return nil\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        l := lst.([]interface{})\n        if len(l) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(l) == 1 {\n            return []interface{}{[]interface{}{l[0].([]interface{})[0]}, []interface{}{l[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{l[0].([]interface{})[0]}, merge(l[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{l[0].([]interface{})[1]}, merge(l[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first, second []interface{}\n        for _, sublist := range lst.([]interface{}) {\n            switch sublist.(type) {\n            case []interface{}:\n                if len(sublist.([]interface{})) != 2 {\n                    panic(\"sublist must have two elements\")\n                }\n                first = append(first, sublist.([]interface{})[0])\n                second = append(second, sublist.([]interface{})[1])\n            default:\n                panic(\"sublist must be a list\")\n            }\n        }\n        return []interface{}{first, second}\n    default:\n        panic(\"list must be a list\")\n    }\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: argument must be a list of lists, got %T\", lst))\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(\"merge: argument must be a list of lists\")\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append(lst[0].([]interface{}), merge(lst[1:]).([]interface{})[0].([]interface{})...), append(lst[0].([]interface{}), merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: expected a list, got %T\", lst))\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: expected []interface{}, got %T\", lst))\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first []interface{}\n        var second []interface{}\n        for _, v := range lst.([]interface{}) {\n            switch v.(type) {\n            case []interface{}:\n                first = append(first, v.([]interface{})[0])\n                second = append(second, v.([]interface{})[1])\n            }\n        }\n        return []interface{}{first, second}\n    }\n    return nil\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: expected []interface{}, got %T\", lst))\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: expected []interface{}, got %T\", lst))\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        switch lst.([]interface{})[0].(type) {\n        case []interface{}:\n            return merge(lst.([]interface{})[1:]).([]interface{})\n        case int:\n            return []interface{}{[]interface{}{lst.([]interface{})[0].(int)}, []interface{}{lst.([]interface{})[1].(int)}}\n        }\n    }\n    return nil\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        } else {\n            var first []interface{}\n            var second []interface{}\n            for _, sublist := range lst {\n                if sublist, ok := sublist.([]interface{}); ok {\n                    if len(sublist) == 2 {\n                        first = append(first, sublist[0])\n                        second = append(second, sublist[1])\n                    }\n                }\n            }\n            return []interface{}{first, second}\n        }\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        } else {\n            var first, second []interface{}\n            for _, sublist := range lst {\n                switch sublist := sublist.(type) {\n                case []interface{}:\n                    if len(sublist) == 2 {\n                        first = append(first, sublist[0])\n                        second = append(second, sublist[1])\n                    }\n                }\n            }\n            return []interface{}{first, second}\n        }\n    }\n    return nil\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append(lst[0].([]interface{})[0].([]interface{}), lst[1].([]interface{})[0].([]interface{})...), append(lst[0].([]interface{})[1].([]interface{}), lst[1].([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    if lst == nil {\n        return nil\n    }\n    switch lst.(type) {\n    case []interface{}:\n        var first []interface{}\n        var second []interface{}\n        for _, v := range lst.([]interface{}) {\n            if v == nil {\n                continue\n            }\n            switch v.(type) {\n            case []interface{}:\n                if len(v.([]interface{})) != 2 {\n                    panic(\"sublist must have two elements\")\n                }\n                first = append(first, v.([]interface{})[0])\n                second = append(second, v.([]interface{})[1])\n            default:\n                panic(\"sublist must be a list\")\n            }\n        }\n        return []interface{}{first, second}\n    default:\n        panic(\"list must be a list\")\n    }\n}\n",
    "    switch lst := lst.(type) {\n        case []interface{}:\n            if len(lst) == 0 {\n                return []interface{}{[]interface{}{}, []interface{}{}}\n            } else {\n                return merge(lst[1:]).([]interface{})[0]\n            }\n        case [][]interface{}:\n            if len(lst) == 0 {\n                return []interface{}{[]interface{}{}, []interface{}{}}\n            } else {\n                return merge(lst[1:]).([]interface{})[0]\n            }\n        default:\n            return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        var first, second []interface{}\n        for _, sub := range lst {\n            switch sub := sub.(type) {\n            case []interface{}:\n                first = append(first, sub[0])\n                second = append(second, sub[1])\n            default:\n                panic(fmt.Sprintf(\"merge: expected list of lists, got %T\", lst))\n            }\n        }\n        return []interface{}{first, second}\n    default:\n        panic(fmt.Sprintf(\"merge: expected list, got %T\", lst))\n    }\n}\n",
    "    var result [][]interface{}\n    var first []interface{}\n    var second []interface{}\n    for _, v := range lst.([][]interface{}) {\n        first = append(first, v[0])\n        second = append(second, v[1])\n    }\n    result = append(result, first)\n    result = append(result, second)\n    return result\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: expected []interface{}, got %T\", lst))\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: expected []interface{}, got %T\", lst))\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append(lst[0].([]interface{}), merge(lst[1:]).([]interface{})[0].([]interface{})...), append(lst[0].([]interface{}), merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    var result [][]int\n    var first []int\n    var second []int\n\n    for _, sublist := range lst.([][]int) {\n        first = append(first, sublist[0])\n        second = append(second, sublist[1])\n    }\n\n    result = append(result, first)\n    result = append(result, second)\n\n    return result\n}\n",
    "    var result [][]int\n    for _, sublist := range lst.([][]int) {\n        result = append(result, sublist)\n    }\n    return result\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        } else {\n            first := lst[0].([]interface{})\n            rest := merge(lst[1:]).([]interface{})\n            return []interface{}{append(first[:1], rest[0].([]interface{})...), append(first[1:], rest[1].([]interface{})...)}\n        }\n    default:\n        panic(fmt.Sprintf(\"merge: expected []interface{}, got %T\", lst))\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first, second []interface{}\n        for _, sublist := range lst.([]interface{}) {\n            switch sublist.(type) {\n            case []interface{}:\n                if len(sublist.([]interface{})) != 2 {\n                    panic(\"Sublists must have two elements\")\n                }\n                first = append(first, sublist.([]interface{})[0])\n                second = append(second, sublist.([]interface{})[1])\n            default:\n                panic(\"Sublists must be lists\")\n            }\n        }\n        return []interface{}{first, second}\n    default:\n        panic(\"List must be a list\")\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first, second []interface{}\n        for _, sublist := range lst.([]interface{}) {\n            switch sublist.(type) {\n            case []interface{}:\n                if len(sublist.([]interface{})) != 2 {\n                    panic(\"sublist has not two elements\")\n                }\n                first = append(first, sublist.([]interface{})[0])\n                second = append(second, sublist.([]interface{})[1])\n            default:\n                panic(\"sublist is not a list\")\n            }\n        }\n        return []interface{}{first, second}\n    default:\n        panic(\"list is not a list\")\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        } else {\n            head := lst[0].([]interface{})\n            tail := lst[1:]\n            tail_merged := merge(tail).([]interface{})\n            return []interface{}{append(head[:1], tail_merged[0]...), append(head[1:], tail_merged[1]...)}\n        }\n    default:\n        panic(fmt.Sprintf(\"merge: expected []interface{}, got %T\", lst))\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return lst\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        if len(lst) == 2 {\n            return lst\n        }\n        return merge([]interface{}{merge(lst[0:2]), merge(lst[2:])})\n    case [][]interface{}:\n        if len(lst) == 0 {\n            return lst\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        if len(lst) == 2 {\n            return [][]interface{}{[]interface{}{lst[0][0], lst[1][0]}, []interface{}{lst[0][1], lst[1][1]}}\n        }\n        return merge([][]interface{}{merge(lst[0:2]), merge(lst[2:])})\n    default:\n        return lst\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: %v is not a list\", lst))\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return nil\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        if len(lst) == 2 {\n            return lst\n        }\n        return merge([]interface{}{merge(lst[0:len(lst)/2]), merge(lst[len(lst)/2:])})\n    case [][]interface{}:\n        if len(lst) == 0 {\n            return nil\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        if len(lst) == 2 {\n            return [][]interface{}{append(lst[0], lst[1][0]), append(lst[0], lst[1][1])}\n        }\n        return merge([][]interface{}{merge(lst[0:len(lst)/2]), merge(lst[len(lst)/2:])})\n    }\n    return nil\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        } else {\n            var first, second []interface{}\n            for _, sublist := range lst {\n                switch sublist := sublist.(type) {\n                case []interface{}:\n                    if len(sublist) == 2 {\n                        first = append(first, sublist[0])\n                        second = append(second, sublist[1])\n                    }\n                }\n            }\n            return []interface{}{first, second}\n        }\n    }\n    return nil\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        } else {\n            switch lst[0].(type) {\n            case []interface{}:\n                if len(lst[0].([]interface{})) == 2 {\n                    return merge(lst[1:]).([]interface{})\n                } else {\n                    return []interface{}{[]interface{}{}, []interface{}{}}\n                }\n            default:\n                return []interface{}{[]interface{}{}, []interface{}{}}\n            }\n        }\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: expected list, got %T\", lst))\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first []interface{}\n        var second []interface{}\n        for _, sublst := range lst.([]interface{}) {\n            switch sublst.(type) {\n            case []interface{}:\n                if len(sublst.([]interface{})) != 2 {\n                    panic(\"Sublist must have exactly two elements\")\n                }\n                first = append(first, sublst.([]interface{})[0])\n                second = append(second, sublst.([]interface{})[1])\n            default:\n                panic(\"Sublist must be a list\")\n            }\n        }\n        return []interface{}{first, second}\n    default:\n        panic(\"List must be a list\")\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: %v is not a list\", lst))\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        } else {\n            first := lst[0].([]interface{})\n            rest := merge(lst[1:]).([]interface{})\n            return []interface{}{append(first[:1], rest[0].([]interface{})...), append(first[1:], rest[1].([]interface{})...)}\n        }\n    default:\n        panic(fmt.Sprintf(\"merge: expected list, got %T\", lst))\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: expected []interface{}, got %T\", lst))\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: expected []interface{}, got %T\", lst))\n    }\n}\n",
    "    var result [][]int\n    switch lst.(type) {\n    case [][]int:\n        for _, sublist := range lst.([][]int) {\n            result = append(result, []int{sublist[0]})\n            result = append(result, []int{sublist[1]})\n        }\n    }\n    return result\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first []interface{}\n        var second []interface{}\n        for _, v := range lst.([]interface{}) {\n            if v.([]interface{})[0] != nil {\n                first = append(first, v.([]interface{})[0])\n            }\n            if v.([]interface{})[1] != nil {\n                second = append(second, v.([]interface{})[1])\n            }\n        }\n        return []interface{}{first, second}\n    default:\n        return nil\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: invalid argument type: %T\", lst))\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first []interface{}\n        var second []interface{}\n        for _, sublst := range lst.([]interface{}) {\n            switch sublst.(type) {\n            case []interface{}:\n                if len(sublst.([]interface{})) != 2 {\n                    panic(\"Sublist must have exactly two elements\")\n                }\n                first = append(first, sublst.([]interface{})[0])\n                second = append(second, sublst.([]interface{})[1])\n            default:\n                panic(\"Sublist must be a list\")\n            }\n        }\n        return []interface{}{first, second}\n    default:\n        panic(\"List must be a list\")\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: expected []interface{}, got %T\", lst))\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first, second []interface{}\n        for _, sub := range lst.([]interface{}) {\n            switch sub.(type) {\n            case []interface{}:\n                first = append(first, sub.([]interface{})[0])\n                second = append(second, sub.([]interface{})[1])\n            }\n        }\n        return []interface{}{first, second}\n    }\n    return nil\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return lst\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        if len(lst) == 2 {\n            return merge(lst[0], lst[1])\n        }\n        return merge(merge(lst[:len(lst)/2]), merge(lst[len(lst)/2:]))\n    case [][]interface{}:\n        if len(lst) == 0 {\n            return lst\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        if len(lst) == 2 {\n            return merge(lst[0], lst[1])\n        }\n        return merge(merge(lst[:len(lst)/2]), merge(lst[len(lst)/2:]))\n    case []int:\n        if len(lst) == 0 {\n            return lst\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        if len(lst) == 2 {\n            return merge(lst[0], lst[1])\n        }\n        return merge(merge(lst[:len(lst)/2]), merge(lst[len(lst)/2:]))\n    case [][]int:\n        if len(lst) == 0 {\n            return lst\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        if len(lst) == 2 {\n            return merge(lst[0], lst[1])\n        }\n        return merge(merge(lst[:len(lst)/2]), merge(lst[len(lst)/2:]))\n    case []string:\n        if len(lst) == 0 {\n            return lst\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        if len(lst) == 2 {\n            return merge",
    "    var result []interface{}\n    var first []interface{}\n    var second []interface{}\n    for _, sublist := range lst.([]interface{}) {\n        first = append(first, sublist.([]interface{})[0])\n        second = append(second, sublist.([]interface{})[1])\n    }\n    result = append(result, first)\n    result = append(result, second)\n    return result\n}\n",
    "    var result []interface{}\n    var first []interface{}\n    var second []interface{}\n    for _, v := range lst.([]interface{}) {\n        first = append(first, v.([]interface{})[0])\n        second = append(second, v.([]interface{})[1])\n    }\n    result = append(result, first)\n    result = append(result, second)\n    return result\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    lst1 := lst.([]interface{})\n    lst2 := make([]interface{}, len(lst1))\n    lst3 := make([]interface{}, len(lst1))\n    for i, v := range lst1 {\n        lst2[i] = v.([]interface{})[0]\n        lst3[i] = v.([]interface{})[1]\n    }\n    return []interface{}{lst2, lst3}\n}\n",
    "    var result [][]interface{}\n    switch lst.(type) {\n    case []interface{}:\n        for _, sublst := range lst.([]interface{}) {\n            switch sublst.(type) {\n            case []interface{}:\n                if len(sublst.([]interface{})) != 2 {\n                    panic(\"Sublist must have two elements\")\n                }\n                if len(result) == 0 {\n                    result = append(result, []interface{}{sublst.([]interface{})[0]})\n                    result = append(result, []interface{}{sublst.([]interface{})[1]})\n                } else {\n                    result[0] = append(result[0], sublst.([]interface{})[0])\n                    result[1] = append(result[1], sublst.([]interface{})[1])\n                }\n            default:\n                panic(\"Sublist must be a list\")\n            }\n        }\n    default:\n        panic(\"List must be a list\")\n    }\n    return result\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var ret [][]interface{}\n        for _, v := range lst.([]interface{}) {\n            switch v.(type) {\n            case []interface{}:\n                if len(v.([]interface{})) != 2 {\n                    panic(\"Each sublist must have two elements\")\n                }\n                ret = append(ret, []interface{}{v.([]interface{})[0], v.([]interface{})[1]})\n            default:\n                panic(\"Each sublist must be a list\")\n            }\n        }\n        return ret\n    default:\n        panic(\"The argument must be a list\")\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first []interface{}\n        var second []interface{}\n        for _, v := range lst.([]interface{}) {\n            switch v.(type) {\n            case []interface{}:\n                if len(v.([]interface{})) == 2 {\n                    first = append(first, v.([]interface{})[0])\n                    second = append(second, v.([]interface{})[1])\n                }\n            }\n        }\n        return []interface{}{first, second}\n    }\n    return nil\n}\n",
    "    var result [][]int\n    switch lst.(type) {\n    case []int:\n        lst := lst.([]int)\n        result = make([][]int, 2)\n        result[0] = make([]int, len(lst))\n        result[1] = make([]int, len(lst))\n        for i, v := range lst {\n            result[0][i] = v\n            result[1][i] = v\n        }\n    case [][]int:\n        lst := lst.([][]int)\n        result = make([][]int, 2)\n        result[0] = make([]int, len(lst))\n        result[1] = make([]int, len(lst))\n        for i, v := range lst {\n            result[0][i] = v[0]\n            result[1][i] = v[1]\n        }\n    }\n    return result\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        } else {\n            return merge(lst[1:]).([]interface{})[0]\n        }\n    default:\n        panic(fmt.Sprintf(\"merge: expected []interface{}, got %T\", lst))\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        res := make([]interface{}, 2)\n        for _, sub := range lst.([]interface{}) {\n            switch sub.(type) {\n            case []interface{}:\n                if len(sub.([]interface{})) != 2 {\n                    panic(\"sublist must have two elements\")\n                }\n                if res[0] == nil {\n                    res[0] = make([]interface{}, 0)\n                }\n                res[0] = append(res[0].([]interface{}), sub.([]interface{})[0])\n                if res[1] == nil {\n                    res[1] = make([]interface{}, 0)\n                }\n                res[1] = append(res[1].([]interface{}), sub.([]interface{})[1])\n            default:\n                panic(\"sublist must be a list\")\n            }\n        }\n        return res\n    default:\n        panic(\"list must be a list\")\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first, second []interface{}\n        for _, sub := range lst.([]interface{}) {\n            switch sub.(type) {\n            case []interface{}:\n                if len(sub.([]interface{})) != 2 {\n                    panic(\"sublist must have two elements\")\n                }\n                first = append(first, sub.([]interface{})[0])\n                second = append(second, sub.([]interface{})[1])\n            default:\n                panic(\"sublist must be a list\")\n            }\n        }\n        return []interface{}{first, second}\n    default:\n        panic(\"list must be a list\")\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return lst\n        }\n        switch lst[0].(type) {\n        case []interface{}:\n            if len(lst[0].([]interface{})) != 2 {\n                panic(fmt.Sprintf(\"Each sublist must have two elements, but the first one has %d\", len(lst[0].([]interface{}))))\n            }\n            return merge(lst[1:]).([]interface{})\n        default:\n            panic(fmt.Sprintf(\"Each sublist must be a list, but the first one is %T\", lst[0]))\n        }\n    default:\n        panic(fmt.Sprintf(\"The list must be a list, but it is %T\", lst))\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{}\n        }\n        return []interface{}{merge(lst[0]), merge(lst[1:])}\n    case []int:\n        lst := lst.([]int)\n        if len(lst) == 0 {\n            return []int{}\n        }\n        return []int{lst[0], merge(lst[1:]).([]int)[0]}\n    }\n    return nil\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first []interface{}\n        var second []interface{}\n        for _, v := range lst.([]interface{}) {\n            switch v.(type) {\n            case []interface{}:\n                first = append(first, v.([]interface{})[0])\n                second = append(second, v.([]interface{})[1])\n            }\n        }\n        return []interface{}{first, second}\n    }\n    return nil\n}\n",
    "    lst_lst := lst.([]interface{})\n    lst1 := make([]interface{}, len(lst_lst))\n    lst2 := make([]interface{}, len(lst_lst))\n    for i, lst := range lst_lst {\n        lst_lst := lst.([]interface{})\n        lst1[i] = lst_lst[0]\n        lst2[i] = lst_lst[1]\n    }\n    return []interface{}{lst1, lst2}\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first, second []interface{}\n        for _, sublist := range lst.([]interface{}) {\n            switch sublist.(type) {\n            case []interface{}:\n                if len(sublist.([]interface{})) != 2 {\n                    return nil\n                }\n                first = append(first, sublist.([]interface{})[0])\n                second = append(second, sublist.([]interface{})[1])\n            default:\n                return nil\n            }\n        }\n        return []interface{}{first, second}\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first, second []interface{}\n        for _, sublist := range lst.([]interface{}) {\n            switch sublist.(type) {\n            case []interface{}:\n                if len(sublist.([]interface{})) != 2 {\n                    panic(\"sublist must have two elements\")\n                }\n                first = append(first, sublist.([]interface{})[0])\n                second = append(second, sublist.([]interface{})[1])\n            default:\n                panic(\"sublist must be a list\")\n            }\n        }\n        return []interface{}{first, second}\n    default:\n        panic(\"list must be a list\")\n    }\n}\n",
    "    var result [][]interface{}\n    switch lst.(type) {\n    case [][]interface{}:\n        for _, sublist := range lst.([][]interface{}) {\n            if len(sublist) != 2 {\n                panic(\"Sublist must have two elements\")\n            }\n            result = append(result, []interface{}{sublist[0]})\n            result = append(result, []interface{}{sublist[1]})\n        }\n    default:\n        panic(\"List must be a list of lists\")\n    }\n    return result\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: expected []interface{}, got %T\", lst))\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return lst\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        if len(lst) == 2 {\n            return [][]interface{}{lst[0].([]interface{}), lst[1].([]interface{})}\n        }\n        return [][]interface{}{merge(lst[:len(lst)/2]).([][]interface{})[0], merge(lst[len(lst)/2:]).([][]interface{})[1]}\n    default:\n        return lst\n    }\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        if len(lst) == 2 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0], lst[1].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1], lst[1].([]interface{})[1]}}\n        }\n        return []interface{}{[]interface{}{lst[0].([]interface{})[0], lst[1].([]interface{})[0], lst[2].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1], lst[1].([]interface{})[1], lst[2].([]interface{})[1]}}\n    default:\n        panic(fmt.Sprintf(\"merge: expected []interface{}, got %T\", lst))\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        } else {\n            if len(lst) == 1 {\n                return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n            } else {\n                return []interface{}{append(lst[0].([]interface{})[0].([]interface{}), lst[1].([]interface{})[0].([]interface{})[0]), append(lst[0].([]interface{})[1].([]interface{}), lst[1].([]interface{})[1].([]interface{})[0])}\n            }\n        }\n    default:\n        panic(fmt.Sprintf(\"merge: expected list, got %T\", lst))\n    }\n}\n",
    "    // TODO: implement this function\n    return nil\n}\n"
  ]
}