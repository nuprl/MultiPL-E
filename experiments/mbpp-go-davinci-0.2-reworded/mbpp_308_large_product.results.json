{
  "name": "mbpp_308_large_product",
  "language": "go_test.go",
  "prompt": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_308_large_product.py",
  "prompt_terminology": "reworded",
  "tests": "func TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    // sort nums1 and nums2\n    // for each nums1, find the largest N nums2\n    // for each nums2, find the largest N nums1\n    // merge the two lists\n    // return the largest N\n    return nil\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpe8tyb0rj_test.go:33: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpe8tyb0rj_test.go:33: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpe8tyb0rj_test.go:33: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * max_index)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return []int{}\n    }\n    if N > len(nums1) * len(nums2) {\n        return []int{}\n    }\n    var result []int\n    for i := 0; i < N; i++ {\n        max := 0\n        max_index := 0\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max {\n                    max = nums1[j] * nums2[k]\n                    max_index = j * len(nums2) + k\n                }\n            }\n        }\n        result = append(result, max)\n        nums1 = append(nums1[:max_index / len(nums2)], nums1[max_index / len(nums2) + 1:]...)\n        nums2 = append(nums2[:max_index % len(nums2)], nums2[max_index % len(nums2) + 1:]...)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpsusvdfzh_test.go:50: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=45) %!s(int=32)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpsusvdfzh_test.go:50: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpsusvdfzh_test.go:50: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18) %!s(int=12)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max {\n                    max = nums1[j] * nums2[k]\n                    max_index = j\n                }\n            }\n        }\n        result = append(result, max)\n        nums1 = append(nums1[:max_index], nums1[max_index+1:]...)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpz6sxiz7e_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=50) %!s(int=40)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpz6sxiz7e_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpz6sxiz7e_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var res []int\n    for i := 0; i < N; i++ {\n        var max, max_i int\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max {\n                    max = nums1[j] * nums2[k]\n                    max_i = j\n                }\n            }\n        }\n        res = append(res, max)\n        nums1 = append(nums1[:max_i], nums1[max_i+1:]...)\n    }\n    return res\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpyja91bcp_test.go:42: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=50) %!s(int=40)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpyja91bcp_test.go:42: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpyja91bcp_test.go:42: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    // TODO\n    return []int{}\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmp9q2p8et1_test.go:29: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmp9q2p8et1_test.go:29: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmp9q2p8et1_test.go:29: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return []int{}\n    }\n    if N > len(nums1) * len(nums2) {\n        return []int{}\n    }\n    if N == len(nums1) * len(nums2) {\n        return append(nums1, nums2...)\n    }\n    var res []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max {\n                    max = nums1[j] * nums2[k]\n                    max_index = j * len(nums2) + k\n                }\n            }\n        }\n        res = append(res, max)\n        nums1 = append(nums1[:max_index / len(nums2)], nums1[max_index / len(nums2) + 1:]...)\n        nums2 = append(nums2[:max_index % len(nums2)], nums2[max_index % len(nums2) + 1:]...)\n    }\n    return res\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmphgy9giwx_test.go:53: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=45) %!s(int=32)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmphgy9giwx_test.go:53: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmphgy9giwx_test.go:53: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18) %!s(int=12)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * max_index)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    var product int\n    for i := 0; i < N; i++ {\n        product = 0\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > product {\n                    product = nums1[j] * nums2[k]\n                }\n            }\n        }\n        result = append(result, product)\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] == product {\n                    nums1[j] = 0\n                    nums2[k] = 0\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmp9pmp532h_test.go:49: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=45) %!s(int=32)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmp9pmp532h_test.go:49: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmp9pmp532h_test.go:49: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18) %!s(int=12)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        max1, max2 := 0, 0\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > nums1[max1] {\n                max1 = j\n            }\n        }\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > nums2[max2] {\n                max2 = j\n            }\n        }\n        result = append(result, nums1[max1] * nums2[max2])\n        nums1[max1] = 0\n        nums2[max2] = 0\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpex94231e_test.go:45: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=45) %!s(int=32)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpex94231e_test.go:45: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpex94231e_test.go:45: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18) %!s(int=12)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max {\n                    max = nums1[j] * nums2[k]\n                    max_index = j\n                }\n            }\n        }\n        result = append(result, max)\n        nums1 = append(nums1[:max_index], nums1[max_index+1:]...)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpz6sxiz7e_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=50) %!s(int=40)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpz6sxiz7e_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpz6sxiz7e_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    // sort nums1 and nums2\n    // for each element in nums1, find the N largest elements in nums2\n    // for each element in nums2, find the N largest elements in nums1\n    // merge the two lists and return the first N elements\n    return []int{}\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpx86ga3es_test.go:32: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpx86ga3es_test.go:32: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpx86ga3es_test.go:32: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        for _, num1 := range nums1 {\n            for _, num2 := range nums2 {\n                if num1 * num2 > max {\n                    max = num1 * num2\n                }\n            }\n        }\n        result = append(result, max)\n        for j, num1 := range nums1 {\n            if num1 * nums2[0] == max {\n                nums1 = append(nums1[:j], nums1[j+1:]...)\n                break\n            }\n        }\n        for j, num2 := range nums2 {\n            if num2 * nums1[0] == max {\n                nums2 = append(nums2[:j], nums2[j+1:]...)\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpumhqh2b1_test.go:52: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=60) %!s(int=60)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpumhqh2b1_test.go:52: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=60) %!s(int=60) %!s(int=60)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpumhqh2b1_test.go:52: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=60) %!s(int=60) %!s(int=60) %!s(int=60)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    var i, j int\n    for i = 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j = 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j = 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n                max_index = j\n            }\n        }\n        nums2[max_index] = 0\n        result = append(result, max)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmp4muwisn7_test.go:50: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=10) %!s(int=9) %!s(int=8)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmp4muwisn7_test.go:50: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=10) %!s(int=9) %!s(int=8) %!s(int=6)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmp4muwisn7_test.go:50: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=10) %!s(int=9) %!s(int=8) %!s(int=6) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * nums1[max_index])\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpalke820m_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpalke820m_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpalke820m_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    // TODO:\n    return []int{}\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmp3v1b9a9y_test.go:29: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmp3v1b9a9y_test.go:29: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmp3v1b9a9y_test.go:29: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * nums1[max_index])\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpalke820m_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpalke820m_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpalke820m_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var res []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max {\n                    max = nums1[j] * nums2[k]\n                    max_index = j\n                }\n            }\n        }\n        res = append(res, max)\n        nums1 = append(nums1[:max_index], nums1[max_index+1:]...)\n    }\n    return res\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmp9yg6vq95_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=50) %!s(int=40)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmp9yg6vq95_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmp9yg6vq95_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return []int{}\n    }\n    if N > len(nums1) * len(nums2) {\n        return []int{}\n    }\n    result := make([]int, N)\n    for i := 0; i < N; i++ {\n        result[i] = -1\n    }\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            product := nums1[i] * nums2[j]\n            if product > result[N-1] {\n                result[N-1] = product\n                for k := N - 1; k > 0; k-- {\n                    if result[k] > result[k-1] {\n                        result[k], result[k-1] = result[k-1], result[k]\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max {\n                    max = nums1[j] * nums2[k]\n                    max_index = j\n                }\n            }\n        }\n        result = append(result, max)\n        nums1 = append(nums1[:max_index], nums1[max_index+1:]...)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpz6sxiz7e_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=50) %!s(int=40)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpz6sxiz7e_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpz6sxiz7e_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return []int{}\n    }\n    if N <= 0 {\n        return []int{}\n    }\n    if N > len(nums1) * len(nums2) {\n        return []int{}\n    }\n    result := make([]int, N)\n    for i := 0; i < N; i++ {\n        result[i] = -1\n    }\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            product := nums1[i] * nums2[j]\n            if product > result[N - 1] {\n                result[N - 1] = product\n                for k := N - 1; k > 0; k-- {\n                    if result[k] > result[k - 1] {\n                        result[k], result[k - 1] = result[k - 1], result[k]\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122860,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return []int{}\n    }\n    if N == 0 {\n        return []int{}\n    }\n    if N > len(nums1) * len(nums2) {\n        return []int{}\n    }\n    // sort nums1 and nums2\n    for i := 0; i < len(nums1); i++ {\n        for j := i + 1; j < len(nums1); j++ {\n            if nums1[i] < nums1[j] {\n                nums1[i], nums1[j] = nums1[j], nums1[i]\n            }\n        }\n    }\n    for i := 0; i < len(nums2); i++ {\n        for j := i + 1; j < len(nums2); j++ {\n            if nums2[i] < nums2[j] {\n                nums2[i], nums2[j] = nums2[j], nums2[i]\n            }\n        }\n    }\n    // find the N largest products\n    var result []int\n    for i := 0; i < N; i++ {\n        result = append(result, nums1[i] * nums2[i])\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122860,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpdjfdpy7k_test.go:57: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=45) %!s(int=32)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpdjfdpy7k_test.go:57: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpdjfdpy7k_test.go:57: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18) %!s(int=12)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * max_index)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    var i, j int\n    for i = 0; i < N; i++ {\n        var max int\n        var index int\n        for j = 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                index = j\n            }\n        }\n        nums1[index] = 0\n        max = 0\n        var index2 int\n        for j = 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n                index2 = j\n            }\n        }\n        nums2[index2] = 0\n        result = append(result, index * index2)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122860,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpas9ytlgf_test.go:51: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=20) %!s(int=12) %!s(int=6)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpas9ytlgf_test.go:51: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=20) %!s(int=12) %!s(int=6) %!s(int=2)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpas9ytlgf_test.go:51: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=20) %!s(int=12) %!s(int=6) %!s(int=2) %!s(int=5)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max1, max2 int\n        for _, v := range nums1 {\n            if v > max1 {\n                max1 = v\n            }\n        }\n        for _, v := range nums2 {\n            if v > max2 {\n                max2 = v\n            }\n        }\n        result = append(result, max1 * max2)\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] == max1 {\n                nums1 = append(nums1[:j], nums1[j+1:]...)\n                break\n            }\n        }\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] == max2 {\n                nums2 = append(nums2[:j], nums2[j+1:]...)\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122860,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpibpq2m_9_test.go:55: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=45) %!s(int=32)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpibpq2m_9_test.go:55: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpibpq2m_9_test.go:55: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18) %!s(int=12)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    // sort nums1 and nums2\n    // find the largest N products\n    // return the products\n    return []int{}\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122860,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpcehoe5vr_test.go:31: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpcehoe5vr_test.go:31: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpcehoe5vr_test.go:31: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    var i, j int\n    for i < len(nums1) && j < len(nums2) {\n        if nums1[i] > nums2[j] {\n            result = append(result, nums1[i])\n            i++\n        } else {\n            result = append(result, nums2[j])\n            j++\n        }\n    }\n    for i < len(nums1) {\n        result = append(result, nums1[i])\n        i++\n    }\n    for j < len(nums2) {\n        result = append(result, nums2[j])\n        j++\n    }\n    return result[:N]\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122860,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpgucp5y5f_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=3) %!s(int=6) %!s(int=8)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpgucp5y5f_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=3) %!s(int=6) %!s(int=8) %!s(int=9)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpgucp5y5f_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=3) %!s(int=6) %!s(int=8) %!s(int=9) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    var i, j int\n    var num1, num2 int\n    for i = 0; i < N; i++ {\n        num1 = nums1[0]\n        num2 = nums2[0]\n        for j = 0; j < len(nums1); j++ {\n            if nums1[j] > num1 {\n                num1 = nums1[j]\n            }\n        }\n        for j = 0; j < len(nums2); j++ {\n            if nums2[j] > num2 {\n                num2 = nums2[j]\n            }\n        }\n        result = append(result, num1 * num2)\n        for j = 0; j < len(nums1); j++ {\n            if nums1[j] == num1 {\n                nums1[j] = 0\n                break\n            }\n        }\n        for j = 0; j < len(nums2); j++ {\n            if nums2[j] == num2 {\n                nums2[j] = 0\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122860,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmp9ankmcfo_test.go:58: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=45) %!s(int=32)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmp9ankmcfo_test.go:58: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmp9ankmcfo_test.go:58: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18) %!s(int=12)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    var i, j int\n    var max int\n    var max_i, max_j int\n    var num int\n    for i = 0; i < N; i++ {\n        max = 0\n        for j = 0; j < len(nums1); j++ {\n            num = nums1[j] * nums2[0]\n            if num > max {\n                max = num\n                max_i = j\n                max_j = 0\n            }\n        }\n        for j = 0; j < len(nums2); j++ {\n            num = nums1[0] * nums2[j]\n            if num > max {\n                max = num\n                max_i = 0\n                max_j = j\n            }\n        }\n        result = append(result, max)\n        nums1 = append(nums1[:max_i], nums1[max_i+1:]...)\n        nums2 = append(nums2[:max_j], nums2[max_j+1:]...)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122860,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpnoro19rw_test.go:55: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=18) %!s(int=30) %!s(int=32)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpnoro19rw_test.go:55: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=18) %!s(int=30) %!s(int=32) %!s(int=27)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpnoro19rw_test.go:55: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=18) %!s(int=30) %!s(int=32) %!s(int=27) %!s(int=20)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var res []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        res = append(res, max * max_index)\n    }\n    return res\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122860,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmp10wz2y0a_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmp10wz2y0a_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmp10wz2y0a_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return []int{}\n    }\n    if N > len(nums1) * len(nums2) {\n        return []int{}\n    }\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var index1, index2 int\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max {\n                    max = nums1[j] * nums2[k]\n                    index1 = j\n                    index2 = k\n                }\n            }\n        }\n        result = append(result, max)\n        nums1 = append(nums1[:index1], nums1[index1+1:]...)\n        nums2 = append(nums2[:index2], nums2[index2+1:]...)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122860,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpshyykrx5_test.go:51: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=45) %!s(int=32)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpshyykrx5_test.go:51: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpshyykrx5_test.go:51: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18) %!s(int=12)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max {\n                    max = nums1[j] * nums2[k]\n                    max_index = j\n                }\n            }\n        }\n        result = append(result, max)\n        nums1 = append(nums1[:max_index], nums1[max_index+1:]...)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpz6sxiz7e_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=50) %!s(int=40)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpz6sxiz7e_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpz6sxiz7e_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * max_index)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    var i, j int\n    for i < len(nums1) && j < len(nums2) {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j+1] {\n            result = append(result, nums1[i] * nums2[j])\n            j++\n        } else {\n            result = append(result, nums1[i] * nums2[j+1])\n            i++\n        }\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122860,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpvgzc7_wf_test.go:39: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=6) %!s(int=12) %!s(int=18) %!s(int=24) %!s(int=30) %!s(int=36)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpvgzc7_wf_test.go:39: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=6) %!s(int=12) %!s(int=18) %!s(int=24) %!s(int=30) %!s(int=36)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpvgzc7_wf_test.go:39: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=6) %!s(int=12) %!s(int=18) %!s(int=24) %!s(int=30) %!s(int=36)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var res []int\n    var i, j, k int\n    var m, n int\n    var tmp int\n    m = len(nums1)\n    n = len(nums2)\n    for i = 0; i < N; i++ {\n        tmp = nums1[0] * nums2[0]\n        k = 0\n        for j = 0; j < m; j++ {\n            if nums1[j] * nums2[k] > tmp {\n                tmp = nums1[j] * nums2[k]\n            }\n        }\n        for j = 0; j < n; j++ {\n            if nums1[k] * nums2[j] > tmp {\n                tmp = nums1[k] * nums2[j]\n            }\n        }\n        res = append(res, tmp)\n        for j = 0; j < m; j++ {\n            if nums1[j] * nums2[k] == tmp {\n                nums1[j] = 0\n            }\n        }\n        for j = 0; j < n; j++ {\n            if nums1[k] * nums2[j] == tmp {\n                nums2[j] = 0\n            }\n        }\n    }\n    return res\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122860,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpu1a8h59o_test.go:59: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=18) %!s(int=15) %!s(int=12)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpu1a8h59o_test.go:59: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=18) %!s(int=15) %!s(int=12) %!s(int=10)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpu1a8h59o_test.go:59: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=18) %!s(int=15) %!s(int=12) %!s(int=10) %!s(int=9)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var res []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max {\n                    max = nums1[j] * nums2[k]\n                    max_index = j\n                }\n            }\n        }\n        res = append(res, max)\n        nums1 = append(nums1[:max_index], nums1[max_index+1:]...)\n    }\n    return res\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmp9yg6vq95_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=50) %!s(int=40)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmp9yg6vq95_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmp9yg6vq95_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var res []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_idx int\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max {\n                    max = nums1[j] * nums2[k]\n                    max_idx = j\n                }\n            }\n        }\n        res = append(res, max)\n        nums1 = append(nums1[:max_idx], nums1[max_idx+1:]...)\n    }\n    return res\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122860,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmp9p5aqy9p_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=50) %!s(int=40)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmp9p5aqy9p_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmp9p5aqy9p_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    var i, j int\n    for i = 0; i < N; i++ {\n        var max int\n        var max_i int\n        for j = 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_i = j\n            }\n        }\n        nums1[max_i] = -1\n        max = 0\n        for j = 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * max_i)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122860,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmp_u_h85h5_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmp_u_h85h5_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmp_u_h85h5_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n\n        max = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * max_index)\n    }\n\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122860,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmp6ytopsnw_test.go:50: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmp6ytopsnw_test.go:50: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmp6ytopsnw_test.go:50: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max {\n                    max = nums1[j] * nums2[k]\n                    max_index = j\n                }\n            }\n        }\n        result = append(result, max)\n        nums1 = append(nums1[:max_index], nums1[max_index+1:]...)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpz6sxiz7e_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=50) %!s(int=40)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpz6sxiz7e_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpz6sxiz7e_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    var i, j int\n    for i = 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j = 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j = 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max_index * max)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122860,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpad4mz4sz_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpad4mz4sz_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpad4mz4sz_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max*max_index)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122860,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmp31zd85n3_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmp31zd85n3_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmp31zd85n3_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max1, max2 int\n        var index1, index2 int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max1 {\n                max1 = nums1[j]\n                index1 = j\n            }\n        }\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max2 {\n                max2 = nums2[j]\n                index2 = j\n            }\n        }\n        result = append(result, max1 * max2)\n        nums1[index1] = 0\n        nums2[index2] = 0\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122860,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmprtv1mkc__test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=45) %!s(int=32)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmprtv1mkc__test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmprtv1mkc__test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18) %!s(int=12)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * nums1[max_index])\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpalke820m_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpalke820m_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpalke820m_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return []int{}\n    }\n    if N > len(nums1) * len(nums2) {\n        return []int{}\n    }\n    var res []int\n    var m = make(map[int]int)\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            m[nums1[i] * nums2[j]] = i * len(nums2) + j\n        }\n    }\n    var keys []int\n    for k := range m {\n        keys = append(keys, k)\n    }\n    quick_sort(keys, 0, len(keys) - 1)\n    for i := len(keys) - 1; i >= len(keys) - N; i-- {\n        res = append(res, m[keys[i]])\n    }\n    return res\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122860,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmf_tq705_test.go:27:5: undefined: quick_sort\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max_product int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max_product {\n                    max_product = nums1[j] * nums2[k]\n                    max_index = j\n                }\n            }\n        }\n        result = append(result, max_product)\n        nums1[max_index] = 0\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122860,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpuvt4er6w_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=50) %!s(int=40)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpuvt4er6w_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpuvt4er6w_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var res []int\n    for i := 0; i < N; i++ {\n        var max1, max2 int\n        for _, v := range nums1 {\n            if v > max1 {\n                max1 = v\n            }\n        }\n        for _, v := range nums2 {\n            if v > max2 {\n                max2 = v\n            }\n        }\n        res = append(res, max1 * max2)\n        nums1 = remove(nums1, max1)\n        nums2 = remove(nums2, max2)\n    }\n    return res\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122860,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp98_08s18_test.go:24:17: undefined: remove\n/tmp/tmp98_08s18_test.go:25:17: undefined: remove\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        max1, max2 := 0, 0\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > nums1[max1] {\n                max1 = j\n            }\n        }\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > nums2[max2] {\n                max2 = j\n            }\n        }\n        result = append(result, nums1[max1] * nums2[max2])\n        nums1[max1] = 0\n        nums2[max2] = 0\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpex94231e_test.go:45: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=45) %!s(int=32)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpex94231e_test.go:45: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpex94231e_test.go:45: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18) %!s(int=12)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        max := 0\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max {\n                    max = nums1[j] * nums2[k]\n                }\n            }\n        }\n        result = append(result, max)\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] == max {\n                    nums1[j] = 0\n                    nums2[k] = 0\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122860,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmp8yc3llkl_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=45) %!s(int=32)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmp8yc3llkl_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmp8yc3llkl_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18) %!s(int=12)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max_product int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                product := nums1[j] * nums2[k]\n                if product > max_product {\n                    max_product = product\n                    max_index = j\n                }\n            }\n        }\n        result = append(result, max_product)\n        nums1 = append(nums1[:max_index], nums1[max_index+1:]...)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122860,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmp2oj2ok7y_test.go:44: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=50) %!s(int=40)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmp2oj2ok7y_test.go:44: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmp2oj2ok7y_test.go:44: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = -1\n        max = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * max_index)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122862,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpvkcnxqe4_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpvkcnxqe4_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpvkcnxqe4_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    var i, j int\n    for i = 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j = 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = -1\n        max = 0\n        for j = 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * max_index)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122862,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpdvqkihv5_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpdvqkihv5_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpdvqkihv5_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    // TODO: implement\n    return []int{}\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122862,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpv7dx8t92_test.go:29: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpv7dx8t92_test.go:29: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpv7dx8t92_test.go:29: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.012s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    var i, j int\n    for i = 0; i < N; i++ {\n        var max int\n        var index int\n        for j = 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                index = j\n            }\n        }\n        nums1[index] = 0\n        max = 0\n        for j = 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n                index = j\n            }\n        }\n        nums2[index] = 0\n        result = append(result, max)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122862,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmp1tr6rwnf_test.go:50: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=10) %!s(int=9) %!s(int=8)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmp1tr6rwnf_test.go:50: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=10) %!s(int=9) %!s(int=8) %!s(int=6)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmp1tr6rwnf_test.go:50: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=10) %!s(int=9) %!s(int=8) %!s(int=6) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var maxIndex int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                maxIndex = j\n            }\n        }\n        nums1[maxIndex] = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] * max > nums1[maxIndex] {\n                nums1[maxIndex] = nums2[j] * max\n            }\n        }\n        result = append(result, nums1[maxIndex])\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122862,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpsl7w7sso_test.go:46: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=600) %!s(int=6000)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpsl7w7sso_test.go:46: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=600) %!s(int=6000) %!s(int=60000)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpsl7w7sso_test.go:46: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=600) %!s(int=6000) %!s(int=60000) %!s(int=600000)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    var i, j int\n    var max int\n    for i = 0; i < N; i++ {\n        max = 0\n        for j = 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n            }\n        }\n        nums1[j] = 0\n        for j = 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        nums2[j] = 0\n        result = append(result, max)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122862,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\npanic: runtime error: index out of range [6] with length 6 [recovered]\n\tpanic: runtime error: index out of range [6] with length 6\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536460, 0xc0001b8000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000186300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536460, 0xc0001b8000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.large_product(0xc00008cde0, 0x6, 0x6, 0xc00008cdb0, 0x6, 0x6, 0x3, 0xf, 0x4cd120, 0x0)\n\t/tmp/tmp4vehl79w_test.go:20 +0x65\ncommand-line-arguments_test.TestLarge_Product(0xc000186300)\n\t/tmp/tmp4vehl79w_test.go:39 +0x14b\ntesting.tRunner(0xc000186300, 0x54f328)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max {\n                    max = nums1[j] * nums2[k]\n                    max_index = j\n                }\n            }\n        }\n        result = append(result, max)\n        nums1 = append(nums1[:max_index], nums1[max_index+1:]...)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpz6sxiz7e_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=50) %!s(int=40)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpz6sxiz7e_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpz6sxiz7e_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return []int{}\n    }\n    if N > len(nums1) * len(nums2) {\n        return []int{}\n    }\n    var res []int\n    for i := 0; i < N; i++ {\n        max := -1\n        var max_i, max_j int\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max {\n                    max = nums1[j] * nums2[k]\n                    max_i = j\n                    max_j = k\n                }\n            }\n        }\n        res = append(res, max)\n        nums1[max_i] = -1\n        nums2[max_j] = -1\n    }\n    return res\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122862,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpkt03qawg_test.go:51: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=45) %!s(int=32)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpkt03qawg_test.go:51: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpkt03qawg_test.go:51: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18) %!s(int=12)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var (\n        res []int\n        i, j, k int\n    )\n    for i = 0; i < len(nums1); i++ {\n        for j = 0; j < len(nums2); j++ {\n            if len(res) < N {\n                res = append(res, nums1[i] * nums2[j])\n            } else {\n                for k = 0; k < len(res); k++ {\n                    if nums1[i] * nums2[j] > res[k] {\n                        res = append(res[:k], append([]int{nums1[i] * nums2[j]}, res[k:]...)...)\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return res[:N]\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122862,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max {\n                    max = nums1[j] * nums2[k]\n                    max_index = j\n                }\n            }\n        }\n        result = append(result, max)\n        nums1 = append(nums1[:max_index], nums1[max_index+1:]...)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpz6sxiz7e_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=50) %!s(int=40)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpz6sxiz7e_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpz6sxiz7e_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    var i, j int\n    for i = 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j = 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j = 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * max_index)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122862,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpjribxv6y_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpjribxv6y_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpjribxv6y_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        if len(nums1) == 0 || len(nums2) == 0 {\n            break\n        }\n        var max1, max2 int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max1 {\n                max1 = nums1[j]\n            }\n        }\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max2 {\n                max2 = nums2[j]\n            }\n        }\n        result = append(result, max1 * max2)\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] == max1 {\n                nums1 = append(nums1[:j], nums1[j+1:]...)\n                break\n            }\n        }\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] == max2 {\n                nums2 = append(nums2[:j], nums2[j+1:]...)\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122862,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpiu5zfcp5_test.go:58: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=45) %!s(int=32)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpiu5zfcp5_test.go:58: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpiu5zfcp5_test.go:58: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18) %!s(int=12)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    // sort nums1 and nums2\n    sort(nums1)\n    sort(nums2)\n\n    // find the N largest products\n    var result []int\n    for i, j := 0, 0; i < len(nums1) && j < len(nums2) && len(result) < N; {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1] {\n            result = append(result, nums1[i] * nums2[j])\n            j++\n        } else {\n            result = append(result, nums1[i] * nums2[j + 1])\n            i++\n        }\n    }\n\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122862,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5hzawoud_test.go:11:5: undefined: sort\n/tmp/tmp5hzawoud_test.go:12:5: undefined: sort\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var res []int\n    var i, j int\n    var n1, n2 int\n    var p int\n    for i = 0; i < N; i++ {\n        n1 = nums1[0]\n        n2 = nums2[0]\n        for j = 0; j < len(nums1); j++ {\n            if nums1[j] > n1 {\n                n1 = nums1[j]\n            }\n        }\n        for j = 0; j < len(nums2); j++ {\n            if nums2[j] > n2 {\n                n2 = nums2[j]\n            }\n        }\n        p = n1 * n2\n        res = append(res, p)\n        for j = 0; j < len(nums1); j++ {\n            if nums1[j] == n1 {\n                nums1 = append(nums1[:j], nums1[j+1:]...)\n                break\n            }\n        }\n        for j = 0; j < len(nums2); j++ {\n            if nums2[j] == n2 {\n                nums2 = append(nums2[:j], nums2[j+1:]...)\n                break\n            }\n        }\n    }\n    return res\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122862,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpndm918mv_test.go:60: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=45) %!s(int=32)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpndm918mv_test.go:60: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpndm918mv_test.go:60: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18) %!s(int=12)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = -1\n        max = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * max_index)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122862,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpvkcnxqe4_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpvkcnxqe4_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpvkcnxqe4_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        max1 := -1\n        max2 := -1\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max1 {\n                max1 = nums1[j]\n            }\n        }\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max2 {\n                max2 = nums2[j]\n            }\n        }\n        result = append(result, max1 * max2)\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] == max1 {\n                nums1[j] = -1\n            }\n        }\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] == max2 {\n                nums2[j] = -1\n            }\n        }\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122862,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmp67mokn0b_test.go:54: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=45) %!s(int=32)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmp67mokn0b_test.go:54: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmp67mokn0b_test.go:54: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return []int{}\n    }\n\n    if N > len(nums1) * len(nums2) {\n        return []int{}\n    }\n\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max {\n                    max = nums1[j] * nums2[k]\n                    max_index = j * len(nums2) + k\n                }\n            }\n        }\n        result = append(result, max)\n        nums1[max_index / len(nums2)] = 0\n        nums2[max_index % len(nums2)] = 0\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122862,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmplsvnt76b_test.go:52: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=45) %!s(int=32)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmplsvnt76b_test.go:52: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmplsvnt76b_test.go:52: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18) %!s(int=12)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * max_index)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return []int{}\n    }\n    if N <= 0 {\n        return []int{}\n    }\n    if N > len(nums1) * len(nums2) {\n        return []int{}\n    }\n    var result []int\n    for i := 0; i < N; i++ {\n        max := -1\n        max_i := -1\n        max_j := -1\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max {\n                    max = nums1[j] * nums2[k]\n                    max_i = j\n                    max_j = k\n                }\n            }\n        }\n        result = append(result, max)\n        nums1[max_i] = -1\n        nums2[max_j] = -1\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122862,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpt9ja5f7w_test.go:55: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=45) %!s(int=32)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpt9ja5f7w_test.go:55: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpt9ja5f7w_test.go:55: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18) %!s(int=12)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    if N > len(nums1) * len(nums2) {\n        return []int{}\n    }\n    result := make([]int, N)\n    for i := 0; i < N; i++ {\n        result[i] = -1\n    }\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            product := nums1[i] * nums2[j]\n            if product > result[N - 1] {\n                result[N - 1] = product\n                for k := N - 1; k > 0; k-- {\n                    if result[k] > result[k - 1] {\n                        result[k], result[k - 1] = result[k - 1], result[k]\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122862,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    var max_product int\n    var max_index int\n    var max_index2 int\n    var max_index3 int\n    var max_index4 int\n    var max_index5 int\n    var max_index6 int\n    var max_index7 int\n    var max_index8 int\n    var max_index9 int\n    var max_index10 int\n    var max_index11 int\n    var max_index12 int\n    var max_index13 int\n    var max_index14 int\n    var max_index15 int\n    var max_index16 int\n    var max_index17 int\n    var max_index18 int\n    var max_index19 int\n    var max_index20 int\n    var max_index21 int\n    var max_index22 int\n    var max_index23 int\n    var max_index24 int\n    var max_index25 int\n    var max_index26 int\n    var max_index27 int\n    var max_index28 int\n    var max_index29 int\n    var max_index30 int\n    var max_index31 int\n    var max_index32 int\n    var max_index33 int\n    var max_index34 int\n    var max_index35 int\n    var max_index36 int\n    var max_index37 int\n    var max_index38 int\n    var max_index39 int\n    var max_index40 int\n    var max_index41 int\n    var max_index42 int\n    var max_index43 int\n    var max_index44 int\n    var max_index45 int\n    var max_index46 int\n    var max_index47 int\n    var max_index48 int\n    var max_index49 int\n    var max_index50 int\n    var max_index51 int\n    var max_index52 int\n    var max_index53 int\n    var max_index54 int\n    var max_index55 int\n    var max_index56 int\n    var max_index57 int\n    var max_index58 int\n    var max_index59 int\n    var max_index60 int\n    var max_index61 int\n    var max_index62 int\n    var max\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122861,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmptwt7dkqi_test.go:74:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max {\n                    max = nums1[j] * nums2[k]\n                    max_index = j\n                }\n            }\n        }\n        result = append(result, max)\n        nums1 = append(nums1[:max_index], nums1[max_index+1:]...)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpz6sxiz7e_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=50) %!s(int=40)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpz6sxiz7e_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpz6sxiz7e_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return []int{}\n    }\n    if N > len(nums1) * len(nums2) {\n        return []int{}\n    }\n    if N == len(nums1) * len(nums2) {\n        return append(nums1, nums2...)\n    }\n    var result []int\n    var i, j int\n    for i = 0; i < len(nums1); i++ {\n        for j = 0; j < len(nums2); j++ {\n            result = append(result, nums1[i] * nums2[j])\n        }\n    }\n    for i = 0; i < N; i++ {\n        for j = i + 1; j < len(result); j++ {\n            if result[i] < result[j] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n    return result[:N]\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122862,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * max_index)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    var i, j int\n    for i < len(nums1) && j < len(nums2) {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j+1] {\n            result = append(result, nums1[i] * nums2[j])\n            j++\n        } else {\n            result = append(result, nums1[i] * nums2[j+1])\n            i++\n        }\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122860,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpvgzc7_wf_test.go:39: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=6) %!s(int=12) %!s(int=18) %!s(int=24) %!s(int=30) %!s(int=36)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpvgzc7_wf_test.go:39: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=6) %!s(int=12) %!s(int=18) %!s(int=24) %!s(int=30) %!s(int=36)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpvgzc7_wf_test.go:39: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=6) %!s(int=12) %!s(int=18) %!s(int=24) %!s(int=30) %!s(int=36)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n    var i, j int\n    for i < len(nums1) && j < len(nums2) {\n        if nums1[i] < nums2[j] {\n            result = append(result, nums1[i] * nums2[j])\n            i++\n        } else {\n            result = append(result, nums1[i] * nums2[j])\n            j++\n        }\n    }\n    for i < len(nums1) {\n        result = append(result, nums1[i] * nums2[len(nums2) - 1])\n        i++\n    }\n    for j < len(nums2) {\n        result = append(result, nums1[len(nums1) - 1] * nums2[j])\n        j++\n    }\n    return result[len(result) - N:]\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122862,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpzc1q_0w4_test.go:50: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=54) %!s(int=60) %!s(int=36)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpzc1q_0w4_test.go:50: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=48) %!s(int=54) %!s(int=60) %!s(int=36)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpzc1q_0w4_test.go:50: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=48) %!s(int=48) %!s(int=54) %!s(int=60) %!s(int=36)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    var i, j int\n    for i = 0; i < N; i++ {\n        var max int\n        var index int\n        for j = 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                index = j\n            }\n        }\n        nums1[index] = 0\n        max = 0\n        for j = 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n                index = j\n            }\n        }\n        nums2[index] = 0\n        result = append(result, max)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122862,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmp1tr6rwnf_test.go:50: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=10) %!s(int=9) %!s(int=8)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmp1tr6rwnf_test.go:50: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=10) %!s(int=9) %!s(int=8) %!s(int=6)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmp1tr6rwnf_test.go:50: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=10) %!s(int=9) %!s(int=8) %!s(int=6) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var res []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n                max_index = j\n            }\n        }\n        nums2[max_index] = 0\n        res = append(res, max)\n    }\n    return res\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122862,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpy6bdaq6v_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=10) %!s(int=9) %!s(int=8)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpy6bdaq6v_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=10) %!s(int=9) %!s(int=8) %!s(int=6)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpy6bdaq6v_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=10) %!s(int=9) %!s(int=8) %!s(int=6) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max {\n                    max = nums1[j] * nums2[k]\n                    max_index = j\n                }\n            }\n        }\n        result = append(result, max)\n        nums1 = append(nums1[:max_index], nums1[max_index+1:]...)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpz6sxiz7e_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=50) %!s(int=40)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpz6sxiz7e_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpz6sxiz7e_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var res []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] * max > max {\n                max = nums2[j] * max\n                max_index = j\n            }\n        }\n        nums2[max_index] = 0\n        res = append(res, max)\n    }\n    return res\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122862,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmp8m_b4rrm_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=466560) %!s(int=64800) %!s(int=5184)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmp8m_b4rrm_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=466560) %!s(int=64800) %!s(int=5184) %!s(int=432)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmp8m_b4rrm_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=466560) %!s(int=64800) %!s(int=5184) %!s(int=432) %!s(int=36)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    // TODO\n    return []int{}\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmp9q2p8et1_test.go:29: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmp9q2p8et1_test.go:29: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmp9q2p8et1_test.go:29: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    var m, n int\n    for i := 0; i < N; i++ {\n        if nums1[m] > nums2[n] {\n            result = append(result, nums1[m])\n            m++\n        } else {\n            result = append(result, nums2[n])\n            n++\n        }\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122862,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpxwnpxow__test.go:39: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=3) %!s(int=6) %!s(int=8)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpxwnpxow__test.go:39: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=3) %!s(int=6) %!s(int=8) %!s(int=9)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpxwnpxow__test.go:39: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=3) %!s(int=6) %!s(int=8) %!s(int=9) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    // TODO: implement\n    return []int{}\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122862,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpv7dx8t92_test.go:29: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpv7dx8t92_test.go:29: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpv7dx8t92_test.go:29: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.012s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        max := 0\n        max_index := 0\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max {\n                    max = nums1[j] * nums2[k]\n                    max_index = j\n                }\n            }\n        }\n        result = append(result, max)\n        nums1 = append(nums1[:max_index], nums1[max_index+1:]...)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122862,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmp02_fkq4c_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=50) %!s(int=40)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmp02_fkq4c_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmp02_fkq4c_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    // sort nums1 and nums2\n    quick_sort(nums1, 0, len(nums1)-1)\n    quick_sort(nums2, 0, len(nums2)-1)\n    // find the N largest products\n    var result []int\n    var i, j int\n    for i, j = 0, 0; i < len(nums1) && j < len(nums2) && len(result) < N; {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j+1] {\n            result = append(result, nums1[i] * nums2[j])\n            j++\n        } else {\n            result = append(result, nums1[i] * nums2[j+1])\n            i++\n        }\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122863,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpau6gbs51_test.go:11:5: undefined: quick_sort\n/tmp/tmpau6gbs51_test.go:12:5: undefined: quick_sort\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * max_index)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    var m, n int\n    var i, j int\n    var p int\n    var v int\n    var x, y int\n\n    m = len(nums1)\n    n = len(nums2)\n\n    result = make([]int, N)\n    for i = 0; i < N; i++ {\n        result[i] = -1\n    }\n\n    for i = 0; i < m; i++ {\n        for j = 0; j < n; j++ {\n            p = nums1[i] * nums2[j]\n            v = nums1[i]\n            x = i\n            y = j\n\n            if p > result[N-1] {\n                result[N-1] = p\n                for k := N-1; k > 0; k-- {\n                    if result[k] > result[k-1] {\n                        result[k], result[k-1] = result[k-1], result[k]\n                    }\n                }\n            }\n        }\n    }\n\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122863,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqua_et6j_test.go:14:9: v declared but not used\n/tmp/tmpqua_et6j_test.go:15:9: x declared but not used\n/tmp/tmpqua_et6j_test.go:15:12: y declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var res []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] * max > nums1[max_index] {\n                nums1[max_index] = nums2[j] * max\n            }\n        }\n        res = append(res, nums1[max_index])\n    }\n    return res\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122864,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpvlfe5md0_test.go:46: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=600) %!s(int=6000)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpvlfe5md0_test.go:46: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=600) %!s(int=6000) %!s(int=60000)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpvlfe5md0_test.go:46: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=600) %!s(int=6000) %!s(int=60000) %!s(int=600000)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var res []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        res = append(res, max * nums1[max_index])\n    }\n    return res\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122864,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpsrlcc1sj_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpsrlcc1sj_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpsrlcc1sj_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    var i, j int\n    for i = 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j = 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = -1\n        max = 0\n        for j = 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * max_index)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122862,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpdvqkihv5_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpdvqkihv5_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpdvqkihv5_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    var max int\n    var max_index int\n    var max_index2 int\n    var max_index3 int\n    var max_index4 int\n    var max_index5 int\n    var max_index6 int\n    var max_index7 int\n    var max_index8 int\n    var max_index9 int\n    var max_index10 int\n    var max_index11 int\n    var max_index12 int\n    var max_index13 int\n    var max_index14 int\n    var max_index15 int\n    var max_index16 int\n    var max_index17 int\n    var max_index18 int\n    var max_index19 int\n    var max_index20 int\n    var max_index21 int\n    var max_index22 int\n    var max_index23 int\n    var max_index24 int\n    var max_index25 int\n    var max_index26 int\n    var max_index27 int\n    var max_index28 int\n    var max_index29 int\n    var max_index30 int\n    var max_index31 int\n    var max_index32 int\n    var max_index33 int\n    var max_index34 int\n    var max_index35 int\n    var max_index36 int\n    var max_index37 int\n    var max_index38 int\n    var max_index39 int\n    var max_index40 int\n    var max_index41 int\n    var max_index42 int\n    var max_index43 int\n    var max_index44 int\n    var max_index45 int\n    var max_index46 int\n    var max_index47 int\n    var max_index48 int\n    var max_index49 int\n    var max_index50 int\n    var max_index51 int\n    var max_index52 int\n    var max_index53 int\n    var max_index54 int\n    var max_index55 int\n    var max_index56 int\n    var max_index57 int\n    var max_index58 int\n    var max_index59 int\n    var max_index60 int\n    var max_index61 int\n    var max_index62 int\n    var max_index\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122864,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmptwqe6ers_test.go:74:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    var i, j int\n    var max int\n    var max_i, max_j int\n    for i = 0; i < N; i++ {\n        max = 0\n        for j = 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_i = j\n            }\n        }\n        nums1[max_i] = 0\n        max = 0\n        for j = 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n                max_j = j\n            }\n        }\n        nums2[max_j] = 0\n        result = append(result, max_i * max_j)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122865,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmp5g4qmkas_test.go:51: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=20) %!s(int=12) %!s(int=6)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmp5g4qmkas_test.go:51: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=20) %!s(int=12) %!s(int=6) %!s(int=2)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmp5g4qmkas_test.go:51: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=20) %!s(int=12) %!s(int=6) %!s(int=2) %!s(int=5)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.010s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return []int{}\n    }\n\n    if N == 0 {\n        return []int{}\n    }\n\n    if N > len(nums1) * len(nums2) {\n        return []int{}\n    }\n\n    products := make([]int, len(nums1) * len(nums2))\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            products[i * len(nums2) + j] = nums1[i] * nums2[j]\n        }\n    }\n\n    quick_sort(products, 0, len(products) - 1)\n\n    return products[len(products) - N:]\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122864,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp409upbpm_test.go:29:5: undefined: quick_sort\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return []int{}\n    }\n    if N == 0 {\n        return []int{}\n    }\n    if N > len(nums1) * len(nums2) {\n        return []int{}\n    }\n\n    products := make([]int, len(nums1) * len(nums2))\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            products[i * len(nums2) + j] = nums1[i] * nums2[j]\n        }\n    }\n\n    // quick sort\n    quick_sort(products, 0, len(products) - 1)\n\n    return products[len(products) - N:]\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122864,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl6ud87pl_test.go:28:5: undefined: quick_sort\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] * max > max {\n                max = nums2[j] * max\n                max_index = j\n            }\n        }\n        nums2[max_index] = 0\n        result = append(result, max)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122865,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpp4rl27gj_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=466560) %!s(int=64800) %!s(int=5184)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpp4rl27gj_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=466560) %!s(int=64800) %!s(int=5184) %!s(int=432)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpp4rl27gj_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=466560) %!s(int=64800) %!s(int=5184) %!s(int=432) %!s(int=36)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    var i, j int\n    for i < len(nums1) && j < len(nums2) {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j+1] {\n            result = append(result, nums1[i] * nums2[j])\n            j++\n        } else {\n            result = append(result, nums1[i] * nums2[j+1])\n            i++\n        }\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122860,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpvgzc7_wf_test.go:39: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=6) %!s(int=12) %!s(int=18) %!s(int=24) %!s(int=30) %!s(int=36)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpvgzc7_wf_test.go:39: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=6) %!s(int=12) %!s(int=18) %!s(int=24) %!s(int=30) %!s(int=36)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpvgzc7_wf_test.go:39: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=6) %!s(int=12) %!s(int=18) %!s(int=24) %!s(int=30) %!s(int=36)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * max_index)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        max1 := 0\n        max2 := 0\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > nums1[max1] {\n                max1 = j\n            }\n        }\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > nums2[max2] {\n                max2 = j\n            }\n        }\n        result = append(result, nums1[max1] * nums2[max2])\n        nums1[max1] = 0\n        nums2[max2] = 0\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122865,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpydczq87j_test.go:46: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=45) %!s(int=32)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpydczq87j_test.go:46: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpydczq87j_test.go:46: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18) %!s(int=12)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var res []int\n    var i, j int\n    for i = 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j = 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = -1\n        max = 0\n        for j = 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        res = append(res, max * max_index)\n    }\n    return res\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122865,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpenylqqdx_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpenylqqdx_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpenylqqdx_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var res []int\n    var i, j int\n    for i < len(nums1) && j < len(nums2) {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j+1] {\n            res = append(res, nums1[i] * nums2[j])\n            j++\n        } else {\n            res = append(res, nums1[i] * nums2[j+1])\n            i++\n        }\n    }\n    return res\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122865,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmp0s9djyi1_test.go:39: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=6) %!s(int=12) %!s(int=18) %!s(int=24) %!s(int=30) %!s(int=36)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmp0s9djyi1_test.go:39: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=6) %!s(int=12) %!s(int=18) %!s(int=24) %!s(int=30) %!s(int=36)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmp0s9djyi1_test.go:39: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=6) %!s(int=12) %!s(int=18) %!s(int=24) %!s(int=30) %!s(int=36)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * nums1[max_index])\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpalke820m_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpalke820m_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpalke820m_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return []int{}\n    }\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var index int\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max {\n                    max = nums1[j] * nums2[k]\n                    index = j\n                }\n            }\n        }\n        result = append(result, max)\n        nums1 = append(nums1[:index], nums1[index+1:]...)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122865,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmp1kjltai0_test.go:46: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=50) %!s(int=40)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmp1kjltai0_test.go:46: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmp1kjltai0_test.go:46: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    var max_product int\n    var max_index int\n    var max_index2 int\n    var max_index3 int\n    var max_index4 int\n    var max_index5 int\n    var max_index6 int\n    var max_index7 int\n    var max_index8 int\n    var max_index9 int\n    var max_index10 int\n    var max_index11 int\n    var max_index12 int\n    var max_index13 int\n    var max_index14 int\n    var max_index15 int\n    var max_index16 int\n    var max_index17 int\n    var max_index18 int\n    var max_index19 int\n    var max_index20 int\n    var max_index21 int\n    var max_index22 int\n    var max_index23 int\n    var max_index24 int\n    var max_index25 int\n    var max_index26 int\n    var max_index27 int\n    var max_index28 int\n    var max_index29 int\n    var max_index30 int\n    var max_index31 int\n    var max_index32 int\n    var max_index33 int\n    var max_index34 int\n    var max_index35 int\n    var max_index36 int\n    var max_index37 int\n    var max_index38 int\n    var max_index39 int\n    var max_index40 int\n    var max_index41 int\n    var max_index42 int\n    var max_index43 int\n    var max_index44 int\n    var max_index45 int\n    var max_index46 int\n    var max_index47 int\n    var max_index48 int\n    var max_index49 int\n    var max_index50 int\n    var max_index51 int\n    var max_index52 int\n    var max_index53 int\n    var max_index54 int\n    var max_index55 int\n    var max_index56 int\n    var max_index57 int\n    var max_index58 int\n    var max_index59 int\n    var max_index60 int\n    var max_index61 int\n    var max_index62 int\n    var max\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122861,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmptwt7dkqi_test.go:74:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var res []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        res = append(res, max * max_index)\n    }\n    return res\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122860,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmp10wz2y0a_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmp10wz2y0a_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmp10wz2y0a_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    var temp []int\n    var i, j int\n    var num1, num2 int\n    var product int\n    var index int\n    var flag bool\n    for i = 0; i < N; i++ {\n        num1 = nums1[i]\n        for j = 0; j < N; j++ {\n            num2 = nums2[j]\n            product = num1 * num2\n            flag = false\n            for index = 0; index < len(temp); index++ {\n                if product > temp[index] {\n                    temp = append(temp[:index], append([]int{product}, temp[index:]...)...)\n                    flag = true\n                    break\n                }\n            }\n            if !flag {\n                temp = append(temp, product)\n            }\n        }\n    }\n    for i = 0; i < N; i++ {\n        result = append(result, temp[i])\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122865,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpobi_mqxq_test.go:56: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=24) %!s(int=18) %!s(int=16)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpobi_mqxq_test.go:56: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=36) %!s(int=32) %!s(int=27) %!s(int=24)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpobi_mqxq_test.go:56: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=50) %!s(int=45) %!s(int=40) %!s(int=40) %!s(int=36)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return []int{}\n    }\n\n    // sort nums1 and nums2\n    sort(nums1)\n    sort(nums2)\n\n    // find the N largest products\n    var products []int\n    for i := 0; i < N; i++ {\n        var product int\n        if nums1[0] * nums2[0] > nums1[len(nums1) - 1] * nums2[len(nums2) - 1] {\n            product = nums1[0] * nums2[0]\n            nums2 = nums2[1:]\n        } else {\n            product = nums1[len(nums1) - 1] * nums2[len(nums2) - 1]\n            nums1 = nums1[:len(nums1) - 1]\n        }\n        products = append(products, product)\n    }\n\n    return products\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122865,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphj167d99_test.go:15:5: undefined: sort\n/tmp/tmphj167d99_test.go:16:5: undefined: sort\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * nums1[max_index])\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpalke820m_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpalke820m_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpalke820m_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max_product int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max_product {\n                    max_product = nums1[j] * nums2[k]\n                    max_index = j\n                }\n            }\n        }\n        result = append(result, max_product)\n        nums1 = append(nums1[:max_index], nums1[max_index+1:]...)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122865,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpupyx7s16_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=50) %!s(int=40)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpupyx7s16_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpupyx7s16_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * nums1[max_index])\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpalke820m_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpalke820m_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpalke820m_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max_product int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max_product {\n                    max_product = nums1[j] * nums2[k]\n                    max_index = j\n                }\n            }\n        }\n        result = append(result, max_product)\n        nums1 = append(nums1[:max_index], nums1[max_index+1:]...)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122865,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpupyx7s16_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=50) %!s(int=40)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpupyx7s16_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpupyx7s16_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        nums2[max_index] = 0\n        result = append(result, max_index)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122865,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmphl3vam12_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=5) %!s(int=4) %!s(int=3)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmphl3vam12_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=5) %!s(int=4) %!s(int=3) %!s(int=2)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmphl3vam12_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=5) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    var i, j int\n    for i < len(nums1) && j < len(nums2) {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j+1] {\n            result = append(result, nums1[i] * nums2[j])\n            j++\n        } else {\n            result = append(result, nums1[i] * nums2[j+1])\n            i++\n        }\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122860,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpvgzc7_wf_test.go:39: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=6) %!s(int=12) %!s(int=18) %!s(int=24) %!s(int=30) %!s(int=36)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpvgzc7_wf_test.go:39: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=6) %!s(int=12) %!s(int=18) %!s(int=24) %!s(int=30) %!s(int=36)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpvgzc7_wf_test.go:39: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=6) %!s(int=12) %!s(int=18) %!s(int=24) %!s(int=30) %!s(int=36)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * nums1[max_index])\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpalke820m_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpalke820m_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpalke820m_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var res []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_idx int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_idx = j\n            }\n        }\n        nums1[max_idx] = -1\n        max = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        res = append(res, max * max_idx)\n    }\n    return res\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122865,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmps9ctu01o_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmps9ctu01o_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmps9ctu01o_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var res []int\n    for i := 0; i < N; i++ {\n        var max int\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max {\n                    max = nums1[j] * nums2[k]\n                }\n            }\n        }\n        res = append(res, max)\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] == max {\n                    nums1[j] = 0\n                    nums2[k] = 0\n                }\n            }\n        }\n    }\n    return res\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122865,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpxr6mb38y_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=45) %!s(int=32)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpxr6mb38y_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpxr6mb38y_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18) %!s(int=12)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return []int{}\n    }\n    if N > len(nums1) * len(nums2) {\n        return []int{}\n    }\n    result := make([]int, N)\n    for i := 0; i < N; i++ {\n        result[i] = -1\n    }\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            product := nums1[i] * nums2[j]\n            for k := 0; k < N; k++ {\n                if product > result[k] {\n                    for l := N - 1; l > k; l-- {\n                        result[l] = result[l-1]\n                    }\n                    result[k] = product\n                    break\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122865,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    var i, j int\n    for i = 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j = 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = -1\n        max = 0\n        for j = 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n                max_index = j\n            }\n        }\n        nums2[max_index] = -1\n        result = append(result, max)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122865,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmp7nti3glq_test.go:50: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=10) %!s(int=9) %!s(int=8)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmp7nti3glq_test.go:50: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=10) %!s(int=9) %!s(int=8) %!s(int=6)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmp7nti3glq_test.go:50: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=10) %!s(int=9) %!s(int=8) %!s(int=6) %!s(int=6)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return []int{}\n    }\n    if N > len(nums1) * len(nums2) {\n        return []int{}\n    }\n    var res []int\n    for i := 0; i < N; i++ {\n        max := -1\n        var max_i, max_j int\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max {\n                    max = nums1[j] * nums2[k]\n                    max_i = j\n                    max_j = k\n                }\n            }\n        }\n        res = append(res, max)\n        nums1 = append(nums1[:max_i], nums1[max_i+1:]...)\n        nums2 = append(nums2[:max_j], nums2[max_j+1:]...)\n    }\n    return res\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122865,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmplnbs3jbr_test.go:51: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=45) %!s(int=32)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmplnbs3jbr_test.go:51: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmplnbs3jbr_test.go:51: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18) %!s(int=12)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * max_index)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max {\n                    max = nums1[j] * nums2[k]\n                    max_index = j\n                }\n            }\n        }\n        result = append(result, max)\n        nums1 = append(nums1[:max_index], nums1[max_index+1:]...)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpz6sxiz7e_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=50) %!s(int=40)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpz6sxiz7e_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpz6sxiz7e_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var products []int\n    for _, n1 := range nums1 {\n        for _, n2 := range nums2 {\n            products = append(products, n1 * n2)\n        }\n    }\n    return products\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122865,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmp1kmn9d2f_test.go:34: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=3) %!s(int=6) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=6) %!s(int=6) %!s(int=12) %!s(int=16) %!s(int=18) %!s(int=20) %!s(int=12) %!s(int=9) %!s(int=18) %!s(int=24) %!s(int=27) %!s(int=30) %!s(int=18) %!s(int=12) %!s(int=24) %!s(int=32) %!s(int=36) %!s(int=40) %!s(int=24) %!s(int=15) %!s(int=30) %!s(int=40) %!s(int=45) %!s(int=50) %!s(int=30) %!s(int=18) %!s(int=36) %!s(int=48) %!s(int=54) %!s(int=60) %!s(int=36)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmp1kmn9d2f_test.go:34: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=3) %!s(int=6) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=6) %!s(int=6) %!s(int=12) %!s(int=16) %!s(int=18) %!s(int=20) %!s(int=12) %!s(int=9) %!s(int=18) %!s(int=24) %!s(int=27) %!s(int=30) %!s(int=18) %!s(int=12) %!s(int=24) %!s(int=32) %!s(int=36) %!s(int=40) %!s(int=24) %!s(int=15) %!s(int=30) %!s(int=40) %!s(int=45) %!s(int=50) %!s(int=30) %!s(int=18) %!s(int=36) %!s(int=48) %!s(int=54) %!s(int=60) %!s(int=36)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmp1kmn9d2f_test.go:34: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=3) %!s(int=6) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=6) %!s(int=6) %!s(int=12) %!s(int=16) %!s(int=18) %!s(int=20) %!s(int=12) %!s(int=9) %!s(int=18) %!s(int=24) %!s(int=27) %!s(int=30) %!s(int=18) %!s(int=12) %!s(int=24) %!s(int=32) %!s(int=36) %!s(int=40) %!s(int=24) %!s(int=15) %!s(int=30) %!s(int=40) %!s(int=45) %!s(int=50) %!s(int=30) %!s(int=18) %!s(int=36) %!s(int=48) %!s(int=54) %!s(int=60) %!s(int=36)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    var i, j int\n    for i = 0; i < N; i++ {\n        var max int\n        for j = 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n            }\n        }\n        nums1 = append(nums1[:j], nums1[j+1:]...)\n        var max2 int\n        for j = 0; j < len(nums2); j++ {\n            if nums2[j] > max2 {\n                max2 = nums2[j]\n            }\n        }\n        nums2 = append(nums2[:j], nums2[j+1:]...)\n        result = append(result, max*max2)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122865,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\npanic: runtime error: slice bounds out of range [7:6] [recovered]\n\tpanic: runtime error: slice bounds out of range [7:6]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536460, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536460, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.large_product(0xc0000925e0, 0x6, 0x6, 0xc0000925b0, 0x6, 0x6, 0x3, 0xf, 0x4cd120, 0x0)\n\t/tmp/tmpgqea4byb_test.go:19 +0x6f\ncommand-line-arguments_test.TestLarge_Product(0xc000001380)\n\t/tmp/tmpgqea4byb_test.go:39 +0x14b\ntesting.tRunner(0xc000001380, 0x54f328)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    n1 := len(nums1)\n    n2 := len(nums2)\n    if n1 == 0 || n2 == 0 {\n        return []int{}\n    }\n    if N > n1 * n2 {\n        return []int{}\n    }\n    if N == n1 * n2 {\n        res := make([]int, N)\n        for i := 0; i < n1; i++ {\n            for j := 0; j < n2; j++ {\n                res[i * n2 + j] = nums1[i] * nums2[j]\n            }\n        }\n        return res\n    }\n    res := make([]int, N)\n    for i := 0; i < N; i++ {\n        res[i] = nums1[0] * nums2[0]\n    }\n    for i := 0; i < n1; i++ {\n        for j := 0; j < n2; j++ {\n            if nums1[i] * nums2[j] > res[0] {\n                res[0] = nums1[i] * nums2[j]\n                for k := 1; k < N; k++ {\n                    if res[k] < res[k - 1] {\n                        res[k], res[k - 1] = res[k - 1], res[k]\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return res\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122865,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmp47qjoxwi_test.go:63: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=50) %!s(int=54) %!s(int=60)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmp47qjoxwi_test.go:63: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=48) %!s(int=50) %!s(int=54) %!s(int=60)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmp47qjoxwi_test.go:63: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=45) %!s(int=48) %!s(int=50) %!s(int=54) %!s(int=60)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var ret []int\n    for i := 0; i < N; i++ {\n        var max1, max2 int\n        var max1_idx, max2_idx int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max1 {\n                max1 = nums1[j]\n                max1_idx = j\n            }\n        }\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max2 {\n                max2 = nums2[j]\n                max2_idx = j\n            }\n        }\n        ret = append(ret, max1 * max2)\n        nums1[max1_idx] = 0\n        nums2[max2_idx] = 0\n    }\n    return ret\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122866,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmprh000w6y_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=45) %!s(int=32)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmprh000w6y_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmprh000w6y_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18) %!s(int=12)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = -1\n        max = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * max_index)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122862,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpvkcnxqe4_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpvkcnxqe4_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpvkcnxqe4_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return []int{}\n    }\n    if N > len(nums1) * len(nums2) {\n        return []int{}\n    }\n    var result []int\n    var i, j int\n    var m, n int\n    var product int\n    for i = 0; i < len(nums1); i++ {\n        for j = 0; j < len(nums2); j++ {\n            product = nums1[i] * nums2[j]\n            if len(result) == 0 {\n                result = append(result, product)\n            } else if len(result) < N {\n                for m = 0; m < len(result); m++ {\n                    if product > result[m] {\n                        result = append(result, 0)\n                        for n = len(result) - 1; n > m; n-- {\n                            result[n] = result[n - 1]\n                        }\n                        result[m] = product\n                        break\n                    }\n                }\n                if m == len(result) {\n                    result = append(result, product)\n                }\n            } else {\n                if product > result[0] {\n                    result[0] = product\n                    for m = 1; m < len(result); m++ {\n                        if result[m] < result[m - 1] {\n                            result[m - 1], result[m] = result[m], result[m - 1]\n                        } else {\n                            break\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122866,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmp80ha0g06_test.go:71: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=50) %!s(int=54) %!s(int=60)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmp80ha0g06_test.go:71: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=48) %!s(int=50) %!s(int=54) %!s(int=60)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmp80ha0g06_test.go:71: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=45) %!s(int=48) %!s(int=50) %!s(int=54) %!s(int=60)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var index int\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max {\n                    max = nums1[j] * nums2[k]\n                    index = j\n                }\n            }\n        }\n        result = append(result, max)\n        nums1 = append(nums1[:index], nums1[index+1:]...)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122866,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmply8fr9k6_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=50) %!s(int=40)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmply8fr9k6_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmply8fr9k6_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    if N == 0 {\n        return []int{}\n    }\n\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return []int{}\n    }\n\n    if N > len(nums1) * len(nums2) {\n        N = len(nums1) * len(nums2)\n    }\n\n    products := make([]int, N)\n    for i := 0; i < N; i++ {\n        products[i] = -1\n    }\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            product := nums1[i] * nums2[j]\n            if product > products[N - 1] {\n                products[N - 1] = product\n                for k := N - 1; k > 0; k-- {\n                    if products[k] > products[k - 1] {\n                        products[k], products[k - 1] = products[k - 1], products[k]\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n\n    return products\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122867,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] * max > nums1[max_index] {\n                nums1[max_index] = nums2[j] * max\n            }\n        }\n        result = append(result, nums1[max_index])\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122867,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpxkepfmjn_test.go:46: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=600) %!s(int=6000)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpxkepfmjn_test.go:46: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=600) %!s(int=6000) %!s(int=60000)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpxkepfmjn_test.go:46: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=600) %!s(int=6000) %!s(int=60000) %!s(int=600000)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    var i, j int\n    for i = 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j = 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j = 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * max_index)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122862,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpjribxv6y_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpjribxv6y_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpjribxv6y_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] * max > nums1[max_index] {\n                nums1[max_index] = nums2[j] * max\n            }\n        }\n        result = append(result, nums1[max_index])\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122867,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpxkepfmjn_test.go:46: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=600) %!s(int=6000)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpxkepfmjn_test.go:46: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=600) %!s(int=6000) %!s(int=60000)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpxkepfmjn_test.go:46: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=600) %!s(int=6000) %!s(int=60000) %!s(int=600000)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var res []int\n    var i, j int\n    for i < len(nums1) && j < len(nums2) {\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j+1] {\n            res = append(res, nums1[i] * nums2[j])\n            j++\n        } else {\n            res = append(res, nums1[i] * nums2[j+1])\n            i++\n        }\n    }\n    return res\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122865,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmp0s9djyi1_test.go:39: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=6) %!s(int=12) %!s(int=18) %!s(int=24) %!s(int=30) %!s(int=36)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmp0s9djyi1_test.go:39: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=6) %!s(int=12) %!s(int=18) %!s(int=24) %!s(int=30) %!s(int=36)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmp0s9djyi1_test.go:39: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=6) %!s(int=12) %!s(int=18) %!s(int=24) %!s(int=30) %!s(int=36)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        max1, max2 := 0, 0\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > nums1[max1] {\n                max1 = j\n            }\n        }\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > nums2[max2] {\n                max2 = j\n            }\n        }\n        result = append(result, nums1[max1] * nums2[max2])\n        nums1[max1] = 0\n        nums2[max2] = 0\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpex94231e_test.go:45: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=45) %!s(int=32)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpex94231e_test.go:45: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpex94231e_test.go:45: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18) %!s(int=12)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = -1\n        max = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * max_index)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122862,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpvkcnxqe4_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpvkcnxqe4_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpvkcnxqe4_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    var i, j, k int\n    var n1, n2 int\n    var n1_index, n2_index int\n    var n1_count, n2_count int\n    var n1_max, n2_max int\n    var n1_max_index, n2_max_index int\n    var n1_max_count, n2_max_count int\n    var n1_max_index_count, n2_max_index_count int\n    var n1_max_index_count_index, n2_max_index_count_index int\n    var n1_max_index_count_index_count, n2_max_index_count_index_count int\n    var n1_max_index_count_index_count_index, n2_max_index_count_index_count_index int\n    var n1_max_index_count_index_count_index_count, n2_max_index_count_index_count_index_count int\n    var n1_max_index_count_index_count_index_count_index, n2_max_index_count_index_count_index_count_index int\n    var n1_max_index_count_index_count_index_count_index_count, n2_max_index_count_index_count_index_count_index_count int\n    var n1_max_index_count_index_count_index_count_index_count_index, n2_max_index_count_index_count_index_count_index_count_index int\n    var n1_max_index_count_index_count_index_count_index_count_index_count, n2_max_index_count_index_count_index_count_index_count_index_count int\n    var n1_max_index_count_index_count_index_count_index_count_index_count_index, n2_max_index_count_index_count_index_count_index_count_index_count_index int\n    var n1_max_index_count_index_count_index_count_index_count_index\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpfmiucwuz_test.go:28:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        max1, max2 := 0, 0\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max1 {\n                max1 = nums1[j]\n            }\n        }\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max2 {\n                max2 = nums2[j]\n            }\n        }\n        result = append(result, max1 * max2)\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] == max1 {\n                nums1 = append(nums1[:j], nums1[j+1:]...)\n                break\n            }\n        }\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] == max2 {\n                nums2 = append(nums2[:j], nums2[j+1:]...)\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122867,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpsd0if9kr_test.go:55: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=45) %!s(int=32)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpsd0if9kr_test.go:55: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpsd0if9kr_test.go:55: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18) %!s(int=12)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    // sort nums1 and nums2\n    sort(nums1)\n    sort(nums2)\n    // get the N largest products\n    var products []int\n    for i := 0; i < N; i++ {\n        products = append(products, nums1[i] * nums2[i])\n    }\n    return products\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122867,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpurje4vv6_test.go:11:5: undefined: sort\n/tmp/tmpurje4vv6_test.go:12:5: undefined: sort\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] * max > max {\n                max = nums2[j] * max\n                max_index = j\n            }\n        }\n        nums2[max_index] = 0\n        result = append(result, max)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122865,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpp4rl27gj_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=466560) %!s(int=64800) %!s(int=5184)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpp4rl27gj_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=466560) %!s(int=64800) %!s(int=5184) %!s(int=432)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpp4rl27gj_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=466560) %!s(int=64800) %!s(int=5184) %!s(int=432) %!s(int=36)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * max_index)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var res []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        res = append(res, max * nums1[max_index])\n    }\n    return res\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122864,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpsrlcc1sj_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpsrlcc1sj_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpsrlcc1sj_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    var max_product int\n    var max_index int\n    var max_index2 int\n    var max_index3 int\n    var max_index4 int\n    var max_index5 int\n    var max_index6 int\n    var max_index7 int\n    var max_index8 int\n    var max_index9 int\n    var max_index10 int\n    var max_index11 int\n    var max_index12 int\n    var max_index13 int\n    var max_index14 int\n    var max_index15 int\n    var max_index16 int\n    var max_index17 int\n    var max_index18 int\n    var max_index19 int\n    var max_index20 int\n    var max_index21 int\n    var max_index22 int\n    var max_index23 int\n    var max_index24 int\n    var max_index25 int\n    var max_index26 int\n    var max_index27 int\n    var max_index28 int\n    var max_index29 int\n    var max_index30 int\n    var max_index31 int\n    var max_index32 int\n    var max_index33 int\n    var max_index34 int\n    var max_index35 int\n    var max_index36 int\n    var max_index37 int\n    var max_index38 int\n    var max_index39 int\n    var max_index40 int\n    var max_index41 int\n    var max_index42 int\n    var max_index43 int\n    var max_index44 int\n    var max_index45 int\n    var max_index46 int\n    var max_index47 int\n    var max_index48 int\n    var max_index49 int\n    var max_index50 int\n    var max_index51 int\n    var max_index52 int\n    var max_index53 int\n    var max_index54 int\n    var max_index55 int\n    var max_index56 int\n    var max_index57 int\n    var max_index58 int\n    var max_index59 int\n    var max_index60 int\n    var max_index61 int\n    var max_index62 int\n    var max\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122861,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmptwt7dkqi_test.go:74:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var res []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max {\n                    max = nums1[j] * nums2[k]\n                    max_index = j\n                }\n            }\n        }\n        res = append(res, max)\n        nums1 = append(nums1[:max_index], nums1[max_index+1:]...)\n    }\n    return res\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmp9yg6vq95_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=50) %!s(int=40)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmp9yg6vq95_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmp9yg6vq95_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * max_index)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var res []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] * max > nums1[max_index] {\n                nums1[max_index] = nums2[j] * max\n            }\n        }\n        res = append(res, nums1[max_index])\n    }\n    return res\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122864,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpvlfe5md0_test.go:46: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=600) %!s(int=6000)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpvlfe5md0_test.go:46: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=600) %!s(int=6000) %!s(int=60000)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpvlfe5md0_test.go:46: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=600) %!s(int=6000) %!s(int=60000) %!s(int=600000)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * max_index)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    var i, j int\n    for i = 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j = 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = -1\n        max = 0\n        for j = 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * max_index)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122862,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpdvqkihv5_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpdvqkihv5_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpdvqkihv5_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return nil\n    }\n    if N > len(nums1) * len(nums2) {\n        return nil\n    }\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_i, max_j int\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max {\n                    max = nums1[j] * nums2[k]\n                    max_i = j\n                    max_j = k\n                }\n            }\n        }\n        result = append(result, max)\n        nums1 = append(nums1[:max_i], nums1[max_i+1:]...)\n        nums2 = append(nums2[:max_j], nums2[max_j+1:]...)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122867,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmp8xgb96dv_test.go:51: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=45) %!s(int=32)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmp8xgb96dv_test.go:51: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmp8xgb96dv_test.go:51: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18) %!s(int=12)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var res []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        res = append(res, max_index * max)\n    }\n    return res\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122867,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpp5jqfta2_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpp5jqfta2_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpp5jqfta2_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return []int{}\n    }\n\n    if N > len(nums1) * len(nums2) {\n        return []int{}\n    }\n\n    var res []int\n    for i := 0; i < N; i++ {\n        max := 0\n        var max_index1, max_index2 int\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max {\n                    max = nums1[j] * nums2[k]\n                    max_index1 = j\n                    max_index2 = k\n                }\n            }\n        }\n        res = append(res, max)\n        nums1 = append(nums1[:max_index1], nums1[max_index1+1:]...)\n        nums2 = append(nums2[:max_index2], nums2[max_index2+1:]...)\n    }\n\n    return res\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122867,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpj20grkwe_test.go:54: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=45) %!s(int=32)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpj20grkwe_test.go:54: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpj20grkwe_test.go:54: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18) %!s(int=12)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    var i, j int\n    for i = 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j = 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j = 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * max_index)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122862,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpjribxv6y_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpjribxv6y_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpjribxv6y_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max_product int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max_product {\n                    max_product = nums1[j] * nums2[k]\n                    max_index = j\n                }\n            }\n        }\n        result = append(result, max_product)\n        nums1 = append(nums1[:max_index], nums1[max_index+1:]...)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122865,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpupyx7s16_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=50) %!s(int=40)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpupyx7s16_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpupyx7s16_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * max_index)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] * max > nums1[max_index] {\n                nums1[max_index] = nums2[j] * max\n            }\n        }\n        result = append(result, nums1[max_index])\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122867,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpxkepfmjn_test.go:46: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=600) %!s(int=6000)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpxkepfmjn_test.go:46: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=600) %!s(int=6000) %!s(int=60000)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpxkepfmjn_test.go:46: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=600) %!s(int=6000) %!s(int=60000) %!s(int=600000)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var (\n        i, j int\n        res []int\n    )\n    for i = 0; i < N; i++ {\n        for j = 0; j < N; j++ {\n            res = append(res, nums1[i] * nums2[j])\n        }\n    }\n    return res\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122867,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpcphs6lgq_test.go:37: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=3) %!s(int=6) %!s(int=8) %!s(int=6) %!s(int=12) %!s(int=16) %!s(int=9) %!s(int=18) %!s(int=24)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpcphs6lgq_test.go:37: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=3) %!s(int=6) %!s(int=8) %!s(int=9) %!s(int=6) %!s(int=12) %!s(int=16) %!s(int=18) %!s(int=9) %!s(int=18) %!s(int=24) %!s(int=27) %!s(int=12) %!s(int=24) %!s(int=32) %!s(int=36)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpcphs6lgq_test.go:37: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=3) %!s(int=6) %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=6) %!s(int=12) %!s(int=16) %!s(int=18) %!s(int=20) %!s(int=9) %!s(int=18) %!s(int=24) %!s(int=27) %!s(int=30) %!s(int=12) %!s(int=24) %!s(int=32) %!s(int=36) %!s(int=40) %!s(int=15) %!s(int=30) %!s(int=40) %!s(int=45) %!s(int=50)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    var i, j int\n    for i = 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j = 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j = 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * max_index)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122862,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpjribxv6y_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpjribxv6y_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpjribxv6y_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    var i, j int\n    for i = 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j = 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = -1\n        max = 0\n        for j = 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * max_index)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122862,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpdvqkihv5_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpdvqkihv5_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpdvqkihv5_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    var i, j int\n    for i = 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j = 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j = 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * max_index)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122862,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpjribxv6y_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpjribxv6y_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpjribxv6y_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = -1\n        max = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * max_index)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122862,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpvkcnxqe4_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpvkcnxqe4_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpvkcnxqe4_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max {\n                    max = nums1[j] * nums2[k]\n                    max_index = j\n                }\n            }\n        }\n        result = append(result, max)\n        nums1 = append(nums1[:max_index], nums1[max_index+1:]...)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpz6sxiz7e_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=50) %!s(int=40)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpz6sxiz7e_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpz6sxiz7e_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * nums1[max_index])\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpalke820m_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpalke820m_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpalke820m_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    var i, j int\n    for i = 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j = 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j = 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * max_index)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122862,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpjribxv6y_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpjribxv6y_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpjribxv6y_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var res []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        res = append(res, max * max_index)\n    }\n    return res\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122860,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmp10wz2y0a_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmp10wz2y0a_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmp10wz2y0a_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * nums1[max_index])\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpalke820m_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpalke820m_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpalke820m_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    var i, j, k int\n    var product int\n\n    for i = 0; i < N; i++ {\n        product = nums1[0] * nums2[0]\n        for j = 0; j < len(nums1); j++ {\n            for k = 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > product {\n                    product = nums1[j] * nums2[k]\n                }\n            }\n        }\n        result = append(result, product)\n        for j = 0; j < len(nums1); j++ {\n            if nums1[j] == product {\n                nums1 = append(nums1[:j], nums1[j+1:]...)\n                break\n            }\n        }\n        for k = 0; k < len(nums2); k++ {\n            if nums2[k] == product {\n                nums2 = append(nums2[:k], nums2[k+1:]...)\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122867,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpjbxtn5jr_test.go:55: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=60) %!s(int=60)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpjbxtn5jr_test.go:55: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=60) %!s(int=60) %!s(int=60)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpjbxtn5jr_test.go:55: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=60) %!s(int=60) %!s(int=60) %!s(int=60)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var res []int\n    var i, j int\n    for i < N {\n        var max int\n        var max_index int\n        for j < len(nums1) {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n            j++\n        }\n        res = append(res, max)\n        nums1 = append(nums1[:max_index], nums1[max_index+1:]...)\n        i++\n    }\n    return res\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122867,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmp_zi9ph66_test.go:44: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=6) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmp_zi9ph66_test.go:44: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=6) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmp_zi9ph66_test.go:44: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=6) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max {\n                    max = nums1[j] * nums2[k]\n                    max_index = j\n                }\n            }\n        }\n        result = append(result, max)\n        nums1 = append(nums1[:max_index], nums1[max_index+1:]...)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpz6sxiz7e_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=50) %!s(int=40)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpz6sxiz7e_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpz6sxiz7e_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max {\n                    max = nums1[j] * nums2[k]\n                    max_index = j\n                }\n            }\n        }\n        result = append(result, max)\n        nums1 = append(nums1[:max_index], nums1[max_index+1:]...)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpz6sxiz7e_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=50) %!s(int=40)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpz6sxiz7e_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpz6sxiz7e_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max {\n                    max = nums1[j] * nums2[k]\n                    max_index = j\n                }\n            }\n        }\n        result = append(result, max)\n        nums1 = append(nums1[:max_index], nums1[max_index+1:]...)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpz6sxiz7e_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=50) %!s(int=40)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpz6sxiz7e_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpz6sxiz7e_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    var i, j int\n    for i = 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j = 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j = 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * max_index)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122862,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpjribxv6y_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpjribxv6y_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpjribxv6y_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    var m = make(map[int]int)\n    for _, num1 := range nums1 {\n        for _, num2 := range nums2 {\n            m[num1 * num2] = num1 * num2\n        }\n    }\n    for i := 0; i < N; i++ {\n        var max = 0\n        for _, v := range m {\n            if v > max {\n                max = v\n            }\n        }\n        result = append(result, max)\n        delete(m, max)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122867,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    var i, j int\n    var n1, n2 int\n    var p int\n\n    for i = 0; i < N; i++ {\n        n1 = nums1[0]\n        n2 = nums2[0]\n        p = n1 * n2\n        for j = 1; j < len(nums1); j++ {\n            if nums1[j] > n1 {\n                n1 = nums1[j]\n                p = n1 * n2\n            }\n        }\n        for j = 1; j < len(nums2); j++ {\n            if nums2[j] > n2 {\n                n2 = nums2[j]\n                p = n1 * n2\n            }\n        }\n        result = append(result, p)\n        for j = 0; j < len(nums1); j++ {\n            if nums1[j] == n1 {\n                nums1 = append(nums1[:j], nums1[j+1:]...)\n                break\n            }\n        }\n        for j = 0; j < len(nums2); j++ {\n            if nums2[j] == n2 {\n                nums2 = append(nums2[:j], nums2[j+1:]...)\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122867,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmp9w55o8f5_test.go:63: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=45) %!s(int=32)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmp9w55o8f5_test.go:63: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmp9w55o8f5_test.go:63: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18) %!s(int=12)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * max_index)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return []int{}\n    }\n    if N > len(nums1) * len(nums2) {\n        return []int{}\n    }\n    var res []int\n    for i := 0; i < N; i++ {\n        max := -1\n        var max_i, max_j int\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max {\n                    max = nums1[j] * nums2[k]\n                    max_i = j\n                    max_j = k\n                }\n            }\n        }\n        res = append(res, max)\n        nums1[max_i] = -1\n        nums2[max_j] = -1\n    }\n    return res\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122862,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpkt03qawg_test.go:51: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=45) %!s(int=32)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpkt03qawg_test.go:51: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpkt03qawg_test.go:51: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18) %!s(int=12)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    // TODO: implement\n    return []int{}\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122862,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpv7dx8t92_test.go:29: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpv7dx8t92_test.go:29: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpv7dx8t92_test.go:29: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.012s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    var i, j int\n    var p int\n    var m, n int\n    var k int\n    var max int\n    var max_index int\n    var max_index_2 int\n    var max_index_3 int\n    var max_index_4 int\n    var max_index_5 int\n    var max_index_6 int\n    var max_index_7 int\n    var max_index_8 int\n    var max_index_9 int\n    var max_index_10 int\n    var max_index_11 int\n    var max_index_12 int\n    var max_index_13 int\n    var max_index_14 int\n    var max_index_15 int\n    var max_index_16 int\n    var max_index_17 int\n    var max_index_18 int\n    var max_index_19 int\n    var max_index_20 int\n    var max_index_21 int\n    var max_index_22 int\n    var max_index_23 int\n    var max_index_24 int\n    var max_index_25 int\n    var max_index_26 int\n    var max_index_27 int\n    var max_index_28 int\n    var max_index_29 int\n    var max_index_30 int\n    var max_index_31 int\n    var max_index_32 int\n    var max_index_33 int\n    var max_index_34 int\n    var max_index_35 int\n    var max_index_36 int\n    var max_index_37 int\n    var max_index_38 int\n    var max_index_39 int\n    var max_index_40 int\n    var max_index_41 int\n    var max_index_42 int\n    var max_index_43 int\n    var max_index_44 int\n    var max_index_45 int\n    var max_index_46 int\n    var max_index_47 int\n    var max_index_48 int\n    var max_index_49 int\n    var max_index_50 int\n    var max_index_51 int\n    var max_index_52 int\n    var max_index_53 int\n   \nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122866,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmplyx6cn9l_test.go:70:6: expected '(', found TestLarge_Product\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] * max > nums1[max_index] {\n                nums1[max_index] = nums2[j] * max\n            }\n        }\n        result = append(result, nums1[max_index])\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122867,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpxkepfmjn_test.go:46: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=600) %!s(int=6000)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpxkepfmjn_test.go:46: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=600) %!s(int=6000) %!s(int=60000)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpxkepfmjn_test.go:46: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=600) %!s(int=6000) %!s(int=60000) %!s(int=600000)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    // TODO:\n    return nil\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122867,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpvd0yapq__test.go:29: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpvd0yapq__test.go:29: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpvd0yapq__test.go:29: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var index int\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max {\n                    max = nums1[j] * nums2[k]\n                    index = j\n                }\n            }\n        }\n        result = append(result, max)\n        nums1 = append(nums1[:index], nums1[index+1:]...)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122866,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmply8fr9k6_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=50) %!s(int=40)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmply8fr9k6_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmply8fr9k6_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] * max > nums1[max_index] {\n                nums1[max_index] = nums2[j] * max\n            }\n        }\n        result = append(result, nums1[max_index])\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122867,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpxkepfmjn_test.go:46: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=600) %!s(int=6000)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpxkepfmjn_test.go:46: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=600) %!s(int=6000) %!s(int=60000)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpxkepfmjn_test.go:46: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=600) %!s(int=6000) %!s(int=60000) %!s(int=600000)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        max := 0\n        for _, v1 := range nums1 {\n            for _, v2 := range nums2 {\n                if v1 * v2 > max {\n                    max = v1 * v2\n                }\n            }\n        }\n        result = append(result, max)\n        for j, v1 := range nums1 {\n            if v1 * nums2[0] == max {\n                nums1 = append(nums1[:j], nums1[j+1:]...)\n                break\n            }\n        }\n        for j, v2 := range nums2 {\n            if v2 * nums1[0] == max {\n                nums2 = append(nums2[:j], nums2[j+1:]...)\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122867,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpyvyclusr_test.go:52: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=60) %!s(int=60)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpyvyclusr_test.go:52: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=60) %!s(int=60) %!s(int=60)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpyvyclusr_test.go:52: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=60) %!s(int=60) %!s(int=60) %!s(int=60)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    if N > len(nums1) || N > len(nums2) {\n        return nil\n    }\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * nums1[max_index])\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122867,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmp7ou3ois6_test.go:50: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmp7ou3ois6_test.go:50: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmp7ou3ois6_test.go:50: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return []int{}\n    }\n\n    // sort nums1 and nums2\n    sort(nums1)\n    sort(nums2)\n\n    // init\n    var result []int\n    var i, j int\n    var max int\n    var max_i, max_j int\n\n    for k := 0; k < N; k++ {\n        max = 0\n        for i = 0; i < len(nums1); i++ {\n            for j = 0; j < len(nums2); j++ {\n                if nums1[i] * nums2[j] > max {\n                    max = nums1[i] * nums2[j]\n                    max_i = i\n                    max_j = j\n                }\n            }\n        }\n\n        result = append(result, max)\n        nums1 = append(nums1[:max_i], nums1[max_i+1:]...)\n        nums2 = append(nums2[:max_j], nums2[max_j+1:]...)\n    }\n\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122867,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5zvow16f_test.go:15:5: undefined: sort\n/tmp/tmp5zvow16f_test.go:16:5: undefined: sort\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * max_index)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    var i, j int\n    for i = 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j = 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j = 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * max_index)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122862,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpjribxv6y_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpjribxv6y_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpjribxv6y_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var index int\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max {\n                    max = nums1[j] * nums2[k]\n                    index = j\n                }\n            }\n        }\n        result = append(result, max)\n        nums1 = append(nums1[:index], nums1[index+1:]...)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122866,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmply8fr9k6_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=50) %!s(int=40)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmply8fr9k6_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmply8fr9k6_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * max_index)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var res []int\n    for i := 0; i < N; i++ {\n        var max int\n        for _, n1 := range nums1 {\n            for _, n2 := range nums2 {\n                if n1 * n2 > max {\n                    max = n1 * n2\n                }\n            }\n        }\n        res = append(res, max)\n        for j, n1 := range nums1 {\n            if n1 * nums2[0] == max {\n                nums1 = append(nums1[:j], nums1[j+1:]...)\n                break\n            }\n        }\n        for j, n2 := range nums2 {\n            if n2 * nums1[0] == max {\n                nums2 = append(nums2[:j], nums2[j+1:]...)\n                break\n            }\n        }\n    }\n    return res\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122867,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpjdazufhn_test.go:52: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=60) %!s(int=60)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpjdazufhn_test.go:52: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=60) %!s(int=60) %!s(int=60)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpjdazufhn_test.go:52: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=60) %!s(int=60) %!s(int=60) %!s(int=60)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var res []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        res = append(res, max_index * max)\n    }\n    return res\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122867,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpp5jqfta2_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpp5jqfta2_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpp5jqfta2_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return []int{}\n    }\n    if N > len(nums1) * len(nums2) {\n        return []int{}\n    }\n    var result []int\n    for i := 0; i < N; i++ {\n        max := -1\n        max_i := -1\n        max_j := -1\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max {\n                    max = nums1[j] * nums2[k]\n                    max_i = j\n                    max_j = k\n                }\n            }\n        }\n        result = append(result, max)\n        nums1[max_i] = -1\n        nums2[max_j] = -1\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122867,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmp9orp_51s_test.go:52: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=45) %!s(int=32)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmp9orp_51s_test.go:52: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmp9orp_51s_test.go:52: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18) %!s(int=12)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var (\n        res []int\n        i, j int\n        p int\n    )\n    for i = 0; i < N; i++ {\n        for j = 0; j < N; j++ {\n            p = nums1[i] * nums2[j]\n            if len(res) < N {\n                res = append(res, p)\n            } else {\n                if p > res[0] {\n                    res[0] = p\n                }\n            }\n        }\n    }\n    return res\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122867,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmp404ww1es_test.go:45: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=24) %!s(int=6) %!s(int=8)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmp404ww1es_test.go:45: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=36) %!s(int=6) %!s(int=8) %!s(int=9)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmp404ww1es_test.go:45: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=50) %!s(int=6) %!s(int=8) %!s(int=9) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    var i, j, k int\n    var n1, n2 int\n    var p int\n    var max int\n    var max_index int\n    var max_nums []int\n    var max_nums_index []int\n\n    for i = 0; i < N; i++ {\n        max = 0\n        max_index = 0\n        for j = 0; j < len(nums1); j++ {\n            for k = 0; k < len(nums2); k++ {\n                p = nums1[j] * nums2[k]\n                if p > max {\n                    max = p\n                    max_index = k\n                }\n            }\n        }\n        result = append(result, max)\n        nums2[max_index] = 0\n    }\n\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122867,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqf8xptv8_test.go:12:9: n1 declared but not used\n/tmp/tmpqf8xptv8_test.go:12:13: n2 declared but not used\n/tmp/tmpqf8xptv8_test.go:16:9: max_nums declared but not used\n/tmp/tmpqf8xptv8_test.go:17:9: max_nums_index declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] * max > nums1[max_index] {\n                nums1[max_index] = nums2[j] * max\n            }\n        }\n        result = append(result, nums1[max_index])\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122867,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpxkepfmjn_test.go:46: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=600) %!s(int=6000)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpxkepfmjn_test.go:46: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=600) %!s(int=6000) %!s(int=60000)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpxkepfmjn_test.go:46: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=600) %!s(int=6000) %!s(int=60000) %!s(int=600000)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var res []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] * max > max {\n                max = nums2[j] * max\n                max_index = j\n            }\n        }\n        nums2[max_index] = 0\n        res = append(res, max)\n    }\n    return res\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122862,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmp8m_b4rrm_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=466560) %!s(int=64800) %!s(int=5184)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmp8m_b4rrm_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=466560) %!s(int=64800) %!s(int=5184) %!s(int=432)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmp8m_b4rrm_test.go:48: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=466560) %!s(int=64800) %!s(int=5184) %!s(int=432) %!s(int=36)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var index int\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max {\n                    max = nums1[j] * nums2[k]\n                    index = j\n                }\n            }\n        }\n        result = append(result, max)\n        nums1 = append(nums1[:index], nums1[index+1:]...)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122866,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmply8fr9k6_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=50) %!s(int=40)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmply8fr9k6_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmply8fr9k6_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        max1, max2 := 0, 0\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > nums1[max1] {\n                max1 = j\n            }\n        }\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > nums2[max2] {\n                max2 = j\n            }\n        }\n        result = append(result, nums1[max1] * nums2[max2])\n        nums1[max1], nums2[max2] = 0, 0\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122867,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpfssepmgu_test.go:44: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=45) %!s(int=32)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpfssepmgu_test.go:44: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpfssepmgu_test.go:44: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18) %!s(int=12)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return []int{}\n    }\n    if N > len(nums1) * len(nums2) {\n        return []int{}\n    }\n    var res []int\n    for i := 0; i < N; i++ {\n        max := 0\n        max_i := 0\n        max_j := 0\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max {\n                    max = nums1[j] * nums2[k]\n                    max_i = j\n                    max_j = k\n                }\n            }\n        }\n        res = append(res, max)\n        nums1[max_i] = 0\n        nums2[max_j] = 0\n    }\n    return res\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122867,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmp3v_nv3cs_test.go:52: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=45) %!s(int=32)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmp3v_nv3cs_test.go:52: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmp3v_nv3cs_test.go:52: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18) %!s(int=12)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max {\n                    max = nums1[j] * nums2[k]\n                    max_index = j\n                }\n            }\n        }\n        result = append(result, max)\n        nums1 = append(nums1[:max_index], nums1[max_index+1:]...)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpz6sxiz7e_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=50) %!s(int=40)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpz6sxiz7e_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpz6sxiz7e_test.go:43: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    // sort the two lists\n    // sort(nums1)\n    // sort(nums2)\n    //\n    // // create a new list to store the result\n    // result := make([]int, N)\n    //\n    // // create two pointers to point to the last elements of the two lists\n    // p1 := len(nums1) - 1\n    // p2 := len(nums2) - 1\n    //\n    // // create a pointer to point to the last element of the result list\n    // p := len(result) - 1\n    //\n    // // loop N times\n    // for i := 0; i < N; i++ {\n    //     // compare the two last elements of the two lists\n    //     if nums1[p1] > nums2[p2] {\n    //         // if the last element of the first list is larger,\n    //         // add the product of the two last elements to the result list\n    //         result[p] = nums1[p1] * nums2[p2]\n    //         // move the pointer of the first list backward\n    //         p1--\n    //     } else {\n    //         // if the last element of the second list is larger,\n    //         // add the product of the two last elements to the result list\n    //         result[p] = nums1[p1] * nums2[p2]\n    //         // move the pointer of the second list backward\n    //         p2--\n    //     }\n    //     // move the pointer of the result list backward\n    //     p--\n    // }\n    //\n    // // return the result list\n    // return result\n    return []int{}\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122867,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmp1wnfpajt_test.go:64: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmp1wnfpajt_test.go:64: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmp1wnfpajt_test.go:64: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    // sort nums1\n    for i := 0; i < len(nums1); i++ {\n        for j := i + 1; j < len(nums1); j++ {\n            if nums1[i] < nums1[j] {\n                nums1[i], nums1[j] = nums1[j], nums1[i]\n            }\n        }\n    }\n    // sort nums2\n    for i := 0; i < len(nums2); i++ {\n        for j := i + 1; j < len(nums2); j++ {\n            if nums2[i] < nums2[j] {\n                nums2[i], nums2[j] = nums2[j], nums2[i]\n            }\n        }\n    }\n    // find the N largest products\n    products := make([]int, 0)\n    for i := 0; i < N; i++ {\n        products = append(products, nums1[i] * nums2[i])\n    }\n    return products\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122867,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpr1gjs1j0_test.go:49: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=60) %!s(int=45) %!s(int=32)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpr1gjs1j0_test.go:49: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpr1gjs1j0_test.go:49: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=60) %!s(int=45) %!s(int=32) %!s(int=18) %!s(int=12)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * max_index)\n    }\n    return result\n}\n\nfunc TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509997,
      "stdout": "--- FAIL: TestLarge_Product (0.00s)\n    --- FAIL: TestLarge_Product/test_num__0 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50)]', got '[%!s(int=50) %!s(int=40) %!s(int=30)]'\n    --- FAIL: TestLarge_Product/test_num__1 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20)]'\n    --- FAIL: TestLarge_Product/test_num__2 (0.00s)\n        tmpxdf1xfkb_test.go:47: expected '[%!s(int=60) %!s(int=54) %!s(int=50) %!s(int=48) %!s(int=45)]', got '[%!s(int=50) %!s(int=40) %!s(int=30) %!s(int=20) %!s(int=10)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}