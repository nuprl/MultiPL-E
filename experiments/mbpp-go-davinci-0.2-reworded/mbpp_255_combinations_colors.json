{
  "name": "mbpp_255_combinations_colors",
  "language": "go_test.go",
  "prompt": "package combinations_colors_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list and length n, and generates all combinations (with repetition) of the elements of the list and returns a list with a list for each combination.\nfunc combinations_colors(l []string, n int) [][]interface{} {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_255_combinations_colors.py",
  "prompt_terminology": "reworded",
  "tests": "func TestCombinations_Colors(t *testing.T) {\n  candidate := combinations_colors\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"Red\", \"Green\", \"Blue\"}, 1), expected: [][]int{[]interface{}{\"Red\"}, []interface{}{\"Green\"}, []interface{}{\"Blue\"}} },\n     { actual: candidate([]string{\"Red\", \"Green\", \"Blue\"}, 2), expected: [][]int{[]interface{}{\"Red\", \"Red\"}, []interface{}{\"Red\", \"Green\"}, []interface{}{\"Red\", \"Blue\"}, []interface{}{\"Green\", \"Green\"}, []interface{}{\"Green\", \"Blue\"}, []interface{}{\"Blue\", \"Blue\"}} },\n     { actual: candidate([]string{\"Red\", \"Green\", \"Blue\"}, 3), expected: [][]int{[]interface{}{\"Red\", \"Red\", \"Red\"}, []interface{}{\"Red\", \"Red\", \"Green\"}, []interface{}{\"Red\", \"Red\", \"Blue\"}, []interface{}{\"Red\", \"Green\", \"Green\"}, []interface{}{\"Red\", \"Green\", \"Blue\"}, []interface{}{\"Red\", \"Blue\", \"Blue\"}, []interface{}{\"Green\", \"Green\", \"Green\"}, []interface{}{\"Green\", \"Green\", \"Blue\"}, []interface{}{\"Green\", \"Blue\", \"Blue\"}, []interface{}{\"Blue\", \"Blue\", \"Blue\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    if n == 1 {\n        var r [][]interface{}\n        for _, e := range l {\n            r = append(r, []interface{}{e})\n        }\n        return r\n    }\n    var r [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, e := range combinations_colors(l[i:], n - 1) {\n            r = append(r, append([]interface{}{l[i]}, e...))\n        }\n    }\n    return r\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, sub := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, sub...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    if len(l) < n {\n        return [][]interface{}{}\n    }\n    if len(l) == n {\n        return [][]interface{}{{l}}\n    }\n    result := [][]interface{}{}\n    for i := 0; i < len(l); i++ {\n        for _, c := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, c...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    if n == 1 {\n        var res [][]interface{}\n        for _, v := range l {\n            res = append(res, []interface{}{v})\n        }\n        return res\n    }\n    var res [][]interface{}\n    for i := 0; i <= len(l)-n; i++ {\n        for _, v := range combinations_colors(l[i+1:], n-1) {\n            res = append(res, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return res\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_result [][]interface{}\n        sub_result = combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            sub_result[j] = append([]interface{}{l[i]}, sub_result[j]...)\n            result = append(result, sub_result[j])\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, c := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, c...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    for i := 0; i < len(l); i++ {\n        for _, comb := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, comb...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    for i := 0; i < len(l); i++ {\n        for _, c := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, c...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i, v := range l {\n        for _, c := range combinations_colors(l[i:], n - 1) {\n            result = append(result, append([]interface{}{v}, c...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    for i := 0; i < len(l); i++ {\n        for _, r := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, r...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_result [][]interface{}\n        sub_result = combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            sub_result[j] = append([]interface{}{l[i]}, sub_result[j]...)\n            result = append(result, sub_result[j])\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, c := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, c...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    for i := 0; i <= len(l) - n; i++ {\n        for _, v := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var inner []interface{}\n    var f func(int, int)\n    f = func(i, j int) {\n        if j == n {\n            result = append(result, inner)\n            return\n        }\n        for ; i < len(l); i++ {\n            inner = append(inner, l[i])\n            f(i, j+1)\n            inner = inner[:len(inner)-1]\n        }\n    }\n    f(0, 0)\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_combinations [][]interface{}\n        sub_combinations = combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_combinations); j++ {\n            sub_combinations[j] = append([]interface{}{l[i]}, sub_combinations[j]...)\n        }\n        result = append(result, sub_combinations...)\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var combination []interface{}\n    var helper func(int)\n    helper = func(start int) {\n        if len(combination) == n {\n            result = append(result, combination)\n            return\n        }\n        for i := start; i < len(l); i++ {\n            combination = append(combination, l[i])\n            helper(i)\n            combination = combination[:len(combination)-1]\n        }\n    }\n    helper(0)\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n\n    var result [][]interface{}\n\n    for i := 0; i < len(l); i++ {\n        for _, c := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, c...))\n        }\n    }\n\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i, v := range l {\n        for _, r := range combinations_colors(l[i:], n - 1) {\n            result = append(result, append([]interface{}{v}, r...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n\n    var result [][]interface{}\n\n    for i := 0; i < len(l); i++ {\n        var sub_result [][]interface{}\n        sub_result = combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            sub_result[j] = append([]interface{}{l[i]}, sub_result[j]...)\n        }\n        result = append(result, sub_result...)\n    }\n\n    return result\n}\n",
    "    var result [][]interface{}\n    var combination []interface{}\n    var helper func(int)\n    helper = func(i int) {\n        if i == n {\n            result = append(result, combination)\n            return\n        }\n        for _, v := range l {\n            combination = append(combination, v)\n            helper(i + 1)\n            combination = combination[:len(combination) - 1]\n        }\n    }\n    helper(0)\n    return result\n}\n",
    "    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for j := 0; j < len(l); j++ {\n            for k := 0; k < len(l); k++ {\n                result = append(result, []interface{}{l[i], l[j], l[k]})\n            }\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    if len(l) < n {\n        return [][]interface{}{}\n    }\n    if len(l) == n {\n        return [][]interface{}{[]interface{}{l}}\n    }\n    var result [][]interface{}\n    for i, v := range l {\n        for _, v2 := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{v}, v2...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i:], n - 1) {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    // TODO: Implement\n    return nil\n}\n",
    "    if n == 1 {\n        var ret [][]interface{}\n        for _, v := range l {\n            ret = append(ret, []interface{}{v})\n        }\n        return ret\n    }\n\n    var ret [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_l []string\n        for j := i; j < len(l); j++ {\n            sub_l = append(sub_l, l[j])\n        }\n        sub_ret := combinations_colors(sub_l, n - 1)\n        for _, v := range sub_ret {\n            ret = append(ret, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return ret\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    return append(combinations_colors(l[1:], n), append(combinations_colors(l[1:], n-1), l[0])...)\n}\n",
    "    var result [][]interface{}\n    var current []interface{}\n    var helper func(int)\n    helper = func(i int) {\n        if i == n {\n            result = append(result, current)\n            return\n        }\n        for _, v := range l {\n            current = append(current, v)\n            helper(i+1)\n            current = current[:len(current)-1]\n        }\n    }\n    helper(0)\n    return result\n}\n",
    "    if n == 1 {\n        var r [][]interface{}\n        for _, v := range l {\n            r = append(r, []interface{}{v})\n        }\n        return r\n    }\n    var r [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i:], n-1) {\n            r = append(r, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return r\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        combinations := combinations_colors(l[i+1:], n-1)\n        for _, combination := range combinations {\n            result = append(result, append([]interface{}{l[i]}, combination...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    return append(combinations_colors(l[1:], n), append(combinations_colors(l[1:], n-1), l[0])...)\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, c := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, c...))\n        }\n    }\n    return result\n}\n",
    "    if n == 1 {\n        var r [][]interface{}\n        for _, e := range l {\n            r = append(r, []interface{}{e})\n        }\n        return r\n    }\n    var r [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, c := range combinations_colors(l[i:], n - 1) {\n            r = append(r, append([]interface{}{l[i]}, c...))\n        }\n    }\n    return r\n}\n",
    "    var result [][]interface{}\n    var combination []interface{}\n    var helper func(int)\n    helper = func(i int) {\n        if i == n {\n            result = append(result, combination)\n            return\n        }\n        for _, v := range l {\n            combination = append(combination, v)\n            helper(i + 1)\n            combination = combination[:len(combination) - 1]\n        }\n    }\n    helper(0)\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, c := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, c...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    if len(l) == 1 {\n        return [][]interface{}{{l[0]}}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, c := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, c...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n\n    var result [][]interface{}\n\n    for i := 0; i < len(l); i++ {\n        var temp []interface{}\n        temp = append(temp, l[i])\n        result = append(result, temp)\n    }\n\n    for i := 1; i < n; i++ {\n        var temp [][]interface{}\n        for j := 0; j < len(result); j++ {\n            for k := 0; k < len(l); k++ {\n                var temp2 []interface{}\n                temp2 = append(temp2, result[j]...)\n                temp2 = append(temp2, l[k])\n                temp = append(temp, temp2)\n            }\n        }\n        result = temp\n    }\n\n    return result\n}\n",
    "    var result [][]interface{}\n    var recurse func([]interface{}, int)\n    recurse = func(a []interface{}, k int) {\n        if k == 0 {\n            result = append(result, a)\n            return\n        }\n        for _, e := range l {\n            b := make([]interface{}, len(a))\n            copy(b, a)\n            b = append(b, e)\n            recurse(b, k-1)\n        }\n    }\n    recurse([]interface{}{}, n)\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n    } else {\n        for i, v := range l {\n            for _, v2 := range combinations_colors(l[i:], n-1) {\n                result = append(result, append([]interface{}{v}, v2...))\n            }\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_result [][]interface{}\n        sub_result = combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            sub_result[j] = append(sub_result[j], l[i])\n            result = append(result, sub_result[j])\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    if len(l) < n {\n        return [][]interface{}{}\n    }\n    if len(l) == n {\n        return [][]interface{}{[]interface{}{l}}\n    }\n    if n == 1 {\n        var result [][]interface{}\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    var result [][]interface{}\n    for i, v := range l {\n        for _, r := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{v}, r...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 0 {\n        return result\n    }\n    for _, v := range l {\n        if n == 1 {\n            result = append(result, []interface{}{v})\n        } else {\n            for _, v2 := range combinations_colors(l, n-1) {\n                result = append(result, append([]interface{}{v}, v2...))\n            }\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, sub_combination := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, sub_combination...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    for _, v := range l {\n        for _, v2 := range combinations_colors(l, n-1) {\n            result = append(result, append([]interface{}{v}, v2...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    if len(l) == 1 {\n        return [][]interface{}{{l[0]}}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_result [][]interface{}\n        sub_result = combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            sub_result[j] = append(sub_result[j], l[i])\n        }\n        result = append(result, sub_result...)\n    }\n    return result\n}\n",
    "    if n == 1 {\n        var res [][]interface{}\n        for _, v := range l {\n            res = append(res, []interface{}{v})\n        }\n        return res\n    }\n    var res [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i:], n - 1) {\n            res = append(res, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return res\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    if len(l) == 1 {\n        return [][]interface{}{[]interface{}{l[0]}}\n    }\n    if len(l) == 2 {\n        return [][]interface{}{[]interface{}{l[0]}, []interface{}{l[1]}, []interface{}{l[0], l[1]}}\n    }\n    if len(l) == 3 {\n        return [][]interface{}{[]interface{}{l[0]}, []interface{}{l[1]}, []interface{}{l[2]}, []interface{}{l[0], l[1]}, []interface{}{l[0], l[2]}, []interface{}{l[1], l[2]}, []interface{}{l[0], l[1], l[2]}}\n    }\n    if len(l) == 4 {\n        return [][]interface{}{[]interface{}{l[0]}, []interface{}{l[1]}, []interface{}{l[2]}, []interface{}{l[3]}, []interface{}{l[0], l[1]}, []interface{}{l[0], l[2]}, []interface{}{l[0], l[3]}, []interface{}{l[1], l[2]}, []interface{}{l[1], l[3]}, []interface{}{l[2], l[3]}, []interface{}{l[0], l[1], l[2]}, []interface{}{l[0], l[1], l[3]}, []interface{}{l[0], l[2], l[3]}, []interface{}{l[1], l[2], l[3]}, []interface{}{l[0], l[1], l[2], l[3]}}\n    }\n    if len(l) == 5 {\n        return [][]interface{}{[]interface{}{l[0]}, []interface{}{l[1]}, []interface{}{l[2]}, []interface{}{l",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        sub_result := combinations_colors(l[i+1:], n-1)\n        for _, sub_list := range sub_result {\n            result = append(result, append([]interface{}{l[i]}, sub_list...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    for i := 0; i < len(l); i++ {\n        for _, c := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, c...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var combination []interface{}\n    var helper func(int, int)\n    helper = func(start, depth int) {\n        if depth == n {\n            result = append(result, append([]interface{}{}, combination...))\n            return\n        }\n        for i := start; i < len(l); i++ {\n            combination = append(combination, l[i])\n            helper(i, depth+1)\n            combination = combination[:len(combination)-1]\n        }\n    }\n    helper(0, 0)\n    return result\n}\n",
    "    var result [][]interface{}\n    var combination []interface{}\n    var recurse func(int)\n    recurse = func(i int) {\n        if len(combination) == n {\n            result = append(result, combination)\n            return\n        }\n        for j := i; j < len(l); j++ {\n            combination = append(combination, l[j])\n            recurse(j)\n            combination = combination[:len(combination)-1]\n        }\n    }\n    recurse(0)\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, c := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, c...))\n        }\n    }\n    return result\n}\n",
    "    if n == 1 {\n        var ret [][]interface{}\n        for _, v := range l {\n            ret = append(ret, []interface{}{v})\n        }\n        return ret\n    }\n    var ret [][]interface{}\n    for i, v := range l {\n        for _, vv := range combinations_colors(l[i:], n-1) {\n            ret = append(ret, append([]interface{}{v}, vv...))\n        }\n    }\n    return ret\n}\n",
    "    var result [][]interface{}\n    var combination []interface{}\n    var helper func(int, int)\n    helper = func(start int, n int) {\n        if n == 0 {\n            result = append(result, combination)\n            return\n        }\n        for i := start; i < len(l); i++ {\n            combination = append(combination, l[i])\n            helper(i, n - 1)\n            combination = combination[:len(combination) - 1]\n        }\n    }\n    helper(0, n)\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n\n    var result [][]interface{}\n\n    for i := 0; i < len(l); i++ {\n        for _, c := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, c...))\n        }\n    }\n\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    result := [][]interface{}{}\n    for i := 0; i < len(l); i++ {\n        for _, c := range combinations_colors(l, n - 1) {\n            result = append(result, append([]interface{}{l[i]}, c...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var comb []interface{}\n    var helper func(int)\n    helper = func(i int) {\n        if i == n {\n            result = append(result, comb)\n            return\n        }\n        for _, v := range l {\n            comb = append(comb, v)\n            helper(i+1)\n            comb = comb[:len(comb)-1]\n        }\n    }\n    helper(0)\n    return result\n}\n",
    "    if n == 1 {\n        var ret [][]interface{}\n        for _, v := range l {\n            ret = append(ret, []interface{}{v})\n        }\n        return ret\n    }\n    var ret [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_list []string\n        for j := i; j < len(l); j++ {\n            sub_list = append(sub_list, l[j])\n        }\n        sub_ret := combinations_colors(sub_list, n - 1)\n        for _, v := range sub_ret {\n            ret = append(ret, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return ret\n}\n",
    "    if n == 1 {\n        var ret [][]interface{}\n        for _, v := range l {\n            ret = append(ret, []interface{}{v})\n        }\n        return ret\n    }\n    var ret [][]interface{}\n    for i, v := range l {\n        for _, vv := range combinations_colors(l[i:], n-1) {\n            ret = append(ret, append([]interface{}{v}, vv...))\n        }\n    }\n    return ret\n}\n",
    "    var result [][]interface{}\n    if n == 0 {\n        return result\n    }\n    if len(l) == 0 {\n        return result\n    }\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    for i, v := range l {\n        for _, c := range combinations_colors(l[i:], n - 1) {\n            result = append(result, append([]interface{}{v}, c...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    if len(l) == 1 {\n        return [][]interface{}{{l[0]}}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var combination []interface{}\n    var helper func(int)\n    helper = func(i int) {\n        if i == n {\n            result = append(result, combination)\n            return\n        }\n        for _, v := range l {\n            combination = append(combination, v)\n            helper(i+1)\n            combination = combination[:len(combination)-1]\n        }\n    }\n    helper(0)\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, sub := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, sub...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    return append(combinations_colors(l[1:], n), combinations_colors(l[1:], n-1)...)\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    result := [][]interface{}{}\n    for _, v := range l {\n        for _, c := range combinations_colors(l, n-1) {\n            result = append(result, append([]interface{}{v}, c...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_result [][]interface{}\n        sub_result = combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            sub_result[j] = append([]interface{}{l[i]}, sub_result[j]...)\n        }\n        result = append(result, sub_result...)\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    for _, v := range l {\n        for _, v2 := range combinations_colors(l, n-1) {\n            result = append(result, append([]interface{}{v}, v2...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    if len(l) == 1 {\n        return [][]interface{}{[]interface{}{l[0]}}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_result [][]interface{}\n        sub_result = combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            result = append(result, append([]interface{}{l[i]}, sub_result[j]...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    for i := 0; i < len(l); i++ {\n        for _, c := range combinations_colors(l, n - 1) {\n            result = append(result, append([]interface{}{l[i]}, c...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var combination []interface{}\n    var recurse func(int, int)\n    recurse = func(start int, depth int) {\n        if depth == 0 {\n            result = append(result, combination)\n            return\n        }\n        for i := start; i <= len(l) - depth; i++ {\n            combination = append(combination, l[i])\n            recurse(i, depth - 1)\n            combination = combination[:len(combination) - 1]\n        }\n    }\n    recurse(0, n)\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    for i, v := range l {\n        for _, w := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{v}, w...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        sub_result := combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            result = append(result, append([]interface{}{l[i]}, sub_result[j]...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, c := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, c...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var helper func(int, int)\n    helper = func(start int, n int) {\n        if n == 0 {\n            result = append(result, temp)\n            return\n        }\n        for i := start; i <= len(l)-n; i++ {\n            temp = append(temp, l[i])\n            helper(i, n-1)\n            temp = temp[:len(temp)-1]\n        }\n    }\n    helper(0, n)\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        sub_result := combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            result = append(result, append([]interface{}{l[i]}, sub_result[j]...))\n        }\n    }\n\n    return result\n}\n",
    "    var result [][]interface{}\n    var helper func(int, []interface{})\n    helper = func(offset int, cur []interface{}) {\n        if len(cur) == n {\n            result = append(result, cur)\n            return\n        }\n        for i := offset; i < len(l); i++ {\n            helper(i, append(cur, l[i]))\n        }\n    }\n    helper(0, []interface{}{})\n    return result\n}\n",
    "    var result [][]interface{}\n    var current []interface{}\n    var helper func(int)\n    helper = func(i int) {\n        if i == n {\n            result = append(result, append([]interface{}(nil), current...))\n            return\n        }\n        for _, v := range l {\n            current = append(current, v)\n            helper(i+1)\n            current = current[:len(current)-1]\n        }\n    }\n    helper(0)\n    return result\n}\n",
    "    var result [][]interface{}\n    var combination []interface{}\n    var helper func(int)\n    helper = func(i int) {\n        if i == n {\n            result = append(result, combination)\n            return\n        }\n        for _, v := range l {\n            combination = append(combination, v)\n            helper(i + 1)\n            combination = combination[:len(combination) - 1]\n        }\n    }\n    helper(0)\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    return append(combinations_colors(l[1:], n), append(combinations_colors(l[1:], n-1), l[0])...)\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    if len(l) < n {\n        return [][]interface{}{}\n    }\n    if len(l) == n {\n        return [][]interface{}{[]interface{}{l}}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_result [][]interface{}\n        sub_result = combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            sub_result[j] = append([]interface{}{l[i]}, sub_result[j]...)\n            result = append(result, sub_result[j])\n        }\n    }\n    return result\n}\n",
    "    if n == 1 {\n        var r [][]interface{}\n        for _, v := range l {\n            r = append(r, []interface{}{v})\n        }\n        return r\n    }\n    var r [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i:], n - 1) {\n            r = append(r, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return r\n}\n",
    "    var result [][]interface{}\n    var combination []interface{}\n    var helper func(int, int)\n    helper = func(start int, k int) {\n        if k == 0 {\n            result = append(result, append([]interface{}{}, combination...))\n            return\n        }\n        for i := start; i <= len(l)-k; i++ {\n            combination = append(combination, l[i])\n            helper(i, k-1)\n            combination = combination[:len(combination)-1]\n        }\n    }\n    helper(0, n)\n    return result\n}\n",
    "    var result [][]interface{}\n    var helper func([]interface{}, int)\n    helper = func(arr []interface{}, n int) {\n        if n == 0 {\n            result = append(result, arr)\n            return\n        }\n        for i := 0; i < len(l); i++ {\n            helper(append(arr, l[i]), n - 1)\n        }\n    }\n    helper([]interface{}{}, n)\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    if len(l) == 1 {\n        return [][]interface{}{[]interface{}{l[0]}}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_result [][]interface{}\n        sub_result = combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            sub_result[j] = append([]interface{}{l[i]}, sub_result[j]...)\n        }\n        result = append(result, sub_result...)\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var combination []interface{}\n    var helper func([]string, int, int)\n    helper = func(l []string, n int, i int) {\n        if n == 0 {\n            result = append(result, combination)\n            return\n        }\n        for j := i; j < len(l); j++ {\n            combination = append(combination, l[j])\n            helper(l, n - 1, j)\n            combination = combination[:len(combination) - 1]\n        }\n    }\n    helper(l, n, 0)\n    return result\n}\n",
    "    var result [][]interface{}\n    var combination []interface{}\n    var combinations func(l []string, n int, combination []interface{})\n    combinations = func(l []string, n int, combination []interface{}) {\n        if n == 0 {\n            result = append(result, combination)\n            return\n        }\n        for _, v := range l {\n            combinations(l, n-1, append(combination, v))\n        }\n    }\n    combinations(l, n, combination)\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i:], n - 1) {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, c := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, c...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    result := [][]interface{}{}\n    for i := 0; i < len(l); i++ {\n        for _, c := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, c...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    for i, v := range l {\n        for _, v2 := range combinations_colors(l[i:], n - 1) {\n            result = append(result, append([]interface{}{v}, v2...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_result [][]interface{}\n        sub_result = combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            sub_result[j] = append([]interface{}{l[i]}, sub_result[j]...)\n            result = append(result, sub_result[j])\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var combination []interface{}\n    var helper func(int, int)\n    helper = func(start int, depth int) {\n        if depth == n {\n            result = append(result, append([]interface{}{}, combination...))\n            return\n        }\n        for i := start; i < len(l); i++ {\n            combination = append(combination, l[i])\n            helper(i, depth + 1)\n            combination = combination[:len(combination) - 1]\n        }\n    }\n    helper(0, 0)\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_result [][]interface{}\n        sub_result = combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            sub_result[j] = append([]interface{}{l[i]}, sub_result[j]...)\n            result = append(result, sub_result[j])\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_result [][]interface{}\n        sub_result = combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            sub_result[j] = append([]interface{}{l[i]}, sub_result[j]...)\n            result = append(result, sub_result[j])\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    for i := 0; i < len(l); i++ {\n        for _, c := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, c...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var helper func(int, []interface{})\n    helper = func(offset int, curr []interface{}) {\n        if len(curr) == n {\n            result = append(result, append([]interface{}{}, curr...))\n            return\n        }\n        for i := offset; i < len(l); i++ {\n            curr = append(curr, l[i])\n            helper(i, curr)\n            curr = curr[:len(curr)-1]\n        }\n    }\n    helper(0, []interface{}{})\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    for i := 0; i < len(l); i++ {\n        for _, c := range combinations_colors(l, n-1) {\n            result = append(result, append([]interface{}{l[i]}, c...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    return append(combinations_colors(l[1:], n), append(combinations_colors(l[1:], n-1), l[0])...)\n}\n",
    "    var result [][]interface{}\n    var combination []interface{}\n    var helper func(int, int)\n    helper = func(start int, k int) {\n        if k == 0 {\n            result = append(result, combination)\n            return\n        }\n        for i := start; i <= len(l) - k; i++ {\n            combination = append(combination, l[i])\n            helper(i, k - 1)\n            combination = combination[:len(combination) - 1]\n        }\n    }\n    helper(0, n)\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var res [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_res [][]interface{}\n        sub_res = combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_res); j++ {\n            sub_res[j] = append([]interface{}{l[i]}, sub_res[j]...)\n            res = append(res, sub_res[j])\n        }\n    }\n    return res\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i:], n - 1) {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i, v := range l {\n        for _, r := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{v}, r...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var combination []interface{}\n    var helper func(int, int)\n    helper = func(start int, n int) {\n        if n == 0 {\n            result = append(result, combination)\n            return\n        }\n        for i := start; i < len(l); i++ {\n            combination = append(combination, l[i])\n            helper(i, n - 1)\n            combination = combination[:len(combination) - 1]\n        }\n    }\n    helper(0, n)\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_result [][]interface{}\n        sub_result = combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            sub_result[j] = append(sub_result[j], l[i])\n            result = append(result, sub_result[j])\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var combination []interface{}\n    var helper func(int, int)\n    helper = func(start int, n int) {\n        if n == 0 {\n            result = append(result, combination)\n            return\n        }\n        for i := start; i < len(l); i++ {\n            combination = append(combination, l[i])\n            helper(i, n - 1)\n            combination = combination[:len(combination) - 1]\n        }\n    }\n    helper(0, n)\n    return result\n}\n",
    "    var result [][]interface{}\n    var combination []interface{}\n    var helper func([]string, int, int)\n    helper = func(l []string, n int, i int) {\n        if n == 0 {\n            result = append(result, combination)\n            return\n        }\n        for j := i; j < len(l); j++ {\n            combination = append(combination, l[j])\n            helper(l, n - 1, j)\n            combination = combination[:len(combination) - 1]\n        }\n    }\n    helper(l, n, 0)\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_result [][]interface{}\n        sub_result = combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            sub_result[j] = append([]interface{}{l[i]}, sub_result[j]...)\n            result = append(result, sub_result[j])\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        sub_result := combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            result = append(result, append([]interface{}{l[i]}, sub_result[j]...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    for i, v := range l {\n        for _, w := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{v}, w...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    for i := 0; i < len(l); i++ {\n        for _, c := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, c...))\n        }\n    }\n    return result\n}\n",
    "    if n == 1 {\n        var r [][]interface{}\n        for _, e := range l {\n            r = append(r, []interface{}{e})\n        }\n        return r\n    }\n    var r [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, e := range combinations_colors(l[i:], n-1) {\n            r = append(r, append([]interface{}{l[i]}, e...))\n        }\n    }\n    return r\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_result [][]interface{}\n        sub_result = combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            sub_result[j] = append([]interface{}{l[i]}, sub_result[j]...)\n            result = append(result, sub_result[j])\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        sub_result := combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            result = append(result, append([]interface{}{l[i]}, sub_result[j]...))\n        }\n    }\n\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    for i, v := range l {\n        for _, v2 := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{v}, v2...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_result [][]interface{}\n        sub_result = combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            sub_result[j] = append([]interface{}{l[i]}, sub_result[j]...)\n            result = append(result, sub_result[j])\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var helper func([]interface{}, int)\n    helper = func(arr []interface{}, n int) {\n        if n == 0 {\n            result = append(result, arr)\n            return\n        } else {\n            for i := 0; i < len(l); i++ {\n                helper(append(arr, l[i]), n - 1)\n            }\n        }\n    }\n    helper([]interface{}{}, n)\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_result [][]interface{}\n        sub_result = combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            sub_result[j] = append(sub_result[j], l[i])\n        }\n        result = append(result, sub_result...)\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_result [][]interface{}\n        sub_result = combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            result = append(result, append([]interface{}{l[i]}, sub_result[j]...))\n        }\n    }\n    return result\n}\n",
    "    if n == 1 {\n        var combinations [][]interface{}\n        for _, v := range l {\n            combinations = append(combinations, []interface{}{v})\n        }\n        return combinations\n    }\n    var combinations [][]interface{}\n    for i, v := range l {\n        for _, c := range combinations_colors(l[i:], n-1) {\n            combinations = append(combinations, append([]interface{}{v}, c...))\n        }\n    }\n    return combinations\n}\n",
    "    var result [][]interface{}\n    var combination []interface{}\n    var helper func(int, int)\n    helper = func(start, end int) {\n        if len(combination) == n {\n            result = append(result, append([]interface{}{}, combination...))\n            return\n        }\n        for i := start; i < end; i++ {\n            combination = append(combination, l[i])\n            helper(i, end)\n            combination = combination[:len(combination)-1]\n        }\n    }\n    helper(0, len(l))\n    return result\n}\n",
    "    var result [][]interface{}\n    var combination []interface{}\n    var helper func(int)\n    helper = func(i int) {\n        if i == n {\n            result = append(result, append([]interface{}{}, combination...))\n            return\n        }\n        for _, v := range l {\n            combination = append(combination, v)\n            helper(i+1)\n            combination = combination[:len(combination)-1]\n        }\n    }\n    helper(0)\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{}\n    }\n\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n\n    if n == 1 {\n        var result [][]interface{}\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n\n    var result [][]interface{}\n    for i, v := range l {\n        for _, v2 := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{v}, v2...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_result [][]interface{}\n        sub_result = combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            sub_result[j] = append([]interface{}{l[i]}, sub_result[j]...)\n            result = append(result, sub_result[j])\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    if len(l) < n {\n        return [][]interface{}{}\n    }\n    if len(l) == n {\n        return [][]interface{}{l}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_result [][]interface{}\n        sub_result = combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            sub_result[j] = append(sub_result[j], l[i])\n            result = append(result, sub_result[j])\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, e := range l {\n            result = append(result, []interface{}{e})\n        }\n        return result\n    }\n    for i, e := range l {\n        for _, c := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{e}, c...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, r := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, r...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var combination []interface{}\n    var helper func(int, int)\n    helper = func(start int, n int) {\n        if n == 0 {\n            result = append(result, combination)\n            return\n        }\n        for i := start; i < len(l); i++ {\n            combination = append(combination, l[i])\n            helper(i, n-1)\n            combination = combination[:len(combination)-1]\n        }\n    }\n    helper(0, n)\n    return result\n}\n",
    "    var res [][]interface{}\n    var current []interface{}\n    var recurse func(int)\n    recurse = func(i int) {\n        if len(current) == n {\n            res = append(res, append([]interface{}{}, current...))\n            return\n        }\n        for ; i < len(l); i++ {\n            current = append(current, l[i])\n            recurse(i)\n            current = current[:len(current)-1]\n        }\n    }\n    recurse(0)\n    return res\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    if len(l) == 1 {\n        return [][]interface{}{[]interface{}{l[0]}}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var recurse func(int, []interface{})\n    recurse = func(i int, current []interface{}) {\n        if i == n {\n            result = append(result, current)\n            return\n        }\n        for _, v := range l {\n            recurse(i + 1, append(current, v))\n        }\n    }\n    recurse(0, []interface{}{})\n    return result\n}\n",
    "    var result [][]interface{}\n    var tmp []interface{}\n    var recurse func(int, int)\n    recurse = func(start, depth int) {\n        if depth == 0 {\n            result = append(result, tmp)\n            return\n        }\n        for i := start; i < len(l); i++ {\n            tmp = append(tmp, l[i])\n            recurse(i, depth - 1)\n            tmp = tmp[:len(tmp) - 1]\n        }\n    }\n    recurse(0, n)\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_result [][]interface{}\n        sub_result = combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            sub_result[j] = append(sub_result[j], l[i])\n        }\n        result = append(result, sub_result...)\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_result [][]interface{}\n        sub_result = combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            sub_result[j] = append([]interface{}{l[i]}, sub_result[j]...)\n            result = append(result, sub_result[j])\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    if len(l) == 1 {\n        return [][]interface{}{{l[0]}}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_result [][]interface{}\n        sub_result = combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            sub_result[j] = append([]interface{}{l[i]}, sub_result[j]...)\n        }\n        result = append(result, sub_result...)\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var helper func([]interface{}, int)\n    helper = func(arr []interface{}, n int) {\n        if n == 0 {\n            result = append(result, arr)\n            return\n        }\n        for i := 0; i < len(l); i++ {\n            helper(append(arr, l[i]), n-1)\n        }\n    }\n    helper([]interface{}{}, n)\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    x := l[0]\n    xs := l[1:]\n    combs := combinations_colors(xs, n)\n    new_combs := [][]interface{}{}\n    for _, comb := range combs {\n        for i := 0; i <= len(comb); i++ {\n            new_comb := make([]interface{}, len(comb) + 1)\n            copy(new_comb, comb[:i])\n            new_comb[i] = x\n            copy(new_comb[i+1:], comb[i:])\n            new_combs = append(new_combs, new_comb)\n        }\n    }\n    return append(combs, new_combs...)\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_result [][]interface{}\n        sub_result = combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            sub_result[j] = append(sub_result[j], l[i])\n            result = append(result, sub_result[j])\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    for i := 0; i < len(l); i++ {\n        for _, r := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, r...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    for _, e := range l {\n        for _, c := range combinations_colors(l, n-1) {\n            result = append(result, append([]interface{}{e}, c...))\n        }\n    }\n    return result\n}\n",
    "    var combinations [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for j := 0; j < len(l); j++ {\n            for k := 0; k < len(l); k++ {\n                combinations = append(combinations, []interface{}{l[i], l[j], l[k]})\n            }\n        }\n    }\n    return combinations\n}\n",
    "    var result [][]interface{}\n    var helper func([]interface{}, int)\n    helper = func(arr []interface{}, n int) {\n        if n == 0 {\n            result = append(result, arr)\n            return\n        } else {\n            for i := 0; i < len(l); i++ {\n                helper(append(arr, l[i]), n-1)\n            }\n        }\n    }\n    helper([]interface{}{}, n)\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var helper func([]interface{}, int)\n    helper = func(arr []interface{}, n int) {\n        if n == 0 {\n            result = append(result, arr)\n            return\n        }\n        for _, v := range l {\n            helper(append(arr, v), n-1)\n        }\n    }\n    helper([]interface{}{}, n)\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    if len(l) == 1 {\n        return [][]interface{}{{l[0]}}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, c := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, c...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var helper func([]interface{}, int)\n    helper = func(arr []interface{}, n int) {\n        if n == 0 {\n            result = append(result, arr)\n            return\n        }\n        for _, e := range l {\n            helper(append(arr, e), n-1)\n        }\n    }\n    helper([]interface{}{}, n)\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i, v := range l {\n        for _, c := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{v}, c...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    for i, v := range l {\n        for _, v2 := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{v}, v2...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_result [][]interface{}\n        sub_result = combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            sub_result[j] = append([]interface{}{l[i]}, sub_result[j]...)\n        }\n        result = append(result, sub_result...)\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var combination []interface{}\n    var helper func(int, int)\n    helper = func(start int, n int) {\n        if n == 0 {\n            result = append(result, combination)\n            return\n        }\n        for i := start; i <= len(l) - n; i++ {\n            combination = append(combination, l[i])\n            helper(i, n - 1)\n            combination = combination[:len(combination) - 1]\n        }\n    }\n    helper(0, n)\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        sub_result := combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            result = append(result, append([]interface{}{l[i]}, sub_result[j]...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_result [][]interface{}\n        sub_result = combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            sub_result[j] = append([]interface{}{l[i]}, sub_result[j]...)\n            result = append(result, sub_result[j])\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var inner []interface{}\n    var helper func(int, int)\n    helper = func(start, depth int) {\n        if depth == 0 {\n            result = append(result, inner)\n            return\n        }\n        for i := start; i < len(l); i++ {\n            inner = append(inner, l[i])\n            helper(i, depth - 1)\n            inner = inner[:len(inner) - 1]\n        }\n    }\n    helper(0, n)\n    return result\n}\n",
    "    var result [][]interface{}\n\n    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n\n    for i := 0; i < len(l); i++ {\n        for _, c := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, c...))\n        }\n    }\n\n    return result\n}\n",
    "    var result [][]interface{}\n    var combination []interface{}\n    var helper func(int, int)\n    helper = func(start, depth int) {\n        if depth == n {\n            result = append(result, append([]interface{}{}, combination...))\n            return\n        }\n        for i := start; i < len(l); i++ {\n            combination = append(combination, l[i])\n            helper(i, depth + 1)\n            combination = combination[:len(combination) - 1]\n        }\n    }\n    helper(0, 0)\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var combination []interface{}\n    var helper func(int, int)\n    helper = func(offset, k int) {\n        if k == 0 {\n            result = append(result, append([]interface{}(nil), combination...))\n            return\n        }\n        for i := offset; i <= len(l) - k; i++ {\n            combination = append(combination, l[i])\n            helper(i, k - 1)\n            combination = combination[:len(combination) - 1]\n        }\n    }\n    helper(0, n)\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i:], n - 1) {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, sub := range combinations_colors(l, n-1) {\n            result = append(result, append([]interface{}{l[i]}, sub...))\n        }\n    }\n    return result\n}\n",
    "    if n == 1 {\n        var r [][]interface{}\n        for _, v := range l {\n            r = append(r, []interface{}{v})\n        }\n        return r\n    }\n    var r [][]interface{}\n    for i, v := range l {\n        for _, w := range combinations_colors(l[i:], n-1) {\n            r = append(r, append([]interface{}{v}, w...))\n        }\n    }\n    return r\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i:], n - 1) {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_result [][]interface{}\n        sub_result = combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            sub_result[j] = append([]interface{}{l[i]}, sub_result[j]...)\n        }\n        result = append(result, sub_result...)\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    if len(l) < n {\n        return [][]interface{}{}\n    }\n    if len(l) == n {\n        return [][]interface{}{[]interface{}{l}}\n    }\n    if n == 1 {\n        var r [][]interface{}\n        for _, v := range l {\n            r = append(r, []interface{}{v})\n        }\n        return r\n    }\n    var r [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i+1:], n-1) {\n            r = append(r, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return r\n}\n",
    "    var result [][]interface{}\n    var recurse func(l []string, n int, i int, c []interface{})\n    recurse = func(l []string, n int, i int, c []interface{}) {\n        if n == 0 {\n            result = append(result, c)\n            return\n        }\n        for j := i; j < len(l); j++ {\n            c = append(c, l[j])\n            recurse(l, n-1, j, c)\n            c = c[:len(c)-1]\n        }\n    }\n    recurse(l, n, 0, []interface{}{})\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_result [][]interface{}\n        sub_result = combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            sub_result[j] = append([]interface{}{l[i]}, sub_result[j]...)\n            result = append(result, sub_result[j])\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i <= len(l)-n; i++ {\n        for _, v := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    var combinations [][]interface{}\n    var combination []interface{}\n    var i int\n    var j int\n    for i = 0; i < n; i++ {\n        combination = append(combination, l[i])\n    }\n    combinations = append(combinations, combination)\n    for i = n; i < len(l); i++ {\n        combination = []interface{}{}\n        for j = i; j < i + n; j++ {\n            combination = append(combination, l[j])\n        }\n        combinations = append(combinations, combination)\n    }\n    return combinations\n}\n",
    "    var result [][]interface{}\n    var current []interface{}\n    var helper func(int)\n    helper = func(start int) {\n        if len(current) == n {\n            result = append(result, append([]interface{}{}, current...))\n            return\n        }\n        for i := start; i < len(l); i++ {\n            current = append(current, l[i])\n            helper(i)\n            current = current[:len(current)-1]\n        }\n    }\n    helper(0)\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_result [][]interface{}\n        sub_result = combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            sub_result[j] = append(sub_result[j], l[i])\n            result = append(result, sub_result[j])\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    if n == 1 {\n        var result [][]interface{}\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i, e := range l {\n        for _, c := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{e}, c...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, c := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, c...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    return append(combinations_colors(l[1:], n),\n        append(combinations_colors(l[1:], n-1), l[0])...)\n}\n",
    "    if n == 0 {\n        return [][]interface{}{}\n    }\n    if n == 1 {\n        var result [][]interface{}\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    var result [][]interface{}\n    for i, v := range l {\n        for _, w := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{v}, w...))\n        }\n    }\n    return result\n}\n",
    "    if n == 1 {\n        var res [][]interface{}\n        for _, v := range l {\n            res = append(res, []interface{}{v})\n        }\n        return res\n    }\n    var res [][]interface{}\n    for _, v := range l {\n        for _, v2 := range combinations_colors(l, n-1) {\n            res = append(res, append([]interface{}{v}, v2...))\n        }\n    }\n    return res\n}\n",
    "    var result [][]interface{}\n    var helper func([]interface{}, int)\n    helper = func(arr []interface{}, n int) {\n        if n == 0 {\n            result = append(result, arr)\n            return\n        }\n        for i := 0; i < len(l); i++ {\n            helper(append(arr, l[i]), n - 1)\n        }\n    }\n    helper([]interface{}{}, n)\n    return result\n}\n",
    "    var result [][]interface{}\n    var combination []interface{}\n    var helper func(int, int)\n    helper = func(start int, k int) {\n        if k == 0 {\n            result = append(result, combination)\n            return\n        }\n        for i := start; i <= len(l) - k; i++ {\n            combination = append(combination, l[i])\n            helper(i, k - 1)\n            combination = combination[:len(combination) - 1]\n        }\n    }\n    helper(0, n)\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_result [][]interface{}\n        sub_result = combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            sub_result[j] = append(sub_result[j], l[i])\n            result = append(result, sub_result[j])\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    for i, v := range l {\n        for _, v2 := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{v}, v2...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    if len(l) == 1 {\n        return [][]interface{}{[]interface{}{l[0]}}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_result [][]interface{}\n        sub_result = combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            sub_result[j] = append([]interface{}{l[i]}, sub_result[j]...)\n            result = append(result, sub_result[j])\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    for i, v := range l {\n        for _, v2 := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{v}, v2...))\n        }\n    }\n    return result\n}\n",
    "    var res [][]interface{}\n    if n == 0 {\n        res = append(res, []interface{}{})\n        return res\n    }\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i+1:], n-1) {\n            res = append(res, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return res\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    if len(l) < n {\n        return [][]interface{}{}\n    }\n    if len(l) == n {\n        return [][]interface{}{{l}}\n    }\n    if n == 1 {\n        var r [][]interface{}\n        for _, v := range l {\n            r = append(r, []interface{}{v})\n        }\n        return r\n    }\n    var r [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i+1:], n-1) {\n            r = append(r, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return r\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    result := [][]interface{}{}\n    for _, v := range l {\n        for _, c := range combinations_colors(l, n-1) {\n            result = append(result, append([]interface{}{v}, c...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i, v := range l {\n        for _, c := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{v}, c...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, c := range combinations_colors(l, n-1) {\n            result = append(result, append([]interface{}{l[i]}, c...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var combination []interface{}\n    var helper func(int)\n    helper = func(i int) {\n        if i == n {\n            result = append(result, combination)\n            return\n        }\n        for _, v := range l {\n            combination = append(combination, v)\n            helper(i+1)\n            combination = combination[:len(combination)-1]\n        }\n    }\n    helper(0)\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    if len(l) < n {\n        return [][]interface{}{}\n    }\n    if len(l) == n {\n        return [][]interface{}{[]interface{}{l}}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_result [][]interface{}\n        sub_result = combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            sub_result[j] = append(sub_result[j], l[i])\n            result = append(result, sub_result[j])\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_result [][]interface{}\n        sub_result = combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            sub_result[j] = append(sub_result[j], l[i])\n        }\n        result = append(result, sub_result...)\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_result [][]interface{}\n        sub_result = combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            sub_result[j] = append([]interface{}{l[i]}, sub_result[j]...)\n            result = append(result, sub_result[j])\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    sub_combos := combinations_colors(l[1:], n - 1)\n    for i := 0; i < len(sub_combos); i++ {\n        sub_combos[i] = append(sub_combos[i], l[0])\n    }\n    return append(sub_combos, combinations_colors(l[1:], n)...)\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    var res [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, c := range combinations_colors(l[i+1:], n-1) {\n            res = append(res, append([]interface{}{l[i]}, c...))\n        }\n    }\n    return res\n}\n",
    "    var result [][]interface{}\n    var combination []interface{}\n    var helper func(int, int)\n    helper = func(start, depth int) {\n        if depth == n {\n            result = append(result, append([]interface{}{}, combination...))\n            return\n        }\n        for i := start; i < len(l); i++ {\n            combination = append(combination, l[i])\n            helper(i, depth + 1)\n            combination = combination[:len(combination) - 1]\n        }\n    }\n    helper(0, 0)\n    return result\n}\n"
  ]
}