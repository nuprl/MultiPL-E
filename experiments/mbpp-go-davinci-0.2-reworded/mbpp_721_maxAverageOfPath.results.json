{
  "name": "mbpp_721_maxAverageOfPath",
  "language": "go_test.go",
  "prompt": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_721_maxAverageOfPath.py",
  "prompt_terminology": "reworded",
  "tests": "func TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_73d6c83_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n    dp := make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i - 1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j - 1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost) - 1][len(cost[0]) - 1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph8oaxgag_test.go:29:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_73d6c83_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    dp := make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkr5c71_h_test.go:34:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[0][0] = cost[0][0]\n    // dp[i][0] = dp[i-1][0] + cost[i][0]\n    // dp[0][j] = dp[0][j-1] + cost[0][j]\n    // dp[n-1][n-1] = max(dp[n-2][n-1], dp[n-1][n-2]) + cost[n-1][n-1]\n    // return dp[n-1][n-1] / (n + n - 1)\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2 * n - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphs359ds3_test.go:28:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var sum int\n    var count int\n    var max float64\n    var dfs func(int, int)\n    dfs = func(i, j int) {\n        if i == len(cost) - 1 && j == len(cost[0]) - 1 {\n            avg := float64(sum) / float64(count)\n            if avg > max {\n                max = avg\n            }\n            return\n        }\n        if i < len(cost) - 1 {\n            sum += cost[i + 1][j]\n            count++\n            dfs(i + 1, j)\n            sum -= cost[i + 1][j]\n            count--\n        }\n        if j < len(cost[0]) - 1 {\n            sum += cost[i][j + 1]\n            count++\n            dfs(i, j + 1)\n            sum -= cost[i][j + 1]\n            count--\n        }\n    }\n    sum = cost[0][0]\n    count = 1\n    dfs(0, 0)\n    return max\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "ok  \tcommand-line-arguments\t0.005s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n\n    var dp [][]float64\n    for i := 0; i < len(cost); i++ {\n        dp = append(dp, make([]float64, len(cost[0])))\n    }\n\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < len(cost[0]); i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnn1ys2i1_test.go:35:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_73d6c83_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := range dp {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzh2a7sfz_test.go:22:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // dp[i][j] means the max average of path from (0,0) to (i,j)\n    dp := make([][]float64, len(cost))\n    for i := range dp {\n        dp[i] = make([]float64, len(cost[i]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[i]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphwrc2q7w_test.go:24:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n    n := len(cost)\n    m := len(cost[0])\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, m)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < m; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < m; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][m-1] / float64(n+m-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkfxbgkis_test.go:31:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var dp [][]float64\n    for i := 0; i < len(cost); i++ {\n        dp = append(dp, make([]float64, len(cost[0])))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < len(cost[0]); i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmppk8dwttc_test.go:35:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2 * n - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpv7xqlx2m_test.go:28:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    row, col := len(cost), len(cost[0])\n    dp := make([][]float64, row)\n    for i := 0; i < row; i++ {\n        dp[i] = make([]float64, col)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < row; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < col; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < row; i++ {\n        for j := 1; j < col; j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[row-1][col-1] / float64(row + col - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnrhbi82b_test.go:27:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n    n := len(cost)\n    m := len(cost[0])\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, m)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < m; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < m; j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[n-1][m-1] / float64(n + m - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1gf58sgp_test.go:31:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var maxAvg float64\n    var maxAvgPath func(int, int, int, float64)\n    maxAvgPath = func(i, j, n int, avg float64) {\n        if i == n - 1 && j == n - 1 {\n            if avg > maxAvg {\n                maxAvg = avg\n            }\n            return\n        }\n        if i < n - 1 {\n            maxAvgPath(i + 1, j, n, avg + float64(cost[i + 1][j]) / float64(n))\n        }\n        if j < n - 1 {\n            maxAvgPath(i, j + 1, n, avg + float64(cost[i][j + 1]) / float64(n))\n        }\n    }\n    maxAvgPath(0, 0, len(cost), float64(cost[0][0]) / float64(len(cost)))\n    return maxAvg\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "--- FAIL: TestMaxaverageofpath (0.00s)\n    --- FAIL: TestMaxaverageofpath/test_num__0 (0.00s)\n        tmp32fh9m8i_test.go:55: expected '%!s(float64=5.2)', got '%!s(float64=8.666666666666668)'\n    --- FAIL: TestMaxaverageofpath/test_num__1 (0.00s)\n        tmp32fh9m8i_test.go:55: expected '%!s(float64=6.2)', got '%!s(float64=10.333333333333332)'\n    --- FAIL: TestMaxaverageofpath/test_num__2 (0.00s)\n        tmp32fh9m8i_test.go:55: expected '%!s(float64=7.2)', got '%!s(float64=11.999999999999998)'\n    --- FAIL: TestMaxaverageofpath/test_num__3 (0.00s)\n        tmp32fh9m8i_test.go:55: expected '%!s(float64=5.8)', got '%!s(float64=9.666666666666666)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    n := len(cost)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return float64(cost[0][0])\n    }\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6is3mnf9_test.go:28:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) +\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509920,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp4d2242dv_test.go:24:6: expected '(', found TestMaxaverageofpath\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_73d6c83_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var max float64\n    var dfs func(int, int, float64, int)\n    dfs = func(i, j int, sum float64, cnt int) {\n        if i == len(cost) - 1 && j == len(cost[0]) - 1 {\n            if sum / float64(cnt) > max {\n                max = sum / float64(cnt)\n            }\n            return\n        }\n        if i < len(cost) - 1 {\n            dfs(i + 1, j, sum + float64(cost[i + 1][j]), cnt + 1)\n        }\n        if j < len(cost[0]) - 1 {\n            dfs(i, j + 1, sum + float64(cost[i][j + 1]), cnt + 1)\n        }\n    }\n    dfs(0, 0, float64(cost[0][0]), 1)\n    return max\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd2kexsn__test.go:25:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // dp[i][j] means the max average of path from (0, 0) to (i, j)\n    dp := make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[i]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[i]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpak8mfisy_test.go:24:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    var dp [][]float64 = make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqhoocomf_test.go:29:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp94a8wckj_test.go:30:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_73d6c83_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // Write your code here\n    return 0.0\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124099,
      "stdout": "--- FAIL: TestMaxaverageofpath (0.00s)\n    --- FAIL: TestMaxaverageofpath/test_num__0 (0.00s)\n        tmps8bwdv6u_test.go:30: expected '%!s(float64=5.2)', got '%!s(float64=0)'\n    --- FAIL: TestMaxaverageofpath/test_num__1 (0.00s)\n        tmps8bwdv6u_test.go:30: expected '%!s(float64=6.2)', got '%!s(float64=0)'\n    --- FAIL: TestMaxaverageofpath/test_num__2 (0.00s)\n        tmps8bwdv6u_test.go:30: expected '%!s(float64=7.2)', got '%!s(float64=0)'\n    --- FAIL: TestMaxaverageofpath/test_num__3 (0.00s)\n        tmps8bwdv6u_test.go:30: expected '%!s(float64=5.8)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_73d6c83_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    n := len(cost)\n    if n == 0 {\n        return 0\n    }\n    m := len(cost[0])\n    if m == 0 {\n        return 0\n    }\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, m)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < m; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < m; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][m-1] / float64(n+m-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpaybx6qw5_test.go:31:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var max float64\n    var dfs func(int, int, int, float64)\n    dfs = func(i, j, n int, sum float64) {\n        if i == n-1 && j == n-1 {\n            if max < sum {\n                max = sum\n            }\n            return\n        }\n        if i < n-1 {\n            dfs(i+1, j, n, sum+float64(cost[i+1][j]))\n        }\n        if j < n-1 {\n            dfs(i, j+1, n, sum+float64(cost[i][j+1]))\n        }\n    }\n    dfs(0, 0, len(cost), float64(cost[0][0]))\n    return max/float64(len(cost))\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124099,
      "stdout": "--- FAIL: TestMaxaverageofpath (0.00s)\n    --- FAIL: TestMaxaverageofpath/test_num__0 (0.00s)\n        tmpupn50y47_test.go:55: expected '%!s(float64=5.2)', got '%!s(float64=8.666666666666666)'\n    --- FAIL: TestMaxaverageofpath/test_num__1 (0.00s)\n        tmpupn50y47_test.go:55: expected '%!s(float64=6.2)', got '%!s(float64=10.333333333333334)'\n    --- FAIL: TestMaxaverageofpath/test_num__2 (0.00s)\n        tmpupn50y47_test.go:55: expected '%!s(float64=7.2)', got '%!s(float64=12)'\n    --- FAIL: TestMaxaverageofpath/test_num__3 (0.00s)\n        tmpupn50y47_test.go:55: expected '%!s(float64=5.8)', got '%!s(float64=9.666666666666666)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    dp := make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < len(cost); i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost)-1] / float64(2*len(cost)-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbfk_4zzo_test.go:29:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m + n - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzod2vovg_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2 * n - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpon1zib_w_test.go:25:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var dp [][]float64\n    for i := 0; i < len(cost); i++ {\n        dp = append(dp, make([]float64, len(cost[0])))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < len(cost[0]); i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa06qbrru_test.go:32:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var maxAverage float64\n    var maxAveragePath [][]int\n    for i := 0; i < len(cost); i++ {\n        for j := 0; j < len(cost[0]); j++ {\n            if i == 0 && j == 0 {\n                continue\n            }\n            var path [][]int\n            var average float64\n            if i == 0 {\n                path = append(path, []int{i, j})\n                average = float64(cost[i][j])\n            } else if j == 0 {\n                path = append(path, []int{i, j})\n                average = float64(cost[i][j])\n            } else {\n                path = append(maxAveragePath, []int{i, j})\n                average = maxAverage + float64(cost[i][j])\n            }\n            if average > maxAverage {\n                maxAverage = average\n                maxAveragePath = path\n            }\n        }\n    }\n    return maxAverage\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124099,
      "stdout": "--- FAIL: TestMaxaverageofpath (0.00s)\n    --- FAIL: TestMaxaverageofpath/test_num__0 (0.00s)\n        tmp87dqg7q4_test.go:63: expected '%!s(float64=5.2)', got '%!s(float64=27)'\n    --- FAIL: TestMaxaverageofpath/test_num__1 (0.00s)\n        tmp87dqg7q4_test.go:63: expected '%!s(float64=6.2)', got '%!s(float64=32)'\n    --- FAIL: TestMaxaverageofpath/test_num__2 (0.00s)\n        tmp87dqg7q4_test.go:63: expected '%!s(float64=7.2)', got '%!s(float64=37)'\n    --- FAIL: TestMaxaverageofpath/test_num__3 (0.00s)\n        tmp87dqg7q4_test.go:63: expected '%!s(float64=5.8)', got '%!s(float64=32)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptz24hy7s_test.go:28:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_73d6c83_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    var dp [][]float64\n    for i := 0; i < len(cost); i++ {\n        dp = append(dp, make([]float64, len(cost[0])))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < len(cost[0]); i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2gyp2j47_test.go:26:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp94a8wckj_test.go:30:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    var dp [][]float64\n    for i := 0; i < len(cost); i++ {\n        dp = append(dp, make([]float64, len(cost[0])))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa7j5zml1_test.go:29:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpopk53lr7_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp85awzzgr_test.go:30:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfzxd21b__test.go:28:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    n := len(cost)\n    if n == 0 {\n        return 0\n    }\n    m := len(cost[0])\n    if m == 0 {\n        return 0\n    }\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, m)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < m; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < m; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][m-1] / float64(n + m - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0dohvenb_test.go:31:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp66eg_z71_test.go:27:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_73d6c83_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    var dp [][]float64\n    for i := 0; i < len(cost); i++ {\n        dp = append(dp, make([]float64, len(cost[0])))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa7j5zml1_test.go:29:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) +\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509920,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp4d2242dv_test.go:24:6: expected '(', found TestMaxaverageofpath\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n    dp := make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpr0ngdsdd_test.go:29:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    n := len(cost)\n    if n == 0 {\n        return 0\n    }\n    m := len(cost[0])\n    if m == 0 {\n        return 0\n    }\n    if n == 1 && m == 1 {\n        return float64(cost[0][0])\n    }\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, m)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < m; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < m; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][m-1] / float64(n+m-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp448sywrx_test.go:34:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[0][0] = cost[0][0]\n    // dp[i][0] = dp[i-1][0] + cost[i][0]\n    // dp[0][j] = dp[0][j-1] + cost[0][j]\n    // dp[n-1][n-1] = max(dp[n-1][n-2], dp[n-2][n-1]) + cost[n-1][n-1]\n    // return dp[n-1][n-1] / (2 * n - 3)\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2 * n - 3)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa3la0isj_test.go:28:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_73d6c83_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124101,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpc2isqmi2_test.go:22:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var max float64\n    var dfs func(int, int, int, float64)\n    dfs = func(i, j, count int, sum float64) {\n        if i == len(cost) - 1 && j == len(cost[0]) - 1 {\n            if count == 0 {\n                max = sum\n            } else {\n                if sum / float64(count) > max {\n                    max = sum / float64(count)\n                }\n            }\n            return\n        }\n        if i < len(cost) - 1 {\n            dfs(i + 1, j, count + 1, sum + float64(cost[i + 1][j]))\n        }\n        if j < len(cost[0]) - 1 {\n            dfs(i, j + 1, count + 1, sum + float64(cost[i][j + 1]))\n        }\n    }\n    dfs(0, 0, 0, float64(cost[0][0]))\n    return max\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124102,
      "stdout": "--- FAIL: TestMaxaverageofpath (0.00s)\n    --- FAIL: TestMaxaverageofpath/test_num__0 (0.00s)\n        tmp7cp0txmh_test.go:59: expected '%!s(float64=5.2)', got '%!s(float64=6.5)'\n    --- FAIL: TestMaxaverageofpath/test_num__1 (0.00s)\n        tmp7cp0txmh_test.go:59: expected '%!s(float64=6.2)', got '%!s(float64=7.75)'\n    --- FAIL: TestMaxaverageofpath/test_num__2 (0.00s)\n        tmp7cp0txmh_test.go:59: expected '%!s(float64=7.2)', got '%!s(float64=9)'\n    --- FAIL: TestMaxaverageofpath/test_num__3 (0.00s)\n        tmp7cp0txmh_test.go:59: expected '%!s(float64=5.8)', got '%!s(float64=7.25)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var max float64\n    for i := 0; i < len(cost); i++ {\n        for j := 0; j < len(cost[0]); j++ {\n            if i == 0 && j == 0 {\n                continue\n            }\n            var left, up float64\n            if i > 0 {\n                up = float64(cost[i-1][j])\n            }\n            if j > 0 {\n                left = float64(cost[i][j-1])\n            }\n            if up > left {\n                cost[i][j] += int(up)\n            } else {\n                cost[i][j] += int(left)\n            }\n            if i == len(cost)-1 && j == len(cost[0])-1 {\n                max = float64(cost[i][j])\n            }\n        }\n    }\n    return max / float64(len(cost)+len(cost[0])-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124102,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n\n    var maxAvg float64\n    var dfs func(int, int, int, float64)\n    dfs = func(i, j, count int, sum float64) {\n        if i == len(cost) - 1 && j == len(cost[0]) - 1 {\n            avg := sum / float64(count)\n            if avg > maxAvg {\n                maxAvg = avg\n            }\n            return\n        }\n        if i < len(cost) - 1 {\n            dfs(i + 1, j, count + 1, sum + float64(cost[i + 1][j]))\n        }\n        if j < len(cost[0]) - 1 {\n            dfs(i, j + 1, count + 1, sum + float64(cost[i][j + 1]))\n        }\n    }\n    dfs(0, 0, 1, float64(cost[0][0]))\n    return maxAvg\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124102,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124101,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpflao6squ_test.go:25:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    row, col := len(cost), len(cost[0])\n    dp := make([][]float64, row)\n    for i := range dp {\n        dp[i] = make([]float64, col)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < row; i++ {\n        dp[i][0] = dp[i - 1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < col; j++ {\n        dp[0][j] = dp[0][j - 1] + float64(cost[0][j])\n    }\n    for i := 1; i < row; i++ {\n        for j := 1; j < col; j++ {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + float64(cost[i][j])\n        }\n    }\n    return dp[row - 1][col - 1] / float64(row + col - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124101,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp24agyzov_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124101,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpc2isqmi2_test.go:22:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var (\n        row = len(cost)\n        col = len(cost[0])\n        dp = make([][]float64, row)\n        i, j int\n    )\n    for i = 0; i < row; i++ {\n        dp[i] = make([]float64, col)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i = 1; i < row; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i = 1; i < col; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i = 1; i < row; i++ {\n        for j = 1; j < col; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[row-1][col-1] / float64(row + col - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124101,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpla4okasz_test.go:37:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    var row, col int = len(cost), len(cost[0])\n    var dp [][]float64 = make([][]float64, row)\n    for i := 0; i < row; i++ {\n        dp[i] = make([]float64, col)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < row; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < col; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < row; i++ {\n        for j := 1; j < col; j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[row-1][col-1] / float64(row + col - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124101,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpspiq915w_test.go:27:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    row := len(cost)\n    col := len(cost[0])\n    dp := make([][]float64, row)\n    for i := 0; i < row; i++ {\n        dp[i] = make([]float64, col)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < row; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < col; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < row; i++ {\n        for j := 1; j < col; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[row-1][col-1] / float64(row+col-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124101,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4svet91f_test.go:28:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] is the max average of path from (0, 0) to (i, j)\n    // dp[i][j] = dp[i-1][j] + cost[i][j]\n    // dp[i][j] = dp[i][j-1] + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = dp[i-1][j] + cost[i][j]\n    // dp[i][j] = dp[i][j-1] + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = dp[i-1][j] + cost[i][j]\n    // dp[i][j] = dp[i][j-1] + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = dp[i-1][j] + cost[i][j]\n    // dp[i][j] = dp[i][j-1] + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = dp[i-1][j] + cost[i][j]\n    // dp[i][j] = dp[i][j-1] + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124100,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpevjkb_03_test.go:27:6: expected '(', found TestMaxaverageofpath\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n\n    return dp[n-1][n-1] / float64(n*n)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124101,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjo7bzhnf_test.go:28:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var dp [][]float64\n    for i := 0; i < len(cost); i++ {\n        dp = append(dp, make([]float64, len(cost[0])))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124101,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprfg0z_is_test.go:32:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n\n    // dp[i][j] means the max average of path from (0, 0) to (i, j)\n    dp := make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124101,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpugnfullc_test.go:36:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp66eg_z71_test.go:27:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    // dp[i][j] means the max average of path from (0, 0) to (i, j)\n    dp := make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i - 1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j - 1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost) - 1][len(cost[0]) - 1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124101,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpyehwnzqx_test.go:30:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp94a8wckj_test.go:30:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124101,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvswezcn2_test.go:25:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n    var max float64 = 0\n    var dfs func(i, j int, sum, count int)\n    dfs = func(i, j int, sum, count int) {\n        if i == len(cost) - 1 && j == len(cost[0]) - 1 {\n            avg := float64(sum) / float64(count)\n            if avg > max {\n                max = avg\n            }\n            return\n        }\n        if i < len(cost) - 1 {\n            dfs(i + 1, j, sum + cost[i + 1][j], count + 1)\n        }\n        if j < len(cost[0]) - 1 {\n            dfs(i, j + 1, sum + cost[i][j + 1], count + 1)\n        }\n    }\n    dfs(0, 0, cost[0][0], 1)\n    return max\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124102,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp94a8wckj_test.go:30:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124101,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6umii0ru_test.go:28:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    dp := make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n\n    // fmt.Println(dp)\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124101,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprc8qayph_test.go:34:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124101,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpc2isqmi2_test.go:22:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) +\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509920,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp4d2242dv_test.go:24:6: expected '(', found TestMaxaverageofpath\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_73d6c83_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    n := len(cost)\n    m := len(cost[0])\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, m)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < m; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < m; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][m-1] / float64(n + m - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124101,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2_zx9nxe_test.go:28:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_73d6c83_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    dp := make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124101,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5vecuxli_test.go:29:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd2kexsn__test.go:25:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    n := len(cost)\n    m := len(cost[0])\n    dp := make([][]float64, n)\n    for i := range dp {\n        dp[i] = make([]float64, m)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < m; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < m; j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[n-1][m-1] / float64(n+m-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124102,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp38gtmrgk_test.go:28:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd2kexsn__test.go:25:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    var max float64\n    var row, col int\n    var path [][]int\n    var pathSum int\n    var pathLen int\n    var avg float64\n    var dfs func(int, int)\n    dfs = func(r, c int) {\n        if r == row - 1 && c == col - 1 {\n            pathSum += cost[r][c]\n            pathLen++\n            avg = float64(pathSum) / float64(pathLen)\n            if avg > max {\n                max = avg\n            }\n            pathSum -= cost[r][c]\n            pathLen--\n            return\n        }\n        if r < row && c < col {\n            path[r][c] = 1\n            pathSum += cost[r][c]\n            pathLen++\n            dfs(r + 1, c)\n            dfs(r, c + 1)\n            pathSum -= cost[r][c]\n            pathLen--\n            path[r][c] = 0\n        }\n    }\n    row = len(cost)\n    col = len(cost[0])\n    path = make([][]int, row)\n    for i := 0; i < row; i++ {\n        path[i] = make([]int, col)\n    }\n    dfs(0, 0)\n    return max\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124102,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n    var max float64 = 0\n    var dfs func(int, int, int, float64)\n    dfs = func(i, j, count int, sum float64) {\n        if i == len(cost) - 1 && j == len(cost[0]) - 1 {\n            if sum / float64(count) > max {\n                max = sum / float64(count)\n            }\n            return\n        }\n        if i < len(cost) - 1 {\n            dfs(i + 1, j, count + 1, sum + float64(cost[i + 1][j]))\n        }\n        if j < len(cost[0]) - 1 {\n            dfs(i, j + 1, count + 1, sum + float64(cost[i][j + 1]))\n        }\n    }\n    dfs(0, 0, 1, float64(cost[0][0]))\n    return max\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124102,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var max float64 = 0\n    var dfs func(int, int, int, float64)\n    dfs = func(i, j, n int, sum float64) {\n        if i == n-1 && j == n-1 {\n            if sum/float64(n) > max {\n                max = sum/float64(n)\n            }\n            return\n        }\n        if i < n-1 {\n            dfs(i+1, j, n, sum+float64(cost[i+1][j]))\n        }\n        if j < n-1 {\n            dfs(i, j+1, n, sum+float64(cost[i][j+1]))\n        }\n    }\n    dfs(0, 0, len(cost), float64(cost[0][0]))\n    return max\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124103,
      "stdout": "--- FAIL: TestMaxaverageofpath (0.00s)\n    --- FAIL: TestMaxaverageofpath/test_num__0 (0.00s)\n        tmpo3c4oytq_test.go:55: expected '%!s(float64=5.2)', got '%!s(float64=8.666666666666666)'\n    --- FAIL: TestMaxaverageofpath/test_num__1 (0.00s)\n        tmpo3c4oytq_test.go:55: expected '%!s(float64=6.2)', got '%!s(float64=10.333333333333334)'\n    --- FAIL: TestMaxaverageofpath/test_num__2 (0.00s)\n        tmpo3c4oytq_test.go:55: expected '%!s(float64=7.2)', got '%!s(float64=12)'\n    --- FAIL: TestMaxaverageofpath/test_num__3 (0.00s)\n        tmpo3c4oytq_test.go:55: expected '%!s(float64=5.8)', got '%!s(float64=9.666666666666666)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    var row, col int\n    row = len(cost)\n    col = len(cost[0])\n    dp := make([][]int, row)\n    for i := 0; i < row; i++ {\n        dp[i] = make([]int, col)\n    }\n    dp[0][0] = cost[0][0]\n    for i := 1; i < row; i++ {\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n    }\n    for i := 1; i < col; i++ {\n        dp[0][i] = dp[0][i-1] + cost[0][i]\n    }\n    for i := 1; i < row; i++ {\n        for j := 1; j < col; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n        }\n    }\n    return float64(dp[row-1][col-1]) / float64(row + col - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124104,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpn8h0ei9d_test.go:32:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfzxd21b__test.go:28:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // dp[i][j] = max average of path from (0,0) to (i,j)\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[0][0] = cost[0][0]\n    // dp[0][j] = dp[0][j-1] + cost[0][j]\n    // dp[i][0] = dp[i-1][0] + cost[i][0]\n    // dp[n-1][n-1] / (n-1) * (n-1)\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(n*n)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124104,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6ne9fjrf_test.go:28:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    n := len(cost)\n    if n == 0 {\n        return 0\n    }\n    m := len(cost[0])\n    if m == 0 {\n        return 0\n    }\n\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, m)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < m; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < m; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][m-1] / float64(n+m-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124104,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpotana7dz_test.go:32:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(n)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124104,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfroy_enp_test.go:22:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    var (\n        max float64 = 0\n        dp [][]float64 = make([][]float64, len(cost))\n        i, j int\n    )\n    for i = 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[i]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i = 1; i < len(cost); i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i = 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i = 1; i < len(cost); i++ {\n        for j = 1; j < len(cost); j++ {\n            dp[i][j] = maxFloat64(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    max = dp[len(cost)-1][len(cost)-1] / float64(len(cost) * 2 - 1)\n    return max\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124104,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd2eom85c_test.go:33:24: undefined: maxFloat64\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    dp := make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < len(cost[0]); i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124104,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpy0pmcz5x_test.go:29:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n\n    // dp[i][j] = max average of path from (0, 0) to (i, j)\n    dp := make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124104,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6l6inw0n_test.go:34:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) +\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509920,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp4d2242dv_test.go:24:6: expected '(', found TestMaxaverageofpath\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_73d6c83_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[n-1][n-1] / float64(n*n)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124104,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpitn7305q_test.go:25:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) +\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509920,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp4d2242dv_test.go:24:6: expected '(', found TestMaxaverageofpath\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n    var dp [][]float64 = make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < len(cost[0]); i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124104,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_zc5c7so_test.go:29:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var sum int\n    var count int\n    var max float64\n    var dfs func(int, int)\n    dfs = func(i, j int) {\n        if i == len(cost) - 1 && j == len(cost[0]) - 1 {\n            avg := float64(sum) / float64(count)\n            if avg > max {\n                max = avg\n            }\n            return\n        }\n        if i < len(cost) - 1 {\n            sum += cost[i + 1][j]\n            count++\n            dfs(i + 1, j)\n            sum -= cost[i + 1][j]\n            count--\n        }\n        if j < len(cost[0]) - 1 {\n            sum += cost[i][j + 1]\n            count++\n            dfs(i, j + 1)\n            sum -= cost[i][j + 1]\n            count--\n        }\n    }\n    sum = cost[0][0]\n    count = 1\n    dfs(0, 0)\n    return max\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "ok  \tcommand-line-arguments\t0.005s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_73d6c83_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_73d6c83_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    var max float64\n    var dfs func(int, int, int, float64)\n    dfs = func(i, j, n int, sum float64) {\n        if i == n - 1 && j == n - 1 {\n            if sum / float64(n) > max {\n                max = sum / float64(n)\n            }\n            return\n        }\n        if i < n - 1 {\n            dfs(i + 1, j, n, sum + float64(cost[i + 1][j]))\n        }\n        if j < n - 1 {\n            dfs(i, j + 1, n, sum + float64(cost[i][j + 1]))\n        }\n    }\n    dfs(0, 0, len(cost), float64(cost[0][0]))\n    return max\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124104,
      "stdout": "--- FAIL: TestMaxaverageofpath (0.00s)\n    --- FAIL: TestMaxaverageofpath/test_num__0 (0.00s)\n        tmp46buplzc_test.go:46: expected '%!s(float64=5.2)', got '%!s(float64=8.666666666666666)'\n    --- FAIL: TestMaxaverageofpath/test_num__1 (0.00s)\n        tmp46buplzc_test.go:46: expected '%!s(float64=6.2)', got '%!s(float64=10.333333333333334)'\n    --- FAIL: TestMaxaverageofpath/test_num__2 (0.00s)\n        tmp46buplzc_test.go:46: expected '%!s(float64=7.2)', got '%!s(float64=12)'\n    --- FAIL: TestMaxaverageofpath/test_num__3 (0.00s)\n        tmp46buplzc_test.go:46: expected '%!s(float64=5.8)', got '%!s(float64=9.666666666666666)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var max float64 = 0\n    var sum float64 = 0\n    var count int = 0\n    var dfs func(int, int)\n    dfs = func(i, j int) {\n        if i == len(cost) - 1 && j == len(cost[0]) - 1 {\n            sum += float64(cost[i][j])\n            count++\n            if sum / float64(count) > max {\n                max = sum / float64(count)\n            }\n            sum -= float64(cost[i][j])\n            count--\n            return\n        }\n        sum += float64(cost[i][j])\n        count++\n        if i < len(cost) - 1 {\n            dfs(i + 1, j)\n        }\n        if j < len(cost[0]) - 1 {\n            dfs(i, j + 1)\n        }\n        sum -= float64(cost[i][j])\n        count--\n    }\n    dfs(0, 0)\n    return max\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124104,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n\n    var dp [][]float64\n    for i := 0; i < len(cost); i++ {\n        dp = append(dp, make([]float64, len(cost[0])))\n    }\n\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124104,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpuhugdm8k_test.go:32:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp66eg_z71_test.go:27:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124101,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6umii0ru_test.go:28:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n    var dp [][]float64\n    for i := 0; i < len(cost); i++ {\n        dp = append(dp, make([]float64, len(cost[0])))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124104,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp39mscqsp_test.go:29:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    var dp [][]float64\n    for i := 0; i < len(cost); i++ {\n        dp = append(dp, make([]float64, len(cost[0])))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124104,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0yyg5lf6_test.go:29:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124104,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp227vuos2_test.go:22:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var max float64\n    var sum float64\n    var count int\n    var dfs func(int, int)\n    dfs = func(i, j int) {\n        if i == len(cost) - 1 && j == len(cost[0]) - 1 {\n            sum += float64(cost[i][j])\n            count++\n            avg := sum / float64(count)\n            if avg > max {\n                max = avg\n            }\n            return\n        }\n        sum += float64(cost[i][j])\n        count++\n        if i < len(cost) - 1 {\n            dfs(i + 1, j)\n        }\n        if j < len(cost[0]) - 1 {\n            dfs(i, j + 1)\n        }\n        sum -= float64(cost[i][j])\n        count--\n    }\n    dfs(0, 0)\n    return max\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124105,
      "stdout": "--- FAIL: TestMaxaverageofpath (0.00s)\n    --- FAIL: TestMaxaverageofpath/test_num__0 (0.00s)\n        tmppa5xnuy1_test.go:64: expected '%!s(float64=5.2)', got '%!s(float64=6.4)'\n    --- FAIL: TestMaxaverageofpath/test_num__1 (0.00s)\n        tmppa5xnuy1_test.go:64: expected '%!s(float64=6.2)', got '%!s(float64=7.4)'\n    --- FAIL: TestMaxaverageofpath/test_num__2 (0.00s)\n        tmppa5xnuy1_test.go:64: expected '%!s(float64=7.2)', got '%!s(float64=8.4)'\n    --- FAIL: TestMaxaverageofpath/test_num__3 (0.00s)\n        tmppa5xnuy1_test.go:64: expected '%!s(float64=5.8)', got '%!s(float64=6.6)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_73d6c83_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    for i := 1; i < len(cost); i++ {\n        cost[i][0] += cost[i-1][0]\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        cost[0][j] += cost[0][j-1]\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            cost[i][j] += max(cost[i-1][j], cost[i][j-1])\n        }\n    }\n    return float64(cost[len(cost)-1][len(cost[0])-1]) / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124104,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpiq8s6sjw_test.go:24:27: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124104,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpgkrxsomh_test.go:28:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // write your code in Go 1.4\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var max float64\n    for i := 0; i < len(cost); i++ {\n        for j := 0; j < len(cost[0]); j++ {\n            if i == 0 && j == 0 {\n                continue\n            }\n            if i == 0 {\n                cost[i][j] += cost[i][j-1]\n            } else if j == 0 {\n                cost[i][j] += cost[i-1][j]\n            } else {\n                cost[i][j] += maxInt(cost[i-1][j], cost[i][j-1])\n            }\n        }\n    }\n    max = float64(cost[len(cost)-1][len(cost[0])-1])\n    return max / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124104,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk_c82gv3_test.go:31:31: undefined: maxInt\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) +\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509920,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp4d2242dv_test.go:24:6: expected '(', found TestMaxaverageofpath\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfzxd21b__test.go:28:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var max float64\n    for i := 0; i < len(cost); i++ {\n        for j := 0; j < len(cost[0]); j++ {\n            if i == 0 && j == 0 {\n                continue\n            }\n            var up, left float64\n            if i == 0 {\n                up = 0\n            } else {\n                up = float64(cost[i-1][j])\n            }\n            if j == 0 {\n                left = 0\n            } else {\n                left = float64(cost[i][j-1])\n            }\n            cost[i][j] += int(maxFloat64(up, left))\n            if i == len(cost)-1 && j == len(cost[0])-1 {\n                max = float64(cost[i][j])\n            }\n        }\n    }\n    return max / float64(len(cost)+len(cost[0])-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124104,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptsg40gg3_test.go:39:31: undefined: maxFloat64\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124105,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3kkdvlax_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    for i := 1; i < len(cost); i++ {\n        cost[i][0] += cost[i-1][0]\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        cost[0][j] += cost[0][j-1]\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            cost[i][j] += max(cost[i-1][j], cost[i][j-1])\n        }\n    }\n    return float64(cost[len(cost)-1][len(cost[0])-1]) / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124104,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpiq8s6sjw_test.go:24:27: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    n := len(cost)\n    if n == 0 {\n        return 0\n    }\n    m := len(cost[0])\n    if m == 0 {\n        return 0\n    }\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, m)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < m; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < m; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][m-1] / float64(n+m-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpaybx6qw5_test.go:31:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) +\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509920,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp4d2242dv_test.go:24:6: expected '(', found TestMaxaverageofpath\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_73d6c83_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    dp := make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124101,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5vecuxli_test.go:29:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n\n    dp := make([][]float64, len(cost))\n    for i := range dp {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < len(cost[0]); i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124105,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmxuvepi0_test.go:29:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    n := len(cost)\n    if n == 0 {\n        return 0\n    }\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbvis3cvw_test.go:25:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var maxAverage float64\n    var maxAveragePath [][]int\n    for i := 0; i < len(cost); i++ {\n        for j := 0; j < len(cost[0]); j++ {\n            if i == 0 && j == 0 {\n                continue\n            }\n            var average float64\n            var path [][]int\n            if i == 0 {\n                average = float64(cost[i][j])\n                path = [][]int{{i, j}}\n            } else if j == 0 {\n                average = float64(cost[i][j])\n                path = [][]int{{i, j}}\n            } else {\n                average = float64(cost[i][j])\n                path = [][]int{{i, j}}\n                if maxAveragePath[len(maxAveragePath) - 1][0] == i - 1 {\n                    average += maxAverage\n                    path = append(path, maxAveragePath...)\n                } else {\n                    average += maxAverage\n                    path = append(path, maxAveragePath...)\n                }\n            }\n            if average > maxAverage {\n                maxAverage = average\n                maxAveragePath = path\n            }\n        }\n    }\n    return maxAverage\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124107,
      "stdout": "--- FAIL: TestMaxaverageofpath (0.00s)\n    --- FAIL: TestMaxaverageofpath/test_num__0 (0.00s)\n        tmpbv86ac7w_test.go:73: expected '%!s(float64=5.2)', got '%!s(float64=27)'\n    --- FAIL: TestMaxaverageofpath/test_num__1 (0.00s)\n        tmpbv86ac7w_test.go:73: expected '%!s(float64=6.2)', got '%!s(float64=32)'\n    --- FAIL: TestMaxaverageofpath/test_num__2 (0.00s)\n        tmpbv86ac7w_test.go:73: expected '%!s(float64=7.2)', got '%!s(float64=37)'\n    --- FAIL: TestMaxaverageofpath/test_num__3 (0.00s)\n        tmpbv86ac7w_test.go:73: expected '%!s(float64=5.8)', got '%!s(float64=32)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    n := len(cost)\n    if n == 0 {\n        return 0\n    }\n    m := len(cost[0])\n    if m == 0 {\n        return 0\n    }\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, m)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < m; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < m; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][m-1] / float64(n+m-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpaybx6qw5_test.go:31:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124101,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvswezcn2_test.go:25:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    dp := make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpt4o440gf_test.go:33:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_73d6c83_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var sum int\n    var count int\n    var max float64\n    var dfs func(int, int)\n    dfs = func(i, j int) {\n        if i == len(cost) - 1 && j == len(cost[0]) - 1 {\n            avg := float64(sum) / float64(count)\n            if avg > max {\n                max = avg\n            }\n            return\n        }\n        if i < len(cost) - 1 {\n            sum += cost[i + 1][j]\n            count++\n            dfs(i + 1, j)\n            sum -= cost[i + 1][j]\n            count--\n        }\n        if j < len(cost[0]) - 1 {\n            sum += cost[i][j + 1]\n            count++\n            dfs(i, j + 1)\n            sum -= cost[i][j + 1]\n            count--\n        }\n    }\n    sum = cost[0][0]\n    count = 1\n    dfs(0, 0)\n    return max\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "ok  \tcommand-line-arguments\t0.005s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    // dp[i][j] = max average of path from (0, 0) to (i, j)\n    dp := make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpep71l9n7_test.go:33:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    var sum float64\n    var count int\n    var max float64\n    var dfs func(int, int)\n    dfs = func(i, j int) {\n        if i == len(cost) - 1 && j == len(cost) - 1 {\n            if sum / float64(count) > max {\n                max = sum / float64(count)\n            }\n            return\n        }\n        if i < len(cost) - 1 {\n            sum += float64(cost[i + 1][j])\n            count++\n            dfs(i + 1, j)\n            sum -= float64(cost[i + 1][j])\n            count--\n        }\n        if j < len(cost) - 1 {\n            sum += float64(cost[i][j + 1])\n            count++\n            dfs(i, j + 1)\n            sum -= float64(cost[i][j + 1])\n            count--\n        }\n    }\n    sum = float64(cost[0][0])\n    count = 1\n    dfs(0, 0)\n    return max\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124107,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) +\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509920,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp4d2242dv_test.go:24:6: expected '(', found TestMaxaverageofpath\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_73d6c83_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124101,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpc2isqmi2_test.go:22:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    n := len(cost)\n    if n == 0 {\n        return 0\n    }\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbvis3cvw_test.go:25:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[0][0] = cost[0][0]\n    // dp[0][j] = dp[0][j-1] + cost[0][j]\n    // dp[i][0] = dp[i-1][0] + cost[i][0]\n    // return dp[n-1][n-1] / (n*n)\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(n*n)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzukcwuiw_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_73d6c83_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // write your code in Go 1.4\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    dp := make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpw56w_rqu_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    // dp[i][j] = max average of path from (0, 0) to (i, j)\n    dp := make([][]float64, len(cost))\n    for i := range dp {\n        dp[i] = make([]float64, len(cost))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost)-1] / float64(len(cost) * 2 - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpeh3pkftj_test.go:30:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb6erm9hl_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    var row, col int\n    row, col = len(cost), len(cost[0])\n    var dp [][]float64\n    dp = make([][]float64, row)\n    for i := 0; i < row; i++ {\n        dp[i] = make([]float64, col)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < row; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < col; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < row; i++ {\n        for j := 1; j < col; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[row-1][col-1] / float64(row+col-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmcuoyfir_test.go:29:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    row := len(cost)\n    col := len(cost[0])\n    dp := make([][]float64, row)\n    for i := 0; i < row; i++ {\n        dp[i] = make([]float64, col)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < row; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < col; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < row; i++ {\n        for j := 1; j < col; j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[row-1][col-1] / float64(row+col-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpf08rkkrr_test.go:28:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n\n    dp := make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < len(cost[0]); i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprbbqvdms_test.go:35:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n        dp[i][0] = float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = float64(cost[0][j])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[n-1][n-1] / float64(n)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmazz88ku_test.go:24:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    row, col := len(cost), len(cost[0])\n    dp := make([][]float64, row)\n    for i := 0; i < row; i++ {\n        dp[i] = make([]float64, col)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < row; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < col; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < row; i++ {\n        for j := 1; j < col; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[row-1][col-1] / float64(row + col - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzy_xwrq0_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_73d6c83_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    var dp [][]float64\n    for i := 0; i < len(cost); i++ {\n        dp = append(dp, make([]float64, len(cost[0])))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa7j5zml1_test.go:29:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[0][0] = cost[0][0]\n    // dp[0][j] = dp[0][j-1] + cost[0][j]\n    // dp[i][0] = dp[i-1][0] + cost[i][0]\n    // return dp[n-1][n-1] / (n*n)\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(n*n)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzukcwuiw_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    n := len(cost)\n    if n == 0 {\n        return 0\n    }\n    m := len(cost[0])\n    if m == 0 {\n        return 0\n    }\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, m)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < m; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < m; j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[n-1][m-1] / float64(n+m-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124107,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2jvg9a4x_test.go:31:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    dp := make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpt4o440gf_test.go:33:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n    n := len(cost)\n    m := len(cost[0])\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, m)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < m; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < m; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][m-1] / float64(n + m - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124107,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp255g7oj9_test.go:31:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) +\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509920,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp4d2242dv_test.go:24:6: expected '(', found TestMaxaverageofpath\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    dp := make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpt4o440gf_test.go:33:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var max float64\n    var dfs func(int, int, int, float64)\n    dfs = func(i, j, count int, sum float64) {\n        if i == len(cost) - 1 && j == len(cost[0]) - 1 {\n            avg := sum / float64(count)\n            if avg > max {\n                max = avg\n            }\n            return\n        }\n        if i < len(cost) - 1 {\n            dfs(i + 1, j, count + 1, sum + float64(cost[i + 1][j]))\n        }\n        if j < len(cost[0]) - 1 {\n            dfs(i, j + 1, count + 1, sum + float64(cost[i][j + 1]))\n        }\n    }\n    dfs(0, 0, 1, float64(cost[0][0]))\n    return max\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124107,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_73d6c83_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    var dp [][]float64\n    for i := 0; i < len(cost); i++ {\n        dp = append(dp, make([]float64, len(cost[0])))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < len(cost[0]); i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124107,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptza8ehb8_test.go:29:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n\n    // dp[i][j] means the max average of path from (0, 0) to (i, j)\n    dp := make([][]float64, len(cost))\n    for i := range dp {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124107,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprz54jkwp_test.go:33:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // dp[i][j] means the max average of path from (0, 0) to (i, j)\n    dp := make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124107,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpaqafyinp_test.go:24:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124107,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnn8z55zk_test.go:25:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    var dp [][]float64 = make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < len(cost[0]); i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124107,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpry8gr_q6_test.go:26:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[0][0] = cost[0][0]\n    // dp[i][0] = dp[i-1][0] + cost[i][0]\n    // dp[0][j] = dp[0][j-1] + cost[0][j]\n    // dp[n-1][n-1] = max(dp[n-2][n-1], dp[n-1][n-2]) + cost[n-1][n-1]\n    // dp[n-1][n-1] / (n+m-2)\n    n := len(cost)\n    m := len(cost[0])\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, m)\n    }\n    dp[0][0] = cost[0][0]\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n    }\n    for j := 1; j < m; j++ {\n        dp[0][j] = dp[0][j-1] + cost[0][j]\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < m; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n        }\n    }\n    return float64(dp[n-1][m-1]) / float64(n+m-2)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124107,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphn7q7xsq_test.go:31:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    dp := make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpt4o440gf_test.go:33:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) +\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509920,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp4d2242dv_test.go:24:6: expected '(', found TestMaxaverageofpath\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_73d6c83_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_73d6c83_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_73d6c83_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    dp := make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost)-1] / float64(len(cost) * len(cost))\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124108,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8w6c3olp_test.go:29:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_73d6c83_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i - 1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j - 1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m - 1][n - 1] / float64(m + n - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124108,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmponp1x71a_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    row := len(cost)\n    col := len(cost[0])\n    dp := make([][]float64, row)\n    for i := 0; i < row; i++ {\n        dp[i] = make([]float64, col)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < row; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < col; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < row; i++ {\n        for j := 1; j < col; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[row-1][col-1] / float64(row + col - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124108,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5a1lgv79_test.go:25:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    n := len(cost)\n    m := len(cost[0])\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, m)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < m; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < m; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][m-1] / float64(n + m - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124101,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2_zx9nxe_test.go:28:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_73d6c83_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124108,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpksv_4yoj_test.go:22:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(n)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124104,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfroy_enp_test.go:22:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_73d6c83_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[0][0] = cost[0][0]\n    // dp[i][0] = dp[i-1][0] + cost[i][0]\n    // dp[0][j] = dp[0][j-1] + cost[0][j]\n    // dp[n-1][n-1] / (n-1) * 2\n    n := len(cost)\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n    dp[0][0] = cost[0][0]\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n        dp[0][i] = dp[0][i-1] + cost[0][i]\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n        }\n    }\n    return float64(dp[n-1][n-1]) / float64(2 * (n - 1))\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124108,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqggcxjjy_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[0][0] = cost[0][0]\n    // dp[i][0] = dp[i-1][0] + cost[i][0]\n    // dp[0][j] = dp[0][j-1] + cost[0][j]\n    // return dp[n-1][n-1] / (n+n-1)\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124108,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkly2t3ix_test.go:29:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n\n    dp := make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < len(cost[0]); i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124108,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpftvc2do__test.go:33:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    n := len(cost)\n    if n == 0 {\n        return 0\n    }\n    m := len(cost[0])\n    if m == 0 {\n        return 0\n    }\n    // dp[i][j] means the max average of path from (0, 0) to (i, j)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, m)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < m; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < m; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][m-1] / float64(n + m - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124108,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsms66hsi_test.go:32:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[0][0] = cost[0][0]\n    // dp[i][0] = dp[i-1][0] + cost[i][0]\n    // dp[0][j] = dp[0][j-1] + cost[0][j]\n    // return dp[n-1][n-1] / (n * n)\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(n * n)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124108,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpuykfo0sc_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n\n    return dp[n-1][n-1] / float64(n*n)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124108,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8wjypo9b_test.go:31:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124101,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvswezcn2_test.go:25:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    dp := make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < len(cost[0]); i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124108,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_bin5n24_test.go:29:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n\n    return dp[n-1][n-1] / float64(n*n)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124108,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbdnn8ik9_test.go:28:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n    n := len(cost)\n    m := len(cost[0])\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, m)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < m; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < m; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][m-1] / float64(n+m-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkfxbgkis_test.go:31:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    n := len(cost)\n    if n == 0 {\n        return 0\n    }\n    m := len(cost[0])\n    if m == 0 {\n        return 0\n    }\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, m)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < m; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < m; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][m-1] / float64(n+m-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpaybx6qw5_test.go:31:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m + n - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzod2vovg_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[0][0] = cost[0][0]\n    // dp[i][0] = dp[i-1][0] + cost[i][0]\n    // dp[0][j] = dp[0][j-1] + cost[0][j]\n    // dp[n-1][n-1] = max(dp[n-1][n-2], dp[n-2][n-1]) + cost[n-1][n-1]\n    // return dp[n-1][n-1] / (n+m-2)\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124108,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpojz9ex16_test.go:28:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124101,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpc2isqmi2_test.go:22:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124101,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpc2isqmi2_test.go:22:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_73d6c83_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    var dp [][]float64\n    for i := 0; i < len(cost); i++ {\n        dp = append(dp, make([]float64, len(cost)))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost); j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[len(cost)-1][len(cost)-1] / float64(len(cost) * len(cost))\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124108,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmps3osynst_test.go:29:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n\n    n := len(cost)\n    m := len(cost[0])\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, m)\n    }\n\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < m; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n\n    for i := 1; i < n; i++ {\n        for j := 1; j < m; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n\n    return dp[n-1][m-1] / float64(n+m-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124108,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpeg5r_8f2_test.go:31:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) +\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509920,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp4d2242dv_test.go:24:6: expected '(', found TestMaxaverageofpath\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_73d6c83_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    row := len(cost)\n    col := len(cost[0])\n    dp := make([][]float64, row)\n    for i := 0; i < row; i++ {\n        dp[i] = make([]float64, col)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < row; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < col; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < row; i++ {\n        for j := 1; j < col; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[row-1][col-1] / float64(row + col - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124108,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpz5wf3_go_test.go:28:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_73d6c83_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var dp [][]float64\n    for i := 0; i < len(cost); i++ {\n        dp = append(dp, make([]float64, len(cost[0])))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < len(cost[0]); i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa06qbrru_test.go:32:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    }
  ]
}