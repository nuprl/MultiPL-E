{
  "name": "mbpp_630_get_coordinates",
  "language": "go_test.go",
  "prompt": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_630_get_coordinates.py",
  "prompt_terminology": "reworded",
  "tests": "func TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        tup_slice := tup.([]interface{})\n        var tup_int []int\n        for _, i := range tup_slice {\n            tup_int = append(tup_int, i.(int))\n        }\n        result = append(result, tup_int)\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc0000866d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmpb5alrsnp_test.go:12 +0x2f9\ncommand-line-arguments_test.TestGet_Coordinates(0xc000102600)\n\t/tmp/tmpb5alrsnp_test.go:29 +0xa8\ntesting.tRunner(0xc000102600, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case int:\n            result = append(result, []int{v.(int), v.(int)})\n        case []int:\n            result = append(result, v.([]int))\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp1grki5zd_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp1grki5zd_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp1grki5zd_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        var tup_int []int\n        for _, v := range tup.([]interface{}) {\n            tup_int = append(tup_int, v.(int))\n        }\n        result = append(result, tup_int)\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc00018c240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000186300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc00018c240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc000086ed0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmpvczph1xh_test.go:13 +0x2f9\ncommand-line-arguments_test.TestGet_Coordinates(0xc000186300)\n\t/tmp/tmpvczph1xh_test.go:28 +0xa8\ntesting.tRunner(0xc000186300, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x, y int\n    for _, tup := range test_tup {\n        x = tup.([]interface{})[0].(int)\n        y = tup.([]interface{})[1].(int)\n        result = append(result, []int{x, y})\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc00008c6d0, 0x2, 0x2, 0x4cd120, 0x5fa360, 0x609a20)\n\t/tmp/tmpk0n1x2fp_test.go:13 +0x270\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmpk0n1x2fp_test.go:27 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        result = append(result, tup.([]int))\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []int [recovered]\n\tpanic: interface conversion: interface {} is int, not []int\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc00008c6d0, 0x2, 0x2, 0x4cd120, 0x5fa340, 0x609a20)\n\t/tmp/tmp_n3k9zs4_test.go:12 +0x185\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmp_n3k9zs4_test.go:24 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        var temp []int\n        for _, v := range tup.([]interface{}) {\n            temp = append(temp, v.(int))\n        }\n        result = append(result, temp)\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc00008c6d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmp6fh2_n8z_test.go:13 +0x2f9\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmp6fh2_n8z_test.go:28 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    // Extract the coordinates from the test tuple.\n    test_coordinates := test_tup[0].([][]int)\n    // Extract the expected coordinates from the test tuple.\n    expected_coordinates := test_tup[1].([][]int)\n    // Extract the actual coordinates from the test tuple.\n    actual_coordinates := get_adjacent_coordinates(test_coordinates)\n    // Check if the actual coordinates are equal to the expected coordinates.\n    if !are_coordinates_equal(expected_coordinates, actual_coordinates) {\n        // If not, then return an error.\n        return [][]int{[]int{-1, -1}}\n    }\n    // If they are equal, then return the actual coordinates.\n    return actual_coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpj53ghg2g_test.go:15:27: undefined: get_adjacent_coordinates\n/tmp/tmpj53ghg2g_test.go:17:9: undefined: are_coordinates_equal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup := tup.(type) {\n        case []int:\n            result = append(result, tup)\n        case []interface{}:\n            result = append(result, get_coordinates(tup)...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp9zf999fb_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp9zf999fb_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp9zf999fb_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        tup_arr := tup.([]interface{})\n        var tup_int []int\n        for _, tup_elem := range tup_arr {\n            tup_int = append(tup_int, int(tup_elem.(float64)))\n        }\n        result = append(result, tup_int)\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc00018c240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000186300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc00018c240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc000086ed0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmpg6yqet7n_test.go:12 +0x30b\ncommand-line-arguments_test.TestGet_Coordinates(0xc000186300)\n\t/tmp/tmpg6yqet7n_test.go:29 +0xa8\ntesting.tRunner(0xc000186300, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, tup := range test_tup {\n        var tup_coordinates []int\n        for _, coord := range tup.([]interface{}) {\n            tup_coordinates = append(tup_coordinates, int(coord.(float64)))\n        }\n        coordinates = append(coordinates, tup_coordinates)\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc0000866d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmpx1mp6s_1_test.go:13 +0x30b\ncommand-line-arguments_test.TestGet_Coordinates(0xc000102600)\n\t/tmp/tmpx1mp6s_1_test.go:28 +0xa8\ntesting.tRunner(0xc000102600, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, tup := range test_tup {\n        var coordinate []int\n        for _, val := range tup.([]interface{}) {\n            coordinate = append(coordinate, val.(int))\n        }\n        coordinates = append(coordinates, coordinate)\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc00008c6d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmp4z7netlk_test.go:13 +0x2f9\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmp4z7netlk_test.go:28 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case int:\n            result = append(result, []int{v.(int)})\n        case []int:\n            result = append(result, v.([]int))\n        case [][]int:\n            for _, v1 := range v.([][]int) {\n                result = append(result, v1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmph991wl79_test.go:41: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3)] [%!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmph991wl79_test.go:41: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4)] [%!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmph991wl79_test.go:41: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5)] [%!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        tup_slice := tup.([]interface{})\n        var tup_int []int\n        for _, val := range tup_slice {\n            tup_int = append(tup_int, val.(int))\n        }\n        result = append(result, tup_int)\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc00008c6d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmpwrwo6rqs_test.go:12 +0x2f9\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmpwrwo6rqs_test.go:29 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, tup := range test_tup {\n        coordinates = append(coordinates, tup.([]int))\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []int [recovered]\n\tpanic: interface conversion: interface {} is int, not []int\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc000010270)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc000010270)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc00008ced0, 0x2, 0x2, 0x4cd120, 0x5fa340, 0x609a20)\n\t/tmp/tmp91z44zqj_test.go:12 +0x185\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmp91z44zqj_test.go:24 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            coordinates = append(coordinates, tup.([]int))\n        case []interface{}:\n            coordinates = append(coordinates, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123929,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpb06mycau_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpb06mycau_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpb06mycau_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            coordinates = append(coordinates, tup.([]int))\n        case [][]int:\n            for _, tup := range tup.([][]int) {\n                coordinates = append(coordinates, tup)\n            }\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123929,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpqvlu8rjb_test.go:39: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpqvlu8rjb_test.go:39: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpqvlu8rjb_test.go:39: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        tup_list := tup.([]interface{})\n        var tup_int []int\n        for _, item := range tup_list {\n            tup_int = append(tup_int, int(item.(float64)))\n        }\n        result = append(result, tup_int)\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123929,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc00008c6d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmpsf8jooia_test.go:12 +0x30b\ncommand-line-arguments_test.TestGet_Coordinates(0xc000102600)\n\t/tmp/tmpsf8jooia_test.go:29 +0xa8\ntesting.tRunner(0xc000102600, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, tup := range test_tup {\n        var tup_list []int\n        for _, tup_item := range tup.([]interface{}) {\n            tup_list = append(tup_list, tup_item.(int))\n        }\n        coordinates = append(coordinates, tup_list)\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123929,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc0000926d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmpqs3yn4g3_test.go:13 +0x2f9\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmpqs3yn4g3_test.go:28 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        var tup_list []int\n        for _, item := range tup.([]interface{}) {\n            tup_list = append(tup_list, item.(int))\n        }\n        result = append(result, tup_list)\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123929,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc0000926d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmphybbu7n3_test.go:13 +0x2f9\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmphybbu7n3_test.go:28 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        var tup_list []int\n        for _, val := range tup.([]interface{}) {\n            tup_list = append(tup_list, int(val.(float64)))\n        }\n        result = append(result, tup_list)\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123929,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc00008c6d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmpzttp6uz7_test.go:13 +0x30b\ncommand-line-arguments_test.TestGet_Coordinates(0xc000102600)\n\t/tmp/tmpzttp6uz7_test.go:28 +0xa8\ntesting.tRunner(0xc000102600, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, tup := range test_tup {\n        var coordinate []int\n        for _, coordinate_value := range tup.([]interface{}) {\n            coordinate = append(coordinate, coordinate_value.(int))\n        }\n        coordinates = append(coordinates, coordinate)\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123929,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc00008c6d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmpn9edekwo_test.go:13 +0x2f9\ncommand-line-arguments_test.TestGet_Coordinates(0xc000102600)\n\t/tmp/tmpn9edekwo_test.go:28 +0xa8\ntesting.tRunner(0xc000102600, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, tup := range test_tup {\n        var coordinate []int\n        for _, t := range tup.([]interface{}) {\n            coordinate = append(coordinate, int(t.(float64)))\n        }\n        coordinates = append(coordinates, coordinate)\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123929,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc0000926d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmpgr5oah_2_test.go:13 +0x30b\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmpgr5oah_2_test.go:28 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        var tup_int []int\n        for _, item := range tup.([]interface{}) {\n            tup_int = append(tup_int, item.(int))\n        }\n        result = append(result, tup_int)\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123929,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0001922a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc0001a2300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0001922a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc00008c6d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmp8ikw8o4t_test.go:13 +0x2f9\ncommand-line-arguments_test.TestGet_Coordinates(0xc0001a2300)\n\t/tmp/tmp8ikw8o4t_test.go:28 +0xa8\ntesting.tRunner(0xc0001a2300, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    // Get the number of rows and columns\n    rows := test_tup[0].(int)\n    cols := test_tup[1].(int)\n    // Get the coordinate list\n    coordinates := test_tup[2].([][]int)\n    // Get the number of coordinates\n    num_coordinates := len(coordinates)\n    // Get the number of adjacent coordinates\n    num_adjacent_coordinates := rows * cols - num_coordinates\n    // Initialize the adjacent coordinate list\n    adjacent_coordinates := make([][]int, num_adjacent_coordinates)\n    // Initialize the index of the adjacent coordinate list\n    index := 0\n    // Iterate through all the coordinates\n    for i := 0; i < rows; i++ {\n        for j := 0; j < cols; j++ {\n            // Check if the current coordinate is in the coordinate list\n            if !is_in_coordinates(coordinates, i, j) {\n                // Add the current coordinate to the adjacent coordinate list\n                adjacent_coordinates[index] = []int{i, j}\n                // Increment the index\n                index++\n            }\n        }\n    }\n    return adjacent_coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123928,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphm0_zpcu_test.go:27:17: undefined: is_in_coordinates\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []interface{}:\n            for _, tup_tup := range tup.([]interface{}) {\n                switch tup_tup.(type) {\n                case []interface{}:\n                    var temp []int\n                    for _, tup_tup_tup := range tup_tup.([]interface{}) {\n                        switch tup_tup_tup.(type) {\n                        case int:\n                            temp = append(temp, tup_tup_tup.(int))\n                        }\n                    }\n                    result = append(result, temp)\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123929,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpyh5wy271_test.go:47: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpyh5wy271_test.go:47: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpyh5wy271_test.go:47: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        var tup_result []int\n        for _, tup_item := range tup.([]interface{}) {\n            tup_result = append(tup_result, tup_item.(int))\n        }\n        result = append(result, tup_result)\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123929,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc0000926d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmptkv_uk05_test.go:13 +0x2f9\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmptkv_uk05_test.go:28 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []interface{}:\n            for _, tup_tup := range tup.([]interface{}) {\n                switch tup_tup.(type) {\n                case []interface{}:\n                    var tup_tup_tup []int\n                    for _, tup_tup_tup_tup := range tup_tup.([]interface{}) {\n                        switch tup_tup_tup_tup.(type) {\n                        case int:\n                            tup_tup_tup = append(tup_tup_tup, tup_tup_tup_tup.(int))\n                        }\n                    }\n                    result = append(result, tup_tup_tup)\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123929,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpu8e9830y_test.go:47: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpu8e9830y_test.go:47: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpu8e9830y_test.go:47: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case int:\n            result = append(result, []int{tup.(int), tup.(int)})\n        case []int:\n            result = append(result, tup.([]int))\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123929,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpevk98_4b_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpevk98_4b_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpevk98_4b_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case []int:\n            result = append(result, v.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(v.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123929,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp9mgxnr0e_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp9mgxnr0e_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp9mgxnr0e_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case []int:\n            result = append(result, v.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(v.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123929,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp9mgxnr0e_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp9mgxnr0e_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp9mgxnr0e_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []interface{}:\n            for _, tup_tup := range tup.([]interface{}) {\n                switch tup_tup.(type) {\n                case []interface{}:\n                    var tup_tup_tup []int\n                    for _, tup_tup_tup_tup := range tup_tup.([]interface{}) {\n                        switch tup_tup_tup_tup.(type) {\n                        case int:\n                            tup_tup_tup = append(tup_tup_tup, tup_tup_tup_tup.(int))\n                        }\n                    }\n                    result = append(result, tup_tup_tup)\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123929,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpu8e9830y_test.go:47: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpu8e9830y_test.go:47: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpu8e9830y_test.go:47: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case [][]int:\n            for _, tup := range tup.([][]int) {\n                result = append(result, tup)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123929,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpxcgup7wy_test.go:39: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpxcgup7wy_test.go:39: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpxcgup7wy_test.go:39: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        case int:\n            result = append(result, []int{tup.(int)})\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123929,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpwsm4xagy_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3)] [%!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpwsm4xagy_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4)] [%!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpwsm4xagy_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5)] [%!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        tup_slice := tup.([]interface{})\n        var tup_int []int\n        for _, num := range tup_slice {\n            tup_int = append(tup_int, num.(int))\n        }\n        result = append(result, tup_int)\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123929,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc00008c6d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmpcudlnore_test.go:12 +0x2f9\ncommand-line-arguments_test.TestGet_Coordinates(0xc000102600)\n\t/tmp/tmpcudlnore_test.go:29 +0xa8\ntesting.tRunner(0xc000102600, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        var tup_list []int\n        for _, t := range tup.([]interface{}) {\n            tup_list = append(tup_list, int(t.(float64)))\n        }\n        result = append(result, tup_list)\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123929,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc0000926d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmpnxvcep8s_test.go:13 +0x30b\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmpnxvcep8s_test.go:28 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case []int:\n            result = append(result, v.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(v.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123929,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp9mgxnr0e_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp9mgxnr0e_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp9mgxnr0e_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        var tup_slice []int\n        for _, t := range tup.([]interface{}) {\n            tup_slice = append(tup_slice, int(t.(float64)))\n        }\n        result = append(result, tup_slice)\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123929,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc0000926d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmpdjmbus9r_test.go:13 +0x30b\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmpdjmbus9r_test.go:28 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.009s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        tup_slice := tup.([]interface{})\n        var temp []int\n        for _, item := range tup_slice {\n            temp = append(temp, item.(int))\n        }\n        result = append(result, temp)\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123929,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc00008c6d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmpeskmivsq_test.go:12 +0x2f9\ncommand-line-arguments_test.TestGet_Coordinates(0xc000102600)\n\t/tmp/tmpeskmivsq_test.go:29 +0xa8\ntesting.tRunner(0xc000102600, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case []int:\n            coordinates = append(coordinates, v.([]int))\n        case [][]int:\n            coordinates = append(coordinates, v.([][]int)...)\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123929,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpcpr4vk9q_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpcpr4vk9q_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpcpr4vk9q_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    test_list := test_tup[0].([]interface{})\n    result := make([][]int, len(test_list))\n    for i, v := range test_list {\n        result[i] = v.([]int)\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123929,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc0000926d0, 0x2, 0x2, 0x4cd120, 0x5fa340, 0x609a20)\n\t/tmp/tmpl7l9hivd_test.go:10 +0x12e\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmpl7l9hivd_test.go:25 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, tup := range test_tup {\n        var tup_coordinates []int\n        for _, coord := range tup.([]interface{}) {\n            tup_coordinates = append(tup_coordinates, int(coord.(float64)))\n        }\n        coordinates = append(coordinates, tup_coordinates)\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc0000866d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmpx1mp6s_1_test.go:13 +0x30b\ncommand-line-arguments_test.TestGet_Coordinates(0xc000102600)\n\t/tmp/tmpx1mp6s_1_test.go:28 +0xa8\ntesting.tRunner(0xc000102600, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        tup_list := tup.([]interface{})\n        var tup_int []int\n        for _, item := range tup_list {\n            tup_int = append(tup_int, int(item.(float64)))\n        }\n        result = append(result, tup_int)\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123929,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc00008c6d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmpsf8jooia_test.go:12 +0x30b\ncommand-line-arguments_test.TestGet_Coordinates(0xc000102600)\n\t/tmp/tmpsf8jooia_test.go:29 +0xa8\ntesting.tRunner(0xc000102600, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        tup_list := tup.([]interface{})\n        var tup_int []int\n        for _, tup_item := range tup_list {\n            tup_int = append(tup_int, int(tup_item.(float64)))\n        }\n        result = append(result, tup_int)\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123930,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0001922a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc0001a0300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0001922a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc00008c6d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmpezt7krcs_test.go:12 +0x30b\ncommand-line-arguments_test.TestGet_Coordinates(0xc0001a0300)\n\t/tmp/tmpezt7krcs_test.go:29 +0xa8\ntesting.tRunner(0xc0001a0300, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case []int:\n            result = append(result, v.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(v.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123929,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp9mgxnr0e_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp9mgxnr0e_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp9mgxnr0e_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, tup := range test_tup {\n        var coordinate []int\n        for _, num := range tup.([]interface{}) {\n            coordinate = append(coordinate, num.(int))\n        }\n        coordinates = append(coordinates, coordinate)\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123931,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc00008c6d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmppplvnggq_test.go:13 +0x2f9\ncommand-line-arguments_test.TestGet_Coordinates(0xc000102600)\n\t/tmp/tmppplvnggq_test.go:28 +0xa8\ntesting.tRunner(0xc000102600, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        var tup_list []int\n        for _, tup_elem := range tup.([]interface{}) {\n            tup_list = append(tup_list, int(tup_elem.(float64)))\n        }\n        result = append(result, tup_list)\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123931,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc0000926d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmp9a5x64aw_test.go:13 +0x30b\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmp9a5x64aw_test.go:28 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.013s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case []int:\n            result = append(result, v.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(v.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123929,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp9mgxnr0e_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp9mgxnr0e_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp9mgxnr0e_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case []int:\n            result = append(result, v.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(v.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123929,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp9mgxnr0e_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp9mgxnr0e_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp9mgxnr0e_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        var tup_list []int\n        for _, val := range tup.([]interface{}) {\n            tup_list = append(tup_list, val.(int))\n        }\n        result = append(result, tup_list)\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123931,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc00011e240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc00011e240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc00008ced0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmpsvd6fzb1_test.go:13 +0x2f9\ncommand-line-arguments_test.TestGet_Coordinates(0xc000102600)\n\t/tmp/tmpsvd6fzb1_test.go:28 +0xa8\ntesting.tRunner(0xc000102600, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case [][]int:\n            for _, tup2 := range tup.([][]int) {\n                result = append(result, tup2)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123931,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp2su9eji__test.go:39: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp2su9eji__test.go:39: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp2su9eji__test.go:39: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            coordinates = append(coordinates, tup.([]int))\n        case [][]int:\n            coordinates = append(coordinates, tup.([][]int)...)\n        default:\n            fmt.Println(\"Error: unknown type.\")\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123931,
      "stdout": "Error: unknown type.\nError: unknown type.\nError: unknown type.\nError: unknown type.\nError: unknown type.\nError: unknown type.\n--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpeq0hdsiu_test.go:39: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpeq0hdsiu_test.go:39: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpeq0hdsiu_test.go:39: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, tup := range test_tup {\n        var coordinate []int\n        for _, val := range tup.([]interface{}) {\n            coordinate = append(coordinate, val.(int))\n        }\n        coordinates = append(coordinates, coordinate)\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc00008c6d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmp4z7netlk_test.go:13 +0x2f9\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmp4z7netlk_test.go:28 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, tup := range test_tup {\n        coordinates = append(coordinates, tup.([]int))\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []int [recovered]\n\tpanic: interface conversion: interface {} is int, not []int\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc000010270)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc000010270)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc00008ced0, 0x2, 0x2, 0x4cd120, 0x5fa340, 0x609a20)\n\t/tmp/tmp91z44zqj_test.go:12 +0x185\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmp91z44zqj_test.go:24 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        default:\n            fmt.Println(\"Invalid input\")\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123931,
      "stdout": "Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\n--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpfg960a_g_test.go:39: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpfg960a_g_test.go:39: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpfg960a_g_test.go:39: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    var coordinate []int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case int:\n            coordinate = append(coordinate, v.(int))\n        case []interface{}:\n            coordinate = append(coordinate, get_coordinates(v.([]interface{}))...)\n        }\n    }\n    coordinates = append(coordinates, coordinate)\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123931,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmps18_kc0x_test.go:17:32: cannot use get_coordinates(v.([]interface {})) (type [][]int) as type []int in append\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        var tup_int []int\n        for _, tup_item := range tup.([]interface{}) {\n            tup_int = append(tup_int, tup_item.(int))\n        }\n        result = append(result, tup_int)\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123931,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc0000926d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmp3x5d1lu0_test.go:13 +0x2f9\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmp3x5d1lu0_test.go:28 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            for _, tup2 := range tup.([]interface{}) {\n                switch tup2.(type) {\n                case []int:\n                    result = append(result, tup2.([]int))\n                case []interface{}:\n                    for _, tup3 := range tup2.([]interface{}) {\n                        switch tup3.(type) {\n                        case []int:\n                            result = append(result, tup3.([]int))\n                        case []interface{}:\n                            for _, tup4 := range tup3.([]interface{}) {\n                                switch tup4.(type) {\n                                case []int:\n                                    result = append(result, tup4.([]int))\n                                case []interface{}:\n                                    for _, tup5 := range tup4.([]interface{}) {\n                                        switch tup5.(type) {\n                                        case []int:\n                                            result = append(result, tup5.([]int))\n                                        case []interface{}:\n                                            for _, tup6 := range tup5.([]interface{}) {\n                                                switch tup6.(type) {\n                                                case []int:\n                                                    result = append(result, tup6.([]int))\n                                                case []interface{}:\n                                                    for _, tup7 := range tup6.([]interface{}) {\n                                                        switch tup7.(type) {\n                                                        case []int:\n                                                            result = append(result, tup7.([]int))\n                                                        case []interface{}:\n                                                            for _, tup8 := range tup7.([]interface{}) {\n                                                                switch tup8.(type) {\n                                                                case []int:\n                                                                    result = append(result, tup8.([]int))\n                                                                case []interface{}:\n                                                                    for _,\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123930,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp7qtj6daw_test.go:51:73: expected 1 expression\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        var temp []int\n        for _, val := range tup.([]interface{}) {\n            temp = append(temp, val.(int))\n        }\n        result = append(result, temp)\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123931,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc0000926d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmpnm1m7urh_test.go:13 +0x2f9\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmpnm1m7urh_test.go:28 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        var tup_list []int\n        for _, tup_item := range tup.([]interface{}) {\n            tup_list = append(tup_list, tup_item.(int))\n        }\n        result = append(result, tup_list)\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123931,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc0000926d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmp7rcrw4fd_test.go:13 +0x2f9\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmp7rcrw4fd_test.go:28 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case []interface{}:\n            result = append(result, get_coordinates(v.([]interface{}))...)\n        case int:\n            result = append(result, []int{v.(int)})\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123931,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpcezjx6m__test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3)] [%!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpcezjx6m__test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4)] [%!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpcezjx6m__test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5)] [%!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case []int:\n            result = append(result, v.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(v.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123929,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp9mgxnr0e_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp9mgxnr0e_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp9mgxnr0e_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        var temp []int\n        for _, item := range tup.([]interface{}) {\n            temp = append(temp, item.(int))\n        }\n        result = append(result, temp)\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123931,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc00008c6d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmpxv00vzsq_test.go:13 +0x2f9\ncommand-line-arguments_test.TestGet_Coordinates(0xc000102600)\n\t/tmp/tmpxv00vzsq_test.go:28 +0xa8\ntesting.tRunner(0xc000102600, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        var tup_list []int\n        for _, v := range tup.([]interface{}) {\n            tup_list = append(tup_list, int(v.(float64)))\n        }\n        result = append(result, tup_list)\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123931,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc0000926d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmpp8tpw8wd_test.go:13 +0x30b\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmpp8tpw8wd_test.go:28 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        result = append(result, tup.([]int))\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []int [recovered]\n\tpanic: interface conversion: interface {} is int, not []int\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc00008c6d0, 0x2, 0x2, 0x4cd120, 0x5fa340, 0x609a20)\n\t/tmp/tmp_n3k9zs4_test.go:12 +0x185\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmp_n3k9zs4_test.go:24 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        result = append(result, tup.([]int))\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []int [recovered]\n\tpanic: interface conversion: interface {} is int, not []int\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc00008c6d0, 0x2, 0x2, 0x4cd120, 0x5fa340, 0x609a20)\n\t/tmp/tmp_n3k9zs4_test.go:12 +0x185\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmp_n3k9zs4_test.go:24 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    // The input is a list of tuples, each tuple has two elements.\n    // The first element is the x coordinate, the second element is the y coordinate.\n    // The output is a list of tuples, each tuple has two elements.\n    // The first element is the x coordinate, the second element is the y coordinate.\n    // The output list contains all the coordinates adjacent to the input coordinates.\n    // The adjacent coordinates are the coordinates that are one unit away from the input coordinates.\n    // The adjacent coordinates are the coordinates that are one unit away from the input coordinates.\n    // The adjacent coordinates are the coordinates that are one unit away from the input coordinates.\n    // The adjacent coordinates are the coordinates that are one unit away from the input coordinates.\n    // The adjacent coordinates are the coordinates that are one unit away from the input coordinates.\n    // The adjacent coordinates are the coordinates that are one unit away from the input coordinates.\n    // The adjacent coordinates are the coordinates that are one unit away from the input coordinates.\n    // The adjacent coordinates are the coordinates that are one unit away from the input coordinates.\n    // The adjacent coordinates are the coordinates that are one unit away from the input coordinates.\n    // The adjacent coordinates are the coordinates that are one unit away from the input coordinates.\n    // The adjacent coordinates are the coordinates that are one unit away from the input coordinates.\n    // The adjacent coordinates are the coordinates that are one unit away from the input coordinates.\n    // The adjacent coordinates are the coordinates that are one unit away from the input coordinates.\n    // The adjacent coordinates are the coordinates that are one unit away from the input coordinates.\n    // The adjacent coordinates are the coordinates that are one unit away from the input coordinates.\n    // The adjacent coordinates are the coordinates that are one unit away from the input coordinates.\n    // The adjacent coordinates are the coordinates that are one unit away from the input coordinates.\n    // The adjacent coordinates are the coordinates that are one unit away from the input coordinates.\n    // The adjacent coordinates are the coordinates that are one unit away from the input coordinates.\n    // The adjacent coordinates are the coordinates that are one unit away from the input coordinates.\n    // The adjacent coordinates are the coordinates that are one unit away from the input coordinates.\n    // The adjacent coordinates are the coordinates that are one unit away from the input coordinates.\n    // The\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123930,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpg_hjbqrs_test.go:38:6: expected '(', found TestGet_Coordinates\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        var tup_list []int\n        for _, tup_item := range tup.([]interface{}) {\n            tup_list = append(tup_list, int(tup_item.(float64)))\n        }\n        result = append(result, tup_list)\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123931,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0001102a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc00011e300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0001102a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc00008c6d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmpz4ym8uh1_test.go:13 +0x30b\ncommand-line-arguments_test.TestGet_Coordinates(0xc00011e300)\n\t/tmp/tmpz4ym8uh1_test.go:28 +0xa8\ntesting.tRunner(0xc00011e300, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, tup := range test_tup {\n        var coordinate []int\n        for _, val := range tup.([]interface{}) {\n            coordinate = append(coordinate, val.(int))\n        }\n        coordinates = append(coordinates, coordinate)\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc00008c6d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmp4z7netlk_test.go:13 +0x2f9\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmp4z7netlk_test.go:28 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    // The input is a list of tuples.\n    // The output is a list of lists.\n    // The output is a list of all the adjacent coordinates of the given coordinate list.\n    // The adjacent coordinates are the coordinates that are adjacent to the given coordinates.\n    // The adjacent coordinates are the coordinates that are adjacent to the given coordinates.\n    // The adjacent coordinates are the coordinates that are adjacent to the given coordinates.\n    // The adjacent coordinates are the coordinates that are adjacent to the given coordinates.\n    // The adjacent coordinates are the coordinates that are adjacent to the given coordinates.\n    // The adjacent coordinates are the coordinates that are adjacent to the given coordinates.\n    // The adjacent coordinates are the coordinates that are adjacent to the given coordinates.\n    // The adjacent coordinates are the coordinates that are adjacent to the given coordinates.\n    // The adjacent coordinates are the coordinates that are adjacent to the given coordinates.\n    // The adjacent coordinates are the coordinates that are adjacent to the given coordinates.\n    // The adjacent coordinates are the coordinates that are adjacent to the given coordinates.\n    // The adjacent coordinates are the coordinates that are adjacent to the given coordinates.\n    // The adjacent coordinates are the coordinates that are adjacent to the given coordinates.\n    // The adjacent coordinates are the coordinates that are adjacent to the given coordinates.\n    // The adjacent coordinates are the coordinates that are adjacent to the given coordinates.\n    // The adjacent coordinates are the coordinates that are adjacent to the given coordinates.\n    // The adjacent coordinates are the coordinates that are adjacent to the given coordinates.\n    // The adjacent coordinates are the coordinates that are adjacent to the given coordinates.\n    // The adjacent coordinates are the coordinates that are adjacent to the given coordinates.\n    // The adjacent coordinates are the coordinates that are adjacent to the given coordinates.\n    // The adjacent coordinates are the coordinates that are adjacent to the given coordinates.\n    // The adjacent coordinates are the coordinates that are adjacent to the given coordinates.\n    // The adjacent coordinates are the coordinates that are adjacent to the given coordinates.\n    // The adjacent coordinates are the coordinates that are adjacent to the given coordinates.\n    // The adjacent coordinates are the coordinates that are adjacent to the given coordinates.\n    // The adjacent coordinates are the coordinates that are adjacent to the given coordinates.\n    // The adjacent coordinates are the coordinates that are adjacent to the given coordinates.\n    // The adjacent coordinates are the coordinates that are\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123931,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpm0d1m0yo_test.go:41:6: expected '(', found TestGet_Coordinates\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, tup := range test_tup {\n        tup_slice := tup.([]interface{})\n        var coordinate []int\n        for _, num := range tup_slice {\n            coordinate = append(coordinate, num.(int))\n        }\n        coordinates = append(coordinates, coordinate)\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123931,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc0000926d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmpwbzdusl0_test.go:12 +0x2f9\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmpwbzdusl0_test.go:29 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case []int:\n            result = append(result, v.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(v.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123929,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp9mgxnr0e_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp9mgxnr0e_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp9mgxnr0e_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    coordinates := make([][]int, 0)\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []interface{}:\n            coordinates = append(coordinates, get_coordinates(tup.([]interface{}))...)\n        case int:\n            coordinates = append(coordinates, []int{tup.(int)})\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123931,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpki5jvyc9_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3)] [%!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpki5jvyc9_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4)] [%!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpki5jvyc9_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5)] [%!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        case int:\n            result = append(result, []int{tup.(int)})\n        default:\n            fmt.Println(\"Error: invalid type\")\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123931,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp_bu12yqn_test.go:39: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3)] [%!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp_bu12yqn_test.go:39: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4)] [%!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp_bu12yqn_test.go:39: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5)] [%!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        x := tup.([]interface{})[0].(int)\n        y := tup.([]interface{})[1].(int)\n        result = append(result, []int{x, y})\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123932,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc0000926d0, 0x2, 0x2, 0x4cd120, 0x5fa360, 0x609a20)\n\t/tmp/tmpy3rj7vca_test.go:12 +0x270\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmpy3rj7vca_test.go:26 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        default:\n            fmt.Println(\"Unknown type\")\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123931,
      "stdout": "Unknown type\nUnknown type\nUnknown type\nUnknown type\nUnknown type\nUnknown type\n--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpt3j28sjk_test.go:39: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpt3j28sjk_test.go:39: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpt3j28sjk_test.go:39: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case [][]int:\n            for _, t := range tup.([][]int) {\n                result = append(result, t)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123933,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpc1b0x_6a_test.go:39: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpc1b0x_6a_test.go:39: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpc1b0x_6a_test.go:39: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup := tup.(type) {\n        case []int:\n            result = append(result, tup)\n        case []interface{}:\n            result = append(result, get_coordinates(tup)...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp9zf999fb_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp9zf999fb_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp9zf999fb_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup := tup.(type) {\n        case []int:\n            result = append(result, tup)\n        case []interface{}:\n            result = append(result, get_coordinates(tup)...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp9zf999fb_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp9zf999fb_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp9zf999fb_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        result = append(result, tup.([]int))\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []int [recovered]\n\tpanic: interface conversion: interface {} is int, not []int\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc00008c6d0, 0x2, 0x2, 0x4cd120, 0x5fa340, 0x609a20)\n\t/tmp/tmp_n3k9zs4_test.go:12 +0x185\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmp_n3k9zs4_test.go:24 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup := tup.(type) {\n        case []interface{}:\n            for _, tup_tup := range tup {\n                switch tup_tup := tup_tup.(type) {\n                case []interface{}:\n                    var tup_tup_int []int\n                    for _, tup_tup_tup := range tup_tup {\n                        switch tup_tup_tup := tup_tup_tup.(type) {\n                        case int:\n                            tup_tup_int = append(tup_tup_int, tup_tup_tup)\n                        }\n                    }\n                    result = append(result, tup_tup_int)\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123933,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmps2nr_qjk_test.go:47: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmps2nr_qjk_test.go:47: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmps2nr_qjk_test.go:47: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        var coord []int\n        for _, val := range tup.([]interface{}) {\n            coord = append(coord, val.(int))\n        }\n        result = append(result, coord)\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123933,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc00008c6d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmp2yggn31b_test.go:13 +0x2f9\ncommand-line-arguments_test.TestGet_Coordinates(0xc000102600)\n\t/tmp/tmp2yggn31b_test.go:28 +0xa8\ntesting.tRunner(0xc000102600, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, tup := range test_tup {\n        coordinates = append(coordinates, tup.([]int))\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []int [recovered]\n\tpanic: interface conversion: interface {} is int, not []int\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc000010270)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc000010270)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc00008ced0, 0x2, 0x2, 0x4cd120, 0x5fa340, 0x609a20)\n\t/tmp/tmp91z44zqj_test.go:12 +0x185\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmp91z44zqj_test.go:24 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            coordinates = append(coordinates, tup.([]int))\n        case [][]int:\n            coordinates = append(coordinates, tup.([][]int)...)\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123933,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpaa5ysmnx_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpaa5ysmnx_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpaa5ysmnx_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []interface{}:\n            for _, tup2 := range tup.([]interface{}) {\n                switch tup2.(type) {\n                case []interface{}:\n                    for _, tup3 := range tup2.([]interface{}) {\n                        switch tup3.(type) {\n                        case []interface{}:\n                            for _, tup4 := range tup3.([]interface{}) {\n                                switch tup4.(type) {\n                                case []interface{}:\n                                    for _, tup5 := range tup4.([]interface{}) {\n                                        switch tup5.(type) {\n                                        case []interface{}:\n                                            for _, tup6 := range tup5.([]interface{}) {\n                                                switch tup6.(type) {\n                                                case []interface{}:\n                                                    for _, tup7 := range tup6.([]interface{}) {\n                                                        switch tup7.(type) {\n                                                        case []interface{}:\n                                                            for _, tup8 := range tup7.([]interface{}) {\n                                                                switch tup8.(type) {\n                                                                case []interface{}:\n                                                                    for _, tup9 := range tup8.([]interface{}) {\n                                                                        switch tup9.(type) {\n                                                                        case []interface{}:\n                                                                            for _, tup10 := range tup9.([]interface{}) {\n                                                                                switch tup10.(type) {\n                                                                                case []interface{}:\n                                                                                    for _, tup11 := range tup10.([]interface{}) {\n                                                                                        switch tup11.(type) {\n                                                                                        case []interface{}:\n                                                                                            for _, tup12 := range tup11.([]interface{}) {\n                                                                                                switch tup12.(type) {\n                                                                                                case []interface{}:\n                                                \nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123932,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp8q_q88te_test.go:48:6: expected '(', found TestGet_Coordinates\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, t := range test_tup {\n        switch t.(type) {\n        case []int:\n            result = append(result, t.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(t.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123934,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp7u0k1_gs_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp7u0k1_gs_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp7u0k1_gs_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.015s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, tup := range test_tup {\n        var coordinate []int\n        switch tup.(type) {\n        case []int:\n            coordinate = tup.([]int)\n        case []interface{}:\n            for _, t := range tup.([]interface{}) {\n                coordinate = append(coordinate, int(t.(float64)))\n            }\n        }\n        coordinates = append(coordinates, coordinate)\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123934,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpeet290v6_test.go:41: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[] []]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpeet290v6_test.go:41: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[] []]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpeet290v6_test.go:41: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[] []]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    // Initialize the output list.\n    output_list := make([][]int, 0)\n    // Loop through the input list.\n    for _, test_coordinate := range test_tup {\n        // Initialize the coordinate list.\n        coordinate_list := make([]int, 0)\n        // Loop through the coordinate list.\n        for _, coordinate := range test_coordinate.([]interface{}) {\n            // Append the coordinate to the coordinate list.\n            coordinate_list = append(coordinate_list, coordinate.(int))\n        }\n        // Append the coordinate list to the output list.\n        output_list = append(output_list, coordinate_list)\n    }\n    // Return the output list.\n    return output_list\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123934,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc00008c6d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmpfv20jlh8_test.go:17 +0x330\ncommand-line-arguments_test.TestGet_Coordinates(0xc000102600)\n\t/tmp/tmpfv20jlh8_test.go:35 +0xa8\ntesting.tRunner(0xc000102600, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        var tup_list []int\n        for _, value := range tup.([]interface{}) {\n            tup_list = append(tup_list, value.(int))\n        }\n        result = append(result, tup_list)\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123934,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc0000926d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmpqnda8qse_test.go:13 +0x2f9\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmpqnda8qse_test.go:28 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case []int:\n            coordinates = append(coordinates, v.([]int))\n        case []interface{}:\n            coordinates = append(coordinates, get_coordinates(v.([]interface{}))...)\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123934,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmph8mi9gnu_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmph8mi9gnu_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmph8mi9gnu_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case int:\n            result = append(result, []int{v.(int)})\n        case []int:\n            result = append(result, v.([]int))\n        case [][]int:\n            for _, v := range v.([][]int) {\n                result = append(result, v)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123934,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmps4zpf1_x_test.go:41: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3)] [%!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmps4zpf1_x_test.go:41: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4)] [%!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmps4zpf1_x_test.go:41: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5)] [%!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, tup := range test_tup {\n        var coordinate []int\n        for _, val := range tup.([]interface{}) {\n            coordinate = append(coordinate, val.(int))\n        }\n        coordinates = append(coordinates, coordinate)\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc00008c6d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmp4z7netlk_test.go:13 +0x2f9\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmp4z7netlk_test.go:28 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, tup := range test_tup {\n        var coordinate []int\n        for _, num := range tup.([]interface{}) {\n            coordinate = append(coordinate, num.(int))\n        }\n        coordinates = append(coordinates, coordinate)\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123931,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc00008c6d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmppplvnggq_test.go:13 +0x2f9\ncommand-line-arguments_test.TestGet_Coordinates(0xc000102600)\n\t/tmp/tmppplvnggq_test.go:28 +0xa8\ntesting.tRunner(0xc000102600, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []interface{}:\n            coordinates = append(coordinates, get_coordinates(tup.([]interface{}))...)\n        case int:\n            coordinates = append(coordinates, []int{tup.(int), tup.(int)})\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123934,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp1o8ljh0m_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp1o8ljh0m_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp1o8ljh0m_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, tup := range test_tup {\n        tup_slice := tup.([]interface{})\n        var coordinate []int\n        for _, num := range tup_slice {\n            coordinate = append(coordinate, num.(int))\n        }\n        coordinates = append(coordinates, coordinate)\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123931,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc0000926d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmpwbzdusl0_test.go:12 +0x2f9\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmpwbzdusl0_test.go:29 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for i := 0; i < len(test_tup); i++ {\n        var coordinate []int\n        for j := 0; j < len(test_tup[i].([]interface{})); j++ {\n            coordinate = append(coordinate, test_tup[i].([]interface{})[j].(int))\n        }\n        coordinates = append(coordinates, coordinate)\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123934,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x524840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x524840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(...)\n\t/tmp/tmp4hcvcf0h_test.go:13\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmp4hcvcf0h_test.go:28 +0x1665\ntesting.tRunner(0xc000001380, 0x550308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for i := 0; i < len(test_tup); i++ {\n        coordinates = append(coordinates, test_tup[i].([]int))\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123934,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []int [recovered]\n\tpanic: interface conversion: interface {} is int, not []int\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(...)\n\t/tmp/tmpqu44_xsp_test.go:12\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmpqu44_xsp_test.go:24 +0x12d3\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        result = append(result, tup.([]int))\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []int [recovered]\n\tpanic: interface conversion: interface {} is int, not []int\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc00008c6d0, 0x2, 0x2, 0x4cd120, 0x5fa340, 0x609a20)\n\t/tmp/tmp_n3k9zs4_test.go:12 +0x185\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmp_n3k9zs4_test.go:24 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var res [][]int\n    for _, tup := range test_tup {\n        res = append(res, tup.([]int))\n    }\n    return res\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123934,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []int [recovered]\n\tpanic: interface conversion: interface {} is int, not []int\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0001922a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc0001a2300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0001922a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc00008c6d0, 0x2, 0x2, 0x4cd120, 0x5fa340, 0x609a20)\n\t/tmp/tmpx6om8wxn_test.go:12 +0x185\ncommand-line-arguments_test.TestGet_Coordinates(0xc0001a2300)\n\t/tmp/tmpx6om8wxn_test.go:24 +0xa8\ntesting.tRunner(0xc0001a2300, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case []int:\n            result = append(result, v.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(v.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123929,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp9mgxnr0e_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp9mgxnr0e_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp9mgxnr0e_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for i := 0; i < len(test_tup); i++ {\n        var tup []int\n        for j := 0; j < len(test_tup[i].([]interface{})); j++ {\n            tup = append(tup, int(test_tup[i].([]interface{})[j].(float64)))\n        }\n        result = append(result, tup)\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123934,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x524840, 0xc0001922a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc0001a0300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x524840, 0xc0001922a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(...)\n\t/tmp/tmp1ygpc4s3_test.go:13\ncommand-line-arguments_test.TestGet_Coordinates(0xc0001a0300)\n\t/tmp/tmp1ygpc4s3_test.go:28 +0x16e5\ntesting.tRunner(0xc0001a0300, 0x550308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case []int:\n            result = append(result, v.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(v.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123929,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp9mgxnr0e_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp9mgxnr0e_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp9mgxnr0e_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        var tup_list []int\n        for _, num := range tup.([]interface{}) {\n            tup_list = append(tup_list, int(num.(float64)))\n        }\n        result = append(result, tup_list)\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123934,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc0000926d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmp44rc_1as_test.go:13 +0x30b\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmp44rc_1as_test.go:28 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        result = append(result, tup.([]int))\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []int [recovered]\n\tpanic: interface conversion: interface {} is int, not []int\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc00008c6d0, 0x2, 0x2, 0x4cd120, 0x5fa340, 0x609a20)\n\t/tmp/tmp_n3k9zs4_test.go:12 +0x185\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmp_n3k9zs4_test.go:24 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        var x, y int\n        switch tup.(type) {\n        case []int:\n            x, y = tup.([]int)[0], tup.([]int)[1]\n        case []interface{}:\n            x, y = tup.([]interface{})[0].(int), tup.([]interface{})[1].(int)\n        }\n        result = append(result, []int{x, y})\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123934,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpfmi7do5t_test.go:39: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=0) %!s(int=0)] [%!s(int=0) %!s(int=0)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpfmi7do5t_test.go:39: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=0) %!s(int=0)] [%!s(int=0) %!s(int=0)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpfmi7do5t_test.go:39: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=0) %!s(int=0)] [%!s(int=0) %!s(int=0)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            coordinates = append(coordinates, tup.([]int))\n        case [][]int:\n            for _, tup_tup := range tup.([][]int) {\n                coordinates = append(coordinates, tup_tup)\n            }\n        default:\n            fmt.Println(\"Error: Invalid type\")\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123934,
      "stdout": "Error: Invalid type\nError: Invalid type\nError: Invalid type\nError: Invalid type\nError: Invalid type\nError: Invalid type\n--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmptk2_wnpy_test.go:41: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmptk2_wnpy_test.go:41: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmptk2_wnpy_test.go:41: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    // Your code here\n    return [][]int{}\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123934,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp6myfka0o_test.go:29: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp6myfka0o_test.go:29: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp6myfka0o_test.go:29: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        tup_list := tup.([]interface{})\n        var tup_result []int\n        for _, tup_item := range tup_list {\n            tup_result = append(tup_result, int(tup_item.(float64)))\n        }\n        result = append(result, tup_result)\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123934,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc0000926d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmpzvuj26az_test.go:12 +0x30b\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmpzvuj26az_test.go:29 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch t := tup.(type) {\n        case []interface{}:\n            result = append(result, get_coordinates(t)...)\n        case int:\n            result = append(result, []int{t})\n        default:\n            fmt.Println(\"Unexpected type:\", t)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123934,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmph64777si_test.go:39: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3)] [%!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmph64777si_test.go:39: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4)] [%!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmph64777si_test.go:39: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5)] [%!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for i := 0; i < len(test_tup); i++ {\n        var temp []int\n        for j := 0; j < len(test_tup[i].([]interface{})); j++ {\n            temp = append(temp, int(test_tup[i].([]interface{})[j].(float64)))\n        }\n        result = append(result, temp)\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123934,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x524840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x524840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(...)\n\t/tmp/tmp12ljcadp_test.go:13\ncommand-line-arguments_test.TestGet_Coordinates(0xc000102600)\n\t/tmp/tmp12ljcadp_test.go:28 +0x16e5\ntesting.tRunner(0xc000102600, 0x550308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup := tup.(type) {\n        case []interface{}:\n            for _, tup_tup := range tup {\n                switch tup_tup := tup_tup.(type) {\n                case []interface{}:\n                    var temp []int\n                    for _, tup_tup_tup := range tup_tup {\n                        switch tup_tup_tup := tup_tup_tup.(type) {\n                        case int:\n                            temp = append(temp, tup_tup_tup)\n                        }\n                    }\n                    result = append(result, temp)\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123934,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp0yo_gtyk_test.go:47: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp0yo_gtyk_test.go:47: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp0yo_gtyk_test.go:47: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    x := test_tup[0].(int)\n    y := test_tup[1].(int)\n    return [][]int{\n        {x - 1, y},\n        {x + 1, y},\n        {x, y - 1},\n        {x, y + 1},\n    }\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123935,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpc3gafivu_test.go:35: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=2) %!s(int=4)] [%!s(int=4) %!s(int=4)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpc3gafivu_test.go:35: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=3) %!s(int=5)] [%!s(int=5) %!s(int=5)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=6)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpc3gafivu_test.go:35: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=4) %!s(int=6)] [%!s(int=6) %!s(int=6)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=7)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, coord := range test_tup {\n        coordinates = append(coordinates, coord.([]int))\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123935,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []int [recovered]\n\tpanic: interface conversion: interface {} is int, not []int\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc00008c6d0, 0x2, 0x2, 0x4cd120, 0x5fa340, 0x609a20)\n\t/tmp/tmpbh_eh0l__test.go:12 +0x185\ncommand-line-arguments_test.TestGet_Coordinates(0xc000102600)\n\t/tmp/tmpbh_eh0l__test.go:24 +0xa8\ntesting.tRunner(0xc000102600, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            coordinates = append(coordinates, tup.([]int))\n        case [][]int:\n            for _, tup2 := range tup.([][]int) {\n                coordinates = append(coordinates, tup2)\n            }\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123935,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpk5n6hz30_test.go:39: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpk5n6hz30_test.go:39: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpk5n6hz30_test.go:39: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        var temp []int\n        for _, item := range tup.([]interface{}) {\n            temp = append(temp, item.(int))\n        }\n        result = append(result, temp)\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123931,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc00008c6d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmpxv00vzsq_test.go:13 +0x2f9\ncommand-line-arguments_test.TestGet_Coordinates(0xc000102600)\n\t/tmp/tmpxv00vzsq_test.go:28 +0xa8\ntesting.tRunner(0xc000102600, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        result = append(result, tup.([]int))\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []int [recovered]\n\tpanic: interface conversion: interface {} is int, not []int\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc00008c6d0, 0x2, 0x2, 0x4cd120, 0x5fa340, 0x609a20)\n\t/tmp/tmp_n3k9zs4_test.go:12 +0x185\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmp_n3k9zs4_test.go:24 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        tup_list := tup.([]interface{})\n        var temp []int\n        for _, num := range tup_list {\n            temp = append(temp, num.(int))\n        }\n        result = append(result, temp)\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123935,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc00008c6d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmpr59jtlp__test.go:12 +0x2f9\ncommand-line-arguments_test.TestGet_Coordinates(0xc000102600)\n\t/tmp/tmpr59jtlp__test.go:29 +0xa8\ntesting.tRunner(0xc000102600, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var res [][]int\n    for _, tup := range test_tup {\n        tup_list := tup.([]interface{})\n        var tup_int []int\n        for _, val := range tup_list {\n            tup_int = append(tup_int, val.(int))\n        }\n        res = append(res, tup_int)\n    }\n    return res\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123936,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc0000926d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmp2pzsx7yf_test.go:12 +0x2f9\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmp2pzsx7yf_test.go:29 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, tup := range test_tup {\n        tup_slice := tup.([]interface{})\n        var coordinate []int\n        for _, i := range tup_slice {\n            coordinate = append(coordinate, int(i.(float64)))\n        }\n        coordinates = append(coordinates, coordinate)\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123936,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc00008c6d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmp8g1xajag_test.go:12 +0x30b\ncommand-line-arguments_test.TestGet_Coordinates(0xc000102600)\n\t/tmp/tmp8g1xajag_test.go:29 +0xa8\ntesting.tRunner(0xc000102600, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, tup := range test_tup {\n        switch tup := tup.(type) {\n        case []int:\n            coordinates = append(coordinates, tup)\n        case [][]int:\n            for _, tup := range tup {\n                coordinates = append(coordinates, tup)\n            }\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123936,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpprg7bxcc_test.go:39: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpprg7bxcc_test.go:39: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpprg7bxcc_test.go:39: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        case int:\n            result = append(result, []int{tup.(int)})\n        default:\n            fmt.Println(\"Invalid type\")\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123936,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpjy0ots71_test.go:39: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3)] [%!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpjy0ots71_test.go:39: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4)] [%!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpjy0ots71_test.go:39: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5)] [%!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, tup := range test_tup {\n        coordinates = append(coordinates, tup.([]int))\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []int [recovered]\n\tpanic: interface conversion: interface {} is int, not []int\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc000010270)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc000010270)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc00008ced0, 0x2, 0x2, 0x4cd120, 0x5fa340, 0x609a20)\n\t/tmp/tmp91z44zqj_test.go:12 +0x185\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmp91z44zqj_test.go:24 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []interface{}:\n            var tup_list []int\n            for _, tup_item := range tup.([]interface{}) {\n                switch tup_item.(type) {\n                case int:\n                    tup_list = append(tup_list, tup_item.(int))\n                }\n            }\n            result = append(result, tup_list)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123936,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpg2k3icwv_test.go:42: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpg2k3icwv_test.go:42: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpg2k3icwv_test.go:42: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, tup := range test_tup {\n        tup_slice := tup.([]interface{})\n        var coordinate []int\n        for _, num := range tup_slice {\n            coordinate = append(coordinate, num.(int))\n        }\n        coordinates = append(coordinates, coordinate)\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123931,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc0000926d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmpwbzdusl0_test.go:12 +0x2f9\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmpwbzdusl0_test.go:29 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var x, y int\n    var x_list, y_list []int\n    for _, tup := range test_tup {\n        x = tup.([]interface{})[0].(int)\n        y = tup.([]interface{})[1].(int)\n        x_list = append(x_list, x)\n        y_list = append(y_list, y)\n    }\n    for i := 0; i < len(x_list); i++ {\n        for j := 0; j < len(y_list); j++ {\n            if i != j {\n                result = append(result, []int{x_list[i], y_list[j]})\n            }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123936,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x524840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x524840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc0000926d0, 0x2, 0x2, 0x4cd120, 0x5fb3e0, 0x60aa20)\n\t/tmp/tmp4z3serww_test.go:14 +0x47f\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmp4z3serww_test.go:36 +0xa8\ntesting.tRunner(0xc000001380, 0x550308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        var tup_int []int\n        for _, i := range tup.([]interface{}) {\n            tup_int = append(tup_int, i.(int))\n        }\n        result = append(result, tup_int)\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123936,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc0000926d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmp5191supj_test.go:13 +0x2f9\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmp5191supj_test.go:28 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []interface{}:\n            coordinates = append(coordinates, get_coordinates(tup.([]interface{}))...)\n        case int:\n            coordinates = append(coordinates, []int{tup.(int), tup.(int)})\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123934,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp1o8ljh0m_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3) %!s(int=3)] [%!s(int=4) %!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp1o8ljh0m_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4) %!s(int=4)] [%!s(int=5) %!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp1o8ljh0m_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5) %!s(int=5)] [%!s(int=6) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []interface{}:\n            for _, tup_tup := range tup.([]interface{}) {\n                switch tup_tup.(type) {\n                case []interface{}:\n                    var tup_tup_tup []int\n                    for _, tup_tup_tup_tup := range tup_tup.([]interface{}) {\n                        switch tup_tup_tup_tup.(type) {\n                        case int:\n                            tup_tup_tup = append(tup_tup_tup, tup_tup_tup_tup.(int))\n                        }\n                    }\n                    result = append(result, tup_tup_tup)\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123929,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpu8e9830y_test.go:47: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpu8e9830y_test.go:47: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpu8e9830y_test.go:47: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, item := range test_tup {\n        switch item.(type) {\n        case []int:\n            result = append(result, item.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(item.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123936,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpbpgwrosz_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpbpgwrosz_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpbpgwrosz_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        default:\n            fmt.Println(\"Unexpected type:\", tup)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123936,
      "stdout": "Unexpected type: 3\nUnexpected type: 4\nUnexpected type: 4\nUnexpected type: 5\nUnexpected type: 5\nUnexpected type: 6\n--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp3o0e58ce_test.go:39: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp3o0e58ce_test.go:39: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp3o0e58ce_test.go:39: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        tup_slice := tup.([]interface{})\n        var tup_int []int\n        for _, val := range tup_slice {\n            tup_int = append(tup_int, val.(int))\n        }\n        result = append(result, tup_int)\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc00008c6d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmpwrwo6rqs_test.go:12 +0x2f9\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmpwrwo6rqs_test.go:29 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        tup_list := tup.([]interface{})\n        var tup_int []int\n        for _, tup_item := range tup_list {\n            tup_int = append(tup_int, int(tup_item.(float64)))\n        }\n        result = append(result, tup_int)\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123930,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0001922a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc0001a0300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0001922a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc00008c6d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmpezt7krcs_test.go:12 +0x30b\ncommand-line-arguments_test.TestGet_Coordinates(0xc0001a0300)\n\t/tmp/tmpezt7krcs_test.go:29 +0xa8\ntesting.tRunner(0xc0001a0300, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, tup := range test_tup {\n        var coordinate []int\n        for _, num := range tup.([]interface{}) {\n            coordinate = append(coordinate, num.(int))\n        }\n        coordinates = append(coordinates, coordinate)\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123931,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc00008c6d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmppplvnggq_test.go:13 +0x2f9\ncommand-line-arguments_test.TestGet_Coordinates(0xc000102600)\n\t/tmp/tmppplvnggq_test.go:28 +0xa8\ntesting.tRunner(0xc000102600, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            coordinates = append(coordinates, tup.([]int))\n        case []interface{}:\n            coordinates = append(coordinates, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123929,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpb06mycau_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpb06mycau_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpb06mycau_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        tup_slice := tup.([]interface{})\n        var tup_int []int\n        for _, tup_elem := range tup_slice {\n            tup_int = append(tup_int, int(tup_elem.(float64)))\n        }\n        result = append(result, tup_int)\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123936,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc0000926d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmpr4hsbywf_test.go:12 +0x30b\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmpr4hsbywf_test.go:29 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            for _, tup_tup := range tup.([]interface{}) {\n                result = append(result, tup_tup.([]int))\n            }\n        default:\n            fmt.Println(\"Error\")\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123936,
      "stdout": "Error\nError\nError\nError\nError\nError\n--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpr3wxf1h3_test.go:41: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpr3wxf1h3_test.go:41: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpr3wxf1h3_test.go:41: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, tup := range test_tup {\n        tup_slice := tup.([]interface{})\n        var coordinate []int\n        for _, num := range tup_slice {\n            coordinate = append(coordinate, num.(int))\n        }\n        coordinates = append(coordinates, coordinate)\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123931,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc0000926d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmpwbzdusl0_test.go:12 +0x2f9\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmpwbzdusl0_test.go:29 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        var tup_int []int\n        for _, tup_elem := range tup.([]interface{}) {\n            tup_int = append(tup_int, tup_elem.(int))\n        }\n        result = append(result, tup_int)\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123936,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc0000926d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmptgn6dy9r_test.go:13 +0x2f9\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmptgn6dy9r_test.go:28 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        tup_slice := tup.([]interface{})\n        var tup_int []int\n        for _, num := range tup_slice {\n            tup_int = append(tup_int, num.(int))\n        }\n        result = append(result, tup_int)\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123929,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc00008c6d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmpcudlnore_test.go:12 +0x2f9\ncommand-line-arguments_test.TestGet_Coordinates(0xc000102600)\n\t/tmp/tmpcudlnore_test.go:29 +0xa8\ntesting.tRunner(0xc000102600, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case []int:\n            result = append(result, v.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(v.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123929,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp9mgxnr0e_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp9mgxnr0e_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp9mgxnr0e_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    // Initialize the result list.\n    result := make([][]int, 0)\n    // Iterate through the test_tup.\n    for _, test_list := range test_tup {\n        // Convert the test_list to a list of integers.\n        test_list_int := test_list.([]interface{})\n        // Initialize the coordinate list.\n        coordinate_list := make([]int, 0)\n        // Iterate through the test_list_int.\n        for _, coordinate := range test_list_int {\n            // Convert the coordinate to an integer.\n            coordinate_int := coordinate.(int)\n            // Append the coordinate_int to the coordinate_list.\n            coordinate_list = append(coordinate_list, coordinate_int)\n        }\n        // Append the coordinate_list to the result.\n        result = append(result, coordinate_list)\n    }\n    // Return the result.\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123936,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc0000926d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmp02h146ax_test.go:15 +0x32b\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmp02h146ax_test.go:39 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            coordinates = append(coordinates, tup.([]int))\n        case []interface{}:\n            coordinates = append(coordinates, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123929,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpb06mycau_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpb06mycau_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpb06mycau_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []interface{}:\n            coordinates = append(coordinates, get_coordinates(tup.([]interface{}))...)\n        case int:\n            coordinates = append(coordinates, []int{tup.(int)})\n        }\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123936,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp3rrn7wjy_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=3)] [%!s(int=4)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp3rrn7wjy_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=4)] [%!s(int=5)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp3rrn7wjy_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=5)] [%!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    var temp []int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case []interface{}:\n            temp = append(temp, get_coordinates(v.([]interface{}))...)\n        case int:\n            temp = append(temp, v.(int))\n        }\n    }\n    result = append(result, temp)\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123936,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfvk3apip_test.go:15:26: cannot use get_coordinates(v.([]interface {})) (type [][]int) as type []int in append\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        var tup_int []int\n        for _, val := range tup.([]interface{}) {\n            tup_int = append(tup_int, int(val.(float64)))\n        }\n        result = append(result, tup_int)\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123936,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc00008c6d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmp6ft8l4r0_test.go:13 +0x30b\ncommand-line-arguments_test.TestGet_Coordinates(0xc000102600)\n\t/tmp/tmp6ft8l4r0_test.go:28 +0xa8\ntesting.tRunner(0xc000102600, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        result = append(result, tup.([]int))\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []int [recovered]\n\tpanic: interface conversion: interface {} is int, not []int\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc00008c6d0, 0x2, 0x2, 0x4cd120, 0x5fa340, 0x609a20)\n\t/tmp/tmp_n3k9zs4_test.go:12 +0x185\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmp_n3k9zs4_test.go:24 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        result = append(result, tup.([]int))\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []int [recovered]\n\tpanic: interface conversion: interface {} is int, not []int\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc00008c6d0, 0x2, 0x2, 0x4cd120, 0x5fa340, 0x609a20)\n\t/tmp/tmp_n3k9zs4_test.go:12 +0x185\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmp_n3k9zs4_test.go:24 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case []int:\n            result = append(result, v.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(v.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123929,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp9mgxnr0e_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp9mgxnr0e_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp9mgxnr0e_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        tup_list := tup.([]interface{})\n        var tup_list_int []int\n        for _, tup_item := range tup_list {\n            tup_list_int = append(tup_list_int, tup_item.(int))\n        }\n        result = append(result, tup_list_int)\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123936,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc00008c6d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmpcjjvsk5h_test.go:12 +0x2f9\ncommand-line-arguments_test.TestGet_Coordinates(0xc000102600)\n\t/tmp/tmpcjjvsk5h_test.go:29 +0xa8\ntesting.tRunner(0xc000102600, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, v := range test_tup {\n        switch v.(type) {\n        case []int:\n            result = append(result, v.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(v.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123929,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp9mgxnr0e_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp9mgxnr0e_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp9mgxnr0e_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []int:\n            result = append(result, tup.([]int))\n        case []interface{}:\n            result = append(result, get_coordinates(tup.([]interface{}))...)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmp6x901q3a_test.go:37: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        var tup_int []int\n        for _, t := range tup.([]interface{}) {\n            tup_int = append(tup_int, int(t.(float64)))\n        }\n        result = append(result, tup_int)\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123936,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc0000926d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmpna2ykh04_test.go:13 +0x30b\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmpna2ykh04_test.go:28 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var coordinates [][]int\n    for _, tup := range test_tup {\n        coordinates = append(coordinates, tup.([]int))\n    }\n    return coordinates\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []int [recovered]\n\tpanic: interface conversion: interface {} is int, not []int\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc000010270)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc000010270)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc00008ced0, 0x2, 0x2, 0x4cd120, 0x5fa340, 0x609a20)\n\t/tmp/tmp91z44zqj_test.go:12 +0x185\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmp91z44zqj_test.go:24 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        tup_list := tup.([]interface{})\n        var tup_int []int\n        for _, tup_item := range tup_list {\n            tup_int = append(tup_int, tup_item.(int))\n        }\n        result = append(result, tup_int)\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123936,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523840, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_coordinates(0xc0000926d0, 0x2, 0x2, 0x4cd120, 0x5fa380, 0x609a20)\n\t/tmp/tmpnverxhiw_test.go:12 +0x2f9\ncommand-line-arguments_test.TestGet_Coordinates(0xc000001380)\n\t/tmp/tmpnverxhiw_test.go:29 +0xa8\ntesting.tRunner(0xc000001380, 0x54f308)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        switch tup.(type) {\n        case []interface{}:\n            for _, t := range tup.([]interface{}) {\n                switch t.(type) {\n                case []interface{}:\n                    for _, tt := range t.([]interface{}) {\n                        switch tt.(type) {\n                        case []interface{}:\n                            for _, ttt := range tt.([]interface{}) {\n                                switch ttt.(type) {\n                                case []interface{}:\n                                    for _, tttt := range ttt.([]interface{}) {\n                                        switch tttt.(type) {\n                                        case []interface{}:\n                                            for _, ttttt := range tttt.([]interface{}) {\n                                                switch ttttt.(type) {\n                                                case []interface{}:\n                                                    for _, tttttt := range ttttt.([]interface{}) {\n                                                        switch tttttt.(type) {\n                                                        case []interface{}:\n                                                            for _, ttttttt := range tttttt.([]interface{}) {\n                                                                switch ttttttt.(type) {\n                                                                case []interface{}:\n                                                                    for _, tttttttt := range ttttttt.([]interface{}) {\n                                                                        switch tttttttt.(type) {\n                                                                        case []interface{}:\n                                                                            for _, ttttttttt := range tttttttt.([]interface{}) {\n                                                                                switch ttttttttt.(type) {\n                                                                                case []interface{}:\n                                                                                    for _, tttttttttt := range ttttttttt.([]interface{}) {\n                                                                                        switch tttttttttt.(type) {\n                                                                                        case []interface{}:\n                                                                                            for _, ttttttttttt := range tttttttttt.([]interface{}) {\n                                                                                                switch ttttttttt\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123936,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp7elnmdax_test.go:46:6: expected '(', found TestGet_Coordinates\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_coordinates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract all the adjacent coordinates of the given coordinate list.\nfunc get_coordinates(test_tup []interface{}) [][]int {\n    var result [][]int\n    for _, tup := range test_tup {\n        var x, y int\n        switch tup.(type) {\n        case []int:\n            x = tup.([]int)[0]\n            y = tup.([]int)[1]\n        case []interface{}:\n            x = tup.([]interface{})[0].(int)\n            y = tup.([]interface{})[1].(int)\n        }\n        result = append(result, []int{x, y})\n    }\n    return result\n}\n\nfunc TestGet_Coordinates(t *testing.T) {\n  candidate := get_coordinates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}), expected: [][]int{[]int{2, 3}, []int{2, 4}, []int{2, 5}, []int{3, 3}, []int{3, 4}, []int{3, 5}, []int{4, 3}, []int{4, 4}, []int{4, 5}} },\n     { actual: candidate([]interface{}{4, 5}), expected: [][]int{[]int{3, 4}, []int{3, 5}, []int{3, 6}, []int{4, 4}, []int{4, 5}, []int{4, 6}, []int{5, 4}, []int{5, 5}, []int{5, 6}} },\n     { actual: candidate([]interface{}{5, 6}), expected: [][]int{[]int{4, 5}, []int{4, 6}, []int{4, 7}, []int{5, 5}, []int{5, 6}, []int{5, 7}, []int{6, 5}, []int{6, 6}, []int{6, 7}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123936,
      "stdout": "--- FAIL: TestGet_Coordinates (0.00s)\n    --- FAIL: TestGet_Coordinates/test_num__0 (0.00s)\n        tmpzrkjmwyo_test.go:41: expected '[[%!s(int=2) %!s(int=3)] [%!s(int=2) %!s(int=4)] [%!s(int=2) %!s(int=5)] [%!s(int=3) %!s(int=3)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=4) %!s(int=3)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)]]', got '[[%!s(int=0) %!s(int=0)] [%!s(int=0) %!s(int=0)]]'\n    --- FAIL: TestGet_Coordinates/test_num__1 (0.00s)\n        tmpzrkjmwyo_test.go:41: expected '[[%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=5)] [%!s(int=3) %!s(int=6)] [%!s(int=4) %!s(int=4)] [%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=5) %!s(int=4)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)]]', got '[[%!s(int=0) %!s(int=0)] [%!s(int=0) %!s(int=0)]]'\n    --- FAIL: TestGet_Coordinates/test_num__2 (0.00s)\n        tmpzrkjmwyo_test.go:41: expected '[[%!s(int=4) %!s(int=5)] [%!s(int=4) %!s(int=6)] [%!s(int=4) %!s(int=7)] [%!s(int=5) %!s(int=5)] [%!s(int=5) %!s(int=6)] [%!s(int=5) %!s(int=7)] [%!s(int=6) %!s(int=5)] [%!s(int=6) %!s(int=6)] [%!s(int=6) %!s(int=7)]]', got '[[%!s(int=0) %!s(int=0)] [%!s(int=0) %!s(int=0)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}