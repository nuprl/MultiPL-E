{
  "name": "mbpp_635_heap_sort",
  "language": "go_test.go",
  "prompt": "package heap_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given list.\nfunc heap_sort(iterable []int) []int {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_635_heap_sort.py",
  "prompt_terminology": "reworded",
  "tests": "func TestHeap_Sort(t *testing.T) {\n  candidate := heap_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 5, 7, 9, 2, 4, 6, 8, 0}), expected: []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} },\n     { actual: candidate([]int{25, 35, 22, 85, 14, 65, 75, 25, 58}), expected: []int{14, 22, 25, 25, 35, 58, 65, 75, 85} },\n     { actual: candidate([]int{7, 1, 9, 5}), expected: []int{1, 5, 7, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    // Build a max heap.\n    heap := build_max_heap(iterable)\n    for i := len(iterable) - 1; i > 0; i-- {\n        // Swap the first element with the last element.\n        heap[0], heap[i] = heap[i], heap[0]\n        // Rebuild the heap.\n        heap = max_heapify(heap[:i], 0)\n    }\n    return heap\n}\n",
    "    // Build a max heap.\n    for i := len(iterable) / 2; i >= 0; i-- {\n        iterable = heapify(iterable, i, len(iterable))\n    }\n\n    // Sort the heap.\n    for i := len(iterable) - 1; i >= 0; i-- {\n        iterable[0], iterable[i] = iterable[i], iterable[0]\n        iterable = heapify(iterable, 0, i)\n    }\n\n    return iterable\n}\n",
    "    // Build a max heap.\n    for i := len(iterable) / 2; i >= 0; i-- {\n        iterable = heapify(iterable, i, len(iterable))\n    }\n\n    // Swap the first element with the last element and heapify the heap.\n    for i := len(iterable) - 1; i > 0; i-- {\n        iterable[0], iterable[i] = iterable[i], iterable[0]\n        iterable = heapify(iterable, 0, i)\n    }\n\n    return iterable\n}\n",
    "    // Build a max-heap from the list.\n    for i := len(iterable) / 2 - 1; i >= 0; i-- {\n        iterable = heapify(iterable, i, len(iterable))\n    }\n\n    // Extract the root element and heapify the remaining heap.\n    for i := len(iterable) - 1; i >= 0; i-- {\n        iterable[0], iterable[i] = iterable[i], iterable[0]\n        iterable = heapify(iterable, 0, i)\n    }\n\n    return iterable\n}\n",
    "    // Build a max heap.\n    for i := len(iterable) / 2; i >= 0; i-- {\n        iterable = heapify(iterable, i, len(iterable))\n    }\n\n    // Sort the heap.\n    for i := len(iterable) - 1; i >= 0; i-- {\n        iterable[0], iterable[i] = iterable[i], iterable[0]\n        iterable = heapify(iterable, 0, i)\n    }\n\n    return iterable\n}\n",
    "    // Build the heap.\n    for i := len(iterable) / 2; i >= 0; i-- {\n        iterable = heapify(iterable, i, len(iterable))\n    }\n\n    // Sort the heap.\n    for i := len(iterable) - 1; i > 0; i-- {\n        iterable[0], iterable[i] = iterable[i], iterable[0]\n        iterable = heapify(iterable, 0, i)\n    }\n\n    return iterable\n}\n",
    "    // Build a max heap from the list.\n    heap := build_max_heap(iterable)\n\n    // Swap the first and last element of the list.\n    heap.swap(0, len(heap.items) - 1)\n\n    // Pop the last element of the list.\n    heap.pop()\n\n    // Rebuild the heap.\n    heap.max_heapify(0)\n\n    // Repeat the above steps until the heap is empty.\n    for len(heap.items) > 0 {\n        heap.swap(0, len(heap.items) - 1)\n        heap.pop()\n        heap.max_heapify(0)\n    }\n\n    return heap.items\n}\n",
    "    // Build a max-heap from the list.\n    for i := len(iterable) / 2; i >= 0; i-- {\n        iterable = heapify(iterable, i, len(iterable))\n    }\n\n    // Pop the largest element from the heap and put it at the end of the list.\n    for i := len(iterable) - 1; i > 0; i-- {\n        iterable[0], iterable[i] = iterable[i], iterable[0]\n        iterable = heapify(iterable, 0, i)\n    }\n\n    return iterable\n}\n",
    "    // Build the heap.\n    for i := len(iterable) / 2; i >= 0; i-- {\n        iterable = heapify(iterable, i, len(iterable))\n    }\n\n    // Sort the heap.\n    for i := len(iterable) - 1; i > 0; i-- {\n        iterable[0], iterable[i] = iterable[i], iterable[0]\n        iterable = heapify(iterable, 0, i)\n    }\n\n    return iterable\n}\n",
    "    // Build the heap.\n    for i := len(iterable) / 2; i >= 0; i-- {\n        iterable = heapify(iterable, i)\n    }\n\n    // Sort the heap.\n    for i := len(iterable) - 1; i >= 0; i-- {\n        iterable[0], iterable[i] = iterable[i], iterable[0]\n        iterable = heapify(iterable[:i], 0)\n    }\n\n    return iterable\n}\n",
    "    // Build a max heap.\n    for i := len(iterable) / 2; i >= 0; i-- {\n        iterable = heapify(iterable, i, len(iterable))\n    }\n\n    // Swap the first element with the last element, and heapify the rest.\n    for i := len(iterable) - 1; i >= 0; i-- {\n        iterable[0], iterable[i] = iterable[i], iterable[0]\n        iterable = heapify(iterable, 0, i)\n    }\n\n    return iterable\n}\n",
    "    // Build a max-heap from the input data.\n    // The largest item will be stored at the root of the heap.\n    for idx := len(iterable) / 2; idx >= 0; idx-- {\n        iterable = sift_down(iterable, idx, len(iterable) - 1)\n    }\n\n    // Repeatedly extract the largest item from the heap.\n    for end := len(iterable) - 1; end > 0; {\n        iterable[end], iterable[0] = iterable[0], iterable[end]\n        end--\n        iterable = sift_down(iterable, 0, end)\n    }\n\n    return iterable\n}\n",
    "    // Build a max heap from the list.\n    heap := build_max_heap(iterable)\n\n    // Swap the first and last elements of the heap.\n    // Pop the last element from the heap.\n    // Repeat until the heap is empty.\n    for i := len(heap) - 1; i > 0; i-- {\n        heap[0], heap[i] = heap[i], heap[0]\n        heap = heap[:i]\n        heap = max_heapify(heap, 0)\n    }\n\n    return heap\n}\n",
    "    // Build a max heap.\n    for i := len(iterable) / 2; i >= 0; i-- {\n        iterable = heapify(iterable, i)\n    }\n\n    // Swap the first element with the last element.\n    // Then heapify the heap excluding the last element.\n    for i := len(iterable) - 1; i >= 0; i-- {\n        iterable[0], iterable[i] = iterable[i], iterable[0]\n        iterable = heapify(iterable[:i], 0)\n    }\n\n    return iterable\n}\n",
    "    // Build a max heap from the list.\n    heap := build_max_heap(iterable)\n\n    // Swap the first element with the last element.\n    // Pop the max element from the heap.\n    // Repeat until the heap is empty.\n    for i := len(iterable) - 1; i >= 0; i-- {\n        iterable[0], iterable[i] = iterable[i], iterable[0]\n        heap.heap_size--\n        heap.max_heapify(0)\n    }\n\n    return iterable\n}\n",
    "    // Build a max-heap from the iterable.\n    heap := build_max_heap(iterable)\n\n    // Swap the first and last elements of the heap.\n    // Pop the last element from the heap.\n    // Restore the heap.\n    for i := len(heap) - 1; i > 0; i-- {\n        heap[0], heap[i] = heap[i], heap[0]\n        heap = heap[:i]\n        heap = max_heapify(heap, 0)\n    }\n\n    return heap\n}\n",
    "    // Create a heap from the iterable.\n    heap := make([]int, len(iterable))\n    copy(heap, iterable)\n    for i := len(heap) / 2; i >= 0; i-- {\n        heap = heapify(heap, i)\n    }\n\n    // Pop the heap and append the popped element to the end of the list.\n    for i := len(heap) - 1; i >= 0; i-- {\n        heap[0], heap[i] = heap[i], heap[0]\n        heap = heapify(heap[:i], 0)\n    }\n\n    return heap\n}\n",
    "    // Build a max heap from the list.\n    heap := build_max_heap(iterable)\n\n    // Swap the first element with the last element.\n    heap[0], heap[len(heap)-1] = heap[len(heap)-1], heap[0]\n\n    // Pop the last element from the heap.\n    heap = heap[:len(heap)-1]\n\n    // Repeat the process until the heap is empty.\n    if len(heap) > 0 {\n        heap = heap_sort(heap)\n    }\n\n    return heap\n}\n",
    "    // Build the heap in-place.\n    for i := len(iterable) / 2; i >= 0; i-- {\n        iterable = heapify(iterable, i, len(iterable))\n    }\n\n    // Pop the heap.\n    for i := len(iterable) - 1; i > 0; i-- {\n        iterable[0], iterable[i] = iterable[i], iterable[0]\n        iterable = heapify(iterable, 0, i)\n    }\n\n    return iterable\n}\n",
    "    // Build a max heap from the list.\n    for i := len(iterable) / 2; i >= 0; i-- {\n        iterable = heapify(iterable, i, len(iterable))\n    }\n\n    // Swap the first element with the last element.\n    // Pop the last element out of the heap.\n    // Rebuild the heap.\n    for i := len(iterable) - 1; i >= 0; i-- {\n        iterable[0], iterable[i] = iterable[i], iterable[0]\n        iterable = heapify(iterable, 0, i)\n    }\n\n    return iterable\n}\n"
  ]
}