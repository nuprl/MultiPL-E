{
  "name": "mbpp_308_large_product",
  "language": "go_test.go",
  "prompt": "package large_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1 []int, nums2 []int, N int) []int {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_308_large_product.py",
  "prompt_terminology": "reworded",
  "tests": "func TestLarge_Product(t *testing.T) {\n  candidate := large_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 3), expected: []int{60, 54, 50} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 4), expected: []int{60, 54, 50, 48} },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6}, []int{3, 6, 8, 9, 10, 6}, 5), expected: []int{60, 54, 50, 48, 45} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    // sort nums1 and nums2\n    // for each nums1, find the largest N nums2\n    // for each nums2, find the largest N nums1\n    // merge the two lists\n    // return the largest N\n    return nil\n}\n",
    "    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * max_index)\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return []int{}\n    }\n    if N > len(nums1) * len(nums2) {\n        return []int{}\n    }\n    var result []int\n    for i := 0; i < N; i++ {\n        max := 0\n        max_index := 0\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max {\n                    max = nums1[j] * nums2[k]\n                    max_index = j * len(nums2) + k\n                }\n            }\n        }\n        result = append(result, max)\n        nums1 = append(nums1[:max_index / len(nums2)], nums1[max_index / len(nums2) + 1:]...)\n        nums2 = append(nums2[:max_index % len(nums2)], nums2[max_index % len(nums2) + 1:]...)\n    }\n    return result\n}\n",
    "    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max {\n                    max = nums1[j] * nums2[k]\n                    max_index = j\n                }\n            }\n        }\n        result = append(result, max)\n        nums1 = append(nums1[:max_index], nums1[max_index+1:]...)\n    }\n    return result\n}\n",
    "    var res []int\n    for i := 0; i < N; i++ {\n        var max, max_i int\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max {\n                    max = nums1[j] * nums2[k]\n                    max_i = j\n                }\n            }\n        }\n        res = append(res, max)\n        nums1 = append(nums1[:max_i], nums1[max_i+1:]...)\n    }\n    return res\n}\n",
    "    // TODO\n    return []int{}\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return []int{}\n    }\n    if N > len(nums1) * len(nums2) {\n        return []int{}\n    }\n    if N == len(nums1) * len(nums2) {\n        return append(nums1, nums2...)\n    }\n    var res []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max {\n                    max = nums1[j] * nums2[k]\n                    max_index = j * len(nums2) + k\n                }\n            }\n        }\n        res = append(res, max)\n        nums1 = append(nums1[:max_index / len(nums2)], nums1[max_index / len(nums2) + 1:]...)\n        nums2 = append(nums2[:max_index % len(nums2)], nums2[max_index % len(nums2) + 1:]...)\n    }\n    return res\n}\n",
    "    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * max_index)\n    }\n    return result\n}\n",
    "    var result []int\n    var product int\n    for i := 0; i < N; i++ {\n        product = 0\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > product {\n                    product = nums1[j] * nums2[k]\n                }\n            }\n        }\n        result = append(result, product)\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] == product {\n                    nums1[j] = 0\n                    nums2[k] = 0\n                }\n            }\n        }\n    }\n    return result\n}\n",
    "    var result []int\n    for i := 0; i < N; i++ {\n        max1, max2 := 0, 0\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > nums1[max1] {\n                max1 = j\n            }\n        }\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > nums2[max2] {\n                max2 = j\n            }\n        }\n        result = append(result, nums1[max1] * nums2[max2])\n        nums1[max1] = 0\n        nums2[max2] = 0\n    }\n    return result\n}\n",
    "    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max {\n                    max = nums1[j] * nums2[k]\n                    max_index = j\n                }\n            }\n        }\n        result = append(result, max)\n        nums1 = append(nums1[:max_index], nums1[max_index+1:]...)\n    }\n    return result\n}\n",
    "    // sort nums1 and nums2\n    // for each element in nums1, find the N largest elements in nums2\n    // for each element in nums2, find the N largest elements in nums1\n    // merge the two lists and return the first N elements\n    return []int{}\n}\n",
    "    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        for _, num1 := range nums1 {\n            for _, num2 := range nums2 {\n                if num1 * num2 > max {\n                    max = num1 * num2\n                }\n            }\n        }\n        result = append(result, max)\n        for j, num1 := range nums1 {\n            if num1 * nums2[0] == max {\n                nums1 = append(nums1[:j], nums1[j+1:]...)\n                break\n            }\n        }\n        for j, num2 := range nums2 {\n            if num2 * nums1[0] == max {\n                nums2 = append(nums2[:j], nums2[j+1:]...)\n                break\n            }\n        }\n    }\n    return result\n}\n",
    "    var result []int\n    var i, j int\n    for i = 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j = 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j = 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n                max_index = j\n            }\n        }\n        nums2[max_index] = 0\n        result = append(result, max)\n    }\n    return result\n}\n",
    "    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * nums1[max_index])\n    }\n    return result\n}\n",
    "    // TODO:\n    return []int{}\n}\n",
    "    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] > max {\n                max = nums1[j]\n                max_index = j\n            }\n        }\n        nums1[max_index] = 0\n        max = 0\n        for j := 0; j < len(nums2); j++ {\n            if nums2[j] > max {\n                max = nums2[j]\n            }\n        }\n        result = append(result, max * nums1[max_index])\n    }\n    return result\n}\n",
    "    var res []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max {\n                    max = nums1[j] * nums2[k]\n                    max_index = j\n                }\n            }\n        }\n        res = append(res, max)\n        nums1 = append(nums1[:max_index], nums1[max_index+1:]...)\n    }\n    return res\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return []int{}\n    }\n    if N > len(nums1) * len(nums2) {\n        return []int{}\n    }\n    result := make([]int, N)\n    for i := 0; i < N; i++ {\n        result[i] = -1\n    }\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            product := nums1[i] * nums2[j]\n            if product > result[N-1] {\n                result[N-1] = product\n                for k := N - 1; k > 0; k-- {\n                    if result[k] > result[k-1] {\n                        result[k], result[k-1] = result[k-1], result[k]\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n",
    "    var result []int\n    for i := 0; i < N; i++ {\n        var max int\n        var max_index int\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] * nums2[k] > max {\n                    max = nums1[j] * nums2[k]\n                    max_index = j\n                }\n            }\n        }\n        result = append(result, max)\n        nums1 = append(nums1[:max_index], nums1[max_index+1:]...)\n    }\n    return result\n}\n"
  ]
}