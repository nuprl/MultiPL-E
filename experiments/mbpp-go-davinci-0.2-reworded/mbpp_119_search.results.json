{
  "name": "mbpp_119_search",
  "language": "go_test.go",
  "prompt": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_119_search.py",
  "prompt_terminology": "reworded",
  "tests": "func TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        return search(arr[mid + 1:])\n    } else if arr[mid] == arr[mid + 1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpn6nkdqi2_test.go:47: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpn6nkdqi2_test.go:47: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        if mid % 2 == 0 {\n            return search(arr[mid+1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid+1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid-1])\n        } else {\n            return search(arr[:mid])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmprirab1vi_test.go:59: expected '%!s(int=3)', got '%!s(int=1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmprirab1vi_test.go:59: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return 0\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    } else if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpuu4naiw9_test.go:48: expected '%!s(int=3)', got '%!s(int=0)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpuu4naiw9_test.go:48: expected '%!s(int=8)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    } else if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmp_thw1673_test.go:48: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmp_thw1673_test.go:48: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    var i int\n    for i = 0; i < len(arr); i++ {\n        if i == 0 {\n            if arr[i] != arr[i+1] {\n                return arr[i]\n            }\n        } else if i == len(arr)-1 {\n            if arr[i] != arr[i-1] {\n                return arr[i]\n            }\n        } else {\n            if arr[i] != arr[i-1] && arr[i] != arr[i+1] {\n                return arr[i]\n            }\n        }\n    }\n    return -1\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    } else if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpann53r2__test.go:47: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpann53r2__test.go:47: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    mid := len(arr) / 2\n    if mid % 2 == 0 {\n        if arr[mid] == arr[mid-1] {\n            return search(arr[mid+1:])\n        } else {\n            return search(arr[:mid])\n        }\n    } else {\n        if arr[mid] == arr[mid-1] {\n            return search(arr[:mid-1])\n        } else {\n            return search(arr[mid+1:])\n        }\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpbva7p86u_test.go:47: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpbva7p86u_test.go:47: expected '%!s(int=8)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__2 (0.00s)\n        tmpbva7p86u_test.go:47: expected '%!s(int=1)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    var i int\n    for i = 0; i < len(arr) - 1; i++ {\n        if arr[i] != arr[i+1] {\n            return arr[i]\n        }\n        i++\n    }\n    return arr[i]\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        }\n        return arr[0]\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        return search(arr[mid + 1:])\n    }\n    if arr[mid] == arr[mid + 1] {\n        return search(arr[:mid])\n    }\n    return arr[mid]\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpnxmj3o4n_test.go:47: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpnxmj3o4n_test.go:47: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return 0\n        }\n        return arr[0]\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    }\n    if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    }\n    return arr[mid]\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpia9xay0s_test.go:47: expected '%!s(int=3)', got '%!s(int=0)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpia9xay0s_test.go:47: expected '%!s(int=8)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if mid % 2 == 0 {\n        if arr[mid] == arr[mid - 1] {\n            return search(arr[mid + 1:])\n        } else {\n            return search(arr[:mid])\n        }\n    } else {\n        if arr[mid] == arr[mid - 1] {\n            return search(arr[:mid - 1])\n        } else {\n            return search(arr[mid + 1:])\n        }\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmp4yogql8x_test.go:54: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmp4yogql8x_test.go:54: expected '%!s(int=8)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__2 (0.00s)\n        tmp4yogql8x_test.go:54: expected '%!s(int=1)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        if mid % 2 == 0 {\n            return search(arr[mid + 1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid + 1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid - 1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpazoznvdm_test.go:53: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpazoznvdm_test.go:53: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        if mid % 2 == 0 {\n            return search(arr[mid + 1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid + 1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid - 1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\npanic: runtime error: index out of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of range [2] with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.search(0xc00008c6b8, 0x2, 0x6, 0x1)\n\t/tmp/tmpjtu1mcmu_test.go:23 +0x1c6\ncommand-line-arguments_test.search(0xc00008c6b8, 0x6, 0x6, 0x1)\n\t/tmp/tmpjtu1mcmu_test.go:27 +0x171\ncommand-line-arguments_test.search(0xc00008c690, 0xb, 0xb, 0x1)\n\t/tmp/tmpjtu1mcmu_test.go:21 +0xf9\ncommand-line-arguments_test.TestSearch(0xc000001380)\n\t/tmp/tmpjtu1mcmu_test.go:42 +0x18c\ntesting.tRunner(0xc000001380, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        return search(arr[mid + 1:])\n    } else if arr[mid] == arr[mid + 1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpjqeyhej1_test.go:45: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpjqeyhej1_test.go:45: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        if mid % 2 == 0 {\n            return search(arr[mid+1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid+1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid-1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpwhhhgdzv_test.go:56: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpwhhhgdzv_test.go:56: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    for i := 0; i < len(arr); i++ {\n        if i == 0 {\n            if arr[i] != arr[i+1] {\n                return arr[i]\n            }\n        } else if i == len(arr) - 1 {\n            if arr[i] != arr[i-1] {\n                return arr[i]\n            }\n        } else {\n            if arr[i] != arr[i-1] && arr[i] != arr[i+1] {\n                return arr[i]\n            }\n        }\n    }\n    return -1\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        return search(arr[mid + 1:])\n    } else if arr[mid] == arr[mid + 1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpunnslamc_test.go:48: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpunnslamc_test.go:48: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        if mid % 2 == 0 {\n            return search(arr[mid + 1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid + 1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid - 1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmp5wcarche_test.go:56: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmp5wcarche_test.go:56: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        }\n        return arr[0]\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        return search(arr[mid + 1:])\n    }\n    if arr[mid] == arr[mid + 1] {\n        return search(arr[:mid])\n    }\n    return arr[mid]\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpi60c4k24_test.go:44: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpi60c4k24_test.go:44: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    if len(arr) == 3 {\n        if arr[0] == arr[1] {\n            return arr[2]\n        } else if arr[1] == arr[2] {\n            return arr[0]\n        } else {\n            return arr[1]\n        }\n    }\n    if len(arr) == 4 {\n        if arr[0] == arr[1] {\n            if arr[2] == arr[3] {\n                return -1\n            } else {\n                return arr[2]\n            }\n        } else if arr[1] == arr[2] {\n            return arr[0]\n        } else if arr[2] == arr[3] {\n            return arr[1]\n        } else {\n            return arr[2]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    } else if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmp78xfh4fm_test.go:69: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmp78xfh4fm_test.go:69: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] != arr[mid-1] && arr[mid] != arr[mid+1] {\n        return arr[mid]\n    }\n    if arr[mid] == arr[mid-1] {\n        if mid % 2 == 0 {\n            return search(arr[mid+1:])\n        } else {\n            return search(arr[:mid-1])\n        }\n    }\n    if mid % 2 == 0 {\n        return search(arr[:mid-1])\n    } else {\n        return search(arr[mid+1:])\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpovb9tlfe_test.go:56: expected '%!s(int=3)', got '%!s(int=1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpovb9tlfe_test.go:56: expected '%!s(int=8)', got '%!s(int=1)'\n    --- FAIL: TestSearch/test_num__2 (0.00s)\n        tmpovb9tlfe_test.go:56: expected '%!s(int=1)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        if mid % 2 == 0 {\n            return search(arr[mid+1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid+1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid-1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpwhhhgdzv_test.go:56: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpwhhhgdzv_test.go:56: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        return search(arr[mid + 1:])\n    } else if arr[mid] == arr[mid + 1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpjqeyhej1_test.go:45: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpjqeyhej1_test.go:45: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if arr[0] != arr[1] {\n        return arr[0]\n    }\n    if arr[len(arr)-1] != arr[len(arr)-2] {\n        return arr[len(arr)-1]\n    }\n    mid := len(arr) / 2\n    if arr[mid] != arr[mid-1] && arr[mid] != arr[mid+1] {\n        return arr[mid]\n    }\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    }\n    return search(arr[:mid])\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    } else if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmp_thw1673_test.go:48: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmp_thw1673_test.go:48: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        }\n        return arr[0]\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    }\n    if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    }\n    return arr[mid]\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmph63yhyao_test.go:44: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmph63yhyao_test.go:44: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return 0\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    } else if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpuu4naiw9_test.go:48: expected '%!s(int=3)', got '%!s(int=0)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpuu4naiw9_test.go:48: expected '%!s(int=8)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        if mid % 2 == 0 {\n            return search(arr[mid+1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid+1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid-1])\n        } else {\n            return search(arr[:mid])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmprirab1vi_test.go:59: expected '%!s(int=3)', got '%!s(int=1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmprirab1vi_test.go:59: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        }\n        return arr[0]\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        if mid % 2 == 0 {\n            return search(arr[mid + 1:])\n        } else {\n            return search(arr[mid:])\n        }\n    }\n    if arr[mid] == arr[mid + 1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid - 1])\n        }\n    }\n    return arr[mid]\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpfswwi75z_test.go:55: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpfswwi75z_test.go:55: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        if mid % 2 == 0 {\n            return search(arr[mid+1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid+1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid-1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpwhhhgdzv_test.go:56: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpwhhhgdzv_test.go:56: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    } else if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmp_thw1673_test.go:48: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmp_thw1673_test.go:48: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        if mid % 2 == 0 {\n            return search(arr[mid+1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid+1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid-1])\n        } else {\n            return search(arr[:mid])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpmu20crvl_test.go:56: expected '%!s(int=3)', got '%!s(int=1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpmu20crvl_test.go:56: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if arr[0] != arr[1] {\n        return arr[0]\n    }\n    if arr[len(arr)-1] != arr[len(arr)-2] {\n        return arr[len(arr)-1]\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    } else {\n        return search(arr[:mid])\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    mid := len(arr) / 2\n\n    if arr[mid] == arr[mid - 1] {\n        return search(arr[mid + 1:])\n    } else if arr[mid] == arr[mid + 1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "--- FAIL: TestSearch (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 33 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000154000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102480)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000154000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.search(0xc000090640, 0x0, 0x3, 0x582483)\n\t/tmp/tmpd6lyiyl3_test.go:16 +0x132\ncommand-line-arguments_test.search(0xc000090630, 0x2, 0x5, 0xc000126698)\n\t/tmp/tmpd6lyiyl3_test.go:17 +0xee\ncommand-line-arguments_test.search(0xc000090630, 0x5, 0x5, 0x0)\n\t/tmp/tmpd6lyiyl3_test.go:19 +0x8e\ncommand-line-arguments_test.TestSearch(0xc000102480)\n\t/tmp/tmpd6lyiyl3_test.go:32 +0xa2\ntesting.tRunner(0xc000102480, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] != arr[1] {\n            return arr[0]\n        }\n        return -1\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    }\n    if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    }\n    return arr[mid]\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpnmbyiea5_test.go:44: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpnmbyiea5_test.go:44: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    var i int\n    for i = 0; i < len(arr) - 1; i++ {\n        if arr[i] != arr[i + 1] {\n            return arr[i]\n        }\n        i++\n    }\n    return arr[i]\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    var i int\n    for i = 0; i < len(arr); i++ {\n        if i == 0 {\n            if arr[i] != arr[i+1] {\n                return arr[i]\n            }\n        } else if i == len(arr)-1 {\n            if arr[i] != arr[i-1] {\n                return arr[i]\n            }\n        } else {\n            if arr[i] != arr[i-1] && arr[i] != arr[i+1] {\n                return arr[i]\n            }\n        }\n    }\n    return -1\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return 0\n        }\n        return arr[0]\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    }\n    if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    }\n    return arr[mid]\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpia9xay0s_test.go:47: expected '%!s(int=3)', got '%!s(int=0)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpia9xay0s_test.go:47: expected '%!s(int=8)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return 0\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    }\n    if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    }\n    return arr[mid]\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpxiriqjo6_test.go:48: expected '%!s(int=3)', got '%!s(int=0)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpxiriqjo6_test.go:48: expected '%!s(int=8)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    } else if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpuw99px7o_test.go:45: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpuw99px7o_test.go:45: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return 0\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if mid % 2 == 0 {\n        if arr[mid] == arr[mid - 1] {\n            return search(arr[mid + 1:])\n        } else if arr[mid] == arr[mid + 1] {\n            return search(arr[:mid])\n        } else {\n            return arr[mid]\n        }\n    } else {\n        if arr[mid] == arr[mid - 1] {\n            return search(arr[:mid - 1])\n        } else if arr[mid] == arr[mid + 1] {\n            return search(arr[mid + 2:])\n        } else {\n            return arr[mid]\n        }\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpu1dsefvr_test.go:58: expected '%!s(int=3)', got '%!s(int=0)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpu1dsefvr_test.go:58: expected '%!s(int=8)', got '%!s(int=0)'\n    --- FAIL: TestSearch/test_num__2 (0.00s)\n        tmpu1dsefvr_test.go:58: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        return arr[0] ^ arr[1]\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    }\n    if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    }\n    return arr[mid]\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpl9vyug0n_test.go:44: expected '%!s(int=3)', got '%!s(int=0)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpl9vyug0n_test.go:44: expected '%!s(int=8)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    var i int\n    for i = 0; i < len(arr); i++ {\n        if i == 0 {\n            if arr[i] != arr[i+1] {\n                return arr[i]\n            }\n        } else if i == len(arr) - 1 {\n            if arr[i] != arr[i-1] {\n                return arr[i]\n            }\n        } else {\n            if arr[i] != arr[i-1] && arr[i] != arr[i+1] {\n                return arr[i]\n            }\n        }\n    }\n    return -1\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    } else if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmp_thw1673_test.go:48: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmp_thw1673_test.go:48: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        if mid % 2 == 0 {\n            return search(arr[mid + 1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid + 1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid + 1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpl2cm2a8__test.go:53: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpl2cm2a8__test.go:53: expected '%!s(int=8)', got '%!s(int=7)'\n    --- FAIL: TestSearch/test_num__2 (0.00s)\n        tmpl2cm2a8__test.go:53: expected '%!s(int=1)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return 0\n        } else {\n            return arr[0]\n        }\n    }\n\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        return search(arr[mid + 1:])\n    } else if arr[mid] == arr[mid + 1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpttih2ciu_test.go:47: expected '%!s(int=3)', got '%!s(int=0)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpttih2ciu_test.go:47: expected '%!s(int=8)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        if mid % 2 == 0 {\n            return search(arr[mid + 1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid + 1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid - 1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmp5wcarche_test.go:56: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmp5wcarche_test.go:56: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        if mid % 2 == 0 {\n            return search(arr[mid + 1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid + 1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid - 1])\n        } else {\n            return search(arr[:mid])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmp1ycef0wu_test.go:56: expected '%!s(int=3)', got '%!s(int=1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmp1ycef0wu_test.go:56: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    if arr[0] != arr[1] {\n        return arr[0]\n    }\n\n    if arr[len(arr) - 1] != arr[len(arr) - 2] {\n        return arr[len(arr) - 1]\n    }\n\n    return search(arr[1:len(arr) - 1])\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    } else if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "--- FAIL: TestSearch (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.search(0xc000092640, 0x0, 0x3, 0x582483)\n\t/tmp/tmpwwi5c8hn_test.go:15 +0x132\ncommand-line-arguments_test.search(0xc000092630, 0x2, 0x5, 0xc0000c6aa8)\n\t/tmp/tmpwwi5c8hn_test.go:16 +0xee\ncommand-line-arguments_test.search(0xc000092630, 0x5, 0x5, 0x0)\n\t/tmp/tmpwwi5c8hn_test.go:18 +0x8e\ncommand-line-arguments_test.TestSearch(0xc000001380)\n\t/tmp/tmpwwi5c8hn_test.go:31 +0xa2\ntesting.tRunner(0xc000001380, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        return search(arr[mid + 1:])\n    } else if arr[mid] == arr[mid + 1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpjqeyhej1_test.go:45: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpjqeyhej1_test.go:45: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        if mid % 2 == 0 {\n            return search(arr[mid + 1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid + 1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid - 1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmp5wcarche_test.go:56: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmp5wcarche_test.go:56: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        return search(arr[mid + 1:])\n    } else if arr[mid] == arr[mid + 1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpunnslamc_test.go:48: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpunnslamc_test.go:48: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        if mid % 2 == 0 {\n            return search(arr[mid + 1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid + 1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid - 1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmp5wcarche_test.go:56: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmp5wcarche_test.go:56: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    } else if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpuw99px7o_test.go:45: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpuw99px7o_test.go:45: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        return search(arr[mid + 1:])\n    } else if arr[mid] == arr[mid + 1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpn6nkdqi2_test.go:47: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpn6nkdqi2_test.go:47: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        return search(arr[mid + 1:])\n    } else if arr[mid] == arr[mid + 1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpn6nkdqi2_test.go:47: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpn6nkdqi2_test.go:47: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        return search(arr[mid + 1:])\n    } else if arr[mid] == arr[mid + 1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpjqeyhej1_test.go:45: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpjqeyhej1_test.go:45: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    if len(arr) == 3 {\n        if arr[0] == arr[1] {\n            return arr[2]\n        } else if arr[1] == arr[2] {\n            return arr[0]\n        } else {\n            return arr[1]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    } else if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmp3di4uumc_test.go:54: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmp3di4uumc_test.go:54: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        return search(arr[mid + 1:])\n    } else if arr[mid] == arr[mid + 1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpjqeyhej1_test.go:45: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpjqeyhej1_test.go:45: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    if len(arr) == 3 {\n        if arr[0] == arr[1] {\n            return arr[2]\n        } else if arr[1] == arr[2] {\n            return arr[0]\n        } else {\n            return arr[1]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        return search(arr[mid + 1:])\n    } else if arr[mid] == arr[mid + 1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpjlmq43mr_test.go:54: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpjlmq43mr_test.go:54: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        if mid % 2 == 0 {\n            return search(arr[mid + 1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid + 1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid - 1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmp5wcarche_test.go:56: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmp5wcarche_test.go:56: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        if mid % 2 == 0 {\n            return search(arr[mid:])\n        } else {\n            return search(arr[mid + 1:])\n        }\n    } else if arr[mid] == arr[mid + 1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid - 1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpngt1yt0s_test.go:56: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpngt1yt0s_test.go:56: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        return search(arr[mid + 1:])\n    } else if arr[mid] == arr[mid + 1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpn6nkdqi2_test.go:47: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpn6nkdqi2_test.go:47: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    var i int\n    for i = 0; i < len(arr) - 1; i++ {\n        if arr[i] != arr[i + 1] {\n            return arr[i]\n        }\n        i++\n    }\n    return arr[i]\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        return search(arr[mid + 1:])\n    } else if arr[mid] == arr[mid + 1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpn6nkdqi2_test.go:47: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpn6nkdqi2_test.go:47: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        if mid % 2 == 0 {\n            return search(arr[mid+1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid+1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid-1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "--- FAIL: TestSearch (0.00s)\npanic: runtime error: index out of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of range [2] with length 2\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000158000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000158000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.search(0xc00008c6b8, 0x2, 0x6, 0x1)\n\t/tmp/tmptvth4orw_test.go:23 +0x1c6\ncommand-line-arguments_test.search(0xc00008c6b8, 0x6, 0x6, 0x1)\n\t/tmp/tmptvth4orw_test.go:27 +0x171\ncommand-line-arguments_test.search(0xc00008c690, 0xb, 0xb, 0x1)\n\t/tmp/tmptvth4orw_test.go:21 +0xf9\ncommand-line-arguments_test.TestSearch(0xc000102600)\n\t/tmp/tmptvth4orw_test.go:42 +0x18c\ntesting.tRunner(0xc000102600, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        if mid % 2 == 0 {\n            return search(arr[mid+1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid+1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid-1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpwhhhgdzv_test.go:56: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpwhhhgdzv_test.go:56: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 3 {\n        if arr[0] == arr[1] {\n            return arr[2]\n        }\n        if arr[1] == arr[2] {\n            return arr[0]\n        }\n        return arr[1]\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        return search(arr[mid + 1:])\n    }\n    if arr[mid] == arr[mid + 1] {\n        return search(arr[:mid])\n    }\n    return arr[mid]\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123265,
      "stdout": "--- FAIL: TestSearch (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.search(0xc000092640, 0x0, 0x3, 0x582483)\n\t/tmp/tmprqn6830l_test.go:23 +0x18b\ncommand-line-arguments_test.search(0xc000092630, 0x2, 0x5, 0xc0000c6aa8)\n\t/tmp/tmprqn6830l_test.go:24 +0x14b\ncommand-line-arguments_test.search(0xc000092630, 0x5, 0x5, 0x0)\n\t/tmp/tmprqn6830l_test.go:27 +0xeb\ncommand-line-arguments_test.TestSearch(0xc000001380)\n\t/tmp/tmprqn6830l_test.go:39 +0xa2\ntesting.tRunner(0xc000001380, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        return search(arr[mid + 1:])\n    } else if arr[mid] == arr[mid + 1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpunnslamc_test.go:48: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpunnslamc_test.go:48: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    } else if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpuw99px7o_test.go:45: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpuw99px7o_test.go:45: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    } else if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpann53r2__test.go:47: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpann53r2__test.go:47: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    } else if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "--- FAIL: TestSearch (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.search(0xc000092640, 0x0, 0x3, 0x582483)\n\t/tmp/tmpwwi5c8hn_test.go:15 +0x132\ncommand-line-arguments_test.search(0xc000092630, 0x2, 0x5, 0xc0000c6aa8)\n\t/tmp/tmpwwi5c8hn_test.go:16 +0xee\ncommand-line-arguments_test.search(0xc000092630, 0x5, 0x5, 0x0)\n\t/tmp/tmpwwi5c8hn_test.go:18 +0x8e\ncommand-line-arguments_test.TestSearch(0xc000001380)\n\t/tmp/tmpwwi5c8hn_test.go:31 +0xa2\ntesting.tRunner(0xc000001380, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    } else if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "--- FAIL: TestSearch (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.search(0xc000092640, 0x0, 0x3, 0x582483)\n\t/tmp/tmpwwi5c8hn_test.go:15 +0x132\ncommand-line-arguments_test.search(0xc000092630, 0x2, 0x5, 0xc0000c6aa8)\n\t/tmp/tmpwwi5c8hn_test.go:16 +0xee\ncommand-line-arguments_test.search(0xc000092630, 0x5, 0x5, 0x0)\n\t/tmp/tmpwwi5c8hn_test.go:18 +0x8e\ncommand-line-arguments_test.TestSearch(0xc000001380)\n\t/tmp/tmpwwi5c8hn_test.go:31 +0xa2\ntesting.tRunner(0xc000001380, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    mid := len(arr) / 2\n    if mid % 2 == 0 {\n        if arr[mid] == arr[mid - 1] {\n            return search(arr[mid + 1:])\n        } else {\n            return search(arr[:mid])\n        }\n    } else {\n        if arr[mid] == arr[mid - 1] {\n            return search(arr[:mid - 1])\n        } else {\n            return search(arr[mid + 1:])\n        }\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123265,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpe65uzt7r_test.go:47: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpe65uzt7r_test.go:47: expected '%!s(int=8)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__2 (0.00s)\n        tmpe65uzt7r_test.go:47: expected '%!s(int=1)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.009s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        if mid % 2 == 0 {\n            return search(arr[mid+1:])\n        } else {\n            return search(arr[mid:])\n        }\n    }\n    if arr[mid] == arr[mid+1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid-1])\n        }\n    }\n    return arr[mid]\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123265,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpnnxbwee0_test.go:56: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpnnxbwee0_test.go:56: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        if mid % 2 == 0 {\n            return search(arr[mid + 1:])\n        } else {\n            return search(arr[:mid - 1])\n        }\n    } else if arr[mid] == arr[mid + 1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid - 1])\n        } else {\n            return search(arr[mid + 1:])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123265,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpr19npua5_test.go:49: expected '%!s(int=3)', got '%!s(int=1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpr19npua5_test.go:49: expected '%!s(int=8)', got '%!s(int=1)'\n    --- FAIL: TestSearch/test_num__2 (0.00s)\n        tmpr19npua5_test.go:49: expected '%!s(int=1)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        }\n        return arr[0]\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    }\n    if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    }\n    return arr[mid]\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123265,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmprt6w5p8g_test.go:47: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmprt6w5p8g_test.go:47: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        if mid % 2 == 0 {\n            return search(arr[mid+1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid+1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid-1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpwhhhgdzv_test.go:56: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpwhhhgdzv_test.go:56: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        return search(arr[mid + 1:])\n    } else if arr[mid] == arr[mid + 1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpjqeyhej1_test.go:45: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpjqeyhej1_test.go:45: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] != arr[1] {\n            return arr[0]\n        } else {\n            return -1\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        return search(arr[mid + 1:])\n    } else if arr[mid] == arr[mid + 1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123265,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmp8gg8fnk8_test.go:45: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmp8gg8fnk8_test.go:45: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    mid := len(arr) / 2\n\n    if mid % 2 == 0 {\n        if arr[mid] == arr[mid - 1] {\n            return search(arr[mid + 1:])\n        } else {\n            return search(arr[:mid])\n        }\n    } else {\n        if arr[mid] == arr[mid - 1] {\n            return search(arr[:mid - 1])\n        } else {\n            return search(arr[mid + 1:])\n        }\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123265,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpq3jtcuh0_test.go:50: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpq3jtcuh0_test.go:50: expected '%!s(int=8)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__2 (0.00s)\n        tmpq3jtcuh0_test.go:50: expected '%!s(int=1)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if arr[0] != arr[1] {\n        return arr[0]\n    }\n    if arr[len(arr)-1] != arr[len(arr)-2] {\n        return arr[len(arr)-1]\n    }\n    mid := len(arr)/2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    }\n    return search(arr[:mid])\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123265,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    for i := 0; i < len(arr); i += 2 {\n        if i == len(arr) - 1 {\n            return arr[i]\n        }\n        if arr[i] != arr[i + 1] {\n            return arr[i]\n        }\n    }\n    return -1\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123265,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        if mid % 2 == 0 {\n            return search(arr[mid + 1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid + 1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid - 1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmp5wcarche_test.go:56: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmp5wcarche_test.go:56: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return 0\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        if mid % 2 == 0 {\n            return search(arr[mid + 1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid + 1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid - 1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123265,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpvj2_u0_6_test.go:56: expected '%!s(int=3)', got '%!s(int=0)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpvj2_u0_6_test.go:56: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid-1])\n        } else {\n            return search(arr[mid+1:])\n        }\n    } else if arr[mid] == arr[mid+1] {\n        if mid % 2 == 0 {\n            return search(arr[mid+2:])\n        } else {\n            return search(arr[:mid-1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123265,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    var i int\n    for i = 0; i < len(arr); i++ {\n        if i == 0 {\n            if arr[i] != arr[i+1] {\n                return arr[i]\n            }\n        } else if i == len(arr) - 1 {\n            if arr[i] != arr[i-1] {\n                return arr[i]\n            }\n        } else {\n            if arr[i] != arr[i-1] && arr[i] != arr[i+1] {\n                return arr[i]\n            }\n        }\n    }\n    return -1\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    } else if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpuw99px7o_test.go:45: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpuw99px7o_test.go:45: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        if mid % 2 == 0 {\n            return search(arr[mid + 1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid + 1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid - 1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123265,
      "stdout": "--- FAIL: TestSearch (0.00s)\npanic: runtime error: index out of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of range [2] with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.search(0xc0000926b8, 0x2, 0x6, 0x1)\n\t/tmp/tmp5maflpl2_test.go:25 +0x1c6\ncommand-line-arguments_test.search(0xc0000926b8, 0x6, 0x6, 0x1)\n\t/tmp/tmp5maflpl2_test.go:29 +0x171\ncommand-line-arguments_test.search(0xc000092690, 0xb, 0xb, 0x1)\n\t/tmp/tmp5maflpl2_test.go:23 +0xf9\ncommand-line-arguments_test.TestSearch(0xc000001380)\n\t/tmp/tmp5maflpl2_test.go:44 +0x18c\ntesting.tRunner(0xc000001380, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        if mid % 2 == 0 {\n            return search(arr[mid+1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid+1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid-1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpwhhhgdzv_test.go:56: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpwhhhgdzv_test.go:56: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        return search(arr[mid + 1:])\n    } else if arr[mid] == arr[mid + 1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpunnslamc_test.go:48: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpunnslamc_test.go:48: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    } else if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpuw99px7o_test.go:45: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpuw99px7o_test.go:45: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        if mid % 2 == 0 {\n            return search(arr[mid + 1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid + 1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid - 1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmp5wcarche_test.go:56: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmp5wcarche_test.go:56: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return 0\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        return search(arr[mid + 1:])\n    } else if arr[mid] == arr[mid + 1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123265,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpa4mp5y3j_test.go:45: expected '%!s(int=3)', got '%!s(int=0)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpa4mp5y3j_test.go:45: expected '%!s(int=8)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        if mid % 2 == 0 {\n            return search(arr[mid + 1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid + 1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid - 1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmp5wcarche_test.go:56: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmp5wcarche_test.go:56: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        if mid % 2 == 0 {\n            return search(arr[mid + 1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid + 1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid - 1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmp5wcarche_test.go:56: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmp5wcarche_test.go:56: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    } else if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpuw99px7o_test.go:45: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpuw99px7o_test.go:45: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        if mid % 2 == 0 {\n            return search(arr[mid + 1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid + 1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid - 1])\n        } else {\n            return search(arr[:mid])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmp1ycef0wu_test.go:56: expected '%!s(int=3)', got '%!s(int=1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmp1ycef0wu_test.go:56: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    } else if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmp_thw1673_test.go:48: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmp_thw1673_test.go:48: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return 0\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    } else if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpuu4naiw9_test.go:48: expected '%!s(int=3)', got '%!s(int=0)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpuu4naiw9_test.go:48: expected '%!s(int=8)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        if mid % 2 == 0 {\n            return search(arr[mid + 1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid + 1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid - 1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpazoznvdm_test.go:53: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpazoznvdm_test.go:53: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        if mid % 2 == 0 {\n            return search(arr[mid + 1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid + 1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid - 1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpazoznvdm_test.go:53: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpazoznvdm_test.go:53: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        if mid % 2 == 0 {\n            return search(arr[mid + 1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid + 1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid - 1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123265,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpd1v7fc_4_test.go:55: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpd1v7fc_4_test.go:55: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        if mid % 2 == 0 {\n            return search(arr[mid+1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid+1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid-1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpwhhhgdzv_test.go:56: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpwhhhgdzv_test.go:56: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if arr[len(arr)/2] == arr[len(arr)/2-1] {\n        return search(arr[len(arr)/2+1:])\n    }\n    if arr[len(arr)/2] == arr[len(arr)/2+1] {\n        return search(arr[:len(arr)/2])\n    }\n    return arr[len(arr)/2]\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123265,
      "stdout": "--- FAIL: TestSearch (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc0001b8000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000186300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc0001b8000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.search(0xc00008ce40, 0x0, 0x3, 0x582483)\n\t/tmp/tmptuehaoyg_test.go:13 +0x132\ncommand-line-arguments_test.search(0xc00008ce30, 0x2, 0x5, 0xc00018ede8)\n\t/tmp/tmptuehaoyg_test.go:14 +0xee\ncommand-line-arguments_test.search(0xc00008ce30, 0x5, 0x5, 0x0)\n\t/tmp/tmptuehaoyg_test.go:17 +0x8e\ncommand-line-arguments_test.TestSearch(0xc000186300)\n\t/tmp/tmptuehaoyg_test.go:29 +0xa2\ntesting.tRunner(0xc000186300, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        if mid % 2 == 0 {\n            return search(arr[mid+1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid+1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid-1])\n        } else {\n            return search(arr[:mid])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpmu20crvl_test.go:56: expected '%!s(int=3)', got '%!s(int=1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpmu20crvl_test.go:56: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        if mid % 2 == 0 {\n            return search(arr[mid + 1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid + 1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid - 1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmp5wcarche_test.go:56: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmp5wcarche_test.go:56: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    mid := len(arr) / 2\n\n    if mid % 2 == 0 {\n        if arr[mid] == arr[mid - 1] {\n            return search(arr[mid + 1:])\n        } else {\n            return search(arr[:mid])\n        }\n    } else {\n        if arr[mid] == arr[mid - 1] {\n            return search(arr[:mid - 1])\n        } else {\n            return search(arr[mid + 1:])\n        }\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123265,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpq3jtcuh0_test.go:50: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpq3jtcuh0_test.go:50: expected '%!s(int=8)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__2 (0.00s)\n        tmpq3jtcuh0_test.go:50: expected '%!s(int=1)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        if mid % 2 == 0 {\n            return search(arr[mid+1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid+1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid-1])\n        } else {\n            return search(arr[:mid])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpmu20crvl_test.go:56: expected '%!s(int=3)', got '%!s(int=1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpmu20crvl_test.go:56: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if arr[0] != arr[1] {\n        return arr[0]\n    }\n    if arr[len(arr)-1] != arr[len(arr)-2] {\n        return arr[len(arr)-1]\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    }\n    return search(arr[:mid])\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123265,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        if mid % 2 == 0 {\n            return search(arr[mid + 1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid + 1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid - 1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\npanic: runtime error: index out of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of range [2] with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.search(0xc00008c6b8, 0x2, 0x6, 0x1)\n\t/tmp/tmpjtu1mcmu_test.go:23 +0x1c6\ncommand-line-arguments_test.search(0xc00008c6b8, 0x6, 0x6, 0x1)\n\t/tmp/tmpjtu1mcmu_test.go:27 +0x171\ncommand-line-arguments_test.search(0xc00008c690, 0xb, 0xb, 0x1)\n\t/tmp/tmpjtu1mcmu_test.go:21 +0xf9\ncommand-line-arguments_test.TestSearch(0xc000001380)\n\t/tmp/tmpjtu1mcmu_test.go:42 +0x18c\ntesting.tRunner(0xc000001380, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        return search(arr[mid + 1:])\n    } else if arr[mid] == arr[mid + 1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpjqeyhej1_test.go:45: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpjqeyhej1_test.go:45: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        if mid % 2 == 0 {\n            return search(arr[mid+1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid+1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid-1])\n        } else {\n            return search(arr[:mid])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpmu20crvl_test.go:56: expected '%!s(int=3)', got '%!s(int=1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpmu20crvl_test.go:56: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        if mid % 2 == 0 {\n            return search(arr[mid+1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid+1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid-1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpwhhhgdzv_test.go:56: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpwhhhgdzv_test.go:56: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        if mid % 2 == 0 {\n            return search(arr[mid+1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid+1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid-1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpwhhhgdzv_test.go:56: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpwhhhgdzv_test.go:56: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        return search(arr[mid + 1:])\n    }\n\n    if arr[mid] == arr[mid + 1] {\n        return search(arr[:mid])\n    }\n\n    return arr[mid]\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123265,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmp4s0hwil2_test.go:45: expected '%!s(int=3)', got '%!s(int=0)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmp4s0hwil2_test.go:45: expected '%!s(int=8)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        }\n        return arr[0]\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        if mid % 2 == 0 {\n            return search(arr[mid + 1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid + 1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid - 1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123265,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpv0tmq_a0_test.go:55: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpv0tmq_a0_test.go:55: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        }\n        return arr[0]\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    }\n    if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    }\n    return arr[mid]\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmph63yhyao_test.go:44: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmph63yhyao_test.go:44: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if mid % 2 == 0 {\n        if arr[mid] == arr[mid-1] {\n            return search(arr[mid+1:])\n        } else {\n            return search(arr[:mid])\n        }\n    } else {\n        if arr[mid] == arr[mid-1] {\n            return search(arr[:mid-1])\n        } else {\n            return search(arr[mid+1:])\n        }\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123265,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpz2751nlw_test.go:54: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpz2751nlw_test.go:54: expected '%!s(int=8)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__2 (0.00s)\n        tmpz2751nlw_test.go:54: expected '%!s(int=1)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    }\n    if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    }\n    return arr[mid]\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123265,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpoa8rg5ec_test.go:45: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpoa8rg5ec_test.go:45: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        return search(arr[mid + 1:])\n    } else if arr[mid] == arr[mid + 1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpn6nkdqi2_test.go:47: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpn6nkdqi2_test.go:47: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    } else if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "--- FAIL: TestSearch (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.search(0xc000092640, 0x0, 0x3, 0x582483)\n\t/tmp/tmpwwi5c8hn_test.go:15 +0x132\ncommand-line-arguments_test.search(0xc000092630, 0x2, 0x5, 0xc0000c6aa8)\n\t/tmp/tmpwwi5c8hn_test.go:16 +0xee\ncommand-line-arguments_test.search(0xc000092630, 0x5, 0x5, 0x0)\n\t/tmp/tmpwwi5c8hn_test.go:18 +0x8e\ncommand-line-arguments_test.TestSearch(0xc000001380)\n\t/tmp/tmpwwi5c8hn_test.go:31 +0xa2\ntesting.tRunner(0xc000001380, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return 0\n        }\n        return arr[0]\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        if mid % 2 == 0 {\n            return search(arr[mid + 1:])\n        }\n        return search(arr[mid:])\n    }\n    if arr[mid] == arr[mid + 1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        }\n        return search(arr[:mid + 1])\n    }\n    return arr[mid]\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123265,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpqyujn2zq_test.go:53: expected '%!s(int=3)', got '%!s(int=0)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpqyujn2zq_test.go:53: expected '%!s(int=8)', got '%!s(int=7)'\n    --- FAIL: TestSearch/test_num__2 (0.00s)\n        tmpqyujn2zq_test.go:53: expected '%!s(int=1)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        return search(arr[mid + 1:])\n    } else if arr[mid] == arr[mid + 1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpjqeyhej1_test.go:45: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpjqeyhej1_test.go:45: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        if mid % 2 == 0 {\n            return search(arr[mid + 1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid + 1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid - 1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmp5wcarche_test.go:56: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmp5wcarche_test.go:56: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    } else if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmp_thw1673_test.go:48: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmp_thw1673_test.go:48: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return 0\n        } else {\n            return arr[0]\n        }\n    }\n    if len(arr) == 3 {\n        if arr[0] == arr[1] {\n            return arr[2]\n        }\n        if arr[1] == arr[2] {\n            return arr[0]\n        }\n        return arr[1]\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        return search(arr[mid + 1:])\n    }\n    if arr[mid] == arr[mid + 1] {\n        return search(arr[:mid])\n    }\n    return arr[mid]\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123265,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmp3ofni_5p_test.go:54: expected '%!s(int=3)', got '%!s(int=0)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmp3ofni_5p_test.go:54: expected '%!s(int=8)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return 0\n        } else {\n            return arr[0]\n        }\n    }\n\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        return search(arr[mid + 1:])\n    } else if arr[mid] == arr[mid + 1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123265,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmppdorpfn4_test.go:51: expected '%!s(int=3)', got '%!s(int=0)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmppdorpfn4_test.go:51: expected '%!s(int=8)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    mid := len(arr) / 2\n\n    if mid % 2 == 0 {\n        if arr[mid] == arr[mid - 1] {\n            return search(arr[mid + 1:])\n        } else {\n            return search(arr[:mid])\n        }\n    } else {\n        if arr[mid] == arr[mid - 1] {\n            return search(arr[:mid - 1])\n        } else {\n            return search(arr[mid + 1:])\n        }\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123265,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpq3jtcuh0_test.go:50: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpq3jtcuh0_test.go:50: expected '%!s(int=8)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__2 (0.00s)\n        tmpq3jtcuh0_test.go:50: expected '%!s(int=1)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return 0\n        } else {\n            return arr[0]\n        }\n    }\n\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        return search(arr[mid + 1:])\n    } else if arr[mid] == arr[mid + 1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpttih2ciu_test.go:47: expected '%!s(int=3)', got '%!s(int=0)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpttih2ciu_test.go:47: expected '%!s(int=8)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        }\n        return arr[0]\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    }\n    if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    }\n    return arr[mid]\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmph63yhyao_test.go:44: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmph63yhyao_test.go:44: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        if mid % 2 == 0 {\n            return search(arr[mid+1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid+1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid-1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpwhhhgdzv_test.go:56: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpwhhhgdzv_test.go:56: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return 0\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        return search(arr[mid + 1:])\n    } else if arr[mid] == arr[mid + 1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123269,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmp2s4z8ym6_test.go:48: expected '%!s(int=3)', got '%!s(int=0)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmp2s4z8ym6_test.go:48: expected '%!s(int=8)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        if mid % 2 == 0 {\n            return search(arr[mid+1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid+1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid-1])\n        } else {\n            return search(arr[:mid])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpmu20crvl_test.go:56: expected '%!s(int=3)', got '%!s(int=1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpmu20crvl_test.go:56: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        if mid % 2 == 0 {\n            return search(arr[mid + 1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid + 1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid - 1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmp5wcarche_test.go:56: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmp5wcarche_test.go:56: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        if mid % 2 == 0 {\n            return search(arr[mid + 1:])\n        } else {\n            return search(arr[:mid - 1])\n        }\n    } else if arr[mid] == arr[mid + 1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[mid + 2:])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123269,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmp00h9gdu9_test.go:49: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmp00h9gdu9_test.go:49: expected '%!s(int=8)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__2 (0.00s)\n        tmp00h9gdu9_test.go:49: expected '%!s(int=1)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        return search(arr[mid + 1:])\n    } else if arr[mid] == arr[mid + 1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123269,
      "stdout": "--- FAIL: TestSearch (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.search(0xc000092640, 0x0, 0x3, 0x582483)\n\t/tmp/tmpxi84j8sw_test.go:14 +0x132\ncommand-line-arguments_test.search(0xc000092630, 0x2, 0x5, 0xc0000c6de8)\n\t/tmp/tmpxi84j8sw_test.go:15 +0xee\ncommand-line-arguments_test.search(0xc000092630, 0x5, 0x5, 0x0)\n\t/tmp/tmpxi84j8sw_test.go:17 +0x8e\ncommand-line-arguments_test.TestSearch(0xc000001380)\n\t/tmp/tmpxi84j8sw_test.go:30 +0xa2\ntesting.tRunner(0xc000001380, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        if mid % 2 == 0 {\n            return search(arr[mid+1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid+1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid-1])\n        } else {\n            return search(arr[:mid])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123269,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpxtegd3ei_test.go:53: expected '%!s(int=3)', got '%!s(int=1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpxtegd3ei_test.go:53: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        if mid % 2 == 0 {\n            return search(arr[mid+1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid+1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid-1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpwhhhgdzv_test.go:56: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpwhhhgdzv_test.go:56: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    mid := len(arr) / 2\n    if mid % 2 == 0 {\n        if arr[mid] == arr[mid + 1] {\n            return search(arr[mid + 2:])\n        } else {\n            return search(arr[:mid])\n        }\n    } else {\n        if arr[mid] == arr[mid - 1] {\n            return search(arr[mid + 1:])\n        } else {\n            return search(arr[:mid - 1])\n        }\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123269,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__2 (0.00s)\n        tmpijb_o0fk_test.go:47: expected '%!s(int=1)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    } else if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpuw99px7o_test.go:45: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpuw99px7o_test.go:45: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        }\n        return arr[0]\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        if mid % 2 == 0 {\n            return search(arr[mid+1:])\n        }\n        return search(arr[mid:])\n    }\n    if arr[mid] == arr[mid+1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid-1])\n        }\n        return search(arr[:mid])\n    }\n    return arr[mid]\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123269,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmploo416cs_test.go:53: expected '%!s(int=3)', got '%!s(int=1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmploo416cs_test.go:53: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    // If the list is empty, return -1\n    if len(arr) == 0 {\n        return -1\n    }\n    // If the list has only one element, return that element\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    // If the list has two elements, return the one that is not equal to the other\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    // If the list has more than two elements, find the middle element\n    mid := len(arr) / 2\n    // If the middle element is the only element in its group, return it\n    if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n        return arr[mid]\n    }\n    // If the middle element is equal to the element to its left,\n    // that means all elements to the left are equal,\n    // so recursively call the function on the right half of the list\n    if arr[mid] == arr[mid - 1] {\n        return search(arr[mid + 1:])\n    }\n    // If the middle element is equal to the element to its right,\n    // that means all elements to the right are equal,\n    // so recursively call the function on the left half of the list\n    if arr[mid] == arr[mid + 1] {\n        return search(arr[:mid])\n    }\n    return -1\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123269,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmptfbqm2wb_test.go:62: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmptfbqm2wb_test.go:62: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    } else if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpuw99px7o_test.go:45: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpuw99px7o_test.go:45: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    } else if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpuw99px7o_test.go:45: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpuw99px7o_test.go:45: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        return search(arr[mid + 1:])\n    } else if arr[mid] == arr[mid + 1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123269,
      "stdout": "--- FAIL: TestSearch (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.search(0xc000092640, 0x0, 0x3, 0x582483)\n\t/tmp/tmpempzc2we_test.go:15 +0x132\ncommand-line-arguments_test.search(0xc000092630, 0x2, 0x5, 0xc0000c7058)\n\t/tmp/tmpempzc2we_test.go:16 +0xee\ncommand-line-arguments_test.search(0xc000092630, 0x5, 0x5, 0x0)\n\t/tmp/tmpempzc2we_test.go:18 +0x8e\ncommand-line-arguments_test.TestSearch(0xc000001380)\n\t/tmp/tmpempzc2we_test.go:31 +0xa2\ntesting.tRunner(0xc000001380, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        if mid % 2 == 0 {\n            return search(arr[mid + 1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid + 1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid - 1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123265,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpd1v7fc_4_test.go:55: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpd1v7fc_4_test.go:55: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        return search(arr[mid + 1:])\n    } else if arr[mid] == arr[mid + 1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpn6nkdqi2_test.go:47: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpn6nkdqi2_test.go:47: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    mid := len(arr) / 2\n    if mid % 2 == 0 {\n        if arr[mid] == arr[mid - 1] {\n            return search(arr[mid + 1:])\n        } else {\n            return search(arr[:mid])\n        }\n    } else {\n        if arr[mid] == arr[mid - 1] {\n            return search(arr[:mid - 1])\n        } else {\n            return search(arr[mid + 1:])\n        }\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123265,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpe65uzt7r_test.go:47: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpe65uzt7r_test.go:47: expected '%!s(int=8)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__2 (0.00s)\n        tmpe65uzt7r_test.go:47: expected '%!s(int=1)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.009s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        if mid % 2 == 0 {\n            return search(arr[mid+1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid+1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid-1])\n        } else {\n            return search(arr[:mid])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpmu20crvl_test.go:56: expected '%!s(int=3)', got '%!s(int=1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpmu20crvl_test.go:56: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        if mid % 2 == 0 {\n            return search(arr[mid + 1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid + 1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid - 1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\npanic: runtime error: index out of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of range [2] with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.search(0xc00008c6b8, 0x2, 0x6, 0x1)\n\t/tmp/tmpjtu1mcmu_test.go:23 +0x1c6\ncommand-line-arguments_test.search(0xc00008c6b8, 0x6, 0x6, 0x1)\n\t/tmp/tmpjtu1mcmu_test.go:27 +0x171\ncommand-line-arguments_test.search(0xc00008c690, 0xb, 0xb, 0x1)\n\t/tmp/tmpjtu1mcmu_test.go:21 +0xf9\ncommand-line-arguments_test.TestSearch(0xc000001380)\n\t/tmp/tmpjtu1mcmu_test.go:42 +0x18c\ntesting.tRunner(0xc000001380, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if arr[0] != arr[1] {\n        return arr[0]\n    }\n    if arr[len(arr) - 1] != arr[len(arr) - 2] {\n        return arr[len(arr) - 1]\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        return search(arr[mid + 1:])\n    } else {\n        return search(arr[:mid])\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123269,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        }\n        return arr[0]\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    }\n    if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    }\n    return arr[mid]\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmph63yhyao_test.go:44: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmph63yhyao_test.go:44: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return 0\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        if mid % 2 == 0 {\n            return search(arr[mid + 1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid + 1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid - 1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123265,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpvj2_u0_6_test.go:56: expected '%!s(int=3)', got '%!s(int=0)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpvj2_u0_6_test.go:56: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return 0\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    } else if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123269,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpg6mr1jyr_test.go:45: expected '%!s(int=3)', got '%!s(int=0)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpg6mr1jyr_test.go:45: expected '%!s(int=8)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        if mid % 2 == 0 {\n            return search(arr[mid + 1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid + 1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid - 1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmp5wcarche_test.go:56: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmp5wcarche_test.go:56: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return 0\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    } else if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123269,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpg6mr1jyr_test.go:45: expected '%!s(int=3)', got '%!s(int=0)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpg6mr1jyr_test.go:45: expected '%!s(int=8)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        if mid % 2 == 0 {\n            return search(arr[mid+1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid+1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid-1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpwhhhgdzv_test.go:56: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpwhhhgdzv_test.go:56: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        }\n        return arr[0]\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        return search(arr[mid + 1:])\n    }\n    if arr[mid] == arr[mid + 1] {\n        return search(arr[:mid])\n    }\n    return arr[mid]\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpnxmj3o4n_test.go:47: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpnxmj3o4n_test.go:47: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        if mid % 2 == 0 {\n            return search(arr[mid + 1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid + 1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid - 1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmp5wcarche_test.go:56: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmp5wcarche_test.go:56: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if arr[0] != arr[1] {\n        return arr[0]\n    }\n    if arr[len(arr) - 1] != arr[len(arr) - 2] {\n        return arr[len(arr) - 1]\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        return search(arr[mid + 1:])\n    }\n    return search(arr[:mid])\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123269,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    mid := len(arr) / 2\n    if mid % 2 == 0 {\n        if arr[mid] == arr[mid - 1] {\n            return search(arr[mid + 1:])\n        } else {\n            return search(arr[:mid])\n        }\n    } else {\n        if arr[mid] == arr[mid - 1] {\n            return search(arr[:mid - 1])\n        } else {\n            return search(arr[mid + 1:])\n        }\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123265,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpe65uzt7r_test.go:47: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpe65uzt7r_test.go:47: expected '%!s(int=8)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__2 (0.00s)\n        tmpe65uzt7r_test.go:47: expected '%!s(int=1)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.009s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[1]\n        }\n    }\n\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        return search(arr[mid + 1:])\n    } else if arr[mid] == arr[mid + 1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123269,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpw8n0kape_test.go:47: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpw8n0kape_test.go:47: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        return search(arr[mid + 1:])\n    } else if arr[mid] == arr[mid + 1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpn6nkdqi2_test.go:47: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpn6nkdqi2_test.go:47: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return 0\n        }\n        return arr[0]\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        if mid % 2 == 0 {\n            return search(arr[mid + 1:])\n        }\n        return search(arr[mid:])\n    }\n    if arr[mid] == arr[mid + 1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        }\n        return search(arr[:mid - 1])\n    }\n    return arr[mid]\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123269,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmp63xb9kar_test.go:53: expected '%!s(int=3)', got '%!s(int=0)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmp63xb9kar_test.go:53: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    } else if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmp_thw1673_test.go:48: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmp_thw1673_test.go:48: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        }\n        return arr[0]\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        if mid % 2 == 0 {\n            return search(arr[mid+1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid+1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid-1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123269,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmp04msy7g2_test.go:55: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmp04msy7g2_test.go:55: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        if mid % 2 == 0 {\n            return search(arr[mid + 1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid + 1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid - 1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpazoznvdm_test.go:53: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpazoznvdm_test.go:53: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    } else if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmp_thw1673_test.go:48: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmp_thw1673_test.go:48: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    } else if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpann53r2__test.go:47: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpann53r2__test.go:47: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        return search(arr[mid + 1:])\n    } else if arr[mid] == arr[mid + 1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123269,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpna6v3vez_test.go:51: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpna6v3vez_test.go:51: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    mid := len(arr) / 2\n    if mid % 2 == 0 {\n        if arr[mid] == arr[mid+1] {\n            return search(arr[mid+2:])\n        } else {\n            return search(arr[:mid])\n        }\n    } else {\n        if arr[mid] == arr[mid-1] {\n            return search(arr[mid+1:])\n        } else {\n            return search(arr[:mid-1])\n        }\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123269,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__2 (0.00s)\n        tmp2_4sfu5y_test.go:47: expected '%!s(int=1)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n\n    mid := len(arr) / 2\n\n    if arr[mid] == arr[mid - 1] {\n        if mid % 2 == 0 {\n            return search(arr[mid + 1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid + 1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid - 1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123269,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmptrs3mdr1_test.go:56: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmptrs3mdr1_test.go:56: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        if mid % 2 == 0 {\n            return search(arr[mid+1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid+1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid-1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123269,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpdg7fc6rw_test.go:53: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpdg7fc6rw_test.go:53: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        if mid % 2 == 0 {\n            return search(arr[mid+1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid+1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid-1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123269,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpdg7fc6rw_test.go:53: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpdg7fc6rw_test.go:53: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    } else if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "--- FAIL: TestSearch (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.search(0xc000092640, 0x0, 0x3, 0x582483)\n\t/tmp/tmpwwi5c8hn_test.go:15 +0x132\ncommand-line-arguments_test.search(0xc000092630, 0x2, 0x5, 0xc0000c6aa8)\n\t/tmp/tmpwwi5c8hn_test.go:16 +0xee\ncommand-line-arguments_test.search(0xc000092630, 0x5, 0x5, 0x0)\n\t/tmp/tmpwwi5c8hn_test.go:18 +0x8e\ncommand-line-arguments_test.TestSearch(0xc000001380)\n\t/tmp/tmpwwi5c8hn_test.go:31 +0xa2\ntesting.tRunner(0xc000001380, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        if mid % 2 == 0 {\n            return search(arr[mid+1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid+1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid-1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpwhhhgdzv_test.go:56: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpwhhhgdzv_test.go:56: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    } else if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "--- FAIL: TestSearch (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.search(0xc000092640, 0x0, 0x3, 0x582483)\n\t/tmp/tmpwwi5c8hn_test.go:15 +0x132\ncommand-line-arguments_test.search(0xc000092630, 0x2, 0x5, 0xc0000c6aa8)\n\t/tmp/tmpwwi5c8hn_test.go:16 +0xee\ncommand-line-arguments_test.search(0xc000092630, 0x5, 0x5, 0x0)\n\t/tmp/tmpwwi5c8hn_test.go:18 +0x8e\ncommand-line-arguments_test.TestSearch(0xc000001380)\n\t/tmp/tmpwwi5c8hn_test.go:31 +0xa2\ntesting.tRunner(0xc000001380, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return 0\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    } else if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpuu4naiw9_test.go:48: expected '%!s(int=3)', got '%!s(int=0)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpuu4naiw9_test.go:48: expected '%!s(int=8)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return 0\n        }\n        return arr[0]\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        return search(arr[mid + 1:])\n    }\n    if arr[mid] == arr[mid + 1] {\n        return search(arr[:mid])\n    }\n    return arr[mid]\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123269,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpoa87qi7u_test.go:47: expected '%!s(int=3)', got '%!s(int=0)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpoa87qi7u_test.go:47: expected '%!s(int=8)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        if mid % 2 == 0 {\n            return search(arr[mid + 1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid + 1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid - 1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123265,
      "stdout": "--- FAIL: TestSearch (0.00s)\npanic: runtime error: index out of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of range [2] with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.search(0xc0000926b8, 0x2, 0x6, 0x1)\n\t/tmp/tmp5maflpl2_test.go:25 +0x1c6\ncommand-line-arguments_test.search(0xc0000926b8, 0x6, 0x6, 0x1)\n\t/tmp/tmp5maflpl2_test.go:29 +0x171\ncommand-line-arguments_test.search(0xc000092690, 0xb, 0xb, 0x1)\n\t/tmp/tmp5maflpl2_test.go:23 +0xf9\ncommand-line-arguments_test.TestSearch(0xc000001380)\n\t/tmp/tmp5maflpl2_test.go:44 +0x18c\ntesting.tRunner(0xc000001380, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    } else if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpuw99px7o_test.go:45: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpuw99px7o_test.go:45: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        if mid % 2 == 0 {\n            return search(arr[mid+1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid+1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid-1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpwhhhgdzv_test.go:56: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpwhhhgdzv_test.go:56: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    var i int\n    for i = 0; i < len(arr); i++ {\n        if i == 0 {\n            if arr[i] != arr[i+1] {\n                return arr[i]\n            }\n        } else if i == len(arr) - 1 {\n            if arr[i] != arr[i-1] {\n                return arr[i]\n            }\n        } else {\n            if arr[i] != arr[i-1] && arr[i] != arr[i+1] {\n                return arr[i]\n            }\n        }\n    }\n    return -1\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    } else if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpuw99px7o_test.go:45: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpuw99px7o_test.go:45: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        return arr[0] ^ arr[1]\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    }\n    if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    }\n    return arr[mid]\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123269,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpqxmwxzkc_test.go:41: expected '%!s(int=3)', got '%!s(int=0)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpqxmwxzkc_test.go:41: expected '%!s(int=8)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    n := len(arr)\n    if n == 1 {\n        return arr[0]\n    }\n    if n == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := n / 2\n    if arr[mid] == arr[mid - 1] {\n        if mid % 2 == 0 {\n            return search(arr[mid + 1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid + 1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid - 1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123269,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpb4t4he9y_test.go:54: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpb4t4he9y_test.go:54: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        return search(arr[mid + 1:])\n    } else if arr[mid] == arr[mid + 1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpjqeyhej1_test.go:45: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpjqeyhej1_test.go:45: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if arr[0] != arr[1] {\n        return arr[0]\n    }\n    if arr[len(arr)-1] != arr[len(arr)-2] {\n        return arr[len(arr)-1]\n    }\n    return search(arr[1:len(arr)-1])\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123269,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    } else if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpuw99px7o_test.go:45: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpuw99px7o_test.go:45: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        if mid % 2 == 0 {\n            return search(arr[mid+1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid+1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid-1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123269,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpdg7fc6rw_test.go:53: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpdg7fc6rw_test.go:53: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        if mid % 2 == 0 {\n            return search(arr[mid+1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid+1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid-1])\n        } else {\n            return search(arr[:mid])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123261,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpmu20crvl_test.go:56: expected '%!s(int=3)', got '%!s(int=1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpmu20crvl_test.go:56: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        if mid % 2 == 0 {\n            return search(arr[mid:])\n        } else {\n            return search(arr[mid+1:])\n        }\n    } else if arr[mid] == arr[mid+1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid-1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123269,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmp04fu49x5_test.go:56: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmp04fu49x5_test.go:56: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    mid := len(arr) / 2\n    if mid % 2 == 0 {\n        if arr[mid] == arr[mid - 1] {\n            return search(arr[mid + 1:])\n        } else {\n            return search(arr[:mid])\n        }\n    } else {\n        if arr[mid] == arr[mid - 1] {\n            return search(arr[:mid - 1])\n        } else {\n            return search(arr[mid + 1:])\n        }\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123265,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpe65uzt7r_test.go:47: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpe65uzt7r_test.go:47: expected '%!s(int=8)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__2 (0.00s)\n        tmpe65uzt7r_test.go:47: expected '%!s(int=1)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.009s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        return search(arr[mid+1:])\n    } else if arr[mid] == arr[mid+1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpann53r2__test.go:47: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpann53r2__test.go:47: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    mid := len(arr) / 2\n    if mid % 2 == 0 {\n        if arr[mid] == arr[mid-1] {\n            return search(arr[mid+1:])\n        } else {\n            return search(arr[:mid])\n        }\n    } else {\n        if arr[mid] == arr[mid-1] {\n            return search(arr[:mid-1])\n        } else {\n            return search(arr[mid+1:])\n        }\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpbva7p86u_test.go:47: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpbva7p86u_test.go:47: expected '%!s(int=8)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__2 (0.00s)\n        tmpbva7p86u_test.go:47: expected '%!s(int=1)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid-1] {\n        if mid % 2 == 0 {\n            return search(arr[mid+1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid+1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid-1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpwhhhgdzv_test.go:56: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpwhhhgdzv_test.go:56: expected '%!s(int=8)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    if len(arr) == 2 {\n        if arr[0] == arr[1] {\n            return -1\n        } else {\n            return arr[0]\n        }\n    }\n\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        return search(arr[mid + 1:])\n    } else if arr[mid] == arr[mid + 1] {\n        return search(arr[:mid])\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\n    --- FAIL: TestSearch/test_num__0 (0.00s)\n        tmpn6nkdqi2_test.go:47: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestSearch/test_num__1 (0.00s)\n        tmpn6nkdqi2_test.go:47: expected '%!s(int=8)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package search_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to find the element that appears only once in a sorted list.\nfunc search(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    mid := len(arr) / 2\n    if arr[mid] == arr[mid - 1] {\n        if mid % 2 == 0 {\n            return search(arr[mid + 1:])\n        } else {\n            return search(arr[mid:])\n        }\n    } else if arr[mid] == arr[mid + 1] {\n        if mid % 2 == 0 {\n            return search(arr[:mid])\n        } else {\n            return search(arr[:mid - 1])\n        }\n    } else {\n        return arr[mid]\n    }\n}\n\nfunc TestSearch(t *testing.T) {\n  candidate := search\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 2, 3}), expected: 3 },\n     { actual: candidate([]int{1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8}), expected: 8 },\n     { actual: candidate([]int{1, 2, 2, 3, 3, 4, 4}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510189,
      "stdout": "--- FAIL: TestSearch (0.00s)\npanic: runtime error: index out of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of range [2] with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.search(0xc00008c6b8, 0x2, 0x6, 0x1)\n\t/tmp/tmpjtu1mcmu_test.go:23 +0x1c6\ncommand-line-arguments_test.search(0xc00008c6b8, 0x6, 0x6, 0x1)\n\t/tmp/tmpjtu1mcmu_test.go:27 +0x171\ncommand-line-arguments_test.search(0xc00008c690, 0xb, 0xb, 0x1)\n\t/tmp/tmpjtu1mcmu_test.go:21 +0xf9\ncommand-line-arguments_test.TestSearch(0xc000001380)\n\t/tmp/tmpjtu1mcmu_test.go:42 +0x18c\ntesting.tRunner(0xc000001380, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}