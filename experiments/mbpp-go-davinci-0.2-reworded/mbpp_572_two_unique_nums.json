{
  "name": "mbpp_572_two_unique_nums",
  "language": "go_test.go",
  "prompt": "package two_unique_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a gothon function to remove duplicate numbers from a given number of lists.\nfunc two_unique_nums(nums []int) []int {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_572_two_unique_nums.py",
  "prompt_terminology": "reworded",
  "tests": "func TestTwo_Unique_Nums(t *testing.T) {\n  candidate := two_unique_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 2, 3, 4, 5}), expected: []int{1, 4, 5} },\n     { actual: candidate([]int{1, 2, 3, 2, 4, 5}), expected: []int{1, 3, 4, 5} },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: []int{1, 2, 3, 4, 5} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    var result []int\n    for _, num := range nums {\n        if len(result) == 0 {\n            result = append(result, num)\n        } else {\n            if result[0] != num {\n                result = append(result, num)\n            }\n        }\n    }\n    return result\n}\n",
    "    var result []int\n    var m = make(map[int]int)\n    for _, v := range nums {\n        if _, ok := m[v]; ok {\n            m[v] += 1\n        } else {\n            m[v] = 1\n        }\n    }\n    for k, v := range m {\n        if v == 1 {\n            result = append(result, k)\n        }\n    }\n    return result\n}\n",
    "    var result []int\n    var m = make(map[int]bool)\n    for _, num := range nums {\n        if _, ok := m[num]; !ok {\n            m[num] = true\n            result = append(result, num)\n        }\n    }\n    return result\n}\n",
    "    var unique_nums []int\n    var num_map = make(map[int]int)\n\n    for _, num := range nums {\n        num_map[num] = num_map[num] + 1\n    }\n\n    for _, num := range nums {\n        if num_map[num] == 1 {\n            unique_nums = append(unique_nums, num)\n        }\n    }\n\n    return unique_nums\n}\n",
    "    var unique_nums []int\n    for _, num := range nums {\n        if len(unique_nums) == 0 {\n            unique_nums = append(unique_nums, num)\n        } else {\n            is_unique := true\n            for _, unique_num := range unique_nums {\n                if num == unique_num {\n                    is_unique = false\n                    break\n                }\n            }\n            if is_unique {\n                unique_nums = append(unique_nums, num)\n            }\n        }\n    }\n    return unique_nums\n}\n",
    "    var unique_nums []int\n    for _, num := range nums {\n        if !contains(unique_nums, num) {\n            unique_nums = append(unique_nums, num)\n        }\n    }\n    return unique_nums\n}\n",
    "    // Create a map to store the numbers and their counts.\n    num_counts := make(map[int]int)\n    // Iterate through the numbers and add them to the map.\n    for _, num := range nums {\n        num_counts[num]++\n    }\n    // Create a slice to store the unique numbers.\n    unique_nums := []int{}\n    // Iterate through the map and add the unique numbers to the slice.\n    for num, count := range num_counts {\n        if count == 1 {\n            unique_nums = append(unique_nums, num)\n        }\n    }\n    // Return the unique numbers.\n    return unique_nums\n}\n",
    "    var result []int\n    for _, num := range nums {\n        if len(result) == 0 {\n            result = append(result, num)\n        } else if result[0] != num {\n            result = append(result, num)\n            break\n        }\n    }\n    return result\n}\n",
    "    var unique_nums []int\n    for _, num := range nums {\n        if len(unique_nums) == 0 {\n            unique_nums = append(unique_nums, num)\n        } else {\n            for i, unique_num := range unique_nums {\n                if num == unique_num {\n                    break\n                }\n                if i == len(unique_nums) - 1 {\n                    unique_nums = append(unique_nums, num)\n                }\n            }\n        }\n    }\n    return unique_nums\n}\n",
    "    var result []int\n    for _, num := range nums {\n        if len(result) == 0 {\n            result = append(result, num)\n        } else if result[0] == num {\n            continue\n        } else if result[0] != num {\n            result = append(result, num)\n            break\n        }\n    }\n    return result\n}\n",
    "    var unique_nums []int\n    for _, num := range nums {\n        if !contains(unique_nums, num) {\n            unique_nums = append(unique_nums, num)\n        }\n    }\n    return unique_nums\n}\n",
    "    var unique_nums []int\n    for _, num := range nums {\n        if !contains(unique_nums, num) {\n            unique_nums = append(unique_nums, num)\n        }\n    }\n    return unique_nums\n}\n",
    "    var unique_nums []int\n    for _, num := range nums {\n        if !is_in_list(num, unique_nums) {\n            unique_nums = append(unique_nums, num)\n        }\n    }\n    return unique_nums\n}\n",
    "    m := make(map[int]int)\n    for _, v := range nums {\n        m[v]++\n    }\n    var res []int\n    for k, v := range m {\n        if v == 1 {\n            res = append(res, k)\n        }\n    }\n    return res\n}\n",
    "    var result []int\n    for i := 0; i < len(nums); i++ {\n        var count int\n        for j := 0; j < len(nums); j++ {\n            if nums[i] == nums[j] {\n                count++\n            }\n        }\n        if count == 1 {\n            result = append(result, nums[i])\n        }\n    }\n    return result\n}\n",
    "    m := make(map[int]int)\n    for _, n := range nums {\n        m[n] += 1\n    }\n    var result []int\n    for k, v := range m {\n        if v == 1 {\n            result = append(result, k)\n        }\n    }\n    return result\n}\n",
    "    var result []int\n    var numsMap = make(map[int]int)\n    for _, v := range nums {\n        numsMap[v] += 1\n    }\n    for k, v := range numsMap {\n        if v == 1 {\n            result = append(result, k)\n        }\n    }\n    return result\n}\n",
    "    var result []int\n    for _, num := range nums {\n        if len(result) == 0 {\n            result = append(result, num)\n        } else {\n            if result[0] == num {\n                continue\n            } else {\n                result = append(result, num)\n            }\n        }\n    }\n    return result\n}\n",
    "    var unique_nums []int\n    for _, num := range nums {\n        if !contains(unique_nums, num) {\n            unique_nums = append(unique_nums, num)\n        }\n    }\n    return unique_nums\n}\n",
    "    var result []int\n    for _, num := range nums {\n        if len(result) == 0 {\n            result = append(result, num)\n        } else if result[len(result)-1] != num {\n            result = append(result, num)\n        }\n    }\n    return result\n}\n"
  ]
}