language: rs
name: HumanEval_78_hex_key
results:
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num: Vec<u8>\
    \ = num.iter().map(|x| *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x|\
    \ *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num:\
    \ Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x|\
    \ *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num:\
    \ Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x|\
    \ *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num:\
    \ Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x|\
    \ *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num:\
    \ Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x|\
    \ *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num:\
    \ Vec<u8> = \n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpi7sdx9zx.rs:46:1\n\
    \   |\n46 | }\n   | ^ expected expression\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n    --> /tmp/tmpi7sdx9zx.rs:23:52\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_string().chars().collect();\n\
    \     |                                                    ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_prime: Vec<u8> = vec![];\n    let mut num_prime_counter: usize\
    \ = 0;\n    let mut num_prime_counter2: usize = 0;\n    let mut num_prime_counter3:\
    \ usize = 0;\n    let mut num_prime_counter4: usize = 0;\n    let mut num_prime_counter5:\
    \ usize = 0;\n    let mut num_prime_counter6: usize = 0;\n    let mut num_prime_counter7:\
    \ usize = 0;\n    let mut num_prime_counter8: usize = 0;\n    let mut num_prime_counter9:\
    \ usize = 0;\n    let mut num_prime_counter10: usize = 0;\n    let mut num_prime_counter11:\
    \ usize = 0;\n    let mut num_prime_counter12: usize = 0;\n    let mut num_prime_counter13:\
    \ usize = 0;\n    let mut num_prime_counter14: usize = 0;\n    let mut num_prime_counter15:\
    \ usize = 0;\n    let mut num_prime_counter16: usize = 0;\n    let mut num_prime_counter17:\
    \ usize = 0;\n    let mut num_prime_counter18: usize = 0;\n    let mut num_prime_counter19:\
    \ usize = 0;\n    let mut num_prime_counter20: usize = 0;\n    let mut num_prime_counter21:\
    \ usize = 0;\n    let mut num_prime_counter22: usize = 0;\n    let mut num_prime_counter23:\
    \ usize = 0;\n    let mut num_prime_counter24: usize = 0;\n    let mut num_prime_counter25:\
    \ usize = 0;\n    let mut num_prime_counter26: usize = 0;\n    let mut num_prime_counter27:\
    \ usize = 0;\n    let mut num_prime_counter28: usize = 0;\n    let mut num_prime_counter29:\
    \ usize = 0;\n    let mut num_prime_counter30: usize = 0;\n    let mut num_prime_counter31:\
    \ usize = 0;\n    let mut num_prime_counter32: usize = 0;\n    let mut num_prime_counter33:\
    \ usize = 0;\n    let mut num_prime_counter34: usize = 0;\n    let mut num_prime_counter35:\
    \ usize = 0;\n    let mut num_prime_counter36: usize = 0;\n    let mut num_prime_counter37:\
    \ usize = 0;\n    let mu\n}\n\nfn main() {\n    let candidate = hex_key;\n   \
    \ assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8bnkep1i.rs:62:11\n   |\n\
    62 |     let mu\n   |           ^ help: add `;` here\n63 | }\n   | - unexpected\
    \ token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmp8bnkep1i.rs:23:55\n     |\n23\
    \   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |\
    \                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8bnkep1i.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_digits: Vec<u8> = vec![2, 3, 4, 5, 7, 11, 13, 17];\n    let\
    \ mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len = prime_digits_len\
    \ as usize;\n    let mut prime_digits_len = prime_digits_len as usize;\n    let\
    \ mut prime_digits_len = prime_digits_len as usize;\n    let mut prime_digits_len\
    \ = prime_digits_len as usize;\n    let mut prime_digits_len = prime_digits_len\
    \ as usize;\n    let mut prime_digits_len = prime_digits_len as usize;\n    let\
    \ mut prime_digits_len = prime_digits_len as usize;\n    let mut prime_digits_len\
    \ = prime_digits_len as usize;\n    let mut prime_digits_len = prime_digits_len\
    \ as usize;\n    let mut prime_digits_len = prime_digits_len as usize;\n    let\
    \ mut prime_digits_len = prime_digits_len as usize;\n    let mut prime_digits_len\
    \ = prime_digits_len as usize;\n    let mut prime_digits_len = prime_digits_len\
    \ as usize;\n    let mut prime_digits_len = prime_digits_len as usize;\n    let\
    \ mut prime_digits_len = prime_digits_len as usize;\n    let mut prime_digits_len\
    \ = prime_digits_len as usize;\n    let mut prime_digits_len = prime_digits_len\
    \ as usize;\n    let mut prime_digits_len = prime_digits_len as usize;\n    let\
    \ mut prime_digits_len = prime_digits_len as usize;\n    let mut prime_digits_len\
    \ = prime_digits_len as usize;\n    let mut prime_digits_len = prime_digits_len\
    \ as usize;\n    let mut prime_digits_len = prime_digits_len as usize;\n    let\
    \ mut prime_digits_len = prime_digits_len as usize;\n    let mut prime_digits_len\
    \ = prime_digits_len as usize;\n    let mut prime_digits_len = prime_digits_len\
    \ as usize;\n    let mut prime_digits_len = prime_digits_len as usize;\n    let\
    \ mut prime_digits_len = prime_digits_len as u\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxda9dlt5.rs:52:53\n   |\n\
    52 |     let mut prime_digits_len = prime_digits_len as u\n   |              \
    \                                       ^ help: add `;` here\n53 | }\n   | - unexpected\
    \ token\n\nerror[E0412]: cannot find type `u` in this scope\n  --> /tmp/tmpxda9dlt5.rs:52:52\n\
    \   |\n52 |     let mut prime_digits_len = prime_digits_len as u\n   |       \
    \                                             ^ help: a builtin type with a similar\
    \ name exists: `u8`\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built\
    \ from an iterator over elements of type `char`\n    --> /tmp/tmpxda9dlt5.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxda9dlt5.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0412.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: isize = 0;\n    let mut num_digits = num.len();\n\
    \    let mut num_digits_div2 = num_digits / 2;\n    let mut num_digits_div4 =\
    \ num_digits / 4;\n    let mut num_digits_div6 = num_digits / 6;\n    let mut\
    \ num_digits_div8 = num_digits / 8;\n    let mut num_digits_div10 = num_digits\
    \ / 10;\n    let mut num_digits_div12 = num_digits / 12;\n    let mut num_digits_div14\
    \ = num_digits / 14;\n    let mut num_digits_div16 = num_digits / 16;\n    let\
    \ mut num_digits_div18 = num_digits / 18;\n    let mut num_digits_div20 = num_digits\
    \ / 20;\n    let mut num_digits_div22 = num_digits / 22;\n    let mut num_digits_div24\
    \ = num_digits / 24;\n    let mut num_digits_div26 = num_digits / 26;\n    let\
    \ mut num_digits_div28 = num_digits / 28;\n    let mut num_digits_div30 = num_digits\
    \ / 30;\n    let mut num_digits_div32 = num_digits / 32;\n    let mut num_digits_div34\
    \ = num_digits / 34;\n    let mut num_digits_div36 = num_digits / 36;\n    let\
    \ mut num_digits_div38 = num_digits / 38;\n    let mut num_digits_div40 = num_digits\
    \ / 40;\n    let mut num_digits_div42 = num_digits / 42;\n    let mut num_digits_div44\
    \ = num_digits / 44;\n    let mut num_digits_div46 = num_digits / 46;\n    let\
    \ mut num_digits_div48 = num_digits / 48;\n    let mut num_digits_div50 = num_digits\
    \ / 50;\n    let mut num_digits_div52 = num_digits / 52;\n    let mut num_digits_div54\
    \ = num_digits / 54;\n    let mut num_digits_div56 = num_digits / 56;\n    let\
    \ mut num_digits_div58 = num_digits / 58;\n    let mut num_digits_div60 = num_digits\
    \ / 60;\n    let mut num_digits_div62 = num_digits / 62;\n    let mut num_digits_div64\
    \ = num_digits / 64;\n    let mut num_digits_div66 = num_digits / 66;\n    let\
    \ mut num_digits_div68 = num_digits / 6\n}\n\nfn main() {\n    let candidate =\
    \ hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpnk5xdr9w.rs:58:46\n   |\n\
    58 |     let mut num_digits_div68 = num_digits / 6\n   |                     \
    \                         ^ help: add `;` here\n59 | }\n   | - unexpected token\n\
    \nerror[E0599]: no method named `len` found for type `isize` in the current scope\n\
    \  --> /tmp/tmpnk5xdr9w.rs:24:30\n   |\n24 |     let mut num_digits = num.len();\n\
    \   |                              ^^^ method not found in `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnk5xdr9w.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut prime_count: isize = 0;\n    let mut prime_digit: u8 = 0;\n    let mut\
    \ prime_digit_count: usize = 0;\n    let mut prime_digit_index: usize = 0;\n \
    \   let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value_count: usize\
    \ = 0;\n    let mut prime_digit_value_prime: u8 = 0;\n    let mut prime_digit_value_prime_count:\
    \ usize = 0;\n    let mut prime_digit_value_prime_prime: u8 = 0;\n    let mut\
    \ prime_digit_value_prime_prime_count: usize = 0;\n    let mut prime_digit_value_prime_prime_prime:\
    \ u8 = 0;\n    let mut prime_digit_value_prime_prime_prime_count: usize = 0;\n\
    \    let mut prime_digit_value_prime_prime_prime_prime: u8 = 0;\n    let mut prime_digit_value_prime_prime_prime_prime_count:\
    \ usize = 0;\n    let mut prime_digit_value_prime_prime_prime_prime_prime: u8\
    \ = 0;\n    let mut prime_digit_value_prime_prime_prime_prime_prime_count: usize\
    \ = 0;\n    let mut prime_digit_value_prime_prime_prime_prime_prime_prime: u8\
    \ = 0;\n    let mut prime_digit_value_prime_prime_prime_prime_prime_count: usize\
    \ = 0;\n    let mut prime_digit_value_prime_prime_prime_prime_prime_prime: u8\
    \ = 0;\n    let mut prime_digit_value_prime_prime_prime_prime_prime_prime_count:\
    \ usize = 0;\n    let mut prime_digit_value_prime_prime_prime_prime_prime_prime_prime:\
    \ u8 = 0;\n    let mut prime_digit_value_prime_prime_prime_prime_prime_prime_prime_count:\
    \ usize = 0;\n    let mut prime_digit_value_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ u8 = 0;\n    let mut prime_digit_value_prime_prime_prime_prime_prime_prime_prime_prime_count:\
    \ usize = 0;\n    let mut prime_digit_value_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ u8 = 0;\n    let mut prime_digit_value_prime_prime_prime_prime_prime_prime_prime_prime_prime_count:\
    \ usize = 0;\n    let mut prime_digit_value_\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp0smwxx44.rs:50:31\n   |\n\
    50 |     let mut prime_digit_value_\n   |                               ^ help:\
    \ add `;` here\n51 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0smwxx44.rs:22:28\n   |\n22 | fn hex_key(num: String) -> isize\
    \ {\n   |    -------                 ^^^^^ expected `isize`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror[E0277]: a value of type `Vec<u8>` cannot be built from an iterator over\
    \ elements of type `char`\n    --> /tmp/tmp0smwxx44.rs:23:52\n     |\n23   | \
    \    let mut num: Vec<u8> = num.to_string().chars().collect();\n     |       \
    \                                             ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: isize = 0;\n    let mut prime_found = false;\n    let mut\
    \ prime_found2 = false;\n    let mut prime_found3 = false;\n    let mut prime_found4\
    \ = false;\n    let mut prime_found5 = false;\n    let mut prime_found6 = false;\n\
    \    let mut prime_found7 = false;\n    let mut prime_found8 = false;\n    let\
    \ mut prime_found9 = false;\n    let mut prime_found10 = false;\n    let mut prime_found11\
    \ = false;\n    let mut prime_found12 = false;\n    let mut prime_found13 = false;\n\
    \    let mut prime_found14 = false;\n    let mut prime_found15 = false;\n    let\
    \ mut prime_found16 = false;\n    let mut prime_found17 = false;\n    let mut\
    \ prime_found18 = false;\n    let mut prime_found19 = false;\n    let mut prime_found20\
    \ = false;\n    let mut prime_found21 = false;\n    let mut prime_found22 = false;\n\
    \    let mut prime_found23 = false;\n    let mut prime_found24 = false;\n    let\
    \ mut prime_found25 = false;\n    let mut prime_found26 = false;\n    let mut\
    \ prime_found27 = false;\n    let mut prime_found28 = false;\n    let mut prime_found29\
    \ = false;\n    let mut prime_found30 = false;\n    let mut prime_found31 = false;\n\
    \    let mut prime_found32 = false;\n    let mut prime_found33 = false;\n    let\
    \ mut prime_found34 = false;\n    let mut prime_found35 = false;\n    let mut\
    \ prime_found36 = false;\n    let mut prime_found37 = false;\n    let mut prime_found38\
    \ = false;\n    let mut prime_found39 = false;\n    let mut prime_found40 = false;\n\
    \    let mut prime_found41 = false;\n    let mut prime_found42 = false;\n    let\
    \ mut prime_found43 = false;\n    let mut prime_found44 = false;\n    let mut\
    \ prime_found45 = false;\n    let mut prime_found46 = false;\n    let mut prime_found47\
    \ = false;\n    let mut prime_found48 = false;\n    let mut prime_found49 = false;\n\
    \    let mut prime_found50 = false;\n    let mut prime_found51 = false;\n    let\
    \ mut prime_found52 = false;\n    let mut prime_found53 = false;\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmprl7xyb0c.rs:23:55\n     |\n23\
    \   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |\
    \                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprl7xyb0c.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut prime_count: isize = 0;\n    let mut prime_digit: u8 = 0;\n    let mut\
    \ prime_digit_count: isize = 0;\n    let mut prime_digit_sum: isize = 0;\n   \
    \ let mut prime_digit_sum2: isize = 0;\n    let mut prime_digit_sum3: isize =\
    \ 0;\n    let mut prime_digit_sum4: isize = 0;\n    let mut prime_digit_sum5:\
    \ isize = 0;\n    let mut prime_digit_sum6: isize = 0;\n    let mut prime_digit_sum7:\
    \ isize = 0;\n    let mut prime_digit_sum8: isize = 0;\n    let mut prime_digit_sum9:\
    \ isize = 0;\n    let mut prime_digit_sum10: isize = 0;\n    let mut prime_digit_sum11:\
    \ isize = 0;\n    let mut prime_digit_sum12: isize = 0;\n    let mut prime_digit_sum13:\
    \ isize = 0;\n    let mut prime_digit_sum14: isize = 0;\n    let mut prime_digit_sum15:\
    \ isize = 0;\n    let mut prime_digit_sum16: isize = 0;\n    let mut prime_digit_sum17:\
    \ isize = 0;\n    let mut prime_digit_sum18: isize = 0;\n    let mut prime_digit_sum19:\
    \ isize = 0;\n    let mut prime_digit_sum20: isize = 0;\n    let mut prime_digit_sum21:\
    \ isize = 0;\n    let mut prime_digit_sum22: isize = 0;\n    let mut prime_digit_sum23:\
    \ isize = 0;\n    let mut prime_digit_sum24: isize = 0;\n    let mut prime_digit_sum25:\
    \ isize = 0;\n    let mut prime_digit_sum26: isize = 0;\n    let mut prime_digit_sum27:\
    \ isize = 0;\n    let mut prime_digit_sum28: isize = 0;\n    let mut prime_digit_sum29:\
    \ isize = 0;\n    let mut prime_digit_sum30: isize = 0;\n    let mut prime_digit_sum31:\
    \ isize = 0;\n    let mut prime_digit_sum32: isize = 0;\n    let mut prime_digit_sum33:\
    \ isize = 0;\n    let mut prime_digit_sum34: isize = 0;\n    let mut prime_digit_sum35:\
    \ isize = 0;\n    let mut prime_digit_sum36: isize = 0;\n}\n\nfn main() {\n  \
    \  let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp697lzw1j.rs:22:28\n   |\n\
    22 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `char`\n  \
    \  --> /tmp/tmp697lzw1j.rs:23:52\n     |\n23   |     let mut num: Vec<u8> = num.to_string().chars().collect();\n\
    \     |                                                    ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut nums = num.chars().collect::<Vec<_>>();\n    let mut num_digits\
    \ = nums.len();\n    let mut num_primes = 0;\n    let mut num_primes_found = 0;\n\
    \    let mut prime_found = false;\n    let mut prime_found2 = false;\n    let\
    \ mut prime_found3 = false;\n    let mut prime_found4 = false;\n    let mut prime_found5\
    \ = false;\n    let mut prime_found6 = false;\n    let mut prime_found7 = false;\n\
    \    let mut prime_found8 = false;\n    let mut prime_found9 = false;\n    let\
    \ mut prime_found10 = false;\n    let mut prime_found11 = false;\n    let mut\
    \ prime_found12 = false;\n    let mut prime_found13 = false;\n    let mut prime_found14\
    \ = false;\n    let mut prime_found15 = false;\n    let mut prime_found16 = false;\n\
    \    let mut prime_found17 = false;\n    let mut prime_found18 = false;\n    let\
    \ mut prime_found19 = false;\n    let mut prime_found20 = false;\n    let mut\
    \ prime_found21 = false;\n    let mut prime_found22 = false;\n    let mut prime_found23\
    \ = false;\n    let mut prime_found24 = false;\n    let mut prime_found25 = false;\n\
    \    let mut prime_found26 = false;\n    let mut prime_found27 = false;\n    let\
    \ mut prime_found28 = false;\n    let mut prime_found29 = false;\n    let mut\
    \ prime_found30 = false;\n    let mut prime_found31 = false;\n    let mut prime_found32\
    \ = false;\n    let mut prime_found33 = false;\n    let mut prime_found34 = false;\n\
    \    let mut prime_found35 = false;\n    let mut prime_found36 = false;\n    let\
    \ mut prime_found37 = false;\n    let mut prime_found38 = false;\n    let mut\
    \ prime_found39 = false;\n    let mut prime_found40 = false;\n    let mut prime_found41\
    \ = false;\n    let mut prime_found42 = false;\n    let mut prime_found43 = false;\n\
    \    let mut prime_found44 = false;\n    let mut prime_found45 = false;\n    let\
    \ mut prime_found46 = false;\n    let mut prime_found47 = false;\n    let mut\
    \ prime_found48 = false;\n    let mut prime_found49 = false;\n    let mut prime_found50\
    \ = false;\n    let mut prime_found51 = false;\n    let mut \n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp1pmsfrdw.rs:79:1\n\
    \   |\n79 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c != 'a' && c != 'b' && c !=\
    \ 'c' && c != 'd' && c != 'e' && c != 'f').collect();\n    let mut num: Vec<u8>\
    \ = num.iter().filter(|&c| c != '0').collect();\n    let mut num: Vec<u8> = num.iter().filter(|&c|\
    \ c != '1').collect();\n    let mut num: Vec<u8> = num.iter().filter(|&c| c !=\
    \ '2').collect();\n    let mut num: Vec<u8> = num.iter().filter(|&c| c != '3').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c != '4').collect();\n    let\
    \ mut num: Vec<u8> = num.iter().filter(|&c| c != '5').collect();\n    let mut\
    \ num: Vec<u8> = num.iter().filter(|&c| c != '6').collect();\n    let mut num:\
    \ Vec<u8> = num.iter().filter(|&c| c != '7').collect();\n    let mut num: Vec<u8>\
    \ = num.iter().filter(|&c| c != '8').collect();\n    let mut num: Vec<u8> = num.iter().filter(|&c|\
    \ c != '9').collect();\n    let mut num: Vec<u8> = num.iter().filter(|&c| c !=\
    \ 'A').collect();\n    let mut num: Vec<u8> = num.iter().filter(|&c| c != 'B').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c != 'C').collect();\n    let\
    \ mut num: Vec<u8> = num.iter().filter(|&c| c != 'D').collect();\n    let mut\
    \ num: Vec<u8> = num.iter().filter(|&c| c != 'E').collect();\n    let mut num:\
    \ Vec<u8> = num.iter().filter(|&c| c != 'F').collect();\n    let mut num: Vec<u8>\
    \ = num.iter().filter(|&c| c != 'a').collect();\n    let mut num: \n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected type, found `}`\n  --> /tmp/tmpos89qgnu.rs:43:1\n   |\n\
    42 |     let mut num: \n   |         ------- while parsing the type for `mut num`\n\
    43 | }\n   | ^ expected type\n\nerror[E0277]: a value of type `Vec<u8>` cannot\
    \ be built from an iterator over elements of type `char`\n    --> /tmp/tmpos89qgnu.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpos89qgnu.rs:24:56\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&c| c != 'a' && c !=\
    \ 'b' && c != 'c' && c != 'd' && c != 'e' && c != 'f').collect();\n   |      \
    \                                                  ^^^ expected `u8`, found `char`\n\
    \nerror[E0277]: can't compare `&u8` with `char`\n  --> /tmp/tmpos89qgnu.rs:24:53\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&c| c != 'a' && c !=\
    \ 'b' && c != 'c' && c != 'd' && c != 'e' && c != 'f').collect();\n   |      \
    \                                               ^^ no implementation for `&u8\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&u8`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpos89qgnu.rs:24:68\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&c| c != 'a' && c !=\
    \ 'b' && c != 'c' && c != 'd' && c != 'e' && c != 'f').collect();\n   |      \
    \                                                              ^^^ expected `u8`,\
    \ found `char`\n\nerror[E0277]: can't compare `&u8` with `char`\n  --> /tmp/tmpos89qgnu.rs:24:65\n\
    \   |\n24 |"
  stdout: ''
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut counter: usize\
    \ = 0;\n    let mut prime_counter: usize = 0;\n    let mut prime_counter2: usize\
    \ = 0;\n    let mut prime_counter3: usize = 0;\n    let mut prime_counter4: usize\
    \ = 0;\n    let mut prime_counter5: usize = 0;\n    let mut prime_counter6: usize\
    \ = 0;\n    let mut prime_counter7: usize = 0;\n    let mut prime_counter8: usize\
    \ = 0;\n    let mut prime_counter9: usize = 0;\n    let mut prime_counter10: usize\
    \ = 0;\n    let mut prime_counter11: usize = 0;\n    let mut prime_counter12:\
    \ usize = 0;\n    let mut prime_counter13: usize = 0;\n    let mut prime_counter14:\
    \ usize = 0;\n    let mut prime_counter15: usize = 0;\n    let mut prime_counter16:\
    \ usize = 0;\n    let mut prime_counter17: usize = 0;\n    let mut prime_counter18:\
    \ usize = 0;\n    let mut prime_counter19: usize = 0;\n    let mut prime_counter20:\
    \ usize = 0;\n    let mut prime_counter21: usize = 0;\n    let mut prime_counter22:\
    \ usize = 0;\n    let mut prime_counter23: usize = 0;\n    let mut prime_counter24:\
    \ usize = 0;\n    let mut prime_counter25: usize = 0;\n    let mut prime_counter26:\
    \ usize = 0;\n    let mut prime_counter27: usize = 0;\n    let mut prime_counter28:\
    \ usize = 0;\n    let mut prime_counter29: usize = 0;\n    let mut prime_counter30:\
    \ usize = 0;\n    let mut prime_counter31: usize = 0;\n    let mut prime_counter32:\
    \ usize = 0;\n    let mut prime_counter33: usize = 0;\n    let mut prime_counter34:\
    \ usize = 0;\n    let mut prime_counter35: usize = 0;\n    let mut prime_counter36:\
    \ usize = 0;\n    let mut prime_counter37: usize = 0;\n\n}\n\nfn main() {\n  \
    \  let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmps9y6fyxe.rs:23:55\n     |\n23\
    \   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |\
    \                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps9y6fyxe.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let mut prime_counter:\
    \ usize = 0;\n    let mut digit: u8 = 0;\n    let mut digit_counter: usize = 0;\n\
    \    let mut digit_prime: u8 = 0;\n    let mut digit_prime_counter: usize = 0;\n\
    \    let mut digit_prime_counter2: usize = 0;\n    let mut digit_prime_counter3:\
    \ usize = 0;\n    let mut digit_prime_counter4: usize = 0;\n    let mut digit_prime_counter5:\
    \ usize = 0;\n    let mut digit_prime_counter6: usize = 0;\n    let mut digit_prime_counter7:\
    \ usize = 0;\n    let mut digit_prime_counter8: usize = 0;\n    let mut digit_prime_counter9:\
    \ usize = 0;\n    let mut digit_prime_counter10: usize = 0;\n    let mut digit_prime_counter11:\
    \ usize = 0;\n    let mut digit_prime_counter12: usize = 0;\n    let mut digit_prime_counter13:\
    \ usize = 0;\n    let mut digit_prime_counter14: usize = 0;\n    let mut digit_prime_counter15:\
    \ usize = 0;\n    let mut digit_prime_counter16: usize = 0;\n    let mut digit_prime_counter17:\
    \ usize = 0;\n    let mut digit_prime_counter18: usize = 0;\n    let mut digit_prime_counter19:\
    \ usize = 0;\n    let mut digit_prime_counter20: usize = 0;\n    let mut digit_prime_counter21:\
    \ usize = 0;\n    let mut digit_prime_counter22: usize = 0;\n    let mut digit_prime_counter23:\
    \ usize = 0;\n    let mut digit_prime_counter24: usize = 0;\n    let mut digit_prime_counter25:\
    \ usize = 0;\n    let mut digit_prime_counter26: usize = 0;\n    let mut digit_prime_counter27:\
    \ usize = 0;\n    let mut digit_prime_counter28: usize = 0;\n    let mut digit_prime_counter29:\
    \ usize = 0;\n    let mut digit_prime_counter30: usize = 0;\n    let mut digit_prime_counter31:\
    \ usize = 0;\n    let mut digit_prime_counter32: usize = 0;\n    let mut digit_prime_counter33:\
    \ usize = 0;\n    let mut digit_prime_counter34: u\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvponr3bx.rs:62:37\n   |\n\
    62 |     let mut digit_prime_counter34: u\n   |                              \
    \       ^ help: add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0412]:\
    \ cannot find type `u` in this scope\n  --> /tmp/tmpvponr3bx.rs:62:36\n   |\n\
    62 |     let mut digit_prime_counter34: u\n   |                              \
    \      ^ help: a builtin type with a similar name exists: `u8`\n\nerror[E0277]:\
    \ a value of type `Vec<u8>` cannot be built from an iterator over elements of\
    \ type `char`\n    --> /tmp/tmpvponr3bx.rs:23:55\n     |\n23   |     let mut num:\
    \ Vec<u8> = num.to_lowercase().chars().collect();\n     |                    \
    \                                   ^^^^^^^ value of type `Vec<u8>` cannot be\
    \ built from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait\
    \ `FromIterator<char>` is not implemented for `Vec<u8>`\n     = help: the trait\
    \ `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound in\
    \ `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvponr3bx.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0412.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num_digits = num.len();\n    let mut prime_digits = 0;\n    let mut\
    \ prime_digits_counter = 0;\n    let mut prime_digits_counter2 = 0;\n    let mut\
    \ prime_digits_counter3 = 0;\n    let mut prime_digits_counter4 = 0;\n    let\
    \ mut prime_digits_counter5 = 0;\n    let mut prime_digits_counter6 = 0;\n   \
    \ let mut prime_digits_counter7 = 0;\n    let mut prime_digits_counter8 = 0;\n\
    \    let mut prime_digits_counter9 = 0;\n    let mut prime_digits_counter10 =\
    \ 0;\n    let mut prime_digits_counter11 = 0;\n    let mut prime_digits_counter12\
    \ = 0;\n    let mut prime_digits_counter13 = 0;\n    let mut prime_digits_counter14\
    \ = 0;\n    let mut prime_digits_counter15 = 0;\n    let mut prime_digits_counter16\
    \ = 0;\n    let mut prime_digits_counter17 = 0;\n    let mut prime_digits_counter18\
    \ = 0;\n    let mut prime_digits_counter19 = 0;\n    let mut prime_digits_counter20\
    \ = 0;\n    let mut prime_digits_counter21 = 0;\n    let mut prime_digits_counter22\
    \ = 0;\n    let mut prime_digits_counter23 = 0;\n    let mut prime_digits_counter24\
    \ = 0;\n    let mut prime_digits_counter25 = 0;\n    let mut prime_digits_counter26\
    \ = 0;\n    let mut prime_digits_counter27 = 0;\n    let mut prime_digits_counter28\
    \ = 0;\n    let mut prime_digits_counter29 = 0;\n    let mut prime_digits_counter30\
    \ = 0;\n    let mut prime_digits_counter31 = 0;\n    let mut prime_digits_counter32\
    \ = 0;\n    let mut prime_digits_counter33 = 0;\n    let mut prime_digits_counter34\
    \ = 0;\n    let mut prime_digits_counter35 = 0;\n    let mut prime_digits_counter36\
    \ = 0;\n    let mut prime_digits_counter37 = 0;\n    let mut prime_digits_counter38\
    \ = 0;\n    let mut prime_digits_counter39 = 0;\n    let mut prime_digits_counter40\
    \ = 0;\n    let mut prime_digits_counter41 = 0;\n    let mut prime_digits_counter42\
    \ = 0;\n    let mut prime_digits_counter43 = 0;\n    let mut prime_digit\n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpb4xai1sp.rs:69:24\n   |\n\
    69 |     let mut prime_digit\n   |                        ^ help: add `;` here\n\
    70 | }\n   | - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot\
    \ be built from an iterator over elements of type `char`\n    --> /tmp/tmpb4xai1sp.rs:23:52\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_string().chars().collect();\n\
    \     |                                                    ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb4xai1sp.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_counter:\
    \ Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_counter_index: usize\
    \ = 0;\n    let mut prime_counter_index2: usize = 0;\n    let mut prime_counter_index3:\
    \ usize = 0;\n    let mut prime_counter_index4: usize = 0;\n    let mut prime_counter_index5:\
    \ usize = 0;\n    let mut prime_counter_index6: usize = 0;\n    let mut prime_counter_index7:\
    \ usize = 0;\n    let mut prime_counter_index8: usize = 0;\n    let mut prime_counter_index9:\
    \ usize = 0;\n    let mut prime_counter_index10: usize = 0;\n    let mut prime_counter_index11:\
    \ usize = 0;\n    let mut prime_counter_index12: usize = 0;\n    let mut prime_counter_index13:\
    \ usize = 0;\n    let mut prime_counter_index14: usize = 0;\n    let mut prime_counter_index15:\
    \ usize = 0;\n    let mut prime_counter_index16: usize = 0;\n    let mut prime_counter_index17:\
    \ usize = 0;\n    let mut prime_counter_index18: usize = 0;\n    let mut prime_counter_index19:\
    \ usize = 0;\n    let mut prime_counter_index20: usize = 0;\n    let mut prime_counter_index21:\
    \ usize = 0;\n    let mut prime_counter_index22: usize = 0;\n    let mut prime_counter_index23:\
    \ usize = 0;\n    let mut prime_counter_index24: usize = 0;\n    let mut prime_counter_index25:\
    \ usize = 0;\n    let mut prime_counter_index26: usize = 0;\n    let mut prime_counter_index27:\
    \ usize = 0;\n    let mut prime_counter_index28: usize = 0;\n    let mut prime_counter_index29:\
    \ usize = 0;\n    let mut prime_counter_index30: usize = 0;\n    let mut prime_counter_index31:\
    \ usize = 0;\n    let mut prime_counter_index32: usize = 0;\n    let mut prime_counter_index33:\
    \ usize = 0;\n    let mut prime_\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmphb22rtc_.rs:59:19\n   |\n\
    59 |     let mut prime_\n   |                   ^ help: add `;` here\n60 | }\n\
    \   | - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be\
    \ built from an iterator over elements of type `char`\n    --> /tmp/tmphb22rtc_.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphb22rtc_.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.in\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found keyword `in`\n  --> /tmp/tmpsxpv55i4.rs:39:32\n\
    \   |\n39 |     let mut num: Vec<u8> = num.in\n   |                          \
    \      ^^ expected identifier, found keyword\n   |\nhelp: escape `in` to use it\
    \ as an identifier\n   |\n39 |     let mut num: Vec<u8> = num.r#in\n   |     \
    \                           ++\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpsxpv55i4.rs:39:34\n\
    \   |\n39 |     let mut num: Vec<u8> = num.in\n   |                          \
    \        ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0277]:\
    \ a value of type `Vec<u8>` cannot be built from an iterator over elements of\
    \ type `char`\n    --> /tmp/tmpsxpv55i4.rs:23:52\n     |\n23   |     let mut num:\
    \ Vec<u8> = num.to_string().chars().collect();\n     |                       \
    \                             ^^^^^^^ value of type `Vec<u8>` cannot be built\
    \ from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsxpv55i4.rs:24:61\n   |\n24 |     let mut num:\
    \ Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n   |\
    \                                                             ^^^ expected `u8`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsxpv55i4.rs:24:73\n\
    \   |\n24 |     let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' &&\
    \ x <= '9').collect();\n   |                                                 \
    \                        ^^^ expected `u8`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpsxpv55i4.rs:25:61\n   |\n25 |     let mut num: Vec<u8>\
    \ = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n   |       \
    \                                                      ^^^ expected `u8`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsxpv55i4.rs:25:73\n\
    \   |\n25 |     let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' &&\
    \ x <= 'F').collect();\n   |              "
  stdout: ''
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_counter:\
    \ usize = 0;\n    let mut prime_counter2: usize = 0;\n    let mut prime_counter3:\
    \ usize = 0;\n    let mut prime_counter4: usize = 0;\n    let mut prime_counter5:\
    \ usize = 0;\n    let mut prime_counter6: usize = 0;\n    let mut prime_counter7:\
    \ usize = 0;\n    let mut prime_counter8: usize = 0;\n    let mut prime_counter9:\
    \ usize = 0;\n    let mut prime_counter10: usize = 0;\n    let mut prime_counter11:\
    \ usize = 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13:\
    \ usize = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: u\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpq_13wd7x.rs:62:31\n   |\n\
    62 |     let mut prime_counter38: u\n   |                               ^ help:\
    \ add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0412]: cannot find type\
    \ `u` in this scope\n  --> /tmp/tmpq_13wd7x.rs:62:30\n   |\n62 |     let mut prime_counter38:\
    \ u\n   |                              ^ help: a builtin type with a similar name\
    \ exists: `u8`\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from\
    \ an iterator over elements of type `char`\n    --> /tmp/tmpq_13wd7x.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq_13wd7x.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0412.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_counter:\
    \ usize = 0;\n    let mut prime_counter2: usize = 0;\n    let mut prime_counter3:\
    \ usize = 0;\n    let mut prime_counter4: usize = 0;\n    let mut prime_counter5:\
    \ usize = 0;\n    let mut prime_counter6: usize = 0;\n    let mut prime_counter7:\
    \ usize = 0;\n    let mut prime_counter8: usize = 0;\n    let mut prime_counter9:\
    \ usize = 0;\n    let mut prime_counter10: usize = 0;\n    let mut prime_counter11:\
    \ usize = 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13:\
    \ usize = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: u\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5h95n5pg.rs:62:31\n   |\n\
    62 |     let mut prime_counter38: u\n   |                               ^ help:\
    \ add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0412]: cannot find type\
    \ `u` in this scope\n  --> /tmp/tmp5h95n5pg.rs:62:30\n   |\n62 |     let mut prime_counter38:\
    \ u\n   |                              ^ help: a builtin type with a similar name\
    \ exists: `u8`\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from\
    \ an iterator over elements of type `char`\n    --> /tmp/tmp5h95n5pg.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5h95n5pg.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0412.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpmum7nkcc.rs:40:36\n   |\n\
    40 |     let mut num: Vec<u8> = num.iter\n   |                               \
    \     ^ help: add `;` here\n41 | }\n   | - unexpected token\n\nerror[E0277]: a\
    \ value of type `Vec<u8>` cannot be built from an iterator over elements of type\
    \ `char`\n    --> /tmp/tmpmum7nkcc.rs:23:55\n     |\n23   |     let mut num: Vec<u8>\
    \ = num.to_lowercase().chars().collect();\n     |                            \
    \                           ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmum7nkcc.rs:24:56\n   |\n24 |     let mut num:\
    \ Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n   |    \
    \                                                    ^^^ expected `&u8`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmum7nkcc.rs:24:68\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <=\
    \ '9').collect();\n   |                                                      \
    \              ^^^ expected `&u8`, found `char`\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `&u8`\n   \
    \ --> /tmp/tmpmum7nkcc.rs:24:73\n     |\n24   |     let mut num: Vec<u8> = num.iter().filter(|&x|\
    \ x >= '0' && x <= '9').collect();\n     |                                   \
    \                                      ^^^^^^^ value of type `Vec<u8>` cannot\
    \ be built from `std::iter::Iterator<Item=&u8>`\n     |\n     = help: the trait\
    \ `FromIterator<&u8>` is not implemented for `Vec<u8>`\n     = help: the trait\
    \ `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound in\
    \ `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmum7nkcc.rs:25:56\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <=\
    \ 'F').collect();\n   |                               "
  stdout: ''
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut nums = num.chars().collect::<Vec<_>>();\n    let mut nums_len\
    \ = nums.len();\n    let mut primes = vec![true; nums_len];\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpf7ghoeaq.rs:69:1\n   |\n69\
    \ | }\n   | ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpf7ghoeaq.rs:68:33\n\
    \   |\n68 |     let mut primes_len = primes.\n   |                           \
    \      ^ help: add `;` here\n69 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf7ghoeaq.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut nums = num.chars().collect::<Vec<_>>();\n    let mut nums_len\
    \ = nums.len();\n    let mut primes = vec![false; 26];\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp126hhtc8.rs:22:28\n   |\n\
    22 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num_prime: Vec<u8> = Vec::new();\n    let mut num_prime_counter: usize\
    \ = 0;\n    let mut num_prime_counter2: usize = 0;\n    let mut num_prime_counter3:\
    \ usize = 0;\n    let mut num_prime_counter4: usize = 0;\n    let mut num_prime_counter5:\
    \ usize = 0;\n    let mut num_prime_counter6: usize = 0;\n    let mut num_prime_counter7:\
    \ usize = 0;\n    let mut num_prime_counter8: usize = 0;\n    let mut num_prime_counter9:\
    \ usize = 0;\n    let mut num_prime_counter10: usize = 0;\n    let mut num_prime_counter11:\
    \ usize = 0;\n    let mut num_prime_counter12: usize = 0;\n    let mut num_prime_counter13:\
    \ usize = 0;\n    let mut num_prime_counter14: usize = 0;\n    let mut num_prime_counter15:\
    \ usize = 0;\n    let mut num_prime_counter16: usize = 0;\n    let mut num_prime_counter17:\
    \ usize = 0;\n    let mut num_prime_counter18: usize = 0;\n    let mut num_prime_counter19:\
    \ usize = 0;\n    let mut num_prime_counter20: usize = 0;\n    let mut num_prime_counter21:\
    \ usize = 0;\n    let mut num_prime_counter22: usize = 0;\n    let mut num_prime_counter23:\
    \ usize = 0;\n    let mut num_prime_counter24: usize = 0;\n    let mut num_prime_counter25:\
    \ usize = 0;\n    let mut num_prime_counter26: usize = 0;\n    let mut num_prime_counter27:\
    \ usize = 0;\n    let mut num_prime_counter28: usize = 0;\n    let mut num_prime_counter29:\
    \ usize = 0;\n    let mut num_prime_counter30: usize = 0;\n    let mut num_prime_counter31:\
    \ usize = 0;\n    let mut num_prime_counter32: usize = 0;\n    let mut num_prime_counter33:\
    \ usize = 0;\n    let mut num_prime_counter34: usize = 0;\n    let mut num_prime_counter35:\
    \ usize = 0;\n    let mut num_prime_counter36: usize = 0;\n    let mut num_prime_counter37:\
    \ usize = 0;\n    let \n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpz3rmj9d_.rs:63:1\n  \
    \ |\n63 | }\n   | ^ expected pattern\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n    --> /tmp/tmpz3rmj9d_.rs:23:52\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_string().chars().collect();\n\
    \     |                                                    ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5u_mhjhg.rs:40:36\n   |\n\
    40 |     let mut num: Vec<u8> = num.iter\n   |                               \
    \     ^ help: add `;` here\n41 | }\n   | - unexpected token\n\nerror[E0277]: a\
    \ value of type `Vec<u8>` cannot be built from an iterator over elements of type\
    \ `char`\n  --> /tmp/tmp5u_mhjhg.rs:23:52\n   |\n23 |     let mut num: Vec<u8>\
    \ = num.to_string().chars().collect();\n   |                                 \
    \                   ^^^^^^^ value of type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n\
    \   |\n   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp5u_mhjhg.rs:24:56\n   |\n24 |\
    \     let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \   |                                                        ^^^ expected `&u8`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5u_mhjhg.rs:24:68\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <=\
    \ '9').collect();\n   |                                                      \
    \              ^^^ expected `&u8`, found `char`\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `&u8`\n  -->\
    \ /tmp/tmp5u_mhjhg.rs:24:73\n   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&x|\
    \ x >= '0' && x <= '9').collect();\n   |                                     \
    \                                    ^^^^^^^ value of type `Vec<u8>` cannot be\
    \ built from `std::iter::Iterator<Item=&u8>`\n   |\n   = help: the trait `FromIterator<&u8>`\
    \ is not implemented for `Vec<u8>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5u_mhjhg.rs:25:56\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <=\
    \ 'F').collect();\n   |                                                      \
    \  ^^^ expected `&u8`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5u_mhjhg.rs:25:68\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <=\
    \ 'F').collect();\n   |                           "
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_prime: Vec<u8> = vec![];\n    let mut num_prime_2: Vec<u8> =\
    \ vec![];\n    let mut num_prime_3: Vec<u8> = vec![];\n    let mut num_prime_4:\
    \ Vec<u8> = vec![];\n    let mut num_prime_5: Vec<u8> = vec![];\n    let mut num_prime_6:\
    \ Vec<u8> = vec![];\n    let mut num_prime_7: Vec<u8> = vec![];\n    let mut num_prime_8:\
    \ Vec<u8> = vec![];\n    let mut num_prime_9: Vec<u8> = vec![];\n    let mut num_prime_10:\
    \ Vec<u8> = vec![];\n    let mut num_prime_11: Vec<u8> = vec![];\n    let mut\
    \ num_prime_12: Vec<u8> = vec![];\n    let mut num_prime_13: Vec<u8> = vec![];\n\
    \    let mut num_prime_14: Vec<u8> = vec![];\n    let mut num_prime_15: Vec<u8>\
    \ = vec![];\n    let mut num_prime_16: Vec<u8> = vec![];\n    let mut num_prime_17:\
    \ Vec<u8> = vec![];\n    let mut num_prime_18: Vec<u8> = vec![];\n    let mut\
    \ num_prime_19: Vec<u8> = vec![];\n    let mut num_prime_20: Vec<u8> = vec![];\n\
    \    let mut num_prime_21: Vec<u8> = vec![];\n    let mut num_prime_22: Vec<u8>\
    \ = vec![];\n    let mut num_prime_23: Vec<u8> = vec![];\n    let mut num_prime_24:\
    \ Vec<u8> = vec![];\n    let mut num_prime_25: Vec<u8> = vec![];\n    let mut\
    \ num_prime_26: Vec<u8> = vec![];\n    let mut num_prime_27: Vec<u8> = vec![];\n\
    \    let mut num_prime_28: Vec<u8> = vec![];\n    let mut num_prime_29: Vec<u8>\
    \ = vec![];\n    let mut num_prime_\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpgj2bjs_b.rs:53:23\n   |\n\
    53 |     let mut num_prime_\n   |                       ^ help: add `;` here\n\
    54 | }\n   | - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot\
    \ be built from an iterator over elements of type `char`\n  --> /tmp/tmpgj2bjs_b.rs:23:55\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgj2bjs_b.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748837
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut nums = num.chars().collect::<Vec<_>>();\n    let mut nums_iter\
    \ = nums.iter();\n    let mut nums_len = nums.len();\n    let mut nums_prime:\
    \ Vec<_> = Vec::new();\n    let mut nums_prime_len = nums_prime.len();\n    let\
    \ mut nums_prime_iter = nums_prime.iter();\n    let mut nums_prime_len = nums_prime.len();\n\
    \    let mut nums_prime_iter = nums_prime.iter();\n    let mut nums_prime_len\
    \ = nums_prime.len();\n    let mut nums_prime_iter = nums_prime.iter();\n    let\
    \ mut nums_prime_len = nums_prime.len();\n    let mut nums_prime_iter = nums_prime.iter();\n\
    \    let mut nums_prime_len = nums_prime.len();\n    let mut nums_prime_iter =\
    \ nums_prime.iter();\n    let mut nums_prime_len = nums_prime.len();\n    let\
    \ mut nums_prime_iter = nums_prime.iter();\n    let mut nums_prime_len = nums_prime.len();\n\
    \    let mut nums_prime_iter = nums_prime.iter();\n    let mut nums_prime_len\
    \ = nums_prime.len();\n    let mut nums_prime_iter = nums_prime.iter();\n    let\
    \ mut nums_prime_len = nums_prime.len();\n    let mut nums_prime_iter = nums_prime.iter();\n\
    \    let mut nums_prime_len = nums_prime.len();\n    let mut nums_prime_iter =\
    \ nums_prime.iter();\n    let mut nums_prime_len = nums_prime.len();\n    let\
    \ mut nums_prime_iter = nums_prime.iter();\n    let mut nums_prime_len = nums_prime.len();\n\
    \    let mut nums_prime_iter = nums_prime.iter();\n    let mut nums_prime_len\
    \ = nums_prime.len();\n    let mut nums_prime_iter = nums_prime.iter();\n    let\
    \ mut nums_prime_len = nums_prime.len();\n    let mut nums_prime_iter = nums_prime.iter();\n\
    \    let mut nums_prime_len = nums_prime.len();\n    let mut nums_prime_iter =\
    \ nums_prime.iter();\n    let mut nums_prime_\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp6m7u3bvp.rs:57:24\n   |\n\
    57 |     let mut nums_prime_\n   |                        ^ help: add `;` here\n\
    58 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6m7u3bvp.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748837
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut prime: Vec<u8> = vec![];\n    let mut prime_counter: usize = 0;\n  \
    \  let mut prime_counter2: usize = 0;\n    let mut prime_counter3: usize = 0;\n\
    \    let mut prime_counter4: usize = 0;\n    let mut prime_counter5: usize = 0;\n\
    \    let mut prime_counter6: usize = 0;\n    let mut prime_counter7: usize = 0;\n\
    \    let mut prime_counter8: usize = 0;\n    let mut prime_counter9: usize = 0;\n\
    \    let mut prime_counter10: usize = 0;\n    let mut prime_counter11: usize =\
    \ 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13: usize\
    \ = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: usize = 0;\n    let mut prime_counter39:\
    \ usize = 0;\n    let mut prime_counter40: usize = 0;\n    let mut prime\n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpe2moik5a.rs:65:18\n   |\n\
    65 |     let mut prime\n   |                  ^ help: add `;` here\n66 | }\n \
    \  | - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built\
    \ from an iterator over elements of type `char`\n  --> /tmp/tmpe2moik5a.rs:23:52\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_string().chars().collect();\n  \
    \ |                                                    ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the\
    \ trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpe2moik5a.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748837
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_count: isize = 0;\n    let mut prime_digit: u8 = 0;\n    let\
    \ mut prime_digit_count: isize = 0;\n    let mut prime_digit_sum: isize = 0;\n\
    \    let mut prime_digit_sum2: isize = 0;\n    let mut prime_digit_sum3: isize\
    \ = 0;\n    let mut prime_digit_sum4: isize = 0;\n    let mut prime_digit_sum5:\
    \ isize = 0;\n    let mut prime_digit_sum6: isize = 0;\n    let mut prime_digit_sum7:\
    \ isize = 0;\n    let mut prime_digit_sum8: isize = 0;\n    let mut prime_digit_sum9:\
    \ isize = 0;\n    let mut prime_digit_sum10: isize = 0;\n    let mut prime_digit_sum11:\
    \ isize = 0;\n    let mut prime_digit_sum12: isize = 0;\n    let mut prime_digit_sum13:\
    \ isize = 0;\n    let mut prime_digit_sum14: isize = 0;\n    let mut prime_digit_sum15:\
    \ isize = 0;\n    let mut prime_digit_sum16: isize = 0;\n    let mut prime_digit_sum17:\
    \ isize = 0;\n    let mut prime_digit_sum18: isize = 0;\n    let mut prime_digit_sum19:\
    \ isize = 0;\n    let mut prime_digit_sum20: isize = 0;\n    let mut prime_digit_sum21:\
    \ isize = 0;\n    let mut prime_digit_sum22: isize = 0;\n    let mut prime_digit_sum23:\
    \ isize = 0;\n    let mut prime_digit_sum24: isize = 0;\n    let mut prime_digit_sum25:\
    \ isize = 0;\n    let mut prime_digit_sum26: isize = 0;\n    let mut prime_digit_sum27:\
    \ isize = 0;\n    let mut prime_digit_sum28: isize = 0;\n    let mut prime_digit_sum29:\
    \ isize = 0;\n    let mut prime_digit_sum30: isize = 0;\n    let mut prime_digit_sum31:\
    \ isize = 0;\n    let mut prime_digit_sum32: isize = 0;\n    let mut prime_digit_sum33:\
    \ isize = 0;\n    let mut prime_digit_sum34: isize = 0;\n    let mut prime_digit_sum35:\
    \ isize = 0;\n    let mut prime_digit_sum36: isize = 0;\n}\n\nfn main() {\n  \
    \  let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppoij5j7x.rs:22:28\n   |\n\
    22 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `char`\n  -->\
    \ /tmp/tmppoij5j7x.rs:23:55\n   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748837
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_prime: Vec<u8> = vec![];\n    let mut num_prime_2: Vec<u8> =\
    \ vec![];\n    let mut num_prime_3: Vec<u8> = vec![];\n    let mut num_prime_4:\
    \ Vec<u8> = vec![];\n    let mut num_prime_5: Vec<u8> = vec![];\n    let mut num_prime_6:\
    \ Vec<u8> = vec![];\n    let mut num_prime_7: Vec<u8> = vec![];\n    let mut num_prime_8:\
    \ Vec<u8> = vec![];\n    let mut num_prime_9: Vec<u8> = vec![];\n    let mut num_prime_10:\
    \ Vec<u8> = vec![];\n    let mut num_prime_11: Vec<u8> = vec![];\n    let mut\
    \ num_prime_12: Vec<u8> = vec![];\n    let mut num_prime_13: Vec<u8> = vec![];\n\
    \    let mut num_prime_14: Vec<u8> = vec![];\n    let mut num_prime_15: Vec<u8>\
    \ = vec![];\n    let mut num_prime_16: Vec<u8> = vec![];\n    let mut num_prime_17:\
    \ Vec<u8> = vec![];\n    let mut num_prime_18: Vec<u8> = vec![];\n    let mut\
    \ num_prime_19: Vec<u8> = vec![];\n    let mut num_prime_20: Vec<u8> = vec![];\n\
    \    let mut num_prime_21: Vec<u8> = vec![];\n    let mut num_prime_22: Vec<u8>\
    \ = vec![];\n    let mut num_prime_23: Vec<u8> = vec![];\n    let mut num_prime_24:\
    \ Vec<u8> = vec![];\n    let mut num_prime_25: Vec<u8> = vec![];\n    let mut\
    \ num_prime_26: Vec<u8> = vec![];\n    let mut num_prime_27: Vec<u8> = vec![];\n\
    \    let mut num_prime_28: Vec<u8> = vec![];\n    let mut num_prime_29: Vec<u8>\
    \ = vec![];\n    let mut num_prime_\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpgj2bjs_b.rs:53:23\n   |\n\
    53 |     let mut num_prime_\n   |                       ^ help: add `;` here\n\
    54 | }\n   | - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot\
    \ be built from an iterator over elements of type `char`\n  --> /tmp/tmpgj2bjs_b.rs:23:55\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgj2bjs_b.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748837
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num_str: String = String::new();\n    let mut num_str2: String = String::new();\n\
    \    let mut num_str3: String = String::new();\n    let mut num_str4: String =\
    \ String::new();\n    let mut num_str5: String = String::new();\n    let mut num_str6:\
    \ String = String::new();\n    let mut num_str7: String = String::new();\n   \
    \ let mut num_str8: String = String::new();\n    let mut num_str9: String = String::new();\n\
    \    let mut num_str10: String = String::new();\n    let mut num_str11: String\
    \ = String::new();\n    let mut num_str12: String = String::new();\n    let mut\
    \ num_str13: String = String::new();\n    let mut num_str14: String = String::new();\n\
    \    let mut num_str15: String = String::new();\n    let mut num_str16: String\
    \ = String::new();\n    let mut num_str17: String = String::new();\n    let mut\
    \ num_str18: String = String::new();\n    let mut num_str19: String = String::new();\n\
    \    let mut num_str20: String = String::new();\n    let mut num_str21: String\
    \ = String::new();\n    let mut num_str22: String = String::new();\n    let mut\
    \ num_str23: String = String::new();\n    let mut num_str24: String = String::new();\n\
    \    let mut num_str25: String = String::new();\n    let mut num_str26: String\
    \ = String::new();\n    let mut num_str27: String = String::new();\n    let mut\
    \ num_str28: String = String::new();\n    let mut num_str29: String = String::new();\n\
    \    let mut num_str30: String = String::new();\n    let mut num_str31: String\
    \ = String::new();\n    let mut num_str32: String = String::new();\n    let mut\
    \ num_str33: String = String::new();\n    let mut num_str34: String = String::new();\n\
    \    let mut num_str35: String = String::new();\n    let mut num_str36: String\
    \ = String::new();\n    let mut num_str37: String = String::new();\n    let mut\
    \ num_str38: String = String::new();\n    let mut num_\n}\n\nfn main() {\n   \
    \ let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpttyyut86.rs:62:17\n   |\n\
    62 |     let mut num_\n   |                 ^ help: add `;` here\n63 | }\n   |\
    \ - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built\
    \ from an iterator over elements of type `char`\n  --> /tmp/tmpttyyut86.rs:23:52\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_string().chars().collect();\n  \
    \ |                                                    ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the\
    \ trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpttyyut86.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748837
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_counter:\
    \ usize = 0;\n    let mut prime_counter2: usize = 0;\n    let mut prime_counter3:\
    \ usize = 0;\n    let mut prime_counter4: usize = 0;\n    let mut prime_counter5:\
    \ usize = 0;\n    let mut prime_counter6: usize = 0;\n    let mut prime_counter7:\
    \ usize = 0;\n    let mut prime_counter8: usize = 0;\n    let mut prime_counter9:\
    \ usize = 0;\n    let mut prime_counter10: usize = 0;\n    let mut prime_counter11:\
    \ usize = 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13:\
    \ usize = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: u\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5h95n5pg.rs:62:31\n   |\n\
    62 |     let mut prime_counter38: u\n   |                               ^ help:\
    \ add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0412]: cannot find type\
    \ `u` in this scope\n  --> /tmp/tmp5h95n5pg.rs:62:30\n   |\n62 |     let mut prime_counter38:\
    \ u\n   |                              ^ help: a builtin type with a similar name\
    \ exists: `u8`\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from\
    \ an iterator over elements of type `char`\n    --> /tmp/tmp5h95n5pg.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5h95n5pg.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0412.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: isize = 0;\n    let mut prime_found = false;\n    let mut\
    \ prime_found2 = false;\n    let mut prime_found3 = false;\n    let mut prime_found4\
    \ = false;\n    let mut prime_found5 = false;\n    let mut prime_found6 = false;\n\
    \    let mut prime_found7 = false;\n    let mut prime_found8 = false;\n    let\
    \ mut prime_found9 = false;\n    let mut prime_found10 = false;\n    let mut prime_found11\
    \ = false;\n    let mut prime_found12 = false;\n    let mut prime_found13 = false;\n\
    \    let mut prime_found14 = false;\n    let mut prime_found15 = false;\n    let\
    \ mut prime_found16 = false;\n    let mut prime_found17 = false;\n    let mut\
    \ prime_found18 = false;\n    let mut prime_found19 = false;\n    let mut prime_found20\
    \ = false;\n    let mut prime_found21 = false;\n    let mut prime_found22 = false;\n\
    \    let mut prime_found23 = false;\n    let mut prime_found24 = false;\n    let\
    \ mut prime_found25 = false;\n    let mut prime_found26 = false;\n    let mut\
    \ prime_found27 = false;\n    let mut prime_found28 = false;\n    let mut prime_found29\
    \ = false;\n    let mut prime_found30 = false;\n    let mut prime_found31 = false;\n\
    \    let mut prime_found32 = false;\n    let mut prime_found33 = false;\n    let\
    \ mut prime_found34 = false;\n    let mut prime_found35 = false;\n    let mut\
    \ prime_found36 = false;\n    let mut prime_found37 = false;\n    let mut prime_found38\
    \ = false;\n    let mut prime_found39 = false;\n    let mut prime_found40 = false;\n\
    \    let mut prime_found41 = false;\n    let mut prime_found42 = false;\n    let\
    \ mut prime_found43 = false;\n    let mut prime_found44 = false;\n    let mut\
    \ prime_found45 = false;\n    let mut prime_found46 = false;\n    let mut prime_found47\
    \ = false;\n    let mut prime_found48 = false;\n    let mut prime_found49 = false;\n\
    \    let mut prime_found50 = false;\n    let mut prime_found51 = false;\n    let\
    \ mut prime_found52 = false;\n    let mut prime_found53 = false;\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmprl7xyb0c.rs:23:55\n     |\n23\
    \   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |\
    \                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprl7xyb0c.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![];\n    let mut prime_counter: usize = 0;\n\
    \    let mut prime_counter2: usize = 0;\n    let mut prime_counter3: usize = 0;\n\
    \    let mut prime_counter4: usize = 0;\n    let mut prime_counter5: usize = 0;\n\
    \    let mut prime_counter6: usize = 0;\n    let mut prime_counter7: usize = 0;\n\
    \    let mut prime_counter8: usize = 0;\n    let mut prime_counter9: usize = 0;\n\
    \    let mut prime_counter10: usize = 0;\n    let mut prime_counter11: usize =\
    \ 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13: usize\
    \ = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: usize = 0;\n    let mut prime_counter39:\
    \ usize = 0;\n    let mut prime_counter40: usize = 0;\n    let mut prime\n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp4biu6__m.rs:65:18\n   |\n\
    65 |     let mut prime\n   |                  ^ help: add `;` here\n66 | }\n \
    \  | - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built\
    \ from an iterator over elements of type `char`\n  --> /tmp/tmp4biu6__m.rs:23:55\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4biu6__m.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748837
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|&x| x as u8).collect();\n    let mut\
    \ num: Vec<u8> = num.iter().filter(|&x| x != 0).collect();\n    let mut num: Vec<u8>\
    \ = num.iter().filter(|&x| x % 2 == 0).collect();\n    let mut num: Vec<u8> =\
    \ num.iter().filter(|&x| x % 3 == 0).collect();\n    let mut num: Vec<u8> = num.iter().filter(|&x|\
    \ x % 5 == 0).collect();\n    let mut num: Vec<u8> = num.iter().filter(|&x| x\
    \ % 7 == 0).collect();\n    let mut num: Vec<u8> = num.iter().filter(|&x| x %\
    \ 11 == 0).collect();\n    let mut num: Vec<u8> = num.iter().filter(|&x| x % 13\
    \ == 0).collect();\n    let mut num: Vec<u8> = num.iter().filter(|&x| x % 17 ==\
    \ 0).collect();\n    let mut num: Vec<u8> = num.iter().filter(|&x| x % 19 == 0).collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x % 23 == 0).collect();\n \
    \   let mut num: Vec<u8> = num.iter().filter(|&x| x % 29 == 0).collect();\n  \
    \  let mut num: Vec<u8> = num.iter().filter(|&x| x % 31 == 0).collect();\n   \
    \ let mut num: Vec<u8> = num.iter().filter(|&x| x % 37 == 0).collect();\n    let\
    \ mut num: Vec<u8> = num.iter().filter(|&x| x % 41 == 0).collect();\n    let mut\
    \ num: Vec<u8> = num.iter().filter(|&x| x % 43 == 0).collect();\n    let mut num:\
    \ Vec<u8> = num.iter().filter(|&x| x % 47 == 0).collect();\n    let mut num: Vec<u8>\
    \ = num.iter().filter(|&x| x % 53 == 0).collect();\n    let mut num: Vec<u8> =\
    \ num.iter\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpg3q6_cpb.rs:42:36\n   |\n\
    42 |     let mut num: Vec<u8> = num.iter\n   |                               \
    \     ^ help: add `;` here\n43 | }\n   | - unexpected token\n\nerror[E0277]: a\
    \ value of type `Vec<u8>` cannot be built from an iterator over elements of type\
    \ `char`\n  --> /tmp/tmpg3q6_cpb.rs:23:55\n   |\n23 |     let mut num: Vec<u8>\
    \ = num.to_lowercase().chars().collect();\n   |                              \
    \                         ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n   |\n   = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n\nerror[E0277]: can't compare `&u8` with `{integer}`\n\
    \  --> /tmp/tmpg3q6_cpb.rs:25:53\n   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&x|\
    \ x != 0).collect();\n   |                                                   \
    \  ^^ no implementation for `&u8 == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&u8`\n\nerror[E0277]: a value of type `Vec<u8>` cannot\
    \ be built from an iterator over elements of type `&u8`\n  --> /tmp/tmpg3q6_cpb.rs:25:59\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&x| x != 0).collect();\n\
    \   |                                                           ^^^^^^^ value\
    \ of type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=&u8>`\n   |\n\
    \   = help: the trait `FromIterator<&u8>` is not implemented for `Vec<u8>`\n\n\
    error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator over\
    \ elements of type `&u8`\n  --> /tmp/tmpg3q6_cpb.rs:26:63\n   |\n26 |     let\
    \ mut num: Vec<u8> = num.iter().filter(|&x| x % 2 == 0).collect();\n   |     \
    \                                                          ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=&u8>`\n   |\n   = help:\
    \ the trait `FromIterator<&u8>` is not implemented for `Vec<u8>`\n\nerror[E0277]:\
    \ a value of type `Vec<u8>` cannot be built from an iterator over elements of\
    \ type `&u8`\n  --> /tmp/tmpg3q6_cpb.rs:27:63\n   |\n27 |     let mut num: Vec<u8>\
    \ = num.iter()."
  stdout: ''
  timestamp: 1659748837
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut nums = num.chars().collect::<Vec<_>>();\n    let mut num_digits\
    \ = nums.len();\n    let mut num_primes = 0;\n    let mut num_primes_digits =\
    \ 0;\n    let mut num_primes_digits_prime = 0;\n    let mut num_primes_digits_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime = 0;\n    let mut num_primes_digits_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime = 0;\n   \
    \ let mut num_primes_digits_prime_prime_prime_prime_prime_prime = 0;\n    let\
    \ mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime = 0;\n    let\
    \ mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n\
    \    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_\n}\n\
    \nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpfng90590.rs:45:67\n   |\n\
    45 |     let mut num_primes_digits_prime_prime_prime_prime_prime_prime_\n   |\
    \                                                                   ^ help: add\
    \ `;` here\n46 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpfng90590.rs:22:28\n   |\n22 | fn hex_key(num: String) -> isize\
    \ {\n   |    -------                 ^^^^^ expected `isize`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748837
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut prime: Vec<u8> = vec![2, 3, 5, 7];\n    let mut prime_counter: usize\
    \ = 0;\n    let mut prime_counter2: usize = 0;\n    let mut prime_counter3: usize\
    \ = 0;\n    let mut prime_counter4: usize = 0;\n    let mut prime_counter5: usize\
    \ = 0;\n    let mut prime_counter6: usize = 0;\n    let mut prime_counter7: usize\
    \ = 0;\n    let mut prime_counter8: usize = 0;\n    let mut prime_counter9: usize\
    \ = 0;\n    let mut prime_counter10: usize = 0;\n    let mut prime_counter11:\
    \ usize = 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13:\
    \ usize = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: usize = 0;\n    let mut prime_counter39:\
    \ usize = 0;\n    let mut prime_counter40: usize = 0;\n    let \n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpfvtu1830.rs:66:1\n  \
    \ |\n66 | }\n   | ^ expected pattern\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n  --> /tmp/tmpfvtu1830.rs:23:52\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_string().chars().collect();\n  \
    \ |                                                    ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the\
    \ trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748837
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num: Vec<u8> = num.into_iter().map(|x| x.to_digit(16)).collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|x| x % 2 == 0).collect();\n   \
    \ let mut num: Vec<u8> = num.iter().filter(|x| x % 3 == 0).collect();\n    let\
    \ mut num: Vec<u8> = num.iter().filter(|x| x % 5 == 0).collect();\n    let mut\
    \ num: Vec<u8> = num.iter().filter(|x| x % 7 == 0).collect();\n    let mut num:\
    \ Vec<u8> = num.iter().filter(|x| x % 11 == 0).collect();\n    let mut num: Vec<u8>\
    \ = num.iter().filter(|x| x % 13 == 0).collect();\n    let mut num: Vec<u8> =\
    \ num.iter().filter(|x| x % 17 == 0).collect();\n    let mut num: Vec<u8> = num.iter().filter(|x|\
    \ x % 19 == 0).collect();\n    let mut num: Vec<u8> = num.iter().filter(|x| x\
    \ % 23 == 0).collect();\n    let mut num: Vec<u8> = num.iter().filter(|x| x %\
    \ 29 == 0).collect();\n    let mut num: Vec<u8> = num.iter().filter(|x| x % 31\
    \ == 0).collect();\n    let mut num: Vec<u8> = num.iter().filter(|x| x % 37 ==\
    \ 0).collect();\n    let mut num: Vec<u8> = num.iter().filter(|x| x % 41 == 0).collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|x| x % 43 == 0).collect();\n  \
    \  let mut num: Vec<u8> = num.iter().filter(|x| x % 47 == 0).collect();\n    let\
    \ mut num: Vec<u8> = num.iter().filter(|x| x % 53 == 0).collect();\n    let mut\
    \ num: Vec<u8> = num.iter().filter(|x| x % 59 == 0).collect();\n    let mut num:\
    \ Vec<u8> = num.iter().filter(|x| x % 61 == 0).collect\n}\n\nfn main() {\n   \
    \ let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpj6k8xpfw.rs:42:70\n   |\n\
    42 |     let mut num: Vec<u8> = num.iter().filter(|x| x % 61 == 0).collect\n \
    \  |                                                                      ^ help:\
    \ add `;` here\n43 | }\n   | - unexpected token\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `char`\n  -->\
    \ /tmp/tmpj6k8xpfw.rs:23:52\n   |\n23 |     let mut num: Vec<u8> = num.to_string().chars().collect();\n\
    \   |                                                    ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0599]:\
    \ no method named `to_digit` found for type `u8` in the current scope\n  --> /tmp/tmpj6k8xpfw.rs:24:54\n\
    \   |\n24 |     let mut num: Vec<u8> = num.into_iter().map(|x| x.to_digit(16)).collect();\n\
    \   |                                                      ^^^^^^^^ method not\
    \ found in `u8`\n\nerror[E0369]: cannot mod `&&u8` by `{integer}`\n  --> /tmp/tmpj6k8xpfw.rs:25:52\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|x| x % 2 == 0).collect();\n\
    \   |                                                  - ^ - {integer}\n   | \
    \                                                 |\n   |                    \
    \                              &&u8\n   |\nhelp: `%` can be used on `u8`, you\
    \ can dereference `x`\n   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|x|\
    \ *x % 2 == 0).collect();\n   |                                              \
    \    +\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `&u8`\n  --> /tmp/tmpj6k8xpfw.rs:25:62\n   |\n25 |   \
    \  let mut num: Vec<u8> = num.iter().filter(|x| x % 2 == 0).collect();\n   | \
    \                                                             ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=&u8>`\n   |\n\
    \   = help: the trait `FromIterator<&u8>` is not implemented for `Vec<u8>`\n\n\
    error[E0369]: cannot mod `&&u8` by `{integer}`\n  --> /tmp/tmpj"
  stdout: ''
  timestamp: 1659748837
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_counter:\
    \ usize = 0;\n    let mut prime_counter2: usize = 0;\n    let mut prime_counter3:\
    \ usize = 0;\n    let mut prime_counter4: usize = 0;\n    let mut prime_counter5:\
    \ usize = 0;\n    let mut prime_counter6: usize = 0;\n    let mut prime_counter7:\
    \ usize = 0;\n    let mut prime_counter8: usize = 0;\n    let mut prime_counter9:\
    \ usize = 0;\n    let mut prime_counter10: usize = 0;\n    let mut prime_counter11:\
    \ usize = 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13:\
    \ usize = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: u\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5h95n5pg.rs:62:31\n   |\n\
    62 |     let mut prime_counter38: u\n   |                               ^ help:\
    \ add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0412]: cannot find type\
    \ `u` in this scope\n  --> /tmp/tmp5h95n5pg.rs:62:30\n   |\n62 |     let mut prime_counter38:\
    \ u\n   |                              ^ help: a builtin type with a similar name\
    \ exists: `u8`\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from\
    \ an iterator over elements of type `char`\n    --> /tmp/tmp5h95n5pg.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5h95n5pg.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0412.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_counter:\
    \ usize = 0;\n    let mut prime_counter2: usize = 0;\n    let mut prime_counter3:\
    \ usize = 0;\n    let mut prime_counter4: usize = 0;\n    let mut prime_counter5:\
    \ usize = 0;\n    let mut prime_counter6: usize = 0;\n    let mut prime_counter7:\
    \ usize = 0;\n    let mut prime_counter8: usize = 0;\n    let mut prime_counter9:\
    \ usize = 0;\n    let mut prime_counter10: usize = 0;\n    let mut prime_counter11:\
    \ usize = 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13:\
    \ usize = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: u\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5h95n5pg.rs:62:31\n   |\n\
    62 |     let mut prime_counter38: u\n   |                               ^ help:\
    \ add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0412]: cannot find type\
    \ `u` in this scope\n  --> /tmp/tmp5h95n5pg.rs:62:30\n   |\n62 |     let mut prime_counter38:\
    \ u\n   |                              ^ help: a builtin type with a similar name\
    \ exists: `u8`\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from\
    \ an iterator over elements of type `char`\n    --> /tmp/tmp5h95n5pg.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5h95n5pg.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0412.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_count: isize = 0;\n    let mut prime_digit: u8 = 0;\n    let\
    \ mut prime_digit_count: u8 = 0;\n    let mut prime_digit_sum: u8 = 0;\n    let\
    \ mut prime_digit_sum2: u8 = 0;\n    let mut prime_digit_sum3: u8 = 0;\n    let\
    \ mut prime_digit_sum4: u8 = 0;\n    let mut prime_digit_sum5: u8 = 0;\n    let\
    \ mut prime_digit_sum6: u8 = 0;\n    let mut prime_digit_sum7: u8 = 0;\n    let\
    \ mut prime_digit_sum8: u8 = 0;\n    let mut prime_digit_sum9: u8 = 0;\n    let\
    \ mut prime_digit_sum10: u8 = 0;\n    let mut prime_digit_sum11: u8 = 0;\n   \
    \ let mut prime_digit_sum12: u8 = 0;\n    let mut prime_digit_sum13: u8 = 0;\n\
    \    let mut prime_digit_sum14: u8 = 0;\n    let mut prime_digit_sum15: u8 = 0;\n\
    \    let mut prime_digit_sum16: u8 = 0;\n    let mut prime_digit_sum17: u8 = 0;\n\
    \    let mut prime_digit_sum18: u8 = 0;\n    let mut prime_digit_sum19: u8 = 0;\n\
    \    let mut prime_digit_sum20: u8 = 0;\n    let mut prime_digit_sum21: u8 = 0;\n\
    \    let mut prime_digit_sum22: u8 = 0;\n    let mut prime_digit_sum23: u8 = 0;\n\
    \    let mut prime_digit_sum24: u8 = 0;\n    let mut prime_digit_sum25: u8 = 0;\n\
    \    let mut prime_digit_sum26: u8 = 0;\n    let mut prime_digit_sum27: u8 = 0;\n\
    \    let mut prime_digit_sum28: u8 = 0;\n    let mut prime_digit_sum29: u8 = 0;\n\
    \    let mut prime_digit_sum30: u8 = 0;\n    let mut prime_digit_sum31: u8 = 0;\n\
    \    let mut prime_digit_sum32: u8 = 0;\n    let mut prime_digit_sum33: u8 = 0;\n\
    \    let mut prime_digit_sum34: u8 = 0;\n    let mut prime_digit_sum35: u8 = 0;\n\
    \    let mut prime_digit_sum36: u8 = 0;\n    let mut prime_digit_sum37: u8 = 0;\n\
    \    let mut prime_digit_sum38: u8 = 0;\n    let mut prime_digit_sum39: u8 = 0;\n\
    \n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgg13bnuq.rs:22:28\n   |\n\
    22 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `char`\n  -->\
    \ /tmp/tmpgg13bnuq.rs:23:55\n   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748837
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut count: usize = 0;\n    let mut prime: usize = 2;\n    let mut prime_found\
    \ = false;\n    let mut prime_found2 = false;\n    let mut prime_found3 = false;\n\
    \    let mut prime_found4 = false;\n    let mut prime_found5 = false;\n    let\
    \ mut prime_found6 = false;\n    let mut prime_found7 = false;\n    let mut prime_found8\
    \ = false;\n    let mut prime_found9 = false;\n    let mut prime_found10 = false;\n\
    \    let mut prime_found11 = false;\n    let mut prime_found12 = false;\n    let\
    \ mut prime_found13 = false;\n    let mut prime_found14 = false;\n    let mut\
    \ prime_found15 = false;\n    let mut prime_found16 = false;\n    let mut prime_found17\
    \ = false;\n    let mut prime_found18 = false;\n    let mut prime_found19 = false;\n\
    \    let mut prime_found20 = false;\n    let mut prime_found21 = false;\n    let\
    \ mut prime_found22 = false;\n    let mut prime_found23 = false;\n    let mut\
    \ prime_found24 = false;\n    let mut prime_found25 = false;\n    let mut prime_found26\
    \ = false;\n    let mut prime_found27 = false;\n    let mut prime_found28 = false;\n\
    \    let mut prime_found29 = false;\n    let mut prime_found30 = false;\n    let\
    \ mut prime_found31 = false;\n    let mut prime_found32 = false;\n    let mut\
    \ prime_found33 = false;\n    let mut prime_found34 = false;\n    let mut prime_found35\
    \ = false;\n    let mut prime_found36 = false;\n    let mut prime_found37 = false;\n\
    \    let mut prime_found38 = false;\n    let mut prime_found39 = false;\n    let\
    \ mut prime_found40 = false;\n    let mut prime_found41 = false;\n    let mut\
    \ prime_found42 = false;\n    let mut prime_found43 = false;\n    let mut prime_found44\
    \ = false;\n    let mut prime_found45 = false;\n    let mut prime_found46 = false;\n\
    \    let mut prime_found47 = false;\n    let mut prime_found48 = false;\n    let\
    \ mut prime_found49 = false;\n    let mut prime_found50 = false;\n    let mut\
    \ prime_found51 = false;\n    let mut prime_found52 = false;\n    let \n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp8y2orenz.rs:79:1\n  \
    \ |\n79 | }\n   | ^ expected pattern\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n  --> /tmp/tmp8y2orenz.rs:23:55\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748837
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut nums: Vec<u8> = num.chars().collect();\n    let mut num_prime: Vec<u8>\
    \ = nums.clone();\n    let mut num_prime_prime: Vec<u8> = num_prime.clone();\n\
    \    let mut num_prime_prime_prime: Vec<u8> = num_prime_prime.clone();\n    let\
    \ mut num_prime_prime_prime_prime: Vec<u8> = num_prime_prime_prime.clone();\n\
    \    let mut num_prime_prime_prime_prime_prime: Vec<u8> = num_prime_prime_prime_prime.clone();\n\
    \    let mut num_prime_prime_prime_prime_prime_prime: Vec<u8> = num_prime_prime_prime_prime_prime.clone();\n\
    \    let mut num_prime_prime_prime_prime_prime_prime_prime: Vec<u8> = num_prime_prime_prime_prime_prime_prime.clone();\n\
    \    let mut num_prime_prime_prime_prime_prime_prime_prime_prime: Vec<u8> = num_prime_prime_prime_prime_prime_prime_prime.clone();\n\
    \    let mut num_prime_prime_prime_prime_prime_prime_prime_prime: Vec<u8> = num_prime_prime_prime_prime_prime_prime_prime_prime.clone();\n\
    \    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime: Vec<u8>\
    \ = num_prime_prime_prime_prime_prime_prime_prime_prime_prime.clone();\n    let\
    \ mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime: Vec<u8> = num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime.clone();\n\
    \    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime: Vec<u8>\
    \ = num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime.clone();\n\
    \    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime.clone();\n\
    \    let mut num_prime\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmplt_rnu_7.rs:38:22\n   |\n\
    38 |     let mut num_prime\n   |                      ^ help: add `;` here\n39\
    \ | }\n   | - unexpected token\n\nerror[E0425]: cannot find value `num_prime_prime_prime_prime_prime_prime_prime_prime_prime`\
    \ in this scope\n  --> /tmp/tmplt_rnu_7.rs:34:82\n   |\n34 | ...e_prime_prime_prime:\
    \ Vec<u8> = num_prime_prime_prime_prime_prime_prime_prime_prime_prime.clone();\n\
    \   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `num_prime_prime_prime_prime_prime_prime_prime_prime`\n\
    \nerror[E0425]: cannot find value `num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime`\
    \ in this scope\n  --> /tmp/tmplt_rnu_7.rs:35:82\n   |\n35 | ...prime_prime_prime:\
    \ Vec<u8> = num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime.clone();\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `num_prime_prime_prime_prime_prime_prime_prime_prime_prime`\n\
    \nerror[E0425]: cannot find value `num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime`\
    \ in this scope\n  --> /tmp/tmplt_rnu_7.rs:36:82\n   |\n36 | ...prime_prime_prime:\
    \ Vec<u8> = num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime.clone();\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `num_prime_prime_prime_prime_prime_prime_prime_prime_prime`\n\
    \nerror[E0425]: cannot find value `num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime`\
    \ in this scope\n  --> /tmp/tmplt_rnu_7.rs:37:88\n   |\n37 | ...e_prime_prime:\
    \ Vec<u8> = num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime.clone();\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `num_prime_prime_prime_prime_prime_prime_prime_prime_prim"
  stdout: ''
  timestamp: 1659748837
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: isize = 0;\n    let mut num_str: String = num.to_string();\n\
    \    let mut num_str: Vec<&str> = num_str.chars().collect();\n    let mut num_str:\
    \ Vec<&str> = num_str.iter().map(|&x| x.to_string()).collect();\n    let mut num_str:\
    \ Vec<&str> = num_str.iter().map(|&x| x.to_string()).collect();\n    let mut num_str:\
    \ Vec<&str> = num_str.iter().map(|&x| x.to_string()).collect();\n    let mut num_str:\
    \ Vec<&str> = num_str.iter().map(|&x| x.to_string()).collect();\n    let mut num_str:\
    \ Vec<&str> = num_str.iter().map(|&x| x.to_string()).collect();\n    let mut num_str:\
    \ Vec<&str> = num_str.iter().map(|&x| x.to_string()).collect();\n    let mut num_str:\
    \ Vec<&str> = num_str.iter().map(|&x| x.to_string()).collect();\n    let mut num_str:\
    \ Vec<&str> = num_str.iter().map(|&x| x.to_string()).collect();\n    let mut num_str:\
    \ Vec<&str> = num_str.iter().map(|&x| x.to_string()).collect();\n    let mut num_str:\
    \ Vec<&str> = num_str.iter().map(|&x| x.to_string()).collect();\n    let mut num_str:\
    \ Vec<&str> = num_str.iter().map(|&x| x.to_string()).collect();\n    let mut num_str:\
    \ Vec<&str> = num_str.iter().map(|&x| x.to_string()).collect();\n    let mut num_str:\
    \ Vec<&str> = num_str.iter().map(|&x| x.to_string()).collect();\n    let mut num_str:\
    \ Vec<&str> = num_str.iter().map(|&x| x.to_string()).collect();\n    let mut num_str:\
    \ Vec<&str> = num_str.iter().map(|&x| x.to_string()).collect();\n    let mut num_str:\
    \ Vec<&str> = num_str.iter().map(|&x| x.to_string()).collect();\n    let mut num_str:\
    \ Vec<&str> = num_str.iter().map(|&x| x.to_string()).collect();\n    let mut num_str:\
    \ Vec<&str> = num_\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpnxi2u95e.rs:43:38\n   |\n\
    43 |     let mut num_str: Vec<&str> = num_\n   |                             \
    \         ^ help: add `;` here\n44 | }\n   | - unexpected token\n\nerror[E0425]:\
    \ cannot find value `num_` in this scope\n  --> /tmp/tmpnxi2u95e.rs:43:34\n  \
    \ |\n43 |     let mut num_str: Vec<&str> = num_\n   |                        \
    \          ^^^^ help: a local variable with a similar name exists: `num`\n\nerror[E0277]:\
    \ a value of type `Vec<&str>` cannot be built from an iterator over elements of\
    \ type `char`\n  --> /tmp/tmpnxi2u95e.rs:25:50\n   |\n25 |     let mut num_str:\
    \ Vec<&str> = num_str.chars().collect();\n   |                               \
    \                   ^^^^^^^ value of type `Vec<&str>` cannot be built from `std::iter::Iterator<Item=char>`\n\
    \   |\n   = help: the trait `FromIterator<char>` is not implemented for `Vec<&str>`\n\
    \nerror[E0277]: a value of type `Vec<&str>` cannot be built from an iterator over\
    \ elements of type `String`\n  --> /tmp/tmpnxi2u95e.rs:26:73\n   |\n26 |     let\
    \ mut num_str: Vec<&str> = num_str.iter().map(|&x| x.to_string()).collect();\n\
    \   |                                                                        \
    \ ^^^^^^^ value of type `Vec<&str>` cannot be built from `std::iter::Iterator<Item=String>`\n\
    \   |\n   = help: the trait `FromIterator<String>` is not implemented for `Vec<&str>`\n\
    \nerror[E0277]: a value of type `Vec<&str>` cannot be built from an iterator over\
    \ elements of type `String`\n  --> /tmp/tmpnxi2u95e.rs:27:73\n   |\n27 |     let\
    \ mut num_str: Vec<&str> = num_str.iter().map(|&x| x.to_string()).collect();\n\
    \   |                                                                        \
    \ ^^^^^^^ value of type `Vec<&str>` cannot be built from `std::iter::Iterator<Item=String>`\n\
    \   |\n   = help: the trait `FromIterator<String>` is not implemented for `Vec<&str>`\n\
    \nerror[E0277]: a value of type `Vec<&str>` cannot be built from an iterator over\
    \ elements of type `String`\n  --> /tmp/tmpnxi2u95e.rs:28:73\n   |\n28 |     let\
    \ mut num_str: Vec<&str> = num_str.iter().map(|&x| x.to_s"
  stdout: ''
  timestamp: 1659748837
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c != 'a' && c != 'b' && c !=\
    \ 'c' && c != 'd' && c != 'e' && c != 'f').collect();\n    let mut num: Vec<u8>\
    \ = num.iter().filter(|&c| c != '0').collect();\n    let mut num: Vec<u8> = num.iter().filter(|&c|\
    \ c != '1').collect();\n    let mut num: Vec<u8> = num.iter().filter(|&c| c !=\
    \ '2').collect();\n    let mut num: Vec<u8> = num.iter().filter(|&c| c != '3').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c != '4').collect();\n    let\
    \ mut num: Vec<u8> = num.iter().filter(|&c| c != '5').collect();\n    let mut\
    \ num: Vec<u8> = num.iter().filter(|&c| c != '6').collect();\n    let mut num:\
    \ Vec<u8> = num.iter().filter(|&c| c != '7').collect();\n    let mut num: Vec<u8>\
    \ = num.iter().filter(|&c| c != '8').collect();\n    let mut num: Vec<u8> = num.iter().filter(|&c|\
    \ c != '9').collect();\n    let mut num: Vec<u8> = num.iter().filter(|&c| c !=\
    \ 'A').collect();\n    let mut num: Vec<u8> = num.iter().filter(|&c| c != 'B').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c != 'C').collect();\n    let\
    \ mut num: Vec<u8> = num.iter().filter(|&c| c != 'D').collect();\n    let mut\
    \ num: Vec<u8> = num.iter().filter(|&c| c != 'E').collect();\n    let mut num:\
    \ Vec<u8> = num.iter().filter(|&c| c != 'F').collect();\n    let mut num: Vec<u8>\
    \ = num.iter().filter(|&c| c != 'a').collect();\n    let mut num: \n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected type, found `}`\n  --> /tmp/tmpos89qgnu.rs:43:1\n   |\n\
    42 |     let mut num: \n   |         ------- while parsing the type for `mut num`\n\
    43 | }\n   | ^ expected type\n\nerror[E0277]: a value of type `Vec<u8>` cannot\
    \ be built from an iterator over elements of type `char`\n    --> /tmp/tmpos89qgnu.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpos89qgnu.rs:24:56\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&c| c != 'a' && c !=\
    \ 'b' && c != 'c' && c != 'd' && c != 'e' && c != 'f').collect();\n   |      \
    \                                                  ^^^ expected `u8`, found `char`\n\
    \nerror[E0277]: can't compare `&u8` with `char`\n  --> /tmp/tmpos89qgnu.rs:24:53\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&c| c != 'a' && c !=\
    \ 'b' && c != 'c' && c != 'd' && c != 'e' && c != 'f').collect();\n   |      \
    \                                               ^^ no implementation for `&u8\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&u8`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpos89qgnu.rs:24:68\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&c| c != 'a' && c !=\
    \ 'b' && c != 'c' && c != 'd' && c != 'e' && c != 'f').collect();\n   |      \
    \                                                              ^^^ expected `u8`,\
    \ found `char`\n\nerror[E0277]: can't compare `&u8` with `char`\n  --> /tmp/tmpos89qgnu.rs:24:65\n\
    \   |\n24 |"
  stdout: ''
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: isize = 0;\n    let mut digit: isize = 0;\n    let\
    \ mut prime: isize = 0;\n    let mut prime_found = false;\n    let mut digits_found\
    \ = 0;\n    let mut digits_not_found = 0;\n    let mut digits_not_found_prime\
    \ = 0;\n    let mut digits_not_found_prime_found = false;\n    let mut digits_not_found_prime_not_found\
    \ = false;\n    let mut digits_not_found_prime_not_found_prime = false;\n    let\
    \ mut digits_not_found_prime_not_found_prime_found = false;\n    let mut digits_not_found_prime_not_found_prime_not_found\
    \ = false;\n    let mut digits_not_found_prime_not_found_prime_not_found_prime\
    \ = false;\n    let mut digits_not_found_prime_not_found_prime_not_found_prime_found\
    \ = false;\n    let mut digits_not_found_prime_not_found_prime_not_found_prime_not_found\
    \ = false;\n    let mut digits_not_found_prime_not_found_prime_not_found_prime_not_found_prime\
    \ = false;\n    let mut digits_not_found_prime_not_found_prime_not_found_prime_not_found_prime_found\
    \ = false;\n    let mut digits_not_found_prime_not_found_prime_not_found_prime_not_found_prime_not_found\
    \ = false;\n    let mut digits_not_found_prime_not_found_prime_not_found_prime_not_found_prime_not_found_prime\
    \ = false;\n    let mut digits_not_found_prime_not_found_prime_not_found_prime_not_found_prime_not_found_prime_found\
    \ = false;\n    let mut digits_not_found_prime_not_found_prime_not_found_prime_not_found_prime_not_found_prime_not_found\
    \ = false;\n    let mut digits_not_found_prime_not_found_prime_not_found_prime_not_found_prime_not_found_prime_not_found_prime\
    \ = false;\n    let mut digits_not_found_prime_not_found_prime_not_found_prime_not_found_prime_not_found_prime_not_found_prime_found\
    \ = false;\n    let mut digits_not_found_prime_not_found_prime_not_found_prime_not_found_prime_not_found_prime_not_found_prime_not_found\
    \ = false;\n    let mut digits_not_found_prime_not_found_prime_not_found_prime_not_found_prime_not_found_prime_not_found_prime_not_found_prime\
    \ = false;\n    let mut digits_not_found_prime_not_found_prime_not_found_prime_not_found_prime_not_found_prime_not_found_prime_not_found_prime_found\
    \ = false;\n\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi8fnatnp.rs:22:28\n   |\n\
    22 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748837
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_count: usize = 0;\n    let mut prime_digit: u8 = 0;\n    let\
    \ mut prime_digit_count: usize = 0;\n    let mut prime_digit_sum: usize = 0;\n\
    \    let mut prime_digit_sum2: usize = 0;\n    let mut prime_digit_sum3: usize\
    \ = 0;\n    let mut prime_digit_sum4: usize = 0;\n    let mut prime_digit_sum5:\
    \ usize = 0;\n    let mut prime_digit_sum6: usize = 0;\n    let mut prime_digit_sum7:\
    \ usize = 0;\n    let mut prime_digit_sum8: usize = 0;\n    let mut prime_digit_sum9:\
    \ usize = 0;\n    let mut prime_digit_sum10: usize = 0;\n    let mut prime_digit_sum11:\
    \ usize = 0;\n    let mut prime_digit_sum12: usize = 0;\n    let mut prime_digit_sum13:\
    \ usize = 0;\n    let mut prime_digit_sum14: usize = 0;\n    let mut prime_digit_sum15:\
    \ usize = 0;\n    let mut prime_digit_sum16: usize = 0;\n    let mut prime_digit_sum17:\
    \ usize = 0;\n    let mut prime_digit_sum18: usize = 0;\n    let mut prime_digit_sum19:\
    \ usize = 0;\n    let mut prime_digit_sum20: usize = 0;\n    let mut prime_digit_sum21:\
    \ usize = 0;\n    let mut prime_digit_sum22: usize = 0;\n    let mut prime_digit_sum23:\
    \ usize = 0;\n    let mut prime_digit_sum24: usize = 0;\n    let mut prime_digit_sum25:\
    \ usize = 0;\n    let mut prime_digit_sum26: usize = 0;\n    let mut prime_digit_sum27:\
    \ usize = 0;\n    let mut prime_digit_sum28: usize = 0;\n    let mut prime_digit_sum29:\
    \ usize = 0;\n    let mut prime_digit_sum30: usize = 0;\n    let mut prime_digit_sum31:\
    \ usize = 0;\n    let mut prime_digit_sum32: usize = 0;\n    let mut prime_digit_sum33:\
    \ usize = 0;\n    let mut prime_digit_sum34: usize = 0;\n    let mut prime_digit_sum35:\
    \ usize = 0;\n    let mut prime_digit_sum36: usize = 0;\n}\n\nfn main() {\n  \
    \  let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptpaoa0ti.rs:22:28\n   |\n\
    22 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `char`\n  -->\
    \ /tmp/tmptpaoa0ti.rs:23:55\n   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748837
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: isize = 0;\n    let mut num_str: String = num.to_string();\n\
    \    let mut num_str: Vec<&str> = num_str.chars().collect();\n    let mut num_str:\
    \ Vec<&str> = num_str.iter().filter(|&x| x >= '0' && x <= '9').collect();\n  \
    \  let mut num_str: Vec<&str> = num_str.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num_str: Vec<&str> = num_str.iter().filter(|&x| x >= 'a' && x <=\
    \ 'f').collect();\n    let mut num_str: Vec<&str> = num_str.iter().filter(|&x|\
    \ x >= '0' && x <= '9').collect();\n    let mut num_str: Vec<&str> = num_str.iter().filter(|&x|\
    \ x >= 'A' && x <= 'F').collect();\n    let mut num_str: Vec<&str> = num_str.iter().filter(|&x|\
    \ x >= 'a' && x <= 'f').collect();\n    let mut num_str: Vec<&str> = num_str.iter().filter(|&x|\
    \ x >= '0' && x <= '9').collect();\n    let mut num_str: Vec<&str> = num_str.iter().filter(|&x|\
    \ x >= 'A' && x <= 'F').collect();\n    let mut num_str: Vec<&str> = num_str.iter().filter(|&x|\
    \ x >= 'a' && x <= 'f').collect();\n    let mut num_str: Vec<&str> = num_str.iter().filter(|&x|\
    \ x >= '0' && x <= '9').collect();\n    let mut num_str: Vec<&str> = num_str.iter().filter(|&x|\
    \ x >= 'A' && x <= 'F').collect();\n    let mut num_str: Vec<&str> = num_str.iter().filter(|&x|\
    \ x >= 'a' && x <= 'f').collect();\n    let mut num_str: Vec<&str> = num_str.iter().filter(|&x|\
    \ x >= '0' && x <= '9').collect();\n    let mut num_str: Vec<&str> = num_str.iter().filter(|&x|\
    \ x >= 'A' && x <= 'F').collect();\n    let mut num_str: Vec<&str> = num_str.iter().filter(|&x|\
    \ x >= 'a\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpcix66hiz.rs:40:55\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |                         \
    \         - closing delimiter possibly meant for this\n...\n40 |     let mut num_str:\
    \ Vec<&str> = num_str.iter().filter(|&x| x >= 'a\n   |                       \
    \                                ^ unclosed delimiter\n41 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror: expected `while`, `for`, `loop` or `{` after a label\n\
    \  --> /tmp/tmpcix66hiz.rs:41:1\n   |\n41 | }\n   | ^ expected `while`, `for`,\
    \ `loop` or `{` after a label\n\nerror: expected expression, found `)`\n  -->\
    \ /tmp/tmpcix66hiz.rs:41:1\n   |\n41 | }\n   | ^ expected expression\n\nerror[E0277]:\
    \ a value of type `Vec<&str>` cannot be built from an iterator over elements of\
    \ type `char`\n  --> /tmp/tmpcix66hiz.rs:25:50\n   |\n25 |     let mut num_str:\
    \ Vec<&str> = num_str.chars().collect();\n   |                               \
    \                   ^^^^^^^ value of type `Vec<&str>` cannot be built from `std::iter::Iterator<Item=char>`\n\
    \   |\n   = help: the trait `FromIterator<char>` is not implemented for `Vec<&str>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpcix66hiz.rs:26:66\n   |\n26 |\
    \     let mut num_str: Vec<&str> = num_str.iter().filter(|&x| x >= '0' && x <=\
    \ '9').collect();\n   |                                                      \
    \            ^^^ expected `&&str`, found `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpcix66hiz.rs:26:78\n   |\n26 |     let mut num_str: Vec<&str> =\
    \ num_str.iter().filter(|&x| x >= '0' && x <= '9').collect();\n   |          \
    \                                                                    ^^^ expected\
    \ `&&str`, found `char`\n\nerror[E0277]: a value of type `Vec<&str>` cannot be\
    \ built from an iterator over elements of type `&&str`\n  --> /tmp/tmpcix66hiz.rs:26:83\n\
    \   |\n26 |     let mut num_str: Vec<&str> = num_str.iter().filter(|&x| x >= '0'\
    \ && x <= '9').collect();\n   |                                              \
    \                                     ^^^^^^^ value of type `Vec<&str>` cannot\
    \ be built from `std:"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut count = 1;\n    let mut prime: isize = 0;\n    let mut prime_found\
    \ = false;\n    let mut prime_found2 = false;\n    let mut prime_found3 = false;\n\
    \    let mut prime_found4 = false;\n    let mut prime_found5 = false;\n    let\
    \ mut prime_found6 = false;\n    let mut prime_found7 = false;\n    let mut prime_found8\
    \ = false;\n    let mut prime_found9 = false;\n    let mut prime_found10 = false;\n\
    \    let mut prime_found11 = false;\n    let mut prime_found12 = false;\n    let\
    \ mut prime_found13 = false;\n    let mut prime_found14 = false;\n    let mut\
    \ prime_found15 = false;\n    let mut prime_found16 = false;\n    let mut prime_found17\
    \ = false;\n    let mut prime_found18 = false;\n    let mut prime_found19 = false;\n\
    \    let mut prime_found20 = false;\n    let mut prime_found21 = false;\n    let\
    \ mut prime_found22 = false;\n    let mut prime_found23 = false;\n    let mut\
    \ prime_found24 = false;\n    let mut prime_found25 = false;\n    let mut prime_found26\
    \ = false;\n    let mut prime_found27 = false;\n    let mut prime_found28 = false;\n\
    \    let mut prime_found29 = false;\n    let mut prime_found30 = false;\n    let\
    \ mut prime_found31 = false;\n    let mut prime_found32 = false;\n    let mut\
    \ prime_found33 = false;\n    let mut prime_found34 = false;\n    let mut prime_found35\
    \ = false;\n    let mut prime_found36 = false;\n    let mut prime_found37 = false;\n\
    \    let mut prime_found38 = false;\n    let mut prime_found39 = false;\n    let\
    \ mut prime_found40 = false;\n    let mut prime_found41 = false;\n    let mut\
    \ prime_found42 = false;\n    let mut prime_found43 = false;\n    let mut prime_found44\
    \ = false;\n    let mut prime_found45 = false;\n    let mut prime_found46 = false;\n\
    \    let mut prime_found47 = false;\n    let mut prime_found48 = false;\n    let\
    \ mut prime_found49 = false;\n    let mut prime_found50 = false;\n    let mut\
    \ prime_found51 = false;\n    let mut prime_found52 = false;\n    let mut \n}\n\
    \nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpdgb3vqwb.rs:79:1\n\
    \   |\n79 | }\n   | ^ expected identifier\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n  --> /tmp/tmpdgb3vqwb.rs:23:55\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748837
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_counter:\
    \ Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_counter2: Vec<u8>\
    \ = vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_counter3: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_counter4: Vec<u8> = vec![0, 0, 0, 0,\
    \ 0, 0, 0, 0];\n    let mut prime_counter5: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0,\
    \ 0];\n    let mut prime_counter6: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n \
    \   let mut prime_counter7: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let mut\
    \ prime_counter8: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_counter9:\
    \ Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_counter10: Vec<u8>\
    \ = vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_counter11: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_counter12: Vec<u8> = vec![0, 0, 0,\
    \ 0, 0, 0, 0, 0];\n    let mut prime_counter13: Vec<u8> = vec![0, 0, 0, 0, 0,\
    \ 0, 0, 0];\n    let mut prime_counter14: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0,\
    \ 0];\n    let mut prime_counter15: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n\
    \    let mut prime_counter16: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let\
    \ mut prime_counter17: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_counter18:\
    \ Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_counter19: Vec<u8>\
    \ = vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_counter20: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_counter21: Vec<u8> = vec![0, 0, 0,\
    \ 0, 0, 0, 0, 0];\n    let mut prime_counter22: Vec<u8> = vec![0, 0, 0, 0, 0,\
    \ 0, 0, 0];\n    let mut prime_counter23: Vec<u8> = \n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpuzj2p86g.rs:48:1\n\
    \   |\n48 | }\n   | ^ expected expression\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n  --> /tmp/tmpuzj2p86g.rs:23:55\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748837
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut count = 1;\n    let mut prime: isize = 2;\n    let mut prime_found =\
    \ false;\n    let mut prime_found2 = false;\n    let mut prime_found3 = false;\n\
    \    let mut prime_found4 = false;\n    let mut prime_found5 = false;\n    let\
    \ mut prime_found6 = false;\n    let mut prime_found7 = false;\n    let mut prime_found8\
    \ = false;\n    let mut prime_found9 = false;\n    let mut prime_found10 = false;\n\
    \    let mut prime_found11 = false;\n    let mut prime_found12 = false;\n    let\
    \ mut prime_found13 = false;\n    let mut prime_found14 = false;\n    let mut\
    \ prime_found15 = false;\n    let mut prime_found16 = false;\n    let mut prime_found17\
    \ = false;\n    let mut prime_found18 = false;\n    let mut prime_found19 = false;\n\
    \    let mut prime_found20 = false;\n    let mut prime_found21 = false;\n    let\
    \ mut prime_found22 = false;\n    let mut prime_found23 = false;\n    let mut\
    \ prime_found24 = false;\n    let mut prime_found25 = false;\n    let mut prime_found26\
    \ = false;\n    let mut prime_found27 = false;\n    let mut prime_found28 = false;\n\
    \    let mut prime_found29 = false;\n    let mut prime_found30 = false;\n    let\
    \ mut prime_found31 = false;\n    let mut prime_found32 = false;\n    let mut\
    \ prime_found33 = false;\n    let mut prime_found34 = false;\n    let mut prime_found35\
    \ = false;\n    let mut prime_found36 = false;\n    let mut prime_found37 = false;\n\
    \    let mut prime_found38 = false;\n    let mut prime_found39 = false;\n    let\
    \ mut prime_found40 = false;\n    let mut prime_found41 = false;\n    let mut\
    \ prime_found42 = false;\n    let mut prime_found43 = false;\n    let mut prime_found44\
    \ = false;\n    let mut prime_found45 = false;\n    let mut prime_found46 = false;\n\
    \    let mut prime_found47 = false;\n    let mut prime_found48 = false;\n    let\
    \ mut prime_found49 = false;\n    let mut prime_found50 = false;\n    let mut\
    \ prime_found51 = false;\n    let mut prime_found52 = false;\n    let mut \n}\n\
    \nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp3jpbeptq.rs:79:1\n\
    \   |\n79 | }\n   | ^ expected identifier\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n  --> /tmp/tmp3jpbeptq.rs:23:52\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_string().chars().collect();\n  \
    \ |                                                    ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the\
    \ trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748837
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_digits = num.len();\n    let mut num_primes = 0;\n    let mut\
    \ num_primes_digits = 0;\n    let mut num_primes_digits_prime = 0;\n    let mut\
    \ num_primes_digits_prime_prime = 0;\n    let mut num_primes_digits_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime = 0;\n    let mut\
    \ num_primes_digits_prime_prime_prime_prime_prime = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n  --> /tmp/tmp8f5dpwr8.rs:23:55\n   |\n23 |  \
    \   let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n   |       \
    \                                                ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the\
    \ trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8f5dpwr8.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748837
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_2:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\
    \ 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_3: Vec<u8> = vec![2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97];\n    let mut num_prime_4: Vec<u8> = vec![2, 3, 5, 7, 11, 13,\
    \ 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n\
    \    let mut num_prime_5: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_6:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\
    \ 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_7: Vec<u8> = vec![2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97];\n    let mut num_prime_8: Vec<u8> = vec![2, 3, 5, 7, 11, 13,\
    \ 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n\
    \    let mut num_prime_9: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_10:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\
    \ 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_11: Vec<u8> = vec![2,\
    \ 3, 5, 7, 11, \n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpmag_tm9a.rs:34:41\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |                         \
    \         - closing delimiter possibly meant for this\n...\n34 |     let mut num_prime_11:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, \n   |                                      \
    \   ^ unclosed delimiter\n35 | }\n   | ^ mismatched closing delimiter\n\nerror:\
    \ expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n  --> /tmp/tmpmag_tm9a.rs:35:1\n\
    \   |\n35 | }\n   | ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\n\
    error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator over\
    \ elements of type `char`\n  --> /tmp/tmpmag_tm9a.rs:23:55\n   |\n23 |     let\
    \ mut num: Vec<u8> = num.to_lowercase().chars().collect();\n   |             \
    \                                          ^^^^^^^ value of type `Vec<u8>` cannot\
    \ be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748837
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num: Vec<u8> = num.iter().map(|c| match c {\n        'A'..'F' => c -\
    \ 'A' as u8,\n        '0'..'9' => c - '0' as u8,\n        _ => panic!(\"Invalid\
    \ hex digit: {}\", c)\n    }).collect();\n    let mut num: Vec<u8> = num.iter().filter(|&c|\
    \ c >= '0' && c <= '9').collect();\n    let mut num: Vec<u8> = num.iter().filter(|&c|\
    \ c >= 'A' && c <= 'F').collect();\n    let mut num: Vec<u8> = num.iter().filter(|&c|\
    \ c >= '0' && c <= '9').collect();\n    let mut num: Vec<u8> = num.iter().filter(|&c|\
    \ c >= 'A' && c <= 'F').collect();\n    let mut num: Vec<u8> = num.iter().filter(|&c|\
    \ c >= '0' && c <= '9').collect();\n    let mut num: Vec<u8> = num.iter().filter(|&c|\
    \ c >= 'A' && c <= 'F').collect();\n    let mut num: Vec<u8> = num.iter().filter(|&c|\
    \ c >= '0' && c <= '9').collect();\n    let mut num: Vec<u8> = num.iter().filter(|&c|\
    \ c >= 'A' && c <= 'F').collect();\n    let mut num: Vec<u8> = num.iter().filter(|&c|\
    \ c >= '0' && c <= '9').collect();\n    let mut num: Vec<u8> = num.iter().filter(|&c|\
    \ c >= 'A' && c <= 'F').collect();\n    let mut num: Vec<u8> = num.iter().filter(|&c|\
    \ c >= '0' && c <= '9').collect();\n    let mut num: Vec<u8> = num.iter().filter(|&c|\
    \ c >= 'A' && c <= 'F').collect();\n    let mut num: Vec<u8> = num.iter().filter(|&c|\
    \ c >= '0' && c <= '9').collect();\n    let mut num: Vec<u8>\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpj4zwqm0z.rs:42:25\n   |\n\
    42 |     let mut num: Vec<u8>\n   |                         ^ help: add `;` here\n\
    43 | }\n   | - unexpected token\n\nerror[E0658]: exclusive range pattern syntax\
    \ is experimental\n  --> /tmp/tmpj4zwqm0z.rs:25:9\n   |\n25 |         'A'..'F'\
    \ => c - 'A' as u8,\n   |         ^^^^^^^^\n   |\n   = note: see issue #37854\
    \ <https://github.com/rust-lang/rust/issues/37854> for more information\n\nerror[E0658]:\
    \ exclusive range pattern syntax is experimental\n  --> /tmp/tmpj4zwqm0z.rs:26:9\n\
    \   |\n26 |         '0'..'9' => c - '0' as u8,\n   |         ^^^^^^^^\n   |\n\
    \   = note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854>\
    \ for more information\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built\
    \ from an iterator over elements of type `char`\n  --> /tmp/tmpj4zwqm0z.rs:23:52\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_string().chars().collect();\n  \
    \ |                                                    ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the\
    \ trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpj4zwqm0z.rs:25:9\n   |\n24 |     let mut num:\
    \ Vec<u8> = num.iter().map(|c| match c {\n   |                               \
    \                      - this expression has type `&u8`\n25 |         'A'..'F'\
    \ => c - 'A' as u8,\n   |         ^^^  --- this is of type `char`\n   |      \
    \   |\n   |         expected `u8`, found `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpj4zwqm0z.rs:25:14\n   |\n24 |     let mut num: Vec<u8> = num.iter().map(|c|\
    \ match c {\n   |                                                     - this expression\
    \ has type `&u8`\n25 |         'A'..'F' => c - 'A' as u8,\n   |         ---  ^^^\
    \ expected `u8`, found `char`\n   |         |\n   |         this is of type `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpj4zwqm0z.rs:26:9\n   |\n24 | \
    \    let mut num: Vec<u8> = num.iter().map(|c| match c {\n   |               \
    \                                      - this "
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_digits = num.len();\n    let mut num_primes = 0;\n    let mut\
    \ num_primes_digits = 0;\n    let mut num_primes_digits_primes = 0;\n    let mut\
    \ num_primes_digits_primes_primes = 0;\n    let mut num_primes_digits_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes = 0;\n    let\
    \ mut num_primes_digits_primes_primes_primes_primes_primes = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digit\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmproz86q8v.rs:44:29\n   |\n\
    44 |     let mut num_primes_digit\n   |                             ^ help: add\
    \ `;` here\n45 | }\n   | - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n  --> /tmp/tmproz86q8v.rs:23:55\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmproz86q8v.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748837
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_count: isize = 0;\n    let mut prime: isize = 2;\n    let mut\
    \ digit: u8;\n    while num.len() > 0 {\n        digit = num.chars().nth(1).unwrap();\n\
    \        if digit == 'a' || digit == 'b' || digit == 'c' || digit == 'd' || digit\
    \ == 'e' || digit == 'f' {\n            prime = prime * digit as isize + digit\
    \ as isize;\n        } else {\n            prime_count = prime_count + 1;\n  \
    \      }\n        num.pop();\n    }\n    prime_count\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n  --> /tmp/tmpw5ec457m.rs:23:55\n   |\n23 |  \
    \   let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n   |       \
    \                                                ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the\
    \ trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0599]:\
    \ no method named `chars` found for struct `Vec<u8>` in the current scope\n  -->\
    \ /tmp/tmpw5ec457m.rs:28:21\n   |\n28 |         digit = num.chars().nth(1).unwrap();\n\
    \   |                     ^^^^^ method not found in `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpw5ec457m.rs:29:21\n   |\n29 |         if digit\
    \ == 'a' || digit == 'b' || digit == 'c' || digit == 'd' || digit == 'e' || digit\
    \ == 'f' {\n   |                     ^^^ expected `u8`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpw5ec457m.rs:29:37\n   |\n29 |         if digit\
    \ == 'a' || digit == 'b' || digit == 'c' || digit == 'd' || digit == 'e' || digit\
    \ == 'f' {\n   |                                     ^^^ expected `u8`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw5ec457m.rs:29:53\n\
    \   |\n29 |         if digit == 'a' || digit == 'b' || digit == 'c' || digit ==\
    \ 'd' || digit == 'e' || digit == 'f' {\n   |                                \
    \                     ^^^ expected `u8`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpw5ec457m.rs:29:69\n   |\n29 |         if digit == 'a' ||\
    \ digit == 'b' || digit == 'c' || digit == 'd' || digit == 'e' || digit == 'f'\
    \ {\n   |                                                                    \
    \ ^^^ expected `u8`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw5ec457m.rs:29:85\n\
    \   |\n29 |         if digit == 'a' || digit == 'b' || digit == 'c' || digit ==\
    \ 'd' || digit == 'e' || digit == 'f' {\n   |                                \
    \                                                     ^^^ expected `u8`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  "
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num_digits = num.len();\n    let mut num_primes = 0;\n    let mut num_primes_digits\
    \ = 0;\n    let mut num_primes_digits_primes = 0;\n    let mut num_primes_digits_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes = 0;\n    let mut num_primes_digits_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes = 0;\n\
    \    let mut num_primes_digits_primes_primes_primes_primes_primes_primes = 0;\n\
    \    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_prime\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpv2jph4n8.rs:44:22\n   |\n\
    44 |     let mut num_prime\n   |                      ^ help: add `;` here\n45\
    \ | }\n   | - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot\
    \ be built from an iterator over elements of type `char`\n  --> /tmp/tmpv2jph4n8.rs:23:52\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_string().chars().collect();\n  \
    \ |                                                    ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the\
    \ trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpv2jph4n8.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\
    \ 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_len = prime.len();\n\
    \    let mut prime_len = prime.len();\n    let mut prime_len = prime.len();\n\
    \    let mut prime_len = prime.len();\n    let mut prime_len = prime.len();\n\
    \    let mut prime_len = prime.len();\n    let mut prime_len = prime.len();\n\
    \    let mut prime_len = prime.len();\n    let mut prime_len = prime.len();\n\
    \    let mut prime_len = prime.len();\n    let mut prime_len = prime.len();\n\
    \    let mut prime_len = prime.len();\n    let mut prime_len = prime.len();\n\
    \    let mut prime_len = prime.len();\n    let mut prime_len = prime.len();\n\
    \    let mut prime_len = prime.len();\n    let mut prime_len = prime.len();\n\
    \    let mut prime_len = prime.len();\n    let mut prime_len = prime.len();\n\
    \    let mut prime_len = prime.len();\n    let mut prime_len = prime.len();\n\
    \    let mut prime_len = prime.len();\n    let mut prime_len = prime.len();\n\
    \    let mut prime_len = prime.len();\n    let mut prime_len = prime.len();\n\
    \    let mut prime_len = prime.len();\n    let mut prime_len = prime.len();\n\
    \    let mut prime_len = prime.len();\n    let mut prime_len = prime.len();\n\
    \    let mut prime_len = prime.len();\n    let mut prime_len = prime.len();\n\
    \    let mut prime_len = prime.len();\n    let mut prime_len = prime.len();\n\
    \    let mut prime_len = prime.len();\n    let mut prime_len = prime.len();\n\
    \    let mut prime_len = prime.len();\n    let mut prime_len = prime.len();\n\
    \    let mut prime_len = prime.len();\n    let mut prime_len = prime.len();\n\
    \    let mut prime_len = prime.len();\n    let mut prime_len = prime.\n}\n\nfn\
    \ main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpwcr96dwv.rs:66:1\n   |\n66\
    \ | }\n   | ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpwcr96dwv.rs:65:31\n\
    \   |\n65 |     let mut prime_len = prime.\n   |                             \
    \  ^ help: add `;` here\n66 | }\n   | - unexpected token\n\nerror[E0277]: a value\
    \ of type `Vec<u8>` cannot be built from an iterator over elements of type `char`\n\
    \  --> /tmp/tmpwcr96dwv.rs:23:52\n   |\n23 |     let mut num: Vec<u8> = num.to_string().chars().collect();\n\
    \   |                                                    ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwcr96dwv.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748837
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_prime: Vec<u8> = vec![];\n    let mut num_prime_counter: Vec<u8>\
    \ = vec![];\n    let mut num_prime_counter2: Vec<u8> = vec![];\n    let mut num_prime_counter3:\
    \ Vec<u8> = vec![];\n    let mut num_prime_counter4: Vec<u8> = vec![];\n    let\
    \ mut num_prime_counter5: Vec<u8> = vec![];\n    let mut num_prime_counter6: Vec<u8>\
    \ = vec![];\n    let mut num_prime_counter7: Vec<u8> = vec![];\n    let mut num_prime_counter8:\
    \ Vec<u8> = vec![];\n    let mut num_prime_counter9: Vec<u8> = vec![];\n    let\
    \ mut num_prime_counter10: Vec<u8> = vec![];\n    let mut num_prime_counter11:\
    \ Vec<u8> = vec![];\n    let mut num_prime_counter12: Vec<u8> = vec![];\n    let\
    \ mut num_prime_counter13: Vec<u8> = vec![];\n    let mut num_prime_counter14:\
    \ Vec<u8> = vec![];\n    let mut num_prime_counter15: Vec<u8> = vec![];\n    let\
    \ mut num_prime_counter16: Vec<u8> = vec![];\n    let mut num_prime_counter17:\
    \ Vec<u8> = vec![];\n    let mut num_prime_counter18: Vec<u8> = vec![];\n    let\
    \ mut num_prime_counter19: Vec<u8> = vec![];\n    let mut num_prime_counter20:\
    \ Vec<u8> = vec![];\n    let mut num_prime_counter21: Vec<u8> = vec![];\n    let\
    \ mut num_prime_counter22: Vec<u8> = vec![];\n    let mut num_prime_counter23:\
    \ Vec<u8> = vec![];\n    let mut num_prime_counter24: Vec<u8> = vec![];\n    let\
    \ mut num_prime_counter25: Vec<u8> = vec![];\n    let mut num_prime_counter26:\
    \ Vec<u8> = vec![];\n    let mut num_prime_counter27: Vec<u8> = vec\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpudo2z3ny.rs:51:47\n   |\n\
    51 |     let mut num_prime_counter27: Vec<u8> = vec\n   |                    \
    \                           ^ help: add `;` here\n52 | }\n   | - unexpected token\n\
    \nerror[E0423]: expected value, found macro `vec`\n  --> /tmp/tmpudo2z3ny.rs:51:44\n\
    \   |\n51 |     let mut num_prime_counter27: Vec<u8> = vec\n   |             \
    \                               ^^^ not a value\n   |\nhelp: use `!` to invoke\
    \ the macro\n   |\n51 |     let mut num_prime_counter27: Vec<u8> = vec!\n   |\
    \                                               +\n\nerror[E0277]: a value of\
    \ type `Vec<u8>` cannot be built from an iterator over elements of type `char`\n\
    \  --> /tmp/tmpudo2z3ny.rs:23:55\n   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpudo2z3ny.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0423.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num_prime: Vec<u8> = num.to_string().chars().collect();\n    let mut\
    \ num_prime_prime: Vec<u8> = num.to_string().chars().collect();\n    let mut num_prime_prime_prime:\
    \ Vec<u8> = num.to_string().chars().collect();\n    let mut num_prime_prime_prime_prime:\
    \ Vec<u8> = num.to_string().chars().collect();\n    let mut num_prime_prime_prime_prime_prime:\
    \ Vec<u8> = num.to_string().chars().collect();\n    let mut num_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = num.to_string().chars().collect();\n    let mut num_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = num.to_string().chars().collect();\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = num.to_string().chars().collect();\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = num.to_string().chars().collect();\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = num.to_string().chars().collect();\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = num.to_string().chars().collect();\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = num.to_string().chars().collect();\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = num.to_string().chars().collect();\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = num.to_string().chars().collect();\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = num.to_string().chars().collect();\n    let mut num_prime\n}\n\nfn\
    \ main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_qdhc19t.rs:39:22\n   |\n\
    39 |     let mut num_prime\n   |                      ^ help: add `;` here\n40\
    \ | }\n   | - unexpected token\n\nerror[E0599]: the method `to_string` exists\
    \ for struct `Vec<u8>`, but its trait bounds were not satisfied\n   --> /tmp/tmp_qdhc19t.rs:24:38\n\
    \    |\n24  |       let mut num_prime: Vec<u8> = num.to_string().chars().collect();\n\
    \    |                                        ^^^^^^^^^ method cannot be called\
    \ on `Vec<u8>` due to unsatisfied trait bounds\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Vec<u8>: std::fmt::Display`\n\
    \            which is required by `Vec<u8>: ToString`\n            `[u8]: std::fmt::Display`\n\
    \            which is required by `[u8]: ToString`\n\nerror[E0277]: a value of\
    \ type `Vec<u8>` cannot be built from an iterator over elements of type `char`\n\
    \  --> /tmp/tmp_qdhc19t.rs:23:52\n   |\n23 |     let mut num: Vec<u8> = num.to_string().chars().collect();\n\
    \   |                                                    ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0599]:\
    \ the method `to_string` exists for struct `Vec<u8>`, but its trait bounds were\
    \ not satisfied\n   --> /tmp/tmp_qdhc19t.rs:25:44\n    |\n25  |       let mut\
    \ num_prime_prime: Vec<u8> = num.to_string().chars().collect();\n    |       \
    \                                       ^^^^^^^^^ method cannot be called on `Vec<u8>`\
    \ due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds\
    \ were not satisfied:\n            `Vec<u8>: std::fmt::Display`\n            which\
    \ is required by `Vec<u8>: ToString`\n            `[u8]: std::fmt::Display`\n\
    \            which is required by `[u8]: ToString`\n\nerror[E0599]: the method\
    \ `to_string` exists for struct `Vec<u8>`, but its trait bounds were not satisfied\n\
    \   --> /tmp/tmp_qdhc19t.rs:26:50\n    |\n26  |       let mut num_prime_prime_prime:\
    \ Vec<u8> = num.to_string().chars().collect();\n    |         "
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut count: usize\
    \ = 0;\n    let mut digit: u8 = 0;\n    let mut i: usize = 0;\n    while i < num.len()\
    \ {\n        digit = num[i] - '0';\n        if prime == digit {\n            count\
    \ += 1;\n        }\n        i += 1;\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n  --> /tmp/tmpxhv7debj.rs:23:55\n   |\n23 |  \
    \   let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n   |       \
    \                                                ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the\
    \ trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0277]:\
    \ cannot subtract `char` from `u8`\n  --> /tmp/tmpxhv7debj.rs:29:24\n   |\n29\
    \ |         digit = num[i] - '0';\n   |                        ^ no implementation\
    \ for `u8 - char`\n   |\n   = help: the trait `Sub<char>` is not implemented for\
    \ `u8`\n\nerror[E0277]: can't compare `Vec<u8>` with `u8`\n  --> /tmp/tmpxhv7debj.rs:30:18\n\
    \   |\n30 |         if prime == digit {\n   |                  ^^ no implementation\
    \ for `Vec<u8> == u8`\n   |\n   = help: the trait `PartialEq<u8>` is not implemented\
    \ for `Vec<u8>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxhv7debj.rs:35:5\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |                         \
    \   ----- expected `isize` because of return type\n...\n35 |     count\n   | \
    \    ^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n35 |     count.try_into().unwrap()\n\
    \   |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748837
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num_digits = num.len();\n    let mut num_primes = 0;\n    let mut num_primes_digits\
    \ = 0;\n    let mut num_primes_digits_primes = 0;\n    let mut num_primes_digits_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes = 0;\n    let mut num_primes_digits_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes = 0;\n\
    \    let mut num_primes_digits_primes_primes_primes_primes_primes_primes = 0;\n\
    \    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digit\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpol4mqwr3.rs:44:29\n   |\n\
    44 |     let mut num_primes_digit\n   |                             ^ help: add\
    \ `;` here\n45 | }\n   | - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n  --> /tmp/tmpol4mqwr3.rs:23:52\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_string().chars().collect();\n  \
    \ |                                                    ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the\
    \ trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpol4mqwr3.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut count: usize = 0;\n    let mut prime: usize = 2;\n    let mut prime_found\
    \ = false;\n    let mut prime_found2 = false;\n    let mut prime_found3 = false;\n\
    \    let mut prime_found4 = false;\n    let mut prime_found5 = false;\n    let\
    \ mut prime_found6 = false;\n    let mut prime_found7 = false;\n    let mut prime_found8\
    \ = false;\n    let mut prime_found9 = false;\n    let mut prime_found10 = false;\n\
    \    let mut prime_found11 = false;\n    let mut prime_found12 = false;\n    let\
    \ mut prime_found13 = false;\n    let mut prime_found14 = false;\n    let mut\
    \ prime_found15 = false;\n    let mut prime_found16 = false;\n    let mut prime_found17\
    \ = false;\n    let mut prime_found18 = false;\n    let mut prime_found19 = false;\n\
    \    let mut prime_found20 = false;\n    let mut prime_found21 = false;\n    let\
    \ mut prime_found22 = false;\n    let mut prime_found23 = false;\n    let mut\
    \ prime_found24 = false;\n    let mut prime_found25 = false;\n    let mut prime_found26\
    \ = false;\n    let mut prime_found27 = false;\n    let mut prime_found28 = false;\n\
    \    let mut prime_found29 = false;\n    let mut prime_found30 = false;\n    let\
    \ mut prime_found31 = false;\n    let mut prime_found32 = false;\n    let mut\
    \ prime_found33 = false;\n    let mut prime_found34 = false;\n    let mut prime_found35\
    \ = false;\n    let mut prime_found36 = false;\n    let mut prime_found37 = false;\n\
    \    let mut prime_found38 = false;\n    let mut prime_found39 = false;\n    let\
    \ mut prime_found40 = false;\n    let mut prime_found41 = false;\n    let mut\
    \ prime_found42 = false;\n    let mut prime_found43 = false;\n    let mut prime_found44\
    \ = false;\n    let mut prime_found45 = false;\n    let mut prime_found46 = false;\n\
    \    let mut prime_found47 = false;\n    let mut prime_found48 = false;\n    let\
    \ mut prime_found49 = false;\n    let mut prime_found50 = false;\n    let mut\
    \ prime_found51 = false;\n    let mut prime_found52 = false;\n    let \n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp6o4juiim.rs:79:1\n  \
    \ |\n79 | }\n   | ^ expected pattern\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n  --> /tmp/tmp6o4juiim.rs:23:52\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_string().chars().collect();\n  \
    \ |                                                    ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the\
    \ trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut counter: usize = 0;\n    let mut prime: usize = 2;\n    let mut prime_counter:\
    \ usize = 2;\n    let mut prime_counter2: usize = 2;\n    let mut prime_counter3:\
    \ usize = 2;\n    let mut prime_counter4: usize = 2;\n    let mut prime_counter5:\
    \ usize = 2;\n    let mut prime_counter6: usize = 2;\n    let mut prime_counter7:\
    \ usize = 2;\n    let mut prime_counter8: usize = 2;\n    let mut prime_counter9:\
    \ usize = 2;\n    let mut prime_counter10: usize = 2;\n    let mut prime_counter11:\
    \ usize = 2;\n    let mut prime_counter12: usize = 2;\n    let mut prime_counter13:\
    \ usize = 2;\n    let mut prime_counter14: usize = 2;\n    let mut prime_counter15:\
    \ usize = 2;\n    let mut prime_counter16: usize = 2;\n    let mut prime_counter17:\
    \ usize = 2;\n    let mut prime_counter18: usize = 2;\n    let mut prime_counter19:\
    \ usize = 2;\n    let mut prime_counter20: usize = 2;\n    let mut prime_counter21:\
    \ usize = 2;\n    let mut prime_counter22: usize = 2;\n    let mut prime_counter23:\
    \ usize = 2;\n    let mut prime_counter24: usize = 2;\n    let mut prime_counter25:\
    \ usize = 2;\n    let mut prime_counter26: usize = 2;\n    let mut prime_counter27:\
    \ usize = 2;\n    let mut prime_counter28: usize = 2;\n    let mut prime_counter29:\
    \ usize = 2;\n    let mut prime_counter30: usize = 2;\n    let mut prime_counter31:\
    \ usize = 2;\n    let mut prime_counter32: usize = 2;\n    let mut prime_counter33:\
    \ usize = 2;\n    let mut prime_counter34: usize = 2;\n    let mut prime_counter35:\
    \ usize = 2;\n    let mut prime_counter36: usize = 2;\n    let mut prime_counter37:\
    \ usize = 2;\n    let mut prime_counter38: usize = 2;\n    let mut prime_counter39:\
    \ usize = 2;\n    let mut prime_counter40: usize = 2;\n\n}\n\nfn main() {\n  \
    \  let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpihx4zr3m.rs:22:28\n   |\n\
    22 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `char`\n  -->\
    \ /tmp/tmpihx4zr3m.rs:23:52\n   |\n23 |     let mut num: Vec<u8> = num.to_string().chars().collect();\n\
    \   |                                                    ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpgxfk7iy6.rs:40:36\n   |\n\
    40 |     let mut num: Vec<u8> = num.iter\n   |                               \
    \     ^ help: add `;` here\n41 | }\n   | - unexpected token\n\nerror[E0277]: a\
    \ value of type `Vec<u8>` cannot be built from an iterator over elements of type\
    \ `char`\n  --> /tmp/tmpgxfk7iy6.rs:23:55\n   |\n23 |     let mut num: Vec<u8>\
    \ = num.to_lowercase().chars().collect();\n   |                              \
    \                         ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n   |\n   = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgxfk7iy6.rs:24:56\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <=\
    \ '9').collect();\n   |                                                      \
    \  ^^^ expected `&u8`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgxfk7iy6.rs:24:68\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <=\
    \ '9').collect();\n   |                                                      \
    \              ^^^ expected `&u8`, found `char`\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `&u8`\n  -->\
    \ /tmp/tmpgxfk7iy6.rs:24:73\n   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&x|\
    \ x >= '0' && x <= '9').collect();\n   |                                     \
    \                                    ^^^^^^^ value of type `Vec<u8>` cannot be\
    \ built from `std::iter::Iterator<Item=&u8>`\n   |\n   = help: the trait `FromIterator<&u8>`\
    \ is not implemented for `Vec<u8>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgxfk7iy6.rs:25:56\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <=\
    \ 'F').collect();\n   |                                                      \
    \  ^^^ expected `&u8`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgxfk7iy6.rs:25:68\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <=\
    \ 'F').collect();\n   |                     "
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: isize = 0;\n    let mut digits = num.chars().collect::<Vec<_>>();\n\
    \    let mut prime_digits = vec![false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, false, false, false, \n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmp8mpgchsj.rs:25:32\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |                         \
    \         - closing delimiter possibly meant for this\n...\n25 |     let mut prime_digits\
    \ = vec![false, false, false, false, false, false, false, false, false, false,\
    \ false, false, false, false, false, ...\n   |                               \
    \ ^ unclosed delimiter\n26 | }\n   | ^ mismatched closing delimiter\n\nerror:\
    \ expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n  --> /tmp/tmp8mpgchsj.rs:26:1\n\
    \   |\n26 | }\n   | ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\n\
    error[E0599]: no method named `chars` found for type `isize` in the current scope\n\
    \  --> /tmp/tmp8mpgchsj.rs:24:26\n   |\n24 |     let mut digits = num.chars().collect::<Vec<_>>();\n\
    \   |                          ^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n  \
    \  let mut num: Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n    let\
    \ mut num: Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n    let mut\
    \ num: Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n    let mut num:\
    \ Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n    let mut num: Vec<u8>\
    \ = num.iter().map(|x| x.to_digit(16)).collect();\n    let mut num: Vec<u8> =\
    \ num.iter().map(|x| x.to_digit(16)).collect();\n    let mut num: Vec<u8> = num.iter().map(|x|\
    \ x.to_digit(16)).collect();\n    let mut num: Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n  \
    \  let mut num: Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n    let\
    \ mut num: Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n    let mut\
    \ num: Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n    let mut num:\
    \ Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n    let mut num: Vec<u8>\
    \ = num.iter().map(|x| x.to_digit(16)).collect();\n    let mut num: Vec<u8> =\
    \ num.iter().map(|x| x.to_digit(16)).collect();\n    let mut num: Vec<u8> = num.iter().map(|x|\
    \ x.to_digit(16)).collect();\n    let mut num: Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n\
    \    let mut num: Vec<\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `>`, a const expression, lifetime, or type, found\
    \ `}`\n  --> /tmp/tmps4izfbmt.rs:43:1\n   |\n42 |     let mut num: Vec<\n   |\
    \         -------      - expected one of `>`, a const expression, lifetime, or\
    \ type\n   |         |\n   |         while parsing the type for `mut num`\n43\
    \ | }\n   | ^ unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot\
    \ be built from an iterator over elements of type `char`\n  --> /tmp/tmps4izfbmt.rs:23:55\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0599]:\
    \ no method named `to_digit` found for reference `&u8` in the current scope\n\
    \  --> /tmp/tmps4izfbmt.rs:24:49\n   |\n24 |     let mut num: Vec<u8> = num.iter().map(|x|\
    \ x.to_digit(16)).collect();\n   |                                           \
    \      ^^^^^^^^ method not found in `&u8`\n\nerror[E0599]: no method named `to_digit`\
    \ found for reference `&u8` in the current scope\n  --> /tmp/tmps4izfbmt.rs:25:49\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n\
    \   |                                                 ^^^^^^^^ method not found\
    \ in `&u8`\n\nerror[E0599]: no method named `to_digit` found for reference `&u8`\
    \ in the current scope\n  --> /tmp/tmps4izfbmt.rs:26:49\n   |\n26 |     let mut\
    \ num: Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n   |         \
    \                                        ^^^^^^^^ method not found in `&u8`\n\n\
    error[E0599]: no method named `to_digit` found for reference `&u8` in the current\
    \ scope\n  --> /tmp/tmps4izfbmt.rs:27:49\n   |\n27 |     let mut num: Vec<u8>\
    \ = num.iter().map(|x| x.to_digit(16)).collect();\n   |                      \
    \                           ^^^^^^^^ method not found in `&u8`\n\nerror[E0599]:\
    \ no method named `to_digit` found for reference `&u8` in the current scope\n\
    \  --> /tmp/tmps4izfbmt.rs:28:49\n "
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_len\
    \ = num_prime.len();\n    let mut num_prime_len = num_prime_len - 1;\n    let\
    \ mut num_prime_len = num_prime_len - 1;\n    let mut num_prime_len = num_prime_len\
    \ - 1;\n    let mut num_prime_len = num_prime_len - 1;\n    let mut num_prime_len\
    \ = num_prime_len - 1;\n    let mut num_prime_len = num_prime_len - 1;\n    let\
    \ mut num_prime_len = num_prime_len - 1;\n    let mut num_prime_len = num_prime_len\
    \ - 1;\n    let mut num_prime_len = num_prime_len - 1;\n    let mut num_prime_len\
    \ = num_prime_len - 1;\n    let mut num_prime_len = num_prime_len - 1;\n    let\
    \ mut num_prime_len = num_prime_len - 1;\n    let mut num_prime_len = num_prime_len\
    \ - 1;\n    let mut num_prime_len = num_prime_len - 1;\n    let mut num_prime_len\
    \ = num_prime_len - 1;\n    let mut num_prime_len = num_prime_len - 1;\n    let\
    \ mut num_prime_len = num_prime_len - 1;\n    let mut num_prime_len = num_prime_len\
    \ - 1;\n    let mut num_prime_len = num_prime_len - 1;\n    let mut num_prime_len\
    \ = num_prime_len - 1;\n    let mut num_prime_len = num_prime_len - 1;\n    let\
    \ mut num_prime_len = num_prime_len - 1;\n    let mut num_prime_len = num_prime_len\
    \ - 1;\n    let mut num_prime_len = num_prime_len - 1;\n    let mut num_prime_len\
    \ = num_prime_len - 1;\n    let mut num_prime_len = num_prime_len - 1;\n    let\
    \ mut num_prime_len = num_prime_len - 1;\n    let mut num_prime_len = num_prime_len\
    \ - 1;\n    let mut num_prime_len = num_prime_len - 1;\n    let mut num_prime_len\
    \ = num_prime_len - 1;\n    let mut num_prime_len = num_prime_len - 1;\n    let\
    \ mut num_prime_len = num_prime_len - 1;\n    let mut num_prime_len = num_prime_len\
    \ - 1;\n    let mut num_prime\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp38ksf0ho.rs:59:22\n   |\n\
    59 |     let mut num_prime\n   |                      ^ help: add `;` here\n60\
    \ | }\n   | - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot\
    \ be built from an iterator over elements of type `char`\n  --> /tmp/tmp38ksf0ho.rs:23:55\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp38ksf0ho.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpgxfk7iy6.rs:40:36\n   |\n\
    40 |     let mut num: Vec<u8> = num.iter\n   |                               \
    \     ^ help: add `;` here\n41 | }\n   | - unexpected token\n\nerror[E0277]: a\
    \ value of type `Vec<u8>` cannot be built from an iterator over elements of type\
    \ `char`\n  --> /tmp/tmpgxfk7iy6.rs:23:55\n   |\n23 |     let mut num: Vec<u8>\
    \ = num.to_lowercase().chars().collect();\n   |                              \
    \                         ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n   |\n   = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgxfk7iy6.rs:24:56\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <=\
    \ '9').collect();\n   |                                                      \
    \  ^^^ expected `&u8`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgxfk7iy6.rs:24:68\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <=\
    \ '9').collect();\n   |                                                      \
    \              ^^^ expected `&u8`, found `char`\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `&u8`\n  -->\
    \ /tmp/tmpgxfk7iy6.rs:24:73\n   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&x|\
    \ x >= '0' && x <= '9').collect();\n   |                                     \
    \                                    ^^^^^^^ value of type `Vec<u8>` cannot be\
    \ built from `std::iter::Iterator<Item=&u8>`\n   |\n   = help: the trait `FromIterator<&u8>`\
    \ is not implemented for `Vec<u8>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgxfk7iy6.rs:25:56\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <=\
    \ 'F').collect();\n   |                                                      \
    \  ^^^ expected `&u8`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgxfk7iy6.rs:25:68\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <=\
    \ 'F').collect();\n   |                     "
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num_digits = num.len();\n    let mut num_primes = 0;\n    let mut num_primes_digits\
    \ = 0;\n    let mut num_primes_digits_sum = 0;\n    let mut num_primes_digits_product\
    \ = 1;\n    let mut num_primes_digits_product2 = 1;\n    let mut num_primes_digits_product3\
    \ = 1;\n    let mut num_primes_digits_product4 = 0;\n    let mut num_primes_digits_product5\
    \ = 1;\n    let mut num_primes_digits_product6 = 1;\n    let mut num_primes_digits_product7\
    \ = 1;\n    let mut num_primes_digits_product8 = 1;\n    let mut num_primes_digits_product9\
    \ = 1;\n    let mut num_primes_digits_product10 = 1;\n    let mut num_primes_digits_product11\
    \ = 1;\n    let mut num_primes_digits_product12 = 1;\n    let mut num_primes_digits_product13\
    \ = 1;\n    let mut num_primes_digits_product14 = 1;\n    let mut num_primes_digits_product15\
    \ = 1;\n    let mut num_primes_digits_product16 = 1;\n    let mut num_primes_digits_product17\
    \ = 1;\n    let mut num_primes_digits_product18 = 1;\n    let mut num_primes_digits_product19\
    \ = 1;\n    let mut num_primes_digits_product20 = 1;\n    let mut num_primes_digits_product21\
    \ = 1;\n    let mut num_primes_digits_product22 = 1;\n    let mut num_primes_digits_product23\
    \ = 1;\n    let mut num_primes_digits_product24 = 1;\n    let mut num_primes_digits_product25\
    \ = 1;\n    let mut num_primes_digits_product26 = 1;\n    let mut num_primes_digits_product27\
    \ = 1;\n    let mut num_primes_digits_product28 = 1;\n    let mut num_primes_digits_product29\
    \ = 1;\n    let mut num_primes_digits_product30 = 1;\n    let mut num_primes_digits_product31\
    \ = 1;\n    let mut num_primes_digits_product32 = 1;\n    let mut num_primes_digits_product33\
    \ = 1;\n    let mut num_primes_digits_product34 = 1;\n    let mut num_primes_digits_product35\
    \ = 1;\n    let mut num_primes_digits_product36 = 1;\n    let mut num_primes_digits_product37\
    \ = 1;\n    let mut num_primes_digits_product38 = 1;\n    let mu\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpjpczya_f.rs:66:11\n   |\n\
    66 |     let mu\n   |           ^ help: add `;` here\n67 | }\n   | - unexpected\
    \ token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n  --> /tmp/tmpjpczya_f.rs:23:52\n   |\n23 |  \
    \   let mut num: Vec<u8> = num.to_string().chars().collect();\n   |          \
    \                                          ^^^^^^^ value of type `Vec<u8>` cannot\
    \ be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjpczya_f.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp2h8mq14_.rs:39:36\n   |\n\
    39 |     let mut num: Vec<u8> = num.iter\n   |                               \
    \     ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0277]: a\
    \ value of type `Vec<u8>` cannot be built from an iterator over elements of type\
    \ `char`\n  --> /tmp/tmp2h8mq14_.rs:23:55\n   |\n23 |     let mut num: Vec<u8>\
    \ = num.to_lowercase().chars().collect();\n   |                              \
    \                         ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n   |\n   = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2h8mq14_.rs:24:56\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <=\
    \ '9').collect();\n   |                                                      \
    \  ^^^ expected `&u8`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2h8mq14_.rs:24:68\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <=\
    \ '9').collect();\n   |                                                      \
    \              ^^^ expected `&u8`, found `char`\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `&u8`\n  -->\
    \ /tmp/tmp2h8mq14_.rs:24:73\n   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&c|\
    \ c >= '0' && c <= '9').collect();\n   |                                     \
    \                                    ^^^^^^^ value of type `Vec<u8>` cannot be\
    \ built from `std::iter::Iterator<Item=&u8>`\n   |\n   = help: the trait `FromIterator<&u8>`\
    \ is not implemented for `Vec<u8>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2h8mq14_.rs:25:56\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <=\
    \ 'F').collect();\n   |                                                      \
    \  ^^^ expected `&u8`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2h8mq14_.rs:25:68\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <=\
    \ 'F').collect();\n   |                     "
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut nums = num.chars().collect::<Vec<_>>();\n    let mut nums_len\
    \ = nums.len();\n    let mut prime_digits = vec![];\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmp8rebevbs.rs:60:1\n   |\n60\
    \ | }\n   | ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmp8rebevbs.rs:59:45\n\
    \   |\n59 |     let mut prime_digits_len = prime_digits.\n   |               \
    \                              ^ help: add `;` here\n60 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8rebevbs.rs:22:28\n \
    \  |\n22 | fn hex_key(num: String) -> isize {\n   |    -------               \
    \  ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748837
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut count: usize = 0;\n    let mut prime: usize = 2;\n    let mut prime_found\
    \ = false;\n    let mut prime_found2 = false;\n    let mut prime_found3 = false;\n\
    \    let mut prime_found4 = false;\n    let mut prime_found5 = false;\n    let\
    \ mut prime_found6 = false;\n    let mut prime_found7 = false;\n    let mut prime_found8\
    \ = false;\n    let mut prime_found9 = false;\n    let mut prime_found10 = false;\n\
    \    let mut prime_found11 = false;\n    let mut prime_found12 = false;\n    let\
    \ mut prime_found13 = false;\n    let mut prime_found14 = false;\n    let mut\
    \ prime_found15 = false;\n    let mut prime_found16 = false;\n    let mut prime_found17\
    \ = false;\n    let mut prime_found18 = false;\n    let mut prime_found19 = false;\n\
    \    let mut prime_found20 = false;\n    let mut prime_found21 = false;\n    let\
    \ mut prime_found22 = false;\n    let mut prime_found23 = false;\n    let mut\
    \ prime_found24 = false;\n    let mut prime_found25 = false;\n    let mut prime_found26\
    \ = false;\n    let mut prime_found27 = false;\n    let mut prime_found28 = false;\n\
    \    let mut prime_found29 = false;\n    let mut prime_found30 = false;\n    let\
    \ mut prime_found31 = false;\n    let mut prime_found32 = false;\n    let mut\
    \ prime_found33 = false;\n    let mut prime_found34 = false;\n    let mut prime_found35\
    \ = false;\n    let mut prime_found36 = false;\n    let mut prime_found37 = false;\n\
    \    let mut prime_found38 = false;\n    let mut prime_found39 = false;\n    let\
    \ mut prime_found40 = false;\n    let mut prime_found41 = false;\n    let mut\
    \ prime_found42 = false;\n    let mut prime_found43 = false;\n    let mut prime_found44\
    \ = false;\n    let mut prime_found45 = false;\n    let mut prime_found46 = false;\n\
    \    let mut prime_found47 = false;\n    let mut prime_found48 = false;\n    let\
    \ mut prime_found49 = false;\n    let mut prime_found50 = false;\n    let mut\
    \ prime_found51 = false;\n    let mut prime_found52 = false;\n    let \n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp8y2orenz.rs:79:1\n  \
    \ |\n79 | }\n   | ^ expected pattern\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n  --> /tmp/tmp8y2orenz.rs:23:55\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748837
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: isize = num.chars().filter(|&c| c >= '0' && c <= '9').count();\n\
    \    let mut prime: isize = 2;\n    while prime <= num {\n        if num % prime\
    \ == 0 {\n            num += 1;\n        } else {\n            prime += 1;\n \
    \       }\n    }\n    num\n}\n\nfn main() {\n    let candidate = hex_key;\n  \
    \  assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnva3x7k3.rs:23:26\n   |\n\
    23 |     let mut num: isize = num.chars().filter(|&c| c >= '0' && c <= '9').count();\n\
    \   |                  -----   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |                  |\n   |             \
    \     expected due to this\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n23 |     let mut num: isize\
    \ = num.chars().filter(|&c| c >= '0' && c <= '9').count().try_into().unwrap();\n\
    \   |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748837
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut counter: usize = 0;\n    let mut prime: usize = 2;\n    let mut prime_counter:\
    \ usize = 2;\n    let mut prime_counter2: usize = 2;\n    let mut prime_counter3:\
    \ usize = 2;\n    let mut prime_counter4: usize = 2;\n    let mut prime_counter5:\
    \ usize = 2;\n    let mut prime_counter6: usize = 2;\n    let mut prime_counter7:\
    \ usize = 2;\n    let mut prime_counter8: usize = 2;\n    let mut prime_counter9:\
    \ usize = 2;\n    let mut prime_counter10: usize = 2;\n    let mut prime_counter11:\
    \ usize = 2;\n    let mut prime_counter12: usize = 2;\n    let mut prime_counter13:\
    \ usize = 2;\n    let mut prime_counter14: usize = 2;\n    let mut prime_counter15:\
    \ usize = 2;\n    let mut prime_counter16: usize = 2;\n    let mut prime_counter17:\
    \ usize = 2;\n    let mut prime_counter18: usize = 2;\n    let mut prime_counter19:\
    \ usize = 2;\n    let mut prime_counter20: usize = 2;\n    let mut prime_counter21:\
    \ usize = 2;\n    let mut prime_counter22: usize = 2;\n    let mut prime_counter23:\
    \ usize = 2;\n    let mut prime_counter24: usize = 2;\n    let mut prime_counter25:\
    \ usize = 2;\n    let mut prime_counter26: usize = 2;\n    let mut prime_counter27:\
    \ usize = 2;\n    let mut prime_counter28: usize = 2;\n    let mut prime_counter29:\
    \ usize = 2;\n    let mut prime_counter30: usize = 2;\n    let mut prime_counter31:\
    \ usize = 2;\n    let mut prime_counter32: usize = 2;\n    let mut prime_counter33:\
    \ usize = 2;\n    let mut prime_counter34: usize = 2;\n    let mut prime_counter35:\
    \ usize = 2;\n    let mut prime_counter36: usize = 2;\n    let mut prime_counter37:\
    \ usize = 2;\n    let mut prime_counter38: usize = 2;\n    let mut prime_counter39:\
    \ usize = 2;\n    let mut prime_counter40: usize = 2;\n\n}\n\nfn main() {\n  \
    \  let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp322thm2j.rs:22:28\n   |\n\
    22 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `char`\n  -->\
    \ /tmp/tmp322thm2j.rs:23:55\n   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_counter:\
    \ usize = 0;\n    let mut prime_counter2: usize = 0;\n    let mut prime_counter3:\
    \ usize = 0;\n    let mut prime_counter4: usize = 0;\n    let mut prime_counter5:\
    \ usize = 0;\n    let mut prime_counter6: usize = 0;\n    let mut prime_counter7:\
    \ usize = 0;\n    let mut prime_counter8: usize = 0;\n    let mut prime_counter9:\
    \ usize = 0;\n    let mut prime_counter10: usize = 0;\n    let mut prime_counter11:\
    \ usize = 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13:\
    \ usize = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: u\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5h95n5pg.rs:62:31\n   |\n\
    62 |     let mut prime_counter38: u\n   |                               ^ help:\
    \ add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0412]: cannot find type\
    \ `u` in this scope\n  --> /tmp/tmp5h95n5pg.rs:62:30\n   |\n62 |     let mut prime_counter38:\
    \ u\n   |                              ^ help: a builtin type with a similar name\
    \ exists: `u8`\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from\
    \ an iterator over elements of type `char`\n    --> /tmp/tmp5h95n5pg.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5h95n5pg.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0412.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_len\
    \ = num_prime.len();\n    let mut num_prime_len = num_prime_len - 1;\n    let\
    \ mut num_prime_len = num_prime_len - 1;\n    let mut num_prime_len = num_prime_len\
    \ - 1;\n    let mut num_prime_len = num_prime_len - 1;\n    let mut num_prime_len\
    \ = num_prime_len - 1;\n    let mut num_prime_len = num_prime_len - 1;\n    let\
    \ mut num_prime_len = num_prime_len - 1;\n    let mut num_prime_len = num_prime_len\
    \ - 1;\n    let mut num_prime_len = num_prime_len - 1;\n    let mut num_prime_len\
    \ = num_prime_len - 1;\n    let mut num_prime_len = num_prime_len - 1;\n    let\
    \ mut num_prime_len = num_prime_len - 1;\n    let mut num_prime_len = num_prime_len\
    \ - 1;\n    let mut num_prime_len = num_prime_len - 1;\n    let mut num_prime_len\
    \ = num_prime_len - 1;\n    let mut num_prime_len = num_prime_len - 1;\n    let\
    \ mut num_prime_len = num_prime_len - 1;\n    let mut num_prime_len = num_prime_len\
    \ - 1;\n    let mut num_prime_len = num_prime_len - 1;\n    let mut num_prime_len\
    \ = num_prime_len - 1;\n    let mut num_prime_len = num_prime_len - 1;\n    let\
    \ mut num_prime_len = num_prime_len - 1;\n    let mut num_prime_len = num_prime_len\
    \ - 1;\n    let mut num_prime_len = num_prime_len - 1;\n    let mut num_prime_len\
    \ = num_prime_len - 1;\n    let mut num_prime_len = num_prime_len - 1;\n    let\
    \ mut num_prime_len = num_prime_len - 1;\n    let mut num_prime_len = num_prime_len\
    \ - 1;\n    let mut num_prime_len = num_prime_len - 1;\n    let mut num_prime_len\
    \ = num_prime_len - 1;\n    let mut num_prime_len = num_prime_len - 1;\n    let\
    \ mut num_prime_len = num_prime_len - 1;\n    let mut num_prime_len = num_prime_len\
    \ - 1;\n    let mut num_prime\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp38ksf0ho.rs:59:22\n   |\n\
    59 |     let mut num_prime\n   |                      ^ help: add `;` here\n60\
    \ | }\n   | - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot\
    \ be built from an iterator over elements of type `char`\n  --> /tmp/tmp38ksf0ho.rs:23:55\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp38ksf0ho.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut nums = num.chars().collect::<Vec<_>>();\n    let mut nums_len\
    \ = nums.len();\n    let mut prime_digits = vec![2, 3];\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_count = prime_digits_len;\n\
    \    let mut prime_digits_count_2 = prime_digits_count_2;\n    let mut prime_digits_count_3\
    \ = prime_digits_count_3;\n    let mut prime_digits_count_4 = prime_digits_count_4;\n\
    \    let mut prime_digits_count_5 = prime_digits_count_5;\n    let mut prime_digits_count_6\
    \ = prime_digits_count_6;\n    let mut prime_digits_count_7 = prime_digits_count_7;\n\
    \    let mut prime_digits_count_8 = prime_digits_count_8;\n    let mut prime_digits_count_9\
    \ = prime_digits_count_9;\n    let mut prime_digits_count_10 = prime_digits_count_10;\n\
    \    let mut prime_digits_count_11 = prime_digits_count_11;\n    let mut prime_digits_count_12\
    \ = prime_digits_count_12;\n    let mut prime_digits_count_13 = prime_digits_count_13;\n\
    \    let mut prime_digits_count_14 = prime_digits_count_14;\n    let mut prime_digits_count_15\
    \ = prime_digits_count_15;\n    let mut prime_digits_count_16 = prime_digits_count_16;\n\
    \    let mut prime_digits_count_17 = prime_digits_count_17;\n    let mut prime_digits_count_18\
    \ = prime_digits_count_18;\n    let mut prime_digits_count_19 = prime_digits_count_19;\n\
    \    let mut prime_digits_count_20 = prime_digits_count_20;\n    let mut prime_digits_count_21\
    \ = prime_digits_count_21;\n    let mut prime_digits_count_22 = prime_digits_count_22;\n\
    \    let mut prime_digits_count_23 = prime_digits_count_23;\n    let mut prime_digits_count_24\
    \ = prime_digits_count_24;\n    let mut prime_digits_count_25 = prime_digits_count_25;\n\
    \    let mut prime_digits_count_26 = prime_digits_count_26;\n    let mut prime_digits_count_27\
    \ = prime_digits_count_27;\n    let mu\n}\n\nfn main() {\n    let candidate =\
    \ hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp6acd9ecu.rs:54:11\n   |\n\
    54 |     let mu\n   |           ^ help: add `;` here\n55 | }\n   | - unexpected\
    \ token\n\nerror[E0425]: cannot find value `prime_digits_count_2` in this scope\n\
    \  --> /tmp/tmp6acd9ecu.rs:28:36\n   |\n28 |     let mut prime_digits_count_2\
    \ = prime_digits_count_2;\n   |                                    ^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `prime_digits_count`\n\n\
    error[E0425]: cannot find value `prime_digits_count_3` in this scope\n  --> /tmp/tmp6acd9ecu.rs:29:36\n\
    \   |\n29 |     let mut prime_digits_count_3 = prime_digits_count_3;\n   |   \
    \                                 ^^^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `prime_digits_count_2`\n\nerror[E0425]: cannot find\
    \ value `prime_digits_count_4` in this scope\n  --> /tmp/tmp6acd9ecu.rs:30:36\n\
    \   |\n30 |     let mut prime_digits_count_4 = prime_digits_count_4;\n   |   \
    \                                 ^^^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `prime_digits_count_2`\n\nerror[E0425]: cannot find\
    \ value `prime_digits_count_5` in this scope\n  --> /tmp/tmp6acd9ecu.rs:31:36\n\
    \   |\n31 |     let mut prime_digits_count_5 = prime_digits_count_5;\n   |   \
    \                                 ^^^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `prime_digits_count_2`\n\nerror[E0425]: cannot find\
    \ value `prime_digits_count_6` in this scope\n  --> /tmp/tmp6acd9ecu.rs:32:36\n\
    \   |\n32 |     let mut prime_digits_count_6 = prime_digits_count_6;\n   |   \
    \                                 ^^^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `prime_digits_count_2`\n\nerror[E0425]: cannot find\
    \ value `prime_digits_count_7` in this scope\n  --> /tmp/tmp6acd9ecu.rs:33:36\n\
    \   |\n33 |     let mut prime_digits_count_7 = prime_digits_count_7;\n   |   \
    \                                 ^^^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `prime_digits_count_2`\n\nerror[E0425]: cannot find\
    \ value `prime_digits_count_8` in this scope\n  -->"
  stdout: ''
  timestamp: 1659748837
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let mut prime_counter:\
    \ usize = 0;\n    let mut prime_counter2: usize = 0;\n    let mut prime_counter3:\
    \ usize = 0;\n    let mut prime_counter4: usize = 0;\n    let mut prime_counter5:\
    \ usize = 0;\n    let mut prime_counter6: usize = 0;\n    let mut prime_counter7:\
    \ usize = 0;\n    let mut prime_counter8: usize = 0;\n    let mut prime_counter9:\
    \ usize = 0;\n    let mut prime_counter10: usize = 0;\n    let mut prime_counter11:\
    \ usize = 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13:\
    \ usize = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: usize = 0;\n    let mut prime_counter39:\
    \ usize = 0;\n    let mut prime_counter40: u\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpx4n45ubt.rs:64:31\n   |\n\
    64 |     let mut prime_counter40: u\n   |                               ^ help:\
    \ add `;` here\n65 | }\n   | - unexpected token\n\nerror[E0412]: cannot find type\
    \ `u` in this scope\n  --> /tmp/tmpx4n45ubt.rs:64:30\n   |\n64 |     let mut prime_counter40:\
    \ u\n   |                              ^ help: a builtin type with a similar name\
    \ exists: `u8`\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from\
    \ an iterator over elements of type `char`\n  --> /tmp/tmpx4n45ubt.rs:23:55\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpx4n45ubt.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0412.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_counter:\
    \ usize = 0;\n    let mut prime_counter2: usize = 0;\n    let mut prime_counter3:\
    \ usize = 0;\n    let mut prime_counter4: usize = 0;\n    let mut prime_counter5:\
    \ usize = 0;\n    let mut prime_counter6: usize = 0;\n    let mut prime_counter7:\
    \ usize = 0;\n    let mut prime_counter8: usize = 0;\n    let mut prime_counter9:\
    \ usize = 0;\n    let mut prime_counter10: usize = 0;\n    let mut prime_counter11:\
    \ usize = 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13:\
    \ usize = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: u\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5h95n5pg.rs:62:31\n   |\n\
    62 |     let mut prime_counter38: u\n   |                               ^ help:\
    \ add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0412]: cannot find type\
    \ `u` in this scope\n  --> /tmp/tmp5h95n5pg.rs:62:30\n   |\n62 |     let mut prime_counter38:\
    \ u\n   |                              ^ help: a builtin type with a similar name\
    \ exists: `u8`\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from\
    \ an iterator over elements of type `char`\n    --> /tmp/tmp5h95n5pg.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5h95n5pg.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0412.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpnsj7n80f.rs:39:36\n   |\n\
    39 |     let mut num: Vec<u8> = num.iter\n   |                               \
    \     ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0277]: a\
    \ value of type `Vec<u8>` cannot be built from an iterator over elements of type\
    \ `char`\n  --> /tmp/tmpnsj7n80f.rs:23:55\n   |\n23 |     let mut num: Vec<u8>\
    \ = num.to_lowercase().chars().collect();\n   |                              \
    \                         ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n   |\n   = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnsj7n80f.rs:24:56\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <=\
    \ '9').collect();\n   |                                                      \
    \  ^^^ expected `&u8`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnsj7n80f.rs:24:68\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <=\
    \ '9').collect();\n   |                                                      \
    \              ^^^ expected `&u8`, found `char`\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `&u8`\n  -->\
    \ /tmp/tmpnsj7n80f.rs:24:73\n   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&c|\
    \ c >= '0' && c <= '9').collect();\n   |                                     \
    \                                    ^^^^^^^ value of type `Vec<u8>` cannot be\
    \ built from `std::iter::Iterator<Item=&u8>`\n   |\n   = help: the trait `FromIterator<&u8>`\
    \ is not implemented for `Vec<u8>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnsj7n80f.rs:25:56\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <=\
    \ 'F').collect();\n   |                                                      \
    \  ^^^ expected `&u8`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnsj7n80f.rs:25:68\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <=\
    \ 'F').collect();\n   |                     "
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let mut\
    \ num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut \n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpgym3kby6.rs:62:1\n\
    \   |\n62 | }\n   | ^ expected identifier\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n  --> /tmp/tmpgym3kby6.rs:23:55\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let mut prime_counter:\
    \ usize = 0;\n    let mut prime_counter2: usize = 0;\n    let mut prime_counter3:\
    \ usize = 0;\n    let mut prime_counter4: usize = 0;\n    let mut prime_counter5:\
    \ usize = 0;\n    let mut prime_counter6: usize = 0;\n    let mut prime_counter7:\
    \ usize = 0;\n    let mut prime_counter8: usize = 0;\n    let mut prime_counter9:\
    \ usize = 0;\n    let mut prime_counter10: usize = 0;\n    let mut prime_counter11:\
    \ usize = 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13:\
    \ usize = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: usize = 0;\n    let mut prime_counter39:\
    \ usize = 0;\n    let mut prime_counter40: u\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpx4n45ubt.rs:64:31\n   |\n\
    64 |     let mut prime_counter40: u\n   |                               ^ help:\
    \ add `;` here\n65 | }\n   | - unexpected token\n\nerror[E0412]: cannot find type\
    \ `u` in this scope\n  --> /tmp/tmpx4n45ubt.rs:64:30\n   |\n64 |     let mut prime_counter40:\
    \ u\n   |                              ^ help: a builtin type with a similar name\
    \ exists: `u8`\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from\
    \ an iterator over elements of type `char`\n  --> /tmp/tmpx4n45ubt.rs:23:55\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpx4n45ubt.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0412.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut nums = num.chars().collect::<Vec<_>>();\n    let mut nums_iter\
    \ = nums.iter();\n    let mut num_digits = nums.len();\n    let mut num_primes\
    \ = 0;\n    let mut num_primes_digits = 0;\n    let mut num_primes_digits_iter\
    \ = 0;\n    let mut num_primes_digits_iter2 = 0;\n    let mut num_primes_digits_iter3\
    \ = 0;\n    let mut num_primes_digits_iter4 = 0;\n    let mut num_primes_digits_iter5\
    \ = 0;\n    let mut num_primes_digits_iter6 = 0;\n    let mut num_primes_digits_iter7\
    \ = 0;\n    let mut num_primes_digits_iter8 = 0;\n    let mut num_primes_digits_iter9\
    \ = 0;\n    let mut num_primes_digits_iter10 = 0;\n    let mut num_primes_digits_iter11\
    \ = 0;\n    let mut num_primes_digits_iter12 = 0;\n    let mut num_primes_digits_iter13\
    \ = 0;\n    let mut num_primes_digits_iter14 = 0;\n    let mut num_primes_digits_iter15\
    \ = 0;\n    let mut num_primes_digits_iter16 = 0;\n    let mut num_primes_digits_iter17\
    \ = 0;\n    let mut num_primes_digits_iter18 = 0;\n    let mut num_primes_digits_iter19\
    \ = 0;\n    let mut num_primes_digits_iter20 = 0;\n    let mut num_primes_digits_iter21\
    \ = 0;\n    let mut num_primes_digits_iter22 = 0;\n    let mut num_primes_digits_iter23\
    \ = 0;\n    let mut num_primes_digits_iter24 = 0;\n    let mut num_primes_digits_iter25\
    \ = 0;\n    let mut num_primes_digits_iter26 = 0;\n    let mut num_primes_digits_iter27\
    \ = 0;\n    let mut num_primes_digits_iter28 = 0;\n    let mut num_primes_digits_iter29\
    \ = 0;\n    let mut num_primes_digits_iter30 = 0;\n    let mut num_primes_digits_iter31\
    \ = 0;\n    let mut num_primes_digits_iter32 = 0;\n    let mut num_primes_digits_iter33\
    \ = 0;\n    let mut num_primes_digits_iter34 = 0;\n    let mut num_primes_digits_iter35\
    \ = 0;\n    let mut num_primes_digits_iter36 = 0;\n    let mut num_primes_digits_iter37\
    \ = 0;\n    let mut num_primes_digits_iter38 = 0;\n    let mut num_primes_\n}\n\
    \nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp02hzo7rx.rs:66:24\n   |\n\
    66 |     let mut num_primes_\n   |                        ^ help: add `;` here\n\
    67 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp02hzo7rx.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_digits: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_idx = 0;\n    let mut prime_digits_idx2:\
    \ usize = 0;\n    let mut prime_digits_idx3: usize = 0;\n    let mut prime_digits_idx4:\
    \ usize = 0;\n    let mut prime_digits_idx5: usize = 0;\n    let mut prime_digits_idx6:\
    \ usize = 0;\n    let mut prime_digits_idx7: usize = 0;\n    let mut prime_digits_idx8:\
    \ usize = 0;\n    let mut prime_digits_idx9: usize = 0;\n    let mut prime_digits_idx10:\
    \ usize = 0;\n    let mut prime_digits_idx11: usize = 0;\n    let mut prime_digits_idx12:\
    \ usize = 0;\n    let mut prime_digits_idx13: usize = 0;\n    let mut prime_digits_idx14:\
    \ usize = 0;\n    let mut prime_digits_idx15: usize = 0;\n    let mut prime_digits_idx16:\
    \ usize = 0;\n    let mut prime_digits_idx17: usize = 0;\n    let mut prime_digits_idx18:\
    \ usize = 0;\n    let mut prime_digits_idx19: usize = 0;\n    let mut prime_digits_idx20:\
    \ usize = 0;\n    let mut prime_digits_idx21: usize = 0;\n    let mut prime_digits_idx22:\
    \ usize = 0;\n    let mut prime_digits_idx23: usize = 0;\n    let mut prime_digits_idx24:\
    \ usize = 0;\n    let mut prime_digits_idx25: usize = 0;\n    let mut prime_digits_idx26:\
    \ usize = 0;\n    let mut prime_digits_idx27: usize = 0;\n    let mut prime_digits_idx28:\
    \ usize = 0;\n    let mut prime_digits_idx29: usize = 0;\n    let mut prime_digits_idx30:\
    \ usize = 0;\n    let mut prime_digits_idx31: usize = 0;\n    let mut prime_digit\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpp31db9xr.rs:57:24\n   |\n\
    57 |     let mut prime_digit\n   |                        ^ help: add `;` here\n\
    58 | }\n   | - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot\
    \ be built from an iterator over elements of type `char`\n  --> /tmp/tmpp31db9xr.rs:23:55\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpp31db9xr.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: isize = 0;\n    let mut prime_digit: u8 = 0;\n    let mut\
    \ prime_digit_count: isize = 0;\n    let mut prime_digit_index: usize = 0;\n \
    \   let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index: usize\
    \ = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_count: isize = 0;\n    let \n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpexs8eu8r.rs:70:1\n  \
    \ |\n70 | }\n   | ^ expected pattern\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n  --> /tmp/tmpexs8eu8r.rs:23:55\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_2:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\
    \ 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_3: Vec<u8> = vec![2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97];\n    let mut num_prime_4: Vec<u8> = vec![2, 3, 5, 7, 11, 13,\
    \ 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n\
    \    let mut num_prime_5: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_6:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\
    \ 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_7: Vec<u8> = vec![2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97];\n    let mut num_prime_8: Vec<u8> = vec![2, 3, 5, 7, 11, 13,\
    \ 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n\
    \    let mut num_prime_9: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_10:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\
    \ 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_11: Vec<u8> = vec![2,\
    \ 3, 5, 7, 11, \n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpmag_tm9a.rs:34:41\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |                         \
    \         - closing delimiter possibly meant for this\n...\n34 |     let mut num_prime_11:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, \n   |                                      \
    \   ^ unclosed delimiter\n35 | }\n   | ^ mismatched closing delimiter\n\nerror:\
    \ expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n  --> /tmp/tmpmag_tm9a.rs:35:1\n\
    \   |\n35 | }\n   | ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\n\
    error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator over\
    \ elements of type `char`\n  --> /tmp/tmpmag_tm9a.rs:23:55\n   |\n23 |     let\
    \ mut num: Vec<u8> = num.to_lowercase().chars().collect();\n   |             \
    \                                          ^^^^^^^ value of type `Vec<u8>` cannot\
    \ be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748837
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_2:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\
    \ 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_3: Vec<u8> = vec![2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97];\n    let mut num_prime_4: Vec<u8> = vec![2, 3, 5, 7, 11, 13,\
    \ 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n\
    \    let mut num_prime_5: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_6:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\
    \ 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_7: Vec<u8> = vec![2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97];\n    let mut num_prime_8: Vec<u8> = vec![2, 3, 5, 7, 11, 13,\
    \ 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n\
    \    let mut num_prime_9: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_10:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\
    \ 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_11: Vec<u8> = vec![2,\
    \ 3, 5, 7, 11, \n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpmag_tm9a.rs:34:41\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |                         \
    \         - closing delimiter possibly meant for this\n...\n34 |     let mut num_prime_11:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, \n   |                                      \
    \   ^ unclosed delimiter\n35 | }\n   | ^ mismatched closing delimiter\n\nerror:\
    \ expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n  --> /tmp/tmpmag_tm9a.rs:35:1\n\
    \   |\n35 | }\n   | ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\n\
    error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator over\
    \ elements of type `char`\n  --> /tmp/tmpmag_tm9a.rs:23:55\n   |\n23 |     let\
    \ mut num: Vec<u8> = num.to_lowercase().chars().collect();\n   |             \
    \                                          ^^^^^^^ value of type `Vec<u8>` cannot\
    \ be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748837
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut prime_digits = vec![];\n    let mut prime_digits_counter: usize = 0;\n\
    \    let mut prime_digits_counter2: usize = 0;\n    let mut prime_digits_counter3:\
    \ usize = 0;\n    let mut prime_digits_counter4: usize = 0;\n    let mut prime_digits_counter5:\
    \ usize = 0;\n    let mut prime_digits_counter6: usize = 0;\n    let mut prime_digits_counter7:\
    \ usize = 0;\n    let mut prime_digits_counter8: usize = 0;\n    let mut prime_digits_counter9:\
    \ usize = 0;\n    let mut prime_digits_counter10: usize = 0;\n    let mut prime_digits_counter11:\
    \ usize = 0;\n    let mut prime_digits_counter12: usize = 0;\n    let mut prime_digits_counter13:\
    \ usize = 0;\n    let mut prime_digits_counter14: usize = 0;\n    let mut prime_digits_counter15:\
    \ usize = 0;\n    let mut prime_digits_counter16: usize = 0;\n    let mut prime_digits_counter17:\
    \ usize = 0;\n    let mut prime_digits_counter18: usize = 0;\n    let mut prime_digits_counter19:\
    \ usize = 0;\n    let mut prime_digits_counter20: usize = 0;\n    let mut prime_digits_counter21:\
    \ usize = 0;\n    let mut prime_digits_counter22: usize = 0;\n    let mut prime_digits_counter23:\
    \ usize = 0;\n    let mut prime_digits_counter24: usize = 0;\n    let mut prime_digits_counter25:\
    \ usize = 0;\n    let mut prime_digits_counter26: usize = 0;\n    let mut prime_digits_counter27:\
    \ usize = 0;\n    let mut prime_digits_counter28: usize = 0;\n    let mut prime_digits_counter29:\
    \ usize = 0;\n    let mut prime_digits_counter30: usize = 0;\n    let mut prime_digits_counter31:\
    \ usize = 0;\n    let mut prime_digits_counter32: usize = 0;\n    let mut prime_digits_counter33:\
    \ usize = 0;\n    let mut prime_digits_counter34: usize = 0;\n    let mut prime_digits_counter35:\
    \ u\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp4yam3n0y.rs:59:38\n   |\n\
    59 |     let mut prime_digits_counter35: u\n   |                             \
    \         ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0412]:\
    \ cannot find type `u` in this scope\n  --> /tmp/tmp4yam3n0y.rs:59:37\n   |\n\
    59 |     let mut prime_digits_counter35: u\n   |                             \
    \        ^ help: a builtin type with a similar name exists: `u8`\n\nerror[E0277]:\
    \ a value of type `Vec<u8>` cannot be built from an iterator over elements of\
    \ type `char`\n  --> /tmp/tmp4yam3n0y.rs:23:52\n   |\n23 |     let mut num: Vec<u8>\
    \ = num.to_string().chars().collect();\n   |                                 \
    \                   ^^^^^^^ value of type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n\
    \   |\n   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp4yam3n0y.rs:22:28\n   |\n22 |\
    \ fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^ expected\
    \ `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0412.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut nums = num.chars().collect::<Vec<_>>();\n    let mut nums_len\
    \ = nums.len();\n    let mut nums_prime = 0;\n    let mut nums_prime_len = nums_len;\n\
    \    let mut nums_prime_prime = 0;\n    let mut nums_prime_prime_len = nums_len;\n\
    \    let mut nums_prime_prime_prime = 0;\n    let mut nums_prime_prime_prime_len\
    \ = nums_len;\n    let mut nums_prime_prime_prime_prime = 0;\n    let mut nums_prime_prime_prime_prime_len\
    \ = nums_len;\n    let mut nums_prime_prime_prime_prime_prime = 0;\n    let mut\
    \ nums_prime_prime_prime_prime_prime_len = nums_len;\n    let mut nums_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut nums_prime_prime_prime_prime_prime_prime_len = nums_len;\n\
    \    let mut nums_prime_prime_prime_prime_prime_prime_prime = 0;\n    let mut\
    \ nums_prime_prime_prime_prime_prime_prime_prime_len = nums_len;\n    let mut\
    \ nums_prime_prime_prime_prime_prime_prime_prime_len = nums_len;\n    let mut\
    \ nums_prime_prime_prime_prime_prime_prime_prime_len = nums_len;\n    let mut\
    \ nums_prime_prime_prime_prime_prime_prime_prime_prime_len = nums_len;\n    let\
    \ mut nums_prime_prime_prime_prime_prime_prime_prime_prime_len = nums_len;\n \
    \   let mut nums_prime_prime_prime_prime_prime_prime_prime_prime_prime_len = nums_len;\n\
    \    let mut nums_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_len\
    \ = nums_len;\n    let mut nums_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_len\
    \ = nums_len;\n    let mut nums_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_len\
    \ = nums_len;\n    let mut nums_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpd___axn9.rs:47:125\n   |\n\
    47 |     let mut nums_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\n\
    \   |                                                                        \
    \                                                     ^ help: add `;` here\n48\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd___axn9.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut count = 1;\n    let mut prime: isize = 2;\n    let mut prime_found\
    \ = false;\n    while !num.is_empty() {\n        if num[0] == b'a' || num[0] ==\
    \ b'b'\n            || num[0] == b'c' || num[0] == b'd'\n            || num[0]\
    \ == b'e' || num[0] == b'f'\n            || num[0] == b'A' || num[0] == b'B'\n\
    \            || num[0] == b'C' || num[0] == b'D'\n            || num[0] == b'E'\
    \ || num[0] == b'F' {\n            prime_found = true;\n            break;\n \
    \       }\n        prime = prime * 2;\n        prime_found = false;\n        for\
    \ &c in num.iter().rev() {\n            if prime % 10 == 0 {\n               \
    \ prime_found = true;\n                break;\n            }\n            prime\
    \ /= 10;\n        }\n        if !prime_found {\n            count += 1;\n    \
    \    }\n        num = num.iter().rev().collect();\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n  --> /tmp/tmp1ok01enb.rs:23:55\n   |\n23 |  \
    \   let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n   |       \
    \                                                ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the\
    \ trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0277]:\
    \ a value of type `Vec<u8>` cannot be built from an iterator over elements of\
    \ type `&u8`\n  --> /tmp/tmp1ok01enb.rs:49:32\n   |\n49 |         num = num.iter().rev().collect();\n\
    \   |                                ^^^^^^^ value of type `Vec<u8>` cannot be\
    \ built from `std::iter::Iterator<Item=&u8>`\n   |\n   = help: the trait `FromIterator<&u8>`\
    \ is not implemented for `Vec<u8>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut count: isize = 0;\n    let mut prime: Vec<u8> = vec![2, 3, 5, 7];\n\
    \    let mut prime_found = false;\n    let mut prime_found2 = false;\n    let\
    \ mut prime_found3 = false;\n    let mut prime_found4 = false;\n    let mut prime_found5\
    \ = false;\n    let mut prime_found6 = false;\n    let mut prime_found7 = false;\n\
    \    let mut prime_found8 = false;\n    let mut prime_found9 = false;\n    let\
    \ mut prime_found10 = false;\n    let mut prime_found11 = false;\n    let mut\
    \ prime_found12 = false;\n    let mut prime_found13 = false;\n    let mut prime_found14\
    \ = false;\n    let mut prime_found15 = false;\n    let mut prime_found16 = false;\n\
    \    let mut prime_found17 = false;\n    let mut prime_found18 = false;\n    let\
    \ mut prime_found19 = false;\n    let mut prime_found20 = false;\n    let mut\
    \ prime_found21 = false;\n    let mut prime_found22 = false;\n    let mut prime_found23\
    \ = false;\n    let mut prime_found24 = false;\n    let mut prime_found25 = false;\n\
    \    let mut prime_found26 = false;\n    let mut prime_found27 = false;\n    let\
    \ mut prime_found28 = false;\n    let mut prime_found29 = false;\n    let mut\
    \ prime_found30 = false;\n    let mut prime_found31 = false;\n    let mut prime_found32\
    \ = false;\n    let mut prime_found33 = false;\n    let mut prime_found34 = false;\n\
    \    let mut prime_found35 = false;\n    let mut prime_found36 = false;\n    let\
    \ mut prime_found37 = false;\n    let mut prime_found38 = false;\n    let mut\
    \ prime_found39 = false;\n    let mut prime_found40 = false;\n    let mut prime_found41\
    \ = false;\n    let mut prime_found42 = false;\n    let mut prime_found43 = false;\n\
    \    let mut prime_found44 = false;\n    let mut prime_found45 = false;\n    let\
    \ mut prime_found46 = false;\n    let mut prime_found47 = false;\n    let mut\
    \ prime_found48 = false;\n    let mut prime_found49 = false;\n    let mut prime_found50\
    \ = false;\n    let mut prime_found51 = false;\n    let mut \n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp1ggo_5z3.rs:78:1\n\
    \   |\n78 | }\n   | ^ expected identifier\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n  --> /tmp/tmp1ggo_5z3.rs:23:55\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_digits = num.len();\n    let mut prime_digits = vec![];\n   \
    \ let mut prime_digits_counter = vec![];\n    let mut prime_digits_counter2 =\
    \ vec![];\n    let mut prime_digits_counter3 = vec![];\n    let mut prime_digits_counter4\
    \ = vec![];\n    let mut prime_digits_counter5 = vec![];\n    let mut prime_digits_counter6\
    \ = vec![];\n    let mut prime_digits_counter7 = vec![];\n    let mut prime_digits_counter8\
    \ = vec![];\n    let mut prime_digits_counter9 = vec![];\n    let mut prime_digits_counter10\
    \ = vec![];\n    let mut prime_digits_counter11 = vec![];\n    let mut prime_digits_counter12\
    \ = vec![];\n    let mut prime_digits_counter13 = vec![];\n    let mut prime_digits_counter14\
    \ = vec![];\n    let mut prime_digits_counter15 = vec![];\n    let mut prime_digits_counter16\
    \ = vec![];\n    let mut prime_digits_counter17 = vec![];\n    let mut prime_digits_counter18\
    \ = vec![];\n    let mut prime_digits_counter19 = vec![];\n    let mut prime_digits_counter20\
    \ = vec![];\n    let mut prime_digits_counter21 = vec![];\n    let mut prime_digits_counter22\
    \ = vec![];\n    let mut prime_digits_counter23 = vec![];\n    let mut prime_digits_counter24\
    \ = vec![];\n    let mut prime_digits_counter25 = vec![];\n    let mut prime_digits_counter26\
    \ = vec![];\n    let mut prime_digits_counter27 = vec![];\n    let mut prime_digits_counter28\
    \ = vec![];\n    let mut prime_digits_counter29 = vec![];\n    let mut prime_digits_counter30\
    \ = vec![];\n    let mut prime_digits_counter31 = vec![];\n    let mut prime_digits_counter32\
    \ = vec![];\n    let mut prime_digits_counter33 = vec![];\n    let mut prime_digits_counter34\
    \ = vec![];\n    let mut prime_digits_\n}\n\nfn main() {\n    let candidate =\
    \ hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpakh2y20k.rs:60:26\n   |\n\
    60 |     let mut prime_digits_\n   |                          ^ help: add `;`\
    \ here\n61 | }\n   | - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n  --> /tmp/tmpakh2y20k.rs:23:55\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpakh2y20k.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut nums = num.chars().collect::<Vec<_>>();\n    let mut primes\
    \ = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let mut primes_len = primes.len();\n\
    \    let mut primes_sum = 0;\n    let mut primes_sum2 = 0;\n    let mut primes_sum3\
    \ = 0;\n    let mut primes_sum4 = 0;\n    let mut primes_sum5 = 0;\n    let mut\
    \ primes_sum6 = 0;\n    let mut primes_sum7 = 0;\n    let mut primes_sum8 = 0;\n\
    \    let mut primes_sum9 = 0;\n    let mut primes_sum10 = 0;\n    let mut primes_sum11\
    \ = 0;\n    let mut primes_sum12 = 0;\n    let mut primes_sum13 = 0;\n    let\
    \ mut primes_sum14 = 0;\n    let mut primes_sum15 = 0;\n    let mut primes_sum16\
    \ = 0;\n    let mut primes_sum17 = 0;\n    let mut primes_sum18 = 0;\n    let\
    \ mut primes_sum19 = 0;\n    let mut primes_sum20 = 0;\n    let mut primes_sum21\
    \ = 0;\n    let mut primes_sum22 = 0;\n    let mut primes_sum23 = 0;\n    let\
    \ mut primes_sum24 = 0;\n    let mut primes_sum25 = 0;\n    let mut primes_sum26\
    \ = 0;\n    let mut primes_sum27 = 0;\n    let mut primes_sum28 = 0;\n    let\
    \ mut primes_sum29 = 0;\n    let mut primes_sum30 = 0;\n    let mut primes_sum31\
    \ = 0;\n    let mut primes_sum32 = 0;\n    let mut primes_sum33 = 0;\n    let\
    \ mut primes_sum34 = 0;\n    let mut primes_sum35 = 0;\n    let mut primes_sum36\
    \ = 0;\n    let mut primes_sum37 = 0;\n    let mut primes_sum38 = 0;\n    let\
    \ mut primes_sum39 = 0;\n    let mut primes_sum40 = 0;\n    let mut primes_sum41\
    \ = 0;\n    let mut primes_sum42 = 0;\n    let mut primes_sum43 = 0;\n    let\
    \ mut primes_sum44 = 0;\n    let mut primes_sum45 = 0;\n    let mut primes_sum46\
    \ = 0;\n    let mut primes_sum47 = 0;\n    let mut primes_sum48 = 0;\n    let\
    \ mut primes_sum49 = 0;\n    let mut primes_sum50 = 0;\n    let mut primes_sum51\
    \ = 0;\n    let mut primes_sum52 = 0;\n    let mut primes_\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpiuu54u6x.rs:78:20\n   |\n\
    78 |     let mut primes_\n   |                    ^ help: add `;` here\n79 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpiuu54u6x.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_len\
    \ = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n    let mut\
    \ num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp605kyhux.rs:59:22\n   |\n\
    59 |     let mut num_prime\n   |                      ^ help: add `;` here\n60\
    \ | }\n   | - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot\
    \ be built from an iterator over elements of type `char`\n  --> /tmp/tmp605kyhux.rs:23:55\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp605kyhux.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut prime_count: isize = 0;\n    let mut prime_digit: u8 = 0;\n    let mut\
    \ prime_digit_count: usize = 0;\n    let mut prime_digit_index: usize = 0;\n \
    \   let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value_count: usize\
    \ = 0;\n    let mut prime_digit_value_prime: u8 = 0;\n    let mut prime_digit_value_prime_count:\
    \ usize = 0;\n    let mut prime_digit_value_prime_prime: u8 = 0;\n    let mut\
    \ prime_digit_value_prime_prime_count: usize = 0;\n    let mut prime_digit_value_prime_prime_prime:\
    \ u8 = 0;\n    let mut prime_digit_value_prime_prime_prime_count: usize = 0;\n\
    \    let mut prime_digit_value_prime_prime_prime_prime: u8 = 0;\n    let mut prime_digit_value_prime_prime_prime_prime_count:\
    \ usize = 0;\n    let mut prime_digit_value_prime_prime_prime_prime_prime: u8\
    \ = 0;\n    let mut prime_digit_value_prime_prime_prime_prime_prime_count: usize\
    \ = 0;\n    let mut prime_digit_value_prime_prime_prime_prime_prime_prime: u8\
    \ = 0;\n    let mut prime_digit_value_prime_prime_prime_prime_prime_prime_count:\
    \ usize = 0;\n    let mut prime_digit_value_prime_prime_prime_prime_prime_prime_prime:\
    \ u8 = 0;\n    let mut prime_digit_value_prime_prime_prime_prime_prime_prime_prime_count:\
    \ usize = 0;\n    let mut prime_digit_value_prime_prime_prime_prime_prime_prime_prime_prime_count:\
    \ usize = 0;\n    let mut prime_digit_value_prime_prime_prime_prime_prime_prime_prime_prime_prime_count:\
    \ usize = 0;\n    let mut prime_digit_value_prime_prime_prime_prime_prime_prime_prime_prime_prime_count:\
    \ usize = 0;\n    let mut prime_digit_value_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_count:\
    \ usize = 0;\n    let mut prime_digit_value_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_count:\
    \ usize = 0;\n    let mut prime_digit_value_prime_\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmptv4kjodh.rs:49:37\n   |\n\
    49 |     let mut prime_digit_value_prime_\n   |                              \
    \       ^ help: add `;` here\n50 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptv4kjodh.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror[E0277]: a value of type `Vec<u8>` cannot be\
    \ built from an iterator over elements of type `char`\n  --> /tmp/tmptv4kjodh.rs:23:52\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_string().chars().collect();\n  \
    \ |                                                    ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the\
    \ trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpmcimx23o.rs:38:50\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |                         \
    \         - closing delimiter possibly meant for this\n...\n38 |     let mut num:\
    \ Vec<u8> = num.into_iter().filter(\n   |                                    \
    \              ^ unclosed delimiter\n39 | }\n   | ^ mismatched closing delimiter\n\
    \nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n  -->\
    \ /tmp/tmpmcimx23o.rs:39:1\n   |\n39 | }\n   | ^ expected one of `.`, `;`, `?`,\
    \ `else`, or an operator\n\nerror[E0277]: a value of type `Vec<u8>` cannot be\
    \ built from an iterator over elements of type `char`\n  --> /tmp/tmpmcimx23o.rs:23:52\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_string().chars().collect();\n  \
    \ |                                                    ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the\
    \ trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmcimx23o.rs:24:61\n   |\n24 |     let mut num:\
    \ Vec<u8> = num.into_iter().filter(|&c| c >= '0' && c <= '9').collect();\n   |\
    \                                                             ^^^ expected `u8`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmcimx23o.rs:24:73\n\
    \   |\n24 |     let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= '0' &&\
    \ c <= '9').collect();\n   |                                                 \
    \                        ^^^ expected `u8`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpmcimx23o.rs:25:61\n   |\n25 |     let mut num: Vec<u8>\
    \ = num.into_iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n   |       \
    \                                                      ^^^ expected `u8`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmcimx23o.rs:25:73\n\
    \   |\n25 |     let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= 'A' &&\
    \ c <= 'F').collect();\n   |                                                 \
    \                        ^^^ expected `u8`, found `char`\n\nerr"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for struct `Vec<u8>` in the\
    \ current scope\n  --> /tmp/tmp2urilp3z.rs:24:32\n   |\n24 |     let mut num:\
    \ Vec<u8> = num.chars().collect();\n   |                                ^^^^^\
    \ method not found in `Vec<u8>`\n\nerror[E0277]: a value of type `Vec<u8>` cannot\
    \ be built from an iterator over elements of type `char`\n  --> /tmp/tmp2urilp3z.rs:23:52\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_string().chars().collect();\n  \
    \ |                                                    ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the\
    \ trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0599]:\
    \ no method named `chars` found for struct `Vec<u8>` in the current scope\n  -->\
    \ /tmp/tmp2urilp3z.rs:25:32\n   |\n25 |     let mut num: Vec<u8> = num.chars().collect();\n\
    \   |                                ^^^^^ method not found in `Vec<u8>`\n\nerror[E0599]:\
    \ no method named `chars` found for struct `Vec<u8>` in the current scope\n  -->\
    \ /tmp/tmp2urilp3z.rs:26:32\n   |\n26 |     let mut num: Vec<u8> = num.chars().collect();\n\
    \   |                                ^^^^^ method not found in `Vec<u8>`\n\nerror[E0599]:\
    \ no method named `chars` found for struct `Vec<u8>` in the current scope\n  -->\
    \ /tmp/tmp2urilp3z.rs:27:32\n   |\n27 |     let mut num: Vec<u8> = num.chars().collect();\n\
    \   |                                ^^^^^ method not found in `Vec<u8>`\n\nerror[E0599]:\
    \ no method named `chars` found for struct `Vec<u8>` in the current scope\n  -->\
    \ /tmp/tmp2urilp3z.rs:28:32\n   |\n28 |     let mut num: Vec<u8> = num.chars().collect();\n\
    \   |                                ^^^^^ method not found in `Vec<u8>`\n\nerror[E0599]:\
    \ no method named `chars` found for struct `Vec<u8>` in the current scope\n  -->\
    \ /tmp/tmp2urilp3z.rs:29:32\n   |\n29 |     let mut num: Vec<u8> = num.chars().collect();\n\
    \   |                                ^^^^^ method not found in `Vec<u8>`\n\nerror[E0599]:\
    \ no method named `chars` found for struct `Vec<u8>` in the current scope\n  -->\
    \ /tmp/tmp2urilp3z.rs:3"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|&c| match c {\n        '0' => 0,\n\
    \        '1' => 1,\n        '2' => 2,\n        '3' => 3,\n        '4' => 4,\n\
    \        '5' => 5,\n        '6' => 6,\n        '7' => 7,\n        '8' => 8,\n\
    \        '9' => 9,\n        'a' => 10,\n        'b' => 11,\n        'c' => 12,\n\
    \        'd' => 13,\n        'e' => 14,\n        'f' => 15,\n        _ => panic!(\"\
    Invalid hexadecimal digit: {}\", c)\n    }).collect();\n    let mut num: Vec<u8>\
    \ = num.iter().map(|&c| match c {\n        0 => 2,\n        1 => 3,\n        2\
    \ => 5,\n        3 => 7,\n        4 => 11,\n        5 => 13,\n        6 => 17,\n\
    \        7 => 19,\n        8 => 23,\n        9 => 29,\n        10 => 31,\n   \
    \     11 => 37,\n        12 => 41,\n        13 => 43,\n        14 => 47,\n   \
    \     15 => 53,\n        _ => panic!(\"Invalid hexadecimal digit: {}\", c)\n \
    \   }).collect();\n    let mut num: Vec<u8> = num.iter().map(|&c| match c {\n\
    \        0 => 2,\n        1 => 3,\n        2 => 5,\n        3 => 7,\n        4\
    \ => 11,\n        5 => 13,\n        6 => 17,\n        7 => 19,\n        8 => 23,\n\
    \        9 => 29,\n        10 => 31,\n        11 => 37,\n        12 => 41,\n \
    \       13 => 43,\n        14 => 47,\n        15 => 53,\n        _ => panic!(\"\
    Invalid hexadecimal digit: {}\", c)\n    }).collect();\n    let mut num: Vec<u8>\
    \ = num.iter().map(|&c| match c {\n        0 => 2,\n        1 => 3,\n        2\
    \ => 5,\n        3 => 7,\n        4 => 11,\n        5 => 13,\n        6 => 17,\n\
    \        7 => 19,\n        8 => 23,\n        9 => 29,\n        10 => 31,\n   \
    \     11 => 37,\n        12 => 41,\n        13 => 43,\n        14 => 47,\n   \
    \     15 => 53,\n        _ => panic!\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpann4nazd.rs:109:3\n\
    \    |\n22  | fn hex_key(num: String) -> isize {\n    |                      \
    \            - unclosed delimiter\n...\n81  |     let mut num: Vec<u8> = num.iter().map(|&c|\
    \ match c {\n    |                                          - unclosed delimiter\n\
    ...\n109 | }\n    |   ^\n\nerror: expected one of `(`, `[`, or `{`, found `}`\n\
    \  --> /tmp/tmpann4nazd.rs:99:1\n   |\n98 |         _ => panic!\n   |        \
    \   --       - expected one of `(`, `[`, or `{`\n   |           |\n   |      \
    \     while parsing the `match` arm starting here\n99 | }\n   | ^ unexpected token\n\
    \nerror: expected one of `)`, `,`, `.`, `?`, or an operator, found keyword `fn`\n\
    \   --> /tmp/tmpann4nazd.rs:101:1\n    |\n99  | }\n    |  - expected one of `)`,\
    \ `,`, `.`, `?`, or an operator\n100 | \n101 | fn main() {\n    | ^^ unexpected\
    \ token\n\nerror: aborting due to 3 previous errors\n\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: isize = 0;\n    let mut prime_found = false;\n    let mut\
    \ prime_found2 = false;\n    let mut prime_found3 = false;\n    let mut prime_found4\
    \ = false;\n    let mut prime_found5 = false;\n    let mut prime_found6 = false;\n\
    \    let mut prime_found7 = false;\n    let mut prime_found8 = false;\n    let\
    \ mut prime_found9 = false;\n    let mut prime_found10 = false;\n    let mut prime_found11\
    \ = false;\n    let mut prime_found12 = false;\n    let mut prime_found13 = false;\n\
    \    let mut prime_found14 = false;\n    let mut prime_found15 = false;\n    let\
    \ mut prime_found16 = false;\n    let mut prime_found17 = false;\n    let mut\
    \ prime_found18 = false;\n    let mut prime_found19 = false;\n    let mut prime_found20\
    \ = false;\n    let mut prime_found21 = false;\n    let mut prime_found22 = false;\n\
    \    let mut prime_found23 = false;\n    let mut prime_found24 = false;\n    let\
    \ mut prime_found25 = false;\n    let mut prime_found26 = false;\n    let mut\
    \ prime_found27 = false;\n    let mut prime_found28 = false;\n    let mut prime_found29\
    \ = false;\n    let mut prime_found30 = false;\n    let mut prime_found31 = false;\n\
    \    let mut prime_found32 = false;\n    let mut prime_found33 = false;\n    let\
    \ mut prime_found34 = false;\n    let mut prime_found35 = false;\n    let mut\
    \ prime_found36 = false;\n    let mut prime_found37 = false;\n    let mut prime_found38\
    \ = false;\n    let mut prime_found39 = false;\n    let mut prime_found40 = false;\n\
    \    let mut prime_found41 = false;\n    let mut prime_found42 = false;\n    let\
    \ mut prime_found43 = false;\n    let mut prime_found44 = false;\n    let mut\
    \ prime_found45 = false;\n    let mut prime_found46 = false;\n    let mut prime_found47\
    \ = false;\n    let mut prime_found48 = false;\n    let mut prime_found49 = false;\n\
    \    let mut prime_found50 = false;\n    let mut prime_found51 = false;\n    let\
    \ mut prime_found52 = false;\n    let mut prime_found53 = false;\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmprl7xyb0c.rs:23:55\n     |\n23\
    \   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |\
    \                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprl7xyb0c.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_counter:\
    \ usize = 0;\n    let mut prime_counter2: usize = 0;\n    let mut prime_counter3:\
    \ usize = 0;\n    let mut prime_counter4: usize = 0;\n    let mut prime_counter5:\
    \ usize = 0;\n    let mut prime_counter6: usize = 0;\n    let mut prime_counter7:\
    \ usize = 0;\n    let mut prime_counter8: usize = 0;\n    let mut prime_counter9:\
    \ usize = 0;\n    let mut prime_counter10: usize = 0;\n    let mut prime_counter11:\
    \ usize = 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13:\
    \ usize = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: u\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5h95n5pg.rs:62:31\n   |\n\
    62 |     let mut prime_counter38: u\n   |                               ^ help:\
    \ add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0412]: cannot find type\
    \ `u` in this scope\n  --> /tmp/tmp5h95n5pg.rs:62:30\n   |\n62 |     let mut prime_counter38:\
    \ u\n   |                              ^ help: a builtin type with a similar name\
    \ exists: `u8`\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from\
    \ an iterator over elements of type `char`\n    --> /tmp/tmp5h95n5pg.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5h95n5pg.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0412.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpnsj7n80f.rs:39:36\n   |\n\
    39 |     let mut num: Vec<u8> = num.iter\n   |                               \
    \     ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0277]: a\
    \ value of type `Vec<u8>` cannot be built from an iterator over elements of type\
    \ `char`\n  --> /tmp/tmpnsj7n80f.rs:23:55\n   |\n23 |     let mut num: Vec<u8>\
    \ = num.to_lowercase().chars().collect();\n   |                              \
    \                         ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n   |\n   = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnsj7n80f.rs:24:56\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <=\
    \ '9').collect();\n   |                                                      \
    \  ^^^ expected `&u8`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnsj7n80f.rs:24:68\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <=\
    \ '9').collect();\n   |                                                      \
    \              ^^^ expected `&u8`, found `char`\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `&u8`\n  -->\
    \ /tmp/tmpnsj7n80f.rs:24:73\n   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&c|\
    \ c >= '0' && c <= '9').collect();\n   |                                     \
    \                                    ^^^^^^^ value of type `Vec<u8>` cannot be\
    \ built from `std::iter::Iterator<Item=&u8>`\n   |\n   = help: the trait `FromIterator<&u8>`\
    \ is not implemented for `Vec<u8>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnsj7n80f.rs:25:56\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <=\
    \ 'F').collect();\n   |                                                      \
    \  ^^^ expected `&u8`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnsj7n80f.rs:25:68\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <=\
    \ 'F').collect();\n   |                     "
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: isize = num.chars().filter(|c| c.is_ascii_uppercase()).count()\
    \ + 1;\n    let mut prime: isize = 2;\n    let mut digit: isize = 2;\n    while\
    \ num > 1 {\n        if num % prime == 0 {\n            digit += 1;\n        }\n\
    \        prime += 2;\n        num /= 10;\n    }\n    digit\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2z2t3fp1.rs:23:26\n   |\n\
    23 |     let mut num: isize = num.chars().filter(|c| c.is_ascii_uppercase()).count()\
    \ + 1;\n   |                  -----   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |                  |\n   |             \
    \     expected due to this\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n23 |     let mut num: isize\
    \ = (num.chars().filter(|c| c.is_ascii_uppercase()).count() + 1).try_into().unwrap();\n\
    \   |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num_prime: Vec<u8> = vec![0; 8];\n    let mut num_prime_counter: Vec<u8>\
    \ = vec![0; 8];\n    let mut num_prime_counter2: Vec<u8> = vec![0; 8];\n    let\
    \ mut num_prime_counter3: Vec<u8> = vec![0; 8];\n    let mut num_prime_counter4:\
    \ Vec<u8> = vec![0; 8];\n    let mut num_prime_counter5: Vec<u8> = vec![0; 8];\n\
    \    let mut num_prime_counter6: Vec<u8> = vec![0; 8];\n    let mut num_prime_counter7:\
    \ Vec<u8> = vec![0; 8];\n    let mut num_prime_counter8: Vec<u8> = vec![0; 8];\n\
    \    let mut num_prime_counter9: Vec<u8> = vec![0; 8];\n    let mut num_prime_counter10:\
    \ Vec<u8> = vec![0; 8];\n    let mut num_prime_counter11: Vec<u8> = vec![0; 8];\n\
    \    let mut num_prime_counter12: Vec<u8> = vec![0; 8];\n    let mut num_prime_counter13:\
    \ Vec<u8> = vec![0; 8];\n    let mut num_prime_counter14: Vec<u8> = vec![0; 8];\n\
    \    let mut num_prime_counter15: Vec<u8> = vec![0; 8];\n    let mut num_prime_counter16:\
    \ Vec<u8> = vec![0; 8];\n    let mut num_prime_counter17: Vec<u8> = vec![0; 8];\n\
    \    let mut num_prime_counter18: Vec<u8> = vec![0; 8];\n    let mut num_prime_counter19:\
    \ Vec<u8> = vec![0; 8];\n    let mut num_prime_counter20: Vec<u8> = vec![0; 8];\n\
    \    let mut num_prime_counter21: Vec<u8> = vec![0; 8];\n    let mut num_prime_counter22:\
    \ Vec<u8> = vec![0; 8];\n    let mut num_prime_counter23: Vec<u8> = vec![0; 8];\n\
    \    let mut num_prime_counter24: Vec<u8> = vec![0; 8];\n    let \n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpqh5c1kov.rs:50:1\n  \
    \ |\n50 | }\n   | ^ expected pattern\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n  --> /tmp/tmpqh5c1kov.rs:23:52\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_string().chars().collect();\n  \
    \ |                                                    ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the\
    \ trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_prime: Vec<u8> = vec![];\n    let mut num_prime_counter: usize\
    \ = 0;\n    let mut num_prime_counter2: usize = 0;\n    let mut num_prime_counter3:\
    \ usize = 0;\n    let mut num_prime_counter4: usize = 0;\n    let mut num_prime_counter5:\
    \ usize = 0;\n    let mut num_prime_counter6: usize = 0;\n    let mut num_prime_counter7:\
    \ usize = 0;\n    let mut num_prime_counter8: usize = 0;\n    let mut num_prime_counter9:\
    \ usize = 0;\n    let mut num_prime_counter10: usize = 0;\n    let mut num_prime_counter11:\
    \ usize = 0;\n    let mut num_prime_counter12: usize = 0;\n    let mut num_prime_counter13:\
    \ usize = 0;\n    let mut num_prime_counter14: usize = 0;\n    let mut num_prime_counter15:\
    \ usize = 0;\n    let mut num_prime_counter16: usize = 0;\n    let mut num_prime_counter17:\
    \ usize = 0;\n    let mut num_prime_counter18: usize = 0;\n    let mut num_prime_counter19:\
    \ usize = 0;\n    let mut num_prime_counter20: usize = 0;\n    let mut num_prime_counter21:\
    \ usize = 0;\n    let mut num_prime_counter22: usize = 0;\n    let mut num_prime_counter23:\
    \ usize = 0;\n    let mut num_prime_counter24: usize = 0;\n    let mut num_prime_counter25:\
    \ usize = 0;\n    let mut num_prime_counter26: usize = 0;\n    let mut num_prime_counter27:\
    \ usize = 0;\n    let mut num_prime_counter28: usize = 0;\n    let mut num_prime_counter29:\
    \ usize = 0;\n    let mut num_prime_counter30: usize = 0;\n    let mut num_prime_counter31:\
    \ usize = 0;\n    let mut num_prime_counter32: usize = 0;\n    let mut num_prime_counter33:\
    \ usize = 0;\n    let mut num_prime_counter34: usize = 0;\n    let mut num_prime_counter35:\
    \ usize = 0;\n    let mut num_prime_counter36: usize = 0;\n    let mut num_prime_counter37:\
    \ usize = 0;\n    let mu\n}\n\nfn main() {\n    let candidate = hex_key;\n   \
    \ assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8bnkep1i.rs:62:11\n   |\n\
    62 |     let mu\n   |           ^ help: add `;` here\n63 | }\n   | - unexpected\
    \ token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmp8bnkep1i.rs:23:55\n     |\n23\
    \   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |\
    \                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8bnkep1i.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8wkly9zt.rs:40:36\n   |\n\
    40 |     let mut num: Vec<u8> = num.iter\n   |                               \
    \     ^ help: add `;` here\n41 | }\n   | - unexpected token\n\nerror[E0277]: a\
    \ value of type `Vec<u8>` cannot be built from an iterator over elements of type\
    \ `char`\n  --> /tmp/tmp8wkly9zt.rs:23:55\n   |\n23 |     let mut num: Vec<u8>\
    \ = num.to_lowercase().chars().collect();\n   |                              \
    \                         ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n   |\n   = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8wkly9zt.rs:24:56\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <=\
    \ '9').collect();\n   |                                                      \
    \  ^^^ expected `&u8`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8wkly9zt.rs:24:68\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <=\
    \ '9').collect();\n   |                                                      \
    \              ^^^ expected `&u8`, found `char`\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `&u8`\n  -->\
    \ /tmp/tmp8wkly9zt.rs:24:73\n   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&x|\
    \ x >= '0' && x <= '9').collect();\n   |                                     \
    \                                    ^^^^^^^ value of type `Vec<u8>` cannot be\
    \ built from `std::iter::Iterator<Item=&u8>`\n   |\n   = help: the trait `FromIterator<&u8>`\
    \ is not implemented for `Vec<u8>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8wkly9zt.rs:25:56\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <=\
    \ 'F').collect();\n   |                                                      \
    \  ^^^ expected `&u8`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8wkly9zt.rs:25:68\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <=\
    \ 'F').collect();\n   |                     "
  stdout: ''
  timestamp: 1659748839
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let mut digit:\
    \ Vec<u8> = vec![2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20];\n    let mut result: Vec<u8> = vec![];\n    let mut i: usize = 0;\n   \
    \ let mut j: usize = 0;\n    let mut k: usize = 0;\n    let mut l: usize = 0;\n\
    \    let mut m: usize = 0;\n    let mut n: usize = 0;\n    let mut o: usize =\
    \ 0;\n    let mut p: usize = 0;\n    let mut q: usize = 0;\n    let mut r: usize\
    \ = 0;\n    let mut s: usize = 0;\n    let mut t: usize = 0;\n    let mut u: usize\
    \ = 0;\n    let mut v: usize = 0;\n    let mut w: usize = 0;\n    let mut x: usize\
    \ = 0;\n    let mut y: usize = 0;\n    let mut z: usize = 0;\n    let mut a: usize\
    \ = 0;\n    let mut b: usize = 0;\n    let mut c: usize = 0;\n    let mut d: usize\
    \ = 0;\n    let mut e: usize = 0;\n    let mut f: usize = 0;\n    let mut g: usize\
    \ = 0;\n    let mut h: usize = 0;\n    let mut i: usize = 0;\n    let mut j: usize\
    \ = 0;\n    let mut k: usize = 0;\n    let mut l: usize = 0;\n    let mut m: usize\
    \ = 0;\n    let mut n: usize = 0;\n    let mut o: usize = 0;\n    let mut p: usize\
    \ = 0;\n    let mut q: usize = 0;\n    let mut r: usize = 0;\n    let mut s: usize\
    \ = 0;\n    let mut t: usize = 0;\n    let mut u: usize = 0;\n    let mut v: usize\
    \ = 0;\n    let mut w: usize = 0;\n    let mut x: usize = 0;\n    let mut y: usize\
    \ = 0;\n    let mut z: usize = 0;\n    let mut a: usize = 0;\n    let mut b: usize\
    \ = 0;\n    let mut c: usize = 0;\n    let mut d: usize = 0;\n    let mut e: usize\
    \ = 0;\n    let mut f: usize = 0;\n    let mut g: usize = 0;\n    let mut h: usize\
    \ = 0;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n  --> /tmp/tmpvtehl0nb.rs:23:55\n   |\n23 |  \
    \   let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n   |       \
    \                                                ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the\
    \ trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvtehl0nb.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut prime_count: isize = 0;\n    let mut prime_digit: u8 = 0;\n    let mut\
    \ prime_digits: Vec<u8> = vec![];\n    let mut prime_digit_count: usize = 0;\n\
    \    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count: usize\
    \ = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_count: usize = 0;\n    let mut prime_digit_count:\
    \ usize = 0;\n    let mut prime_digit_\n}\n\nfn main() {\n    let candidate =\
    \ hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9_7mvz4p.rs:68:25\n   |\n\
    68 |     let mut prime_digit_\n   |                         ^ help: add `;` here\n\
    69 | }\n   | - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot\
    \ be built from an iterator over elements of type `char`\n  --> /tmp/tmp9_7mvz4p.rs:23:52\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_string().chars().collect();\n  \
    \ |                                                    ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the\
    \ trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9_7mvz4p.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut nums = num.chars().collect::<Vec<_>>();\n    let mut nums_len\
    \ = nums.len();\n    let mut prime_nums = vec![];\n    let mut prime_nums_len\
    \ = prime_nums.len();\n    let mut prime_nums_counter = 0;\n    let mut prime_nums_counter_len\
    \ = prime_nums_counter.len();\n    let mut prime_nums_counter_counter = 0;\n \
    \   let mut prime_nums_counter_counter_len = prime_nums_counter_counter.len();\n\
    \    let mut prime_nums_counter_counter_counter = 0;\n    let mut prime_nums_counter_counter_counter_len\
    \ = prime_nums_counter_counter_counter.len();\n    let mut prime_nums_counter_counter_counter_counter\
    \ = 0;\n    let mut prime_nums_counter_counter_counter_counter_len = prime_nums_counter_counter_counter_counter.len();\n\
    \    let mut prime_nums_counter_counter_counter_counter_counter = 0;\n    let\
    \ mut prime_nums_counter_counter_counter_counter_counter_len = prime_nums_counter_counter_counter_counter_counter.len();\n\
    \    let mut prime_nums_counter_counter_counter_counter_counter_counter = 0;\n\
    \    let mut prime_nums_counter_counter_counter_counter_counter_counter_len =\
    \ prime_nums_counter_counter_counter_counter_counter_counter.len();\n    let mut\
    \ prime_nums_counter_counter_counter_counter_counter_counter_counter = 0;\n  \
    \  let mut prime_nums_counter_counter_counter_counter_counter_counter_counter_len\
    \ = prime_nums_counter_counter_counter_counter_counter_counter_counter.len();\n\
    \    let mut prime_nums_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    let mut prime_nums_counter_counter_counter_counter_counter_counter_counter_counter_len\
    \ = prime_nums_counter_counter_counter_counter_counter_counter_counter_counter.len();\n\
    \    let mut prime_nums_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    let mut prime_nums_counter_counter_counter_counter_counter_counter_counter_counter_counter_len\
    \ = prime_nums_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter.len();\n\
    \    let mut prime_nums_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    let mut prime_nums_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_len\
    \ = prime_nums_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter.len();\n\
    \    let mut prime_nums_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    let mut prime_nums_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_len\
    \ = prime_nums_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter.len();\n\
    \    let mut prime_nums_counter_counter_counter_counter_\n}\n\nfn main() {\n \
    \   let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmplx1n2cfw.rs:49:56\n   |\n\
    49 |     let mut prime_nums_counter_counter_counter_counter_\n   |           \
    \                                             ^ help: add `;` here\n50 | }\n \
    \  | - unexpected token\n\nerror[E0425]: cannot find value `prime_nums_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter`\
    \ in this scope\n  --> /tmp/tmplx1n2cfw.rs:44:102\n   |\n44 | ..._counter_len\
    \ = prime_nums_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter.len();\n\
    \   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `prime_nums_counter_counter_counter_counter_counter_counter_counter_counter_counter`\n\
    \nerror[E0425]: cannot find value `prime_nums_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter`\
    \ in this scope\n  --> /tmp/tmplx1n2cfw.rs:46:110\n   |\n46 | ...nter_len = prime_nums_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter.len();\n\
    \   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `prime_nums_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter`\n\
    \nerror[E0425]: cannot find value `prime_nums_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter`\
    \ in this scope\n  --> /tmp/tmplx1n2cfw.rs:48:134\n   |\n48 | ... = prime_nums_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter.le...\n\
    \   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `prime_nums_counter_counter_counter_counter_counter_counter_counter_counter_co"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num_digits = num.len();\n    let mut prime_digits = vec![];\n    let\
    \ mut prime_digits_counter: usize = 0;\n    let mut prime_digits_counter2: usize\
    \ = 0;\n    let mut prime_digits_counter3: usize = 0;\n    let mut prime_digits_counter4:\
    \ usize = 0;\n    let mut prime_digits_counter5: usize = 0;\n    let mut prime_digits_counter6:\
    \ usize = 0;\n    let mut prime_digits_counter7: usize = 0;\n    let mut prime_digits_counter8:\
    \ usize = 0;\n    let mut prime_digits_counter9: usize = 0;\n    let mut prime_digits_counter10:\
    \ usize = 0;\n    let mut prime_digits_counter11: usize = 0;\n    let mut prime_digits_counter12:\
    \ usize = 0;\n    let mut prime_digits_counter13: usize = 0;\n    let mut prime_digits_counter14:\
    \ usize = 0;\n    let mut prime_digits_counter15: usize = 0;\n    let mut prime_digits_counter16:\
    \ usize = 0;\n    let mut prime_digits_counter17: usize = 0;\n    let mut prime_digits_counter18:\
    \ usize = 0;\n    let mut prime_digits_counter19: usize = 0;\n    let mut prime_digits_counter20:\
    \ usize = 0;\n    let mut prime_digits_counter21: usize = 0;\n    let mut prime_digits_counter22:\
    \ usize = 0;\n    let mut prime_digits_counter23: usize = 0;\n    let mut prime_digits_counter24:\
    \ usize = 0;\n    let mut prime_digits_counter25: usize = 0;\n    let mut prime_digits_counter26:\
    \ usize = 0;\n    let mut prime_digits_counter27: usize = 0;\n    let mut prime_digits_counter28:\
    \ usize = 0;\n    let mut prime_digits_counter29: usize = 0;\n    let mut prime_digits_counter30:\
    \ usize = 0;\n    let mut prime_digits_counter31: usize = 0;\n    let mut prime_digits_counter32:\
    \ usize = 0;\n    let mut prime_digits_counter33: usize = 0;\n    let mut prime_digits_counter34:\
    \ usize = 0;\n\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n  --> /tmp/tmpplrnai32.rs:23:52\n   |\n23 |  \
    \   let mut num: Vec<u8> = num.to_string().chars().collect();\n   |          \
    \                                          ^^^^^^^ value of type `Vec<u8>` cannot\
    \ be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpplrnai32.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num: Vec<u8> = num.to_owned();\n    let mut num_prime: Vec<u8> = vec![];\n\
    \    let mut num_prime: Vec<u8> = num.to_owned();\n    let mut num_prime: Vec<u8>\
    \ = num.to_owned();\n    let mut num_prime: Vec<u8> = num.to_owned();\n    let\
    \ mut num_prime: Vec<u8> = num.to_owned();\n    let mut num_prime: Vec<u8> = num.to_owned();\n\
    \    let mut num_prime: Vec<u8> = num.to_owned();\n    let mut num_prime: Vec<u8>\
    \ = num.to_owned();\n    let mut num_prime: Vec<u8> = num.to_owned();\n    let\
    \ mut num_prime: Vec<u8> = num.to_owned();\n    let mut num_prime: Vec<u8> = num.to_owned();\n\
    \    let mut num_prime: Vec<u8> = num.to_owned();\n    let mut num_prime: Vec<u8>\
    \ = num.to_owned();\n    let mut num_prime: Vec<u8> = num.to_owned();\n    let\
    \ mut num_prime: Vec<u8> = num.to_owned();\n    let mut num_prime: Vec<u8> = num.to_owned();\n\
    \    let mut num_prime: Vec<u8> = num.to_owned();\n    let mut num_prime: Vec<u8>\
    \ = num.to_owned();\n    let mut num_prime: Vec<u8> = num.to_owned();\n    let\
    \ mut num_prime: Vec<u8> = num.to_owned();\n    let mut num_prime: Vec<u8> = num.to_owned();\n\
    \    let mut num_prime: Vec<u8> = num.to_owned();\n    let mut num_prime: Vec<u8>\
    \ = num.to_owned();\n    let mut num_prime: Vec<u8> = num.to_owned();\n    let\
    \ mut num_prime: Vec<u8> = num.to_owned();\n    let mut num_prime: Vec<u8> = num.to_owned();\n\
    \    let mut num_prime: Vec<u8> = num.to_owned();\n    let mut num_prime: Vec<u8>\
    \ = num.to_owned();\n    let mut \n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpugl1e3go.rs:54:1\n\
    \   |\n54 | }\n   | ^ expected identifier\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n  --> /tmp/tmpugl1e3go.rs:23:52\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_string().chars().collect();\n  \
    \ |                                                    ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the\
    \ trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_prime: Vec<u8> = vec![2, 3];\n    let mut num_prime_prime: Vec<u8>\
    \ = vec![5, 7];\n    let mut num_prime_prime_prime: Vec<u8> = vec![11, 13];\n\
    \    let mut num_prime_prime_prime_prime: Vec<u8> = vec![17, 19];\n    let mut\
    \ num_prime_prime_prime_prime_prime: Vec<u8> = vec![29, 31];\n    let mut num_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = vec![37, 41];\n    let mut num_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = vec![49, 53];\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = vec![57, 59];\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = vec![61, 63];\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = vec![67, 71];\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = vec![73, 79];\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = vec![83, 89];\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = vec![87, 91];\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = vec![93, 97];\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = vec![99, 101];\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = vec![103, 107];\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime_\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpktg8e7ia.rs:40:71\n   |\n\
    40 |     let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime_\n\
    \   |                                                                       ^\
    \ help: add `;` here\n41 | }\n   | - unexpected token\n\nerror[E0277]: a value\
    \ of type `Vec<u8>` cannot be built from an iterator over elements of type `char`\n\
    \  --> /tmp/tmpktg8e7ia.rs:23:55\n   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpktg8e7ia.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num: Vec<u8> = num.iter().map(|x| x as u8).collect();\n    let mut num:\
    \ Vec<u8> = num.iter().map(|x| x as u8).collect();\n    let mut num: Vec<u8> =\
    \ num.iter().map(|x| x as u8).collect();\n    let mut num: Vec<u8> = num.iter().map(|x|\
    \ x as u8).collect();\n    let mut num: Vec<u8> = num.iter().map(|x| x as u8).collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|x| x as u8).collect();\n    let mut\
    \ num: Vec<u8> = num.iter().map(|x| x as u8).collect();\n    let mut num: Vec<u8>\
    \ = num.iter().map(|x| x as u8).collect();\n    let mut num: Vec<u8> = num.iter().map(|x|\
    \ x as u8).collect();\n    let mut num: Vec<u8> = num.iter().map(|x| x as u8).collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|x| x as u8).collect();\n    let mut\
    \ num: Vec<u8> = num.iter().map(|x| x as u8).collect();\n    let mut num: Vec<u8>\
    \ = num.iter().map(|x| x as u8).collect();\n    let mut num: Vec<u8> = num.iter().map(|x|\
    \ x as u8).collect();\n    let mut num: Vec<u8> = num.iter().map(|x| x as u8).collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|x| x as u8).collect();\n    let mut\
    \ num: Vec<u8> = num.iter().map(|x| x as u8).collect();\n    let mut num: Vec<u8>\
    \ = num.iter().map(|x| x as u8).collect();\n    let mut num: Vec<u8> = num.iter().map(|x|\
    \ x as u8).collect();\n    let mut num: Vec<u8> = num.iter().map(|x| x as u8).collect();\n\
    \    let mut num: Vec<u8> = num.iter\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpgniore6b.rs:44:36\n   |\n\
    44 |     let mut num: Vec<u8> = num.iter\n   |                               \
    \     ^ help: add `;` here\n45 | }\n   | - unexpected token\n\nerror[E0277]: a\
    \ value of type `Vec<u8>` cannot be built from an iterator over elements of type\
    \ `char`\n  --> /tmp/tmpgniore6b.rs:23:52\n   |\n23 |     let mut num: Vec<u8>\
    \ = num.to_string().chars().collect();\n   |                                 \
    \                   ^^^^^^^ value of type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n\
    \   |\n   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \nerror[E0615]: attempted to take value of method `iter` on type `Vec<u8>`\n \
    \ --> /tmp/tmpgniore6b.rs:44:32\n   |\n44 |     let mut num: Vec<u8> = num.iter\n\
    \   |                                ^^^^ method, not a field\n   |\nhelp: use\
    \ parentheses to call the method\n   |\n44 |     let mut num: Vec<u8> = num.iter()\n\
    \   |                                    ++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpgniore6b.rs:22:28\n   |\n22 | fn hex_key(num: String) -> isize\
    \ {\n   |    -------                 ^^^^^ expected `isize`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror[E0606]: casting `&u8` as `u8` is invalid\n  --> /tmp/tmpgniore6b.rs:24:47\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().map(|x| x as u8).collect();\n\
    \   |                                               -^^^^^^\n   |            \
    \                                   |\n   |                                  \
    \             cannot cast `&u8` as `u8`\n   |                                \
    \               help: dereference the expression: `*x`\n\nerror[E0606]: casting\
    \ `&u8` as `u8` is invalid\n  --> /tmp/tmpgniore6b.rs:25:47\n   |\n25 |     let\
    \ mut num: Vec<u8> = num.iter().map(|x| x as u8).collect();\n   |            \
    \                                   -^^^^^^\n   |                            \
    \                   |\n   |                                               cannot\
    \ cast `&u8` as `u8`\n   |                   "
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num: Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n    let\
    \ mut num: Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n    let mut\
    \ num: Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n    let mut num:\
    \ Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n    let mut num: Vec<u8>\
    \ = num.iter().map(|x| x.to_digit(16)).collect();\n    let mut num: Vec<u8> =\
    \ num.iter().map(|x| x.to_digit(16)).collect();\n    let mut num: Vec<u8> = num.iter().map(|x|\
    \ x.to_digit(16)).collect();\n    let mut num: Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n  \
    \  let mut num: Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n    let\
    \ mut num: Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n    let mut\
    \ num: Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n    let mut num:\
    \ Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n    let mut num: Vec<u8>\
    \ = num.iter().map(|x| x.to_digit(16)).collect();\n    let mut num: Vec<u8> =\
    \ num.iter().map(|x| x.to_digit(16)).collect();\n    let mut num: Vec<u8> = num.iter().map(|x|\
    \ x.to_digit(16)).collect();\n    let mut num: Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n  \
    \  let mut num: Vec<\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `>`, a const expression, lifetime, or type, found\
    \ `}`\n  --> /tmp/tmpnpts03uk.rs:43:1\n   |\n42 |     let mut num: Vec<\n   |\
    \         -------      - expected one of `>`, a const expression, lifetime, or\
    \ type\n   |         |\n   |         while parsing the type for `mut num`\n43\
    \ | }\n   | ^ unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot\
    \ be built from an iterator over elements of type `char`\n  --> /tmp/tmpnpts03uk.rs:23:52\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_string().chars().collect();\n  \
    \ |                                                    ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the\
    \ trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0599]:\
    \ no method named `to_digit` found for reference `&u8` in the current scope\n\
    \  --> /tmp/tmpnpts03uk.rs:24:49\n   |\n24 |     let mut num: Vec<u8> = num.iter().map(|x|\
    \ x.to_digit(16)).collect();\n   |                                           \
    \      ^^^^^^^^ method not found in `&u8`\n\nerror[E0599]: no method named `to_digit`\
    \ found for reference `&u8` in the current scope\n  --> /tmp/tmpnpts03uk.rs:25:49\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n\
    \   |                                                 ^^^^^^^^ method not found\
    \ in `&u8`\n\nerror[E0599]: no method named `to_digit` found for reference `&u8`\
    \ in the current scope\n  --> /tmp/tmpnpts03uk.rs:26:49\n   |\n26 |     let mut\
    \ num: Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n   |         \
    \                                        ^^^^^^^^ method not found in `&u8`\n\n\
    error[E0599]: no method named `to_digit` found for reference `&u8` in the current\
    \ scope\n  --> /tmp/tmpnpts03uk.rs:27:49\n   |\n27 |     let mut num: Vec<u8>\
    \ = num.iter().map(|x| x.to_digit(16)).collect();\n   |                      \
    \                           ^^^^^^^^ method not found in `&u8`\n\nerror[E0599]:\
    \ no method named `to_digit` found for reference `&u8` in the current scope\n\
    \  --> /tmp/tmpnpts03uk.rs:28:49\n   |\n28"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_counter:\
    \ usize = 0;\n    let mut prime_counter2: usize = 0;\n    let mut prime_counter3:\
    \ usize = 0;\n    let mut prime_counter4: usize = 0;\n    let mut prime_counter5:\
    \ usize = 0;\n    let mut prime_counter6: usize = 0;\n    let mut prime_counter7:\
    \ usize = 0;\n    let mut prime_counter8: usize = 0;\n    let mut prime_counter9:\
    \ usize = 0;\n    let mut prime_counter10: usize = 0;\n    let mut prime_counter11:\
    \ usize = 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13:\
    \ usize = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: u\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5h95n5pg.rs:62:31\n   |\n\
    62 |     let mut prime_counter38: u\n   |                               ^ help:\
    \ add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0412]: cannot find type\
    \ `u` in this scope\n  --> /tmp/tmp5h95n5pg.rs:62:30\n   |\n62 |     let mut prime_counter38:\
    \ u\n   |                              ^ help: a builtin type with a similar name\
    \ exists: `u8`\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from\
    \ an iterator over elements of type `char`\n    --> /tmp/tmp5h95n5pg.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5h95n5pg.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0412.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_counter:\
    \ usize = 0;\n    let mut prime_counter2: usize = 0;\n    let mut prime_counter3:\
    \ usize = 0;\n    let mut prime_counter4: usize = 0;\n    let mut prime_counter5:\
    \ usize = 0;\n    let mut prime_counter6: usize = 0;\n    let mut prime_counter7:\
    \ usize = 0;\n    let mut prime_counter8: usize = 0;\n    let mut prime_counter9:\
    \ usize = 0;\n    let mut prime_counter10: usize = 0;\n    let mut prime_counter11:\
    \ usize = 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13:\
    \ usize = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: u\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5h95n5pg.rs:62:31\n   |\n\
    62 |     let mut prime_counter38: u\n   |                               ^ help:\
    \ add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0412]: cannot find type\
    \ `u` in this scope\n  --> /tmp/tmp5h95n5pg.rs:62:30\n   |\n62 |     let mut prime_counter38:\
    \ u\n   |                              ^ help: a builtin type with a similar name\
    \ exists: `u8`\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from\
    \ an iterator over elements of type `char`\n    --> /tmp/tmp5h95n5pg.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5h95n5pg.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0412.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut count: usize = 0;\n    let mut prime: usize = 2;\n    let mut prime_found\
    \ = false;\n    let mut prime_found2 = false;\n    let mut prime_found3 = false;\n\
    \    let mut prime_found4 = false;\n    let mut prime_found5 = false;\n    let\
    \ mut prime_found6 = false;\n    let mut prime_found7 = false;\n    let mut prime_found8\
    \ = false;\n    let mut prime_found9 = false;\n    let mut prime_found10 = false;\n\
    \    let mut prime_found11 = false;\n    let mut prime_found12 = false;\n    let\
    \ mut prime_found13 = false;\n    let mut prime_found14 = false;\n    let mut\
    \ prime_found15 = false;\n    let mut prime_found16 = false;\n    let mut prime_found17\
    \ = false;\n    let mut prime_found18 = false;\n    let mut prime_found19 = false;\n\
    \    let mut prime_found20 = false;\n    let mut prime_found21 = false;\n    let\
    \ mut prime_found22 = false;\n    let mut prime_found23 = false;\n    let mut\
    \ prime_found24 = false;\n    let mut prime_found25 = false;\n    let mut prime_found26\
    \ = false;\n    let mut prime_found27 = false;\n    let mut prime_found28 = false;\n\
    \    let mut prime_found29 = false;\n    let mut prime_found30 = false;\n    let\
    \ mut prime_found31 = false;\n    let mut prime_found32 = false;\n    let mut\
    \ prime_found33 = false;\n    let mut prime_found34 = false;\n    let mut prime_found35\
    \ = false;\n    let mut prime_found36 = false;\n    let mut prime_found37 = false;\n\
    \    let mut prime_found38 = false;\n    let mut prime_found39 = false;\n    let\
    \ mut prime_found40 = false;\n    let mut prime_found41 = false;\n    let mut\
    \ prime_found42 = false;\n    let mut prime_found43 = false;\n    let mut prime_found44\
    \ = false;\n    let mut prime_found45 = false;\n    let mut prime_found46 = false;\n\
    \    let mut prime_found47 = false;\n    let mut prime_found48 = false;\n    let\
    \ mut prime_found49 = false;\n    let mut prime_found50 = false;\n    let mut\
    \ prime_found51 = false;\n    let mut prime_found52 = false;\n    let \n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp8y2orenz.rs:79:1\n  \
    \ |\n79 | }\n   | ^ expected pattern\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n  --> /tmp/tmp8y2orenz.rs:23:55\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748837
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: isize = 0;\n    let mut digits: Vec<&str> = num.chars().collect();\n\
    \    let mut prime_digits: Vec<&str> = vec![];\n    let mut prime_digits_len:\
    \ usize = 0;\n    let mut prime_digits_len2: usize = 0;\n    let mut prime_digits_len3:\
    \ usize = 0;\n    let mut prime_digits_len4: usize = 0;\n    let mut prime_digits_len5:\
    \ usize = 0;\n    let mut prime_digits_len6: usize = 0;\n    let mut prime_digits_len7:\
    \ usize = 0;\n    let mut prime_digits_len8: usize = 0;\n    let mut prime_digits_len9:\
    \ usize = 0;\n    let mut prime_digits_len10: usize = 0;\n    let mut prime_digits_len11:\
    \ usize = 0;\n    let mut prime_digits_len12: usize = 0;\n    let mut prime_digits_len13:\
    \ usize = 0;\n    let mut prime_digits_len14: usize = 0;\n    let mut prime_digits_len15:\
    \ usize = 0;\n    let mut prime_digits_len16: usize = 0;\n    let mut prime_digits_len17:\
    \ usize = 0;\n    let mut prime_digits_len18: usize = 0;\n    let mut prime_digits_len19:\
    \ usize = 0;\n    let mut prime_digits_len20: usize = 0;\n    let mut prime_digits_len21:\
    \ usize = 0;\n    let mut prime_digits_len22: usize = 0;\n    let mut prime_digits_len23:\
    \ usize = 0;\n    let mut prime_digits_len24: usize = 0;\n    let mut prime_digits_len25:\
    \ usize = 0;\n    let mut prime_digits_len26: usize = 0;\n    let mut prime_digits_len27:\
    \ usize = 0;\n    let mut prime_digits_len28: usize = 0;\n    let mut prime_digits_len29:\
    \ usize = 0;\n    let mut prime_digits_len30: usize = 0;\n    let mut prime_digits_len31:\
    \ usize = 0;\n    let mut prime_digits_len32: usize = 0;\n    let mut prime_digits_len33:\
    \ usize = 0;\n    let mut prime_digits_len34: u\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwu84yayr.rs:59:34\n   |\n\
    59 |     let mut prime_digits_len34: u\n   |                                 \
    \ ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0412]: cannot\
    \ find type `u` in this scope\n  --> /tmp/tmpwu84yayr.rs:59:33\n   |\n59 |   \
    \  let mut prime_digits_len34: u\n   |                                 ^ help:\
    \ a builtin type with a similar name exists: `u8`\n\nerror[E0599]: no method named\
    \ `chars` found for type `isize` in the current scope\n  --> /tmp/tmpwu84yayr.rs:24:37\n\
    \   |\n24 |     let mut digits: Vec<&str> = num.chars().collect();\n   |     \
    \                                ^^^^^ method not found in `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwu84yayr.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0412, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num_digits = num.len();\n    let mut num_primes = 0;\n    let mut num_primes_digits\
    \ = 0;\n    let mut num_primes_digits_prime = 0;\n    let mut num_primes_digits_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime = 0;\n    let mut num_primes_digits_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime = 0;\n   \
    \ let mut num_primes_digits_prime_prime_prime_prime_prime_prime = 0;\n    let\
    \ mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime = 0;\n    let\
    \ mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n\
    \    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n  --> /tmp/tmpctzffduy.rs:23:52\n   |\n23 |  \
    \   let mut num: Vec<u8> = num.to_string().chars().collect();\n   |          \
    \                                          ^^^^^^^ value of type `Vec<u8>` cannot\
    \ be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpctzffduy.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3];\n    let mut counter: usize = 0;\n \
    \   let mut prime_counter: usize = 0;\n    let mut prime_counter2: usize = 0;\n\
    \    let mut prime_counter3: usize = 0;\n    let mut prime_counter4: usize = 0;\n\
    \    let mut prime_counter5: usize = 0;\n    let mut prime_counter6: usize = 0;\n\
    \    let mut prime_counter7: usize = 0;\n    let mut prime_counter8: usize = 0;\n\
    \    let mut prime_counter9: usize = 0;\n    let mut prime_counter10: usize =\
    \ 0;\n    let mut prime_counter11: usize = 0;\n    let mut prime_counter12: usize\
    \ = 0;\n    let mut prime_counter13: usize = 0;\n    let mut prime_counter14:\
    \ usize = 0;\n    let mut prime_counter15: usize = 0;\n    let mut prime_counter16:\
    \ usize = 0;\n    let mut prime_counter17: usize = 0;\n    let mut prime_counter18:\
    \ usize = 0;\n    let mut prime_counter19: usize = 0;\n    let mut prime_counter20:\
    \ usize = 0;\n    let mut prime_counter21: usize = 0;\n    let mut prime_counter22:\
    \ usize = 0;\n    let mut prime_counter23: usize = 0;\n    let mut prime_counter24:\
    \ usize = 0;\n    let mut prime_counter25: usize = 0;\n    let mut prime_counter26:\
    \ usize = 0;\n    let mut prime_counter27: usize = 0;\n    let mut prime_counter28:\
    \ usize = 0;\n    let mut prime_counter29: usize = 0;\n    let mut prime_counter30:\
    \ usize = 0;\n    let mut prime_counter31: usize = 0;\n    let mut prime_counter32:\
    \ usize = 0;\n    let mut prime_counter33: usize = 0;\n    let mut prime_counter34:\
    \ usize = 0;\n    let mut prime_counter35: usize = 0;\n    let mut prime_counter36:\
    \ usize = 0;\n    let mut prime_counter37: usize = 0;\n    let mut prime_counter38:\
    \ usize = 0;\n    let mut prime_counter39: usize = 0;\n    let mut prime_\n}\n\
    \nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_v1cmodn.rs:65:19\n   |\n\
    65 |     let mut prime_\n   |                   ^ help: add `;` here\n66 | }\n\
    \   | - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be\
    \ built from an iterator over elements of type `char`\n  --> /tmp/tmp_v1cmodn.rs:23:55\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_v1cmodn.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8wkly9zt.rs:40:36\n   |\n\
    40 |     let mut num: Vec<u8> = num.iter\n   |                               \
    \     ^ help: add `;` here\n41 | }\n   | - unexpected token\n\nerror[E0277]: a\
    \ value of type `Vec<u8>` cannot be built from an iterator over elements of type\
    \ `char`\n  --> /tmp/tmp8wkly9zt.rs:23:55\n   |\n23 |     let mut num: Vec<u8>\
    \ = num.to_lowercase().chars().collect();\n   |                              \
    \                         ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n   |\n   = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8wkly9zt.rs:24:56\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <=\
    \ '9').collect();\n   |                                                      \
    \  ^^^ expected `&u8`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8wkly9zt.rs:24:68\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <=\
    \ '9').collect();\n   |                                                      \
    \              ^^^ expected `&u8`, found `char`\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `&u8`\n  -->\
    \ /tmp/tmp8wkly9zt.rs:24:73\n   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&x|\
    \ x >= '0' && x <= '9').collect();\n   |                                     \
    \                                    ^^^^^^^ value of type `Vec<u8>` cannot be\
    \ built from `std::iter::Iterator<Item=&u8>`\n   |\n   = help: the trait `FromIterator<&u8>`\
    \ is not implemented for `Vec<u8>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8wkly9zt.rs:25:56\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <=\
    \ 'F').collect();\n   |                                                      \
    \  ^^^ expected `&u8`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8wkly9zt.rs:25:68\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <=\
    \ 'F').collect();\n   |                     "
  stdout: ''
  timestamp: 1659748839
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpw9luf4fj.rs:39:36\n   |\n\
    39 |     let mut num: Vec<u8> = num.iter\n   |                               \
    \     ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0277]: a\
    \ value of type `Vec<u8>` cannot be built from an iterator over elements of type\
    \ `char`\n  --> /tmp/tmpw9luf4fj.rs:23:55\n   |\n23 |     let mut num: Vec<u8>\
    \ = num.to_lowercase().chars().collect();\n   |                              \
    \                         ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n   |\n   = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw9luf4fj.rs:24:56\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <=\
    \ '9').collect();\n   |                                                      \
    \  ^^^ expected `&u8`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw9luf4fj.rs:24:68\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <=\
    \ '9').collect();\n   |                                                      \
    \              ^^^ expected `&u8`, found `char`\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `&u8`\n  -->\
    \ /tmp/tmpw9luf4fj.rs:24:73\n   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&c|\
    \ c >= '0' && c <= '9').collect();\n   |                                     \
    \                                    ^^^^^^^ value of type `Vec<u8>` cannot be\
    \ built from `std::iter::Iterator<Item=&u8>`\n   |\n   = help: the trait `FromIterator<&u8>`\
    \ is not implemented for `Vec<u8>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw9luf4fj.rs:25:56\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <=\
    \ 'F').collect();\n   |                                                      \
    \  ^^^ expected `&u8`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw9luf4fj.rs:25:68\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <=\
    \ 'F').collect();\n   |                     "
  stdout: ''
  timestamp: 1659748839
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num_prime: Vec<u8> = vec![];\n    let mut num_prime_counter: Vec<u8>\
    \ = vec![];\n    let mut num_prime_counter2: Vec<u8> = vec![];\n    let mut num_prime_counter3:\
    \ Vec<u8> = vec![];\n    let mut num_prime_counter4: Vec<u8> = vec![];\n    let\
    \ mut num_prime_counter5: Vec<u8> = vec![];\n    let mut num_prime_counter6: Vec<u8>\
    \ = vec![];\n    let mut num_prime_counter7: Vec<u8> = vec![];\n    let mut num_prime_counter8:\
    \ Vec<u8> = vec![];\n    let mut num_prime_counter9: Vec<u8> = vec![];\n    let\
    \ mut num_prime_counter10: Vec<u8> = vec![];\n    let mut num_prime_counter11:\
    \ Vec<u8> = vec![];\n    let mut num_prime_counter12: Vec<u8> = vec![];\n    let\
    \ mut num_prime_counter13: Vec<u8> = vec![];\n    let mut num_prime_counter14:\
    \ Vec<u8> = vec![];\n    let mut num_prime_counter15: Vec<u8> = vec![];\n    let\
    \ mut num_prime_counter16: Vec<u8> = vec![];\n    let mut num_prime_counter17:\
    \ Vec<u8> = vec![];\n    let mut num_prime_counter18: Vec<u8> = vec![];\n    let\
    \ mut num_prime_counter19: Vec<u8> = vec![];\n    let mut num_prime_counter20:\
    \ Vec<u8> = vec![];\n    let mut num_prime_counter21: Vec<u8> = vec![];\n    let\
    \ mut num_prime_counter22: Vec<u8> = vec![];\n    let mut num_prime_counter23:\
    \ Vec<u8> = vec![];\n    let mut num_prime_counter24: Vec<u8> = vec![];\n    let\
    \ mut num_prime_counter25: Vec<u8> = vec![];\n    let mut num_prime_counter26:\
    \ Vec<u8> = vec![];\n    let mut num_prime_counter27: Vec<u8> = vec\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpv2_2ywiz.rs:51:47\n   |\n\
    51 |     let mut num_prime_counter27: Vec<u8> = vec\n   |                    \
    \                           ^ help: add `;` here\n52 | }\n   | - unexpected token\n\
    \nerror[E0423]: expected value, found macro `vec`\n  --> /tmp/tmpv2_2ywiz.rs:51:44\n\
    \   |\n51 |     let mut num_prime_counter27: Vec<u8> = vec\n   |             \
    \                               ^^^ not a value\n   |\nhelp: use `!` to invoke\
    \ the macro\n   |\n51 |     let mut num_prime_counter27: Vec<u8> = vec!\n   |\
    \                                               +\n\nerror[E0277]: a value of\
    \ type `Vec<u8>` cannot be built from an iterator over elements of type `char`\n\
    \  --> /tmp/tmpv2_2ywiz.rs:23:52\n   |\n23 |     let mut num: Vec<u8> = num.to_string().chars().collect();\n\
    \   |                                                    ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpv2_2ywiz.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0423.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut nums = num.chars().collect::<Vec<_>>();\n    let mut primes\
    \ = vec![false; 26];\n    let mut primes_count = vec![0; 26];\n    let mut primes_count_index\
    \ = vec![0; 26];\n    let mut primes_count_index2 = vec![0; 26];\n    let mut\
    \ primes_count_index3 = vec![0; 26];\n    let mut primes_count_index4 = vec![0;\
    \ 26];\n    let mut primes_count_index5 = vec![0; 26];\n    let mut primes_count_index6\
    \ = vec![0; 26];\n    let mut primes_count_index7 = vec![0; 26];\n    let mut\
    \ primes_count_index8 = vec![0; 26];\n    let mut primes_count_index9 = vec![0;\
    \ 26];\n    let mut primes_count_index10 = vec![0; 26];\n    let mut primes_count_index11\
    \ = vec![0; 26];\n    let mut primes_count_index12 = vec![0; 26];\n    let mut\
    \ primes_count_index13 = vec![0; 26];\n    let mut primes_count_index14 = vec![0;\
    \ 26];\n    let mut primes_count_index15 = vec![0; 26];\n    let mut primes_count_index16\
    \ = vec![0; 26];\n    let mut primes_count_index17 = vec![0; 26];\n    let mut\
    \ primes_count_index18 = vec![0; 26];\n    let mut primes_count_index19 = vec![0;\
    \ 26];\n    let mut primes_count_index20 = vec![0; 26];\n    let mut primes_count_index21\
    \ = vec![0; 26];\n    let mut primes_count_index22 = vec![0; 26];\n    let mut\
    \ primes_count_index23 = vec![0; 26];\n    let mut primes_count_index24 = vec![0;\
    \ 26];\n    let mut primes_count_index25 = vec![0; 26];\n    let mut primes_count_index26\
    \ = vec![0; 26];\n    let mut primes_count_index27 = vec![0; 26];\n    let mut\
    \ primes_count_index28 = vec![0; 26];\n    let mut primes_count_index29 = vec![0;\
    \ 26];\n    let mut primes_count_index30 = vec![0; 26];\n    let mut primes_count_index31\
    \ = vec![0; 26];\n    let mut primes_count_index32 = vec![0; 26];\n    let mut\
    \ prime\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_x4rolzp.rs:58:18\n   |\n\
    58 |     let mut prime\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_x4rolzp.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num_digits = num.len();\n    let mut prime_digits = vec![];\n    let\
    \ mut prime_digits_counter = 0;\n    let mut prime_digits_counter_max = num.len()\
    \ / 2;\n    let mut prime_digits_counter_min = num.len() / 2;\n    let mut prime_digits_counter_max_index\
    \ = 0;\n    let mut prime_digits_counter_min_index = 0;\n    let mut prime_digits_counter_max:\
    \ usize = 0;\n    let mut prime_digits_counter_min: usize = 0;\n    let mut prime_digits_counter_max_index\
    \ = 0;\n    let mut prime_digits_counter_min_index = 0;\n    let mut prime_digits_counter_max:\
    \ usize = 0;\n    let mut prime_digits_counter_min: usize = 0;\n    let mut prime_digits_counter_max_index\
    \ = 0;\n    let mut prime_digits_counter_min_index = 0;\n    let mut prime_digits_counter_max:\
    \ usize = 0;\n    let mut prime_digits_counter_min: usize = 0;\n    let mut prime_digits_counter_max_index\
    \ = 0;\n    let mut prime_digits_counter_min_index = 0;\n    let mut prime_digits_counter_max:\
    \ usize = 0;\n    let mut prime_digits_counter_min: usize = 0;\n    let mut prime_digits_counter_max_index\
    \ = 0;\n    let mut prime_digits_counter_min_index = 0;\n    let mut prime_digits_counter_max:\
    \ usize = 0;\n    let mut prime_digits_counter_min: usize = 0;\n    let mut prime_digits_counter_max_index\
    \ = 0;\n    let mut prime_digits_counter_min_index = 0;\n    let mut prime_digits_counter_max:\
    \ usize = 0;\n    let mut prime_digits_counter_min: usize = 0;\n    let mut prime_digits_counter_max_index\
    \ = 0;\n    let mut prime_digits_counter_min_index = 0;\n    let mut prime_digits_counter_max:\
    \ usize = 0;\n    let mut prime_digits_counter_min: usize = 0;\n    let mut prime_digits_counter_max_index\
    \ = 0;\n    let mut prime_digits_counter_min_index = 0;\n    let mut prime_digits_counter_max:\
    \ usize = 0;\n    let mut prime_digits_counter_min: usize = 0;\n    let mut prime_digits_counter_max_index\
    \ = 0;\n    let mut \n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp7gtj5p1g.rs:63:1\n\
    \   |\n63 | }\n   | ^ expected identifier\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n  --> /tmp/tmp7gtj5p1g.rs:23:52\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_string().chars().collect();\n  \
    \ |                                                    ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the\
    \ trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpnsj7n80f.rs:39:36\n   |\n\
    39 |     let mut num: Vec<u8> = num.iter\n   |                               \
    \     ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0277]: a\
    \ value of type `Vec<u8>` cannot be built from an iterator over elements of type\
    \ `char`\n  --> /tmp/tmpnsj7n80f.rs:23:55\n   |\n23 |     let mut num: Vec<u8>\
    \ = num.to_lowercase().chars().collect();\n   |                              \
    \                         ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n   |\n   = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnsj7n80f.rs:24:56\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <=\
    \ '9').collect();\n   |                                                      \
    \  ^^^ expected `&u8`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnsj7n80f.rs:24:68\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <=\
    \ '9').collect();\n   |                                                      \
    \              ^^^ expected `&u8`, found `char`\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `&u8`\n  -->\
    \ /tmp/tmpnsj7n80f.rs:24:73\n   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&c|\
    \ c >= '0' && c <= '9').collect();\n   |                                     \
    \                                    ^^^^^^^ value of type `Vec<u8>` cannot be\
    \ built from `std::iter::Iterator<Item=&u8>`\n   |\n   = help: the trait `FromIterator<&u8>`\
    \ is not implemented for `Vec<u8>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnsj7n80f.rs:25:56\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <=\
    \ 'F').collect();\n   |                                                      \
    \  ^^^ expected `&u8`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnsj7n80f.rs:25:68\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <=\
    \ 'F').collect();\n   |                     "
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_2:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\
    \ 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_3: Vec<u8> = vec![2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97];\n    let mut num_prime_4: Vec<u8> = vec![2, 3, 5, 7, 11, 13,\
    \ 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n\
    \    let mut num_prime_5: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_6:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\
    \ 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_7: Vec<u8> = vec![2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97];\n    let mut num_prime_8: Vec<u8> = vec![2, 3, 5, 7, 11, 13,\
    \ 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n\
    \    let mut num_prime_9: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_10:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\
    \ 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_11: Vec<u8> = vec![2,\
    \ 3, 5, 7, 11, \n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpmag_tm9a.rs:34:41\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |                         \
    \         - closing delimiter possibly meant for this\n...\n34 |     let mut num_prime_11:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, \n   |                                      \
    \   ^ unclosed delimiter\n35 | }\n   | ^ mismatched closing delimiter\n\nerror:\
    \ expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n  --> /tmp/tmpmag_tm9a.rs:35:1\n\
    \   |\n35 | }\n   | ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\n\
    error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator over\
    \ elements of type `char`\n  --> /tmp/tmpmag_tm9a.rs:23:55\n   |\n23 |     let\
    \ mut num: Vec<u8> = num.to_lowercase().chars().collect();\n   |             \
    \                                          ^^^^^^^ value of type `Vec<u8>` cannot\
    \ be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748837
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_2:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\
    \ 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_3: Vec<u8> = vec![2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97];\n    let mut num_prime_4: Vec<u8> = vec![2, 3, 5, 7, 11, 13,\
    \ 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n\
    \    let mut num_prime_5: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_6:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\
    \ 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_7: Vec<u8> = vec![2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97];\n    let mut num_prime_8: Vec<u8> = vec![2, 3, 5, 7, 11, 13,\
    \ 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n\
    \    let mut num_prime_9: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_10:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\
    \ 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_11: Vec<u8> = vec![2,\
    \ 3, 5, 7, 11, \n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpmag_tm9a.rs:34:41\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |                         \
    \         - closing delimiter possibly meant for this\n...\n34 |     let mut num_prime_11:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, \n   |                                      \
    \   ^ unclosed delimiter\n35 | }\n   | ^ mismatched closing delimiter\n\nerror:\
    \ expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n  --> /tmp/tmpmag_tm9a.rs:35:1\n\
    \   |\n35 | }\n   | ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\n\
    error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator over\
    \ elements of type `char`\n  --> /tmp/tmpmag_tm9a.rs:23:55\n   |\n23 |     let\
    \ mut num: Vec<u8> = num.to_lowercase().chars().collect();\n   |             \
    \                                          ^^^^^^^ value of type `Vec<u8>` cannot\
    \ be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748837
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut nums = num.chars().collect::<Vec<_>>();\n    let mut num_primes\
    \ = 0;\n    let mut num_hex = 0;\n    let mut num_hex_digits = 0;\n    let mut\
    \ num_hex_digits_prime = 0;\n    let mut num_hex_digits_prime_hex = 0;\n    let\
    \ mut num_hex_digits_prime_hex_hex = 0;\n    let mut num_hex_digits_prime_hex_hex_hex\
    \ = 0;\n    let mut num_hex_digits_prime_hex_hex_hex_hex = 0;\n    let mut num_hex_digits_prime_hex_hex_hex_hex_hex\
    \ = 0;\n    let mut num_hex_digits_prime_hex_hex_hex_hex_hex_hex = 0;\n    let\
    \ mut num_hex_digits_prime_hex_hex_hex_hex_hex_hex_hex = 0;\n    let mut num_hex_digits_prime_hex_hex_hex_hex_hex_hex_hex_hex\
    \ = 0;\n    let mut num_hex_digits_prime_hex_hex_hex_hex_hex_hex_hex_hex_hex =\
    \ 0;\n    let mut num_hex_digits_prime_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex\
    \ = 0;\n    let mut num_hex_digits_prime_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex\
    \ = 0;\n    let mut num_hex_digits_prime_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex\
    \ = 0;\n    let mut num_hex_digits_prime_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex\
    \ = 0;\n    let mut num_hex_digits_prime_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex\
    \ = 0;\n    let mut num_hex_digits_prime_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex\
    \ = 0;\n    let mut num_hex_digits_prime_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex\
    \ = 0;\n    let mut num_hex_digits_prime_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex\
    \ = 0;\n    let mut num_hex_digits_prime_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex\
    \ = 0;\n    let mut num_hex_digits_prime_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex\
    \ = 0;\n    let mut num_hex_digits_prime_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex\
    \ = 0;\n    let mut num_hex_digits_prime_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex_hex\
    \ = 0;\n    let mut num_\n}\n\nfn main() {\n    let candidate = hex_key;\n   \
    \ assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmppnvy7bi3.rs:49:17\n   |\n\
    49 |     let mut num_\n   |                 ^ help: add `;` here\n50 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppnvy7bi3.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut nums = num.chars().collect::<Vec<_>>();\n    let mut nums_len\
    \ = nums.len();\n    let mut prime_digits = vec![2, 3];\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_counter = vec![2, 3];\n    let\
    \ mut prime_digits_counter_len = prime_digits_counter.len();\n    let mut prime_digits_counter2\
    \ = vec![2, 3];\n    let mut prime_digits_counter2_len = prime_digits_counter2.len();\n\
    \    let mut prime_digits_counter3 = vec![2, 3];\n    let mut prime_digits_counter3_len\
    \ = prime_digits_counter3.len();\n    let mut prime_digits_counter4 = vec![2,\
    \ 3];\n    let mut prime_digits_counter4_len = prime_digits_counter4.len();\n\
    \    let mut prime_digits_counter5 = vec![2, 3];\n    let mut prime_digits_counter5_len\
    \ = prime_digits_counter5.len();\n    let mut prime_digits_counter6 = vec![2,\
    \ 3];\n    let mut prime_digits_counter6_len = prime_digits_counter6.len();\n\
    \    let mut prime_digits_counter7 = vec![2, 3];\n    let mut prime_digits_counter7_len\
    \ = prime_digits_counter7.len();\n    let mut prime_digits_counter8 = vec![2,\
    \ 3];\n    let mut prime_digits_counter8_len = prime_digits_counter8.len();\n\
    \    let mut prime_digits_counter9 = vec![2, 3];\n    let mut prime_digits_counter9_len\
    \ = prime_digits_counter9.len();\n    let mut prime_digits_counter10 = vec![2,\
    \ 3];\n    let mut prime_digits_counter10_len = prime_digits_counter10.len();\n\
    \    let mut prime_digits_counter11 = vec![2, 3];\n    let mut prime_digits_counter11_len\
    \ = prime_digits_counter11.len();\n    let mut prime_digits_counter12 = vec![2,\
    \ 3];\n    let mut prime_digits_counter12_len = prime_digits_counter12.len();\n\
    \    let mut prime_digits_counter13 = vec![2, 3];\n    let mut prime_digits_counter13_len\
    \ = prime_digits_counter13.len();\n    let mut prime_digits_counter14 = vec![2,\
    \ 3];\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5x0klo3v.rs:22:28\n   |\n\
    22 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut count = 1;\n    let mut prime: isize = 2;\n    let mut prime_found =\
    \ false;\n    let mut prime_found2 = false;\n    let mut prime_found3 = false;\n\
    \    let mut prime_found4 = false;\n    let mut prime_found5 = false;\n    let\
    \ mut prime_found6 = false;\n    let mut prime_found7 = false;\n    let mut prime_found8\
    \ = false;\n    let mut prime_found9 = false;\n    let mut prime_found10 = false;\n\
    \    let mut prime_found11 = false;\n    let mut prime_found12 = false;\n    let\
    \ mut prime_found13 = false;\n    let mut prime_found14 = false;\n    let mut\
    \ prime_found15 = false;\n    let mut prime_found16 = false;\n    let mut prime_found17\
    \ = false;\n    let mut prime_found18 = false;\n    let mut prime_found19 = false;\n\
    \    let mut prime_found20 = false;\n    let mut prime_found21 = false;\n    let\
    \ mut prime_found22 = false;\n    let mut prime_found23 = false;\n    let mut\
    \ prime_found24 = false;\n    let mut prime_found25 = false;\n    let mut prime_found26\
    \ = false;\n    let mut prime_found27 = false;\n    let mut prime_found28 = false;\n\
    \    let mut prime_found29 = false;\n    let mut prime_found30 = false;\n    let\
    \ mut prime_found31 = false;\n    let mut prime_found32 = false;\n    let mut\
    \ prime_found33 = false;\n    let mut prime_found34 = false;\n    let mut prime_found35\
    \ = false;\n    let mut prime_found36 = false;\n    let mut prime_found37 = false;\n\
    \    let mut prime_found38 = false;\n    let mut prime_found39 = false;\n    let\
    \ mut prime_found40 = false;\n    let mut prime_found41 = false;\n    let mut\
    \ prime_found42 = false;\n    let mut prime_found43 = false;\n    let mut prime_found44\
    \ = false;\n    let mut prime_found45 = false;\n    let mut prime_found46 = false;\n\
    \    let mut prime_found47 = false;\n    let mut prime_found48 = false;\n    let\
    \ mut prime_found49 = false;\n    let mut prime_found50 = false;\n    let mut\
    \ prime_found51 = false;\n    let mut prime_found52 = false;\n    let mut \n}\n\
    \nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp3jpbeptq.rs:79:1\n\
    \   |\n79 | }\n   | ^ expected identifier\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n  --> /tmp/tmp3jpbeptq.rs:23:52\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_string().chars().collect();\n  \
    \ |                                                    ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the\
    \ trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748837
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpgxfk7iy6.rs:40:36\n   |\n\
    40 |     let mut num: Vec<u8> = num.iter\n   |                               \
    \     ^ help: add `;` here\n41 | }\n   | - unexpected token\n\nerror[E0277]: a\
    \ value of type `Vec<u8>` cannot be built from an iterator over elements of type\
    \ `char`\n  --> /tmp/tmpgxfk7iy6.rs:23:55\n   |\n23 |     let mut num: Vec<u8>\
    \ = num.to_lowercase().chars().collect();\n   |                              \
    \                         ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n   |\n   = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgxfk7iy6.rs:24:56\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <=\
    \ '9').collect();\n   |                                                      \
    \  ^^^ expected `&u8`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgxfk7iy6.rs:24:68\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <=\
    \ '9').collect();\n   |                                                      \
    \              ^^^ expected `&u8`, found `char`\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `&u8`\n  -->\
    \ /tmp/tmpgxfk7iy6.rs:24:73\n   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&x|\
    \ x >= '0' && x <= '9').collect();\n   |                                     \
    \                                    ^^^^^^^ value of type `Vec<u8>` cannot be\
    \ built from `std::iter::Iterator<Item=&u8>`\n   |\n   = help: the trait `FromIterator<&u8>`\
    \ is not implemented for `Vec<u8>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgxfk7iy6.rs:25:56\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <=\
    \ 'F').collect();\n   |                                                      \
    \  ^^^ expected `&u8`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgxfk7iy6.rs:25:68\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <=\
    \ 'F').collect();\n   |                     "
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut count: usize = 0;\n    let mut prime: usize = 2;\n    let mut prime_found\
    \ = false;\n    let mut prime_found2 = false;\n    let mut prime_found3 = false;\n\
    \    let mut prime_found4 = false;\n    let mut prime_found5 = false;\n    let\
    \ mut prime_found6 = false;\n    let mut prime_found7 = false;\n    let mut prime_found8\
    \ = false;\n    let mut prime_found9 = false;\n    let mut prime_found10 = false;\n\
    \    let mut prime_found11 = false;\n    let mut prime_found12 = false;\n    let\
    \ mut prime_found13 = false;\n    let mut prime_found14 = false;\n    let mut\
    \ prime_found15 = false;\n    let mut prime_found16 = false;\n    let mut prime_found17\
    \ = false;\n    let mut prime_found18 = false;\n    let mut prime_found19 = false;\n\
    \    let mut prime_found20 = false;\n    let mut prime_found21 = false;\n    let\
    \ mut prime_found22 = false;\n    let mut prime_found23 = false;\n    let mut\
    \ prime_found24 = false;\n    let mut prime_found25 = false;\n    let mut prime_found26\
    \ = false;\n    let mut prime_found27 = false;\n    let mut prime_found28 = false;\n\
    \    let mut prime_found29 = false;\n    let mut prime_found30 = false;\n    let\
    \ mut prime_found31 = false;\n    let mut prime_found32 = false;\n    let mut\
    \ prime_found33 = false;\n    let mut prime_found34 = false;\n    let mut prime_found35\
    \ = false;\n    let mut prime_found36 = false;\n    let mut prime_found37 = false;\n\
    \    let mut prime_found38 = false;\n    let mut prime_found39 = false;\n    let\
    \ mut prime_found40 = false;\n    let mut prime_found41 = false;\n    let mut\
    \ prime_found42 = false;\n    let mut prime_found43 = false;\n    let mut prime_found44\
    \ = false;\n    let mut prime_found45 = false;\n    let mut prime_found46 = false;\n\
    \    let mut prime_found47 = false;\n    let mut prime_found48 = false;\n    let\
    \ mut prime_found49 = false;\n    let mut prime_found50 = false;\n    let mut\
    \ prime_found51 = false;\n    let mut prime_found52 = false;\n    let \n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp8y2orenz.rs:79:1\n  \
    \ |\n79 | }\n   | ^ expected pattern\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n  --> /tmp/tmp8y2orenz.rs:23:55\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748837
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num: Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n    let\
    \ mut num: Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n    let mut\
    \ num: Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n    let mut num:\
    \ Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n    let mut num: Vec<u8>\
    \ = num.iter().map(|x| x.to_digit(16)).collect();\n    let mut num: Vec<u8> =\
    \ num.iter().map(|x| x.to_digit(16)).collect();\n    let mut num: Vec<u8> = num.iter().map(|x|\
    \ x.to_digit(16)).collect();\n    let mut num: Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n  \
    \  let mut num: Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n    let\
    \ mut num: Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n    let mut\
    \ num: Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n    let mut num:\
    \ Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n    let mut num: Vec<u8>\
    \ = num.iter().map(|x| x.to_digit(16)).collect();\n    let mut num: Vec<u8> =\
    \ num.iter().map(|x| x.to_digit(16)).collect();\n    let mut num: Vec<u8> = num.iter().map(|x|\
    \ x.to_digit(16)).collect();\n    let mut num: Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n  \
    \  let mut num: Vec<\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `>`, a const expression, lifetime, or type, found\
    \ `}`\n  --> /tmp/tmpnpts03uk.rs:43:1\n   |\n42 |     let mut num: Vec<\n   |\
    \         -------      - expected one of `>`, a const expression, lifetime, or\
    \ type\n   |         |\n   |         while parsing the type for `mut num`\n43\
    \ | }\n   | ^ unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot\
    \ be built from an iterator over elements of type `char`\n  --> /tmp/tmpnpts03uk.rs:23:52\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_string().chars().collect();\n  \
    \ |                                                    ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the\
    \ trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0599]:\
    \ no method named `to_digit` found for reference `&u8` in the current scope\n\
    \  --> /tmp/tmpnpts03uk.rs:24:49\n   |\n24 |     let mut num: Vec<u8> = num.iter().map(|x|\
    \ x.to_digit(16)).collect();\n   |                                           \
    \      ^^^^^^^^ method not found in `&u8`\n\nerror[E0599]: no method named `to_digit`\
    \ found for reference `&u8` in the current scope\n  --> /tmp/tmpnpts03uk.rs:25:49\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n\
    \   |                                                 ^^^^^^^^ method not found\
    \ in `&u8`\n\nerror[E0599]: no method named `to_digit` found for reference `&u8`\
    \ in the current scope\n  --> /tmp/tmpnpts03uk.rs:26:49\n   |\n26 |     let mut\
    \ num: Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n   |         \
    \                                        ^^^^^^^^ method not found in `&u8`\n\n\
    error[E0599]: no method named `to_digit` found for reference `&u8` in the current\
    \ scope\n  --> /tmp/tmpnpts03uk.rs:27:49\n   |\n27 |     let mut num: Vec<u8>\
    \ = num.iter().map(|x| x.to_digit(16)).collect();\n   |                      \
    \                           ^^^^^^^^ method not found in `&u8`\n\nerror[E0599]:\
    \ no method named `to_digit` found for reference `&u8` in the current scope\n\
    \  --> /tmp/tmpnpts03uk.rs:28:49\n   |\n28"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8wkly9zt.rs:40:36\n   |\n\
    40 |     let mut num: Vec<u8> = num.iter\n   |                               \
    \     ^ help: add `;` here\n41 | }\n   | - unexpected token\n\nerror[E0277]: a\
    \ value of type `Vec<u8>` cannot be built from an iterator over elements of type\
    \ `char`\n  --> /tmp/tmp8wkly9zt.rs:23:55\n   |\n23 |     let mut num: Vec<u8>\
    \ = num.to_lowercase().chars().collect();\n   |                              \
    \                         ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n   |\n   = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8wkly9zt.rs:24:56\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <=\
    \ '9').collect();\n   |                                                      \
    \  ^^^ expected `&u8`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8wkly9zt.rs:24:68\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <=\
    \ '9').collect();\n   |                                                      \
    \              ^^^ expected `&u8`, found `char`\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `&u8`\n  -->\
    \ /tmp/tmp8wkly9zt.rs:24:73\n   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&x|\
    \ x >= '0' && x <= '9').collect();\n   |                                     \
    \                                    ^^^^^^^ value of type `Vec<u8>` cannot be\
    \ built from `std::iter::Iterator<Item=&u8>`\n   |\n   = help: the trait `FromIterator<&u8>`\
    \ is not implemented for `Vec<u8>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8wkly9zt.rs:25:56\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <=\
    \ 'F').collect();\n   |                                                      \
    \  ^^^ expected `&u8`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8wkly9zt.rs:25:68\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <=\
    \ 'F').collect();\n   |                     "
  stdout: ''
  timestamp: 1659748839
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\
    \ 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_counter:\
    \ usize = 0;\n    let mut prime_counter2: usize = 0;\n    let mut prime_counter3:\
    \ usize = 0;\n    let mut prime_counter4: usize = 0;\n    let mut prime_counter5:\
    \ usize = 0;\n    let mut prime_counter6: usize = 0;\n    let mut prime_counter7:\
    \ usize = 0;\n    let mut prime_counter8: usize = 0;\n    let mut prime_counter9:\
    \ usize = 0;\n    let mut prime_counter10: usize = 0;\n    let mut prime_counter11:\
    \ usize = 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13:\
    \ usize = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: u\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpqyco8i0_.rs:62:31\n   |\n\
    62 |     let mut prime_counter38: u\n   |                               ^ help:\
    \ add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0412]: cannot find type\
    \ `u` in this scope\n  --> /tmp/tmpqyco8i0_.rs:62:30\n   |\n62 |     let mut prime_counter38:\
    \ u\n   |                              ^ help: a builtin type with a similar name\
    \ exists: `u8`\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from\
    \ an iterator over elements of type `char`\n  --> /tmp/tmpqyco8i0_.rs:23:52\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_string().chars().collect();\n  \
    \ |                                                    ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the\
    \ trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqyco8i0_.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0412.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut count = 1;\n    let mut prime_count = 0;\n    let mut prime_number:\
    \ Vec<u8> = vec![];\n    let mut prime_number_count: usize = 0;\n    let mut prime_number_digit:\
    \ usize = 0;\n    let mut prime_number_digits: Vec<u8> = vec![];\n    let mut\
    \ prime_number_digits_count: usize = 0;\n    let mut prime_number_digits_digit:\
    \ usize = 0;\n    let mut prime_number_digits_digits: Vec<u8> = vec![];\n    let\
    \ mut prime_number_digits_digits_count: usize = 0;\n    let mut prime_number_digits_digits_digit:\
    \ usize = 0;\n    let mut prime_number_digits_digits_digits: Vec<u8> = vec![];\n\
    \    let mut prime_number_digits_digits_digits_count: usize = 0;\n    let mut\
    \ prime_number_digits_digits_digits_digit: usize = 0;\n    let mut prime_number_digits_digits_digits_digits:\
    \ Vec<u8> = vec![];\n    let mut prime_number_digits_digits_digits_digits_count:\
    \ usize = 0;\n    let mut prime_number_digits_digits_digits_digits_digit: usize\
    \ = 0;\n    let mut prime_number_digits_digits_digits_digits: Vec<u8> = vec![];\n\
    \    let mut prime_number_digits_digits_digits_digits_count: usize = 0;\n    let\
    \ mut prime_number_digits_digits_digits_digits_digit: usize = 0;\n    let mut\
    \ prime_number_digits_digits_digits_digits_digits: Vec<u8> = vec![];\n    let\
    \ mut prime_number_digits_digits_digits_digits_digits_count: usize = 0;\n    let\
    \ mut prime_number_digits_digits_digits_digits_digits_digit: usize = 0;\n    let\
    \ mut prime_number_digits_digits_digits_digits_digits: Vec<u8> = vec![];\n   \
    \ let mut prime_number_digits_digits_digits_digits_digits_count: usize = 0;\n\
    \    let mut prime_number_digits_digits_digits_digits_digits_digit: usize = 0;\n\
    \    let mut prime_number_digits_digits_digits_digits_digits_digits: Vec<u8> =\
    \ vec![];\n    let mut prime\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5earsjam.rs:51:18\n   |\n\
    51 |     let mut prime\n   |                  ^ help: add `;` here\n52 | }\n \
    \  | - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built\
    \ from an iterator over elements of type `char`\n  --> /tmp/tmp5earsjam.rs:23:55\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5earsjam.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|x| x as u8).collect();\n    let mut\
    \ num: Vec<u8> = num.iter().filter(|x| x % 2 == 0).collect();\n    let mut num:\
    \ Vec<u8> = num.iter().filter(|x| x % 3 == 0).collect();\n    let mut num: Vec<u8>\
    \ = num.iter().filter(|x| x % 5 == 0).collect();\n    let mut num: Vec<u8> = num.iter().filter(|x|\
    \ x % 7 == 0).collect();\n    let mut num: Vec<u8> = num.iter().filter(|x| x %\
    \ 11 == 0).collect();\n    let mut num: Vec<u8> = num.iter().filter(|x| x % 13\
    \ == 0).collect();\n    let mut num: Vec<u8> = num.iter().filter(|x| x % 17 ==\
    \ 0).collect();\n    let mut num: Vec<u8> = num.iter().filter(|x| x % 19 == 0).collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|x| x % 23 == 0).collect();\n  \
    \  let mut num: Vec<u8> = num.iter().filter(|x| x % 29 == 0).collect();\n    let\
    \ mut num: Vec<u8> = num.iter().filter(|x| x % 31 == 0).collect();\n    let mut\
    \ num: Vec<u8> = num.iter().filter(|x| x % 37 == 0).collect();\n    let mut num:\
    \ Vec<u8> = num.iter().filter(|x| x % 41 == 0).collect();\n    let mut num: Vec<u8>\
    \ = num.iter().filter(|x| x % 43 == 0).collect();\n    let mut num: Vec<u8> =\
    \ num.iter().filter(|x| x % 47 == 0).collect();\n    let mut num: Vec<u8> = num.iter().filter(|x|\
    \ x % 53 == 0).collect();\n    let mut num: Vec<u8> = num.iter().filter(|x| x\
    \ % 59 == 0).collect();\n    let mut num: Vec<u8> = num.iter().filter(|x| x %\
    \ 61 == 0).collect();\n    let mut \n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp69p6ypb8.rs:44:1\n\
    \   |\n44 | }\n   | ^ expected identifier\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n  --> /tmp/tmp69p6ypb8.rs:23:55\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0369]:\
    \ cannot mod `&&u8` by `{integer}`\n  --> /tmp/tmp69p6ypb8.rs:25:52\n   |\n25\
    \ |     let mut num: Vec<u8> = num.iter().filter(|x| x % 2 == 0).collect();\n\
    \   |                                                  - ^ - {integer}\n   | \
    \                                                 |\n   |                    \
    \                              &&u8\n   |\nhelp: `%` can be used on `u8`, you\
    \ can dereference `x`\n   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|x|\
    \ *x % 2 == 0).collect();\n   |                                              \
    \    +\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `&u8`\n  --> /tmp/tmp69p6ypb8.rs:25:62\n   |\n25 |   \
    \  let mut num: Vec<u8> = num.iter().filter(|x| x % 2 == 0).collect();\n   | \
    \                                                             ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=&u8>`\n   |\n\
    \   = help: the trait `FromIterator<&u8>` is not implemented for `Vec<u8>`\n\n\
    error[E0369]: cannot mod `&&u8` by `{integer}`\n  --> /tmp/tmp69p6ypb8.rs:26:52\n\
    \   |\n26 |     let mut num: Vec<u8> = num.iter().filter(|x| x % 3 == 0).collect();\n\
    \   |                                                  - ^ - {integer}\n   | \
    \                                                 |\n   |                    \
    \                              &&u8\n   |\nhelp: `%` can be used on `u8`, you\
    \ can dereference `x`\n   |\n26 |     let mut num: Vec<u8> = num.iter().filter(|x|\
    \ *x % 3 == 0).collect();\n   |                   "
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.in\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found keyword `in`\n  --> /tmp/tmpsxpv55i4.rs:39:32\n\
    \   |\n39 |     let mut num: Vec<u8> = num.in\n   |                          \
    \      ^^ expected identifier, found keyword\n   |\nhelp: escape `in` to use it\
    \ as an identifier\n   |\n39 |     let mut num: Vec<u8> = num.r#in\n   |     \
    \                           ++\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpsxpv55i4.rs:39:34\n\
    \   |\n39 |     let mut num: Vec<u8> = num.in\n   |                          \
    \        ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0277]:\
    \ a value of type `Vec<u8>` cannot be built from an iterator over elements of\
    \ type `char`\n    --> /tmp/tmpsxpv55i4.rs:23:52\n     |\n23   |     let mut num:\
    \ Vec<u8> = num.to_string().chars().collect();\n     |                       \
    \                             ^^^^^^^ value of type `Vec<u8>` cannot be built\
    \ from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsxpv55i4.rs:24:61\n   |\n24 |     let mut num:\
    \ Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n   |\
    \                                                             ^^^ expected `u8`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsxpv55i4.rs:24:73\n\
    \   |\n24 |     let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' &&\
    \ x <= '9').collect();\n   |                                                 \
    \                        ^^^ expected `u8`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpsxpv55i4.rs:25:61\n   |\n25 |     let mut num: Vec<u8>\
    \ = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n   |       \
    \                                                      ^^^ expected `u8`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsxpv55i4.rs:25:73\n\
    \   |\n25 |     let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' &&\
    \ x <= 'F').collect();\n   |              "
  stdout: ''
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmp5wzakgvl.rs:38:50\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |                         \
    \         - closing delimiter possibly meant for this\n...\n38 |     let mut num:\
    \ Vec<u8> = num.into_iter().filter(\n   |                                    \
    \              ^ unclosed delimiter\n39 | }\n   | ^ mismatched closing delimiter\n\
    \nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n  -->\
    \ /tmp/tmp5wzakgvl.rs:39:1\n   |\n39 | }\n   | ^ expected one of `.`, `;`, `?`,\
    \ `else`, or an operator\n\nerror[E0277]: a value of type `Vec<u8>` cannot be\
    \ built from an iterator over elements of type `char`\n  --> /tmp/tmp5wzakgvl.rs:23:52\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_string().chars().collect();\n  \
    \ |                                                    ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the\
    \ trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5wzakgvl.rs:24:61\n   |\n24 |     let mut num:\
    \ Vec<u8> = num.into_iter().filter(|&c| c >= '0' && c <= '9').collect();\n   |\
    \                                                             ^^^ expected `u8`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5wzakgvl.rs:24:73\n\
    \   |\n24 |     let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= '0' &&\
    \ c <= '9').collect();\n   |                                                 \
    \                        ^^^ expected `u8`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5wzakgvl.rs:25:61\n   |\n25 |     let mut num: Vec<u8>\
    \ = num.into_iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n   |       \
    \                                                      ^^^ expected `u8`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5wzakgvl.rs:25:73\n\
    \   |\n25 |     let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= 'A' &&\
    \ c <= 'F').collect();\n   |                                                 \
    \                        ^^^ expected `u8`, found `char`\n\nerr"
  stdout: ''
  timestamp: 1659748839
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut count: usize\
    \ = 0;\n    let mut i: usize = 0;\n    while i < num.len() {\n        if num[i]\
    \ == num[num.len() - 1] {\n            i += 1;\n        } else {\n           \
    \ prime = prime.iter().filter(|&x| num[i] == x).collect();\n            i += 1;\n\
    \        }\n    }\n    for i in prime {\n        if num.len() - 1 < i {\n    \
    \        count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n  --> /tmp/tmpcorx5hd5.rs:23:55\n   |\n23 |  \
    \   let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n   |       \
    \                                                ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the\
    \ trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcorx5hd5.rs:31:56\n   |\n31 |             prime\
    \ = prime.iter().filter(|&x| num[i] == x).collect();\n   |                   \
    \                                     ^ expected `u8`, found `&u8`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n31 |             prime = prime.iter().filter(|&x|\
    \ num[i] == *x).collect();\n   |                                             \
    \           +\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from\
    \ an iterator over elements of type `&u8`\n  --> /tmp/tmpcorx5hd5.rs:31:59\n \
    \  |\n31 |             prime = prime.iter().filter(|&x| num[i] == x).collect();\n\
    \   |                                                           ^^^^^^^ value\
    \ of type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=&u8>`\n   |\n\
    \   = help: the trait `FromIterator<&u8>` is not implemented for `Vec<u8>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpcorx5hd5.rs:36:28\n   |\n36 |  \
    \       if num.len() - 1 < i {\n   |                            ^\n   |      \
    \                      |\n   |                            expected `usize`, found\
    \ `u8`\n   |                            help: you can convert a `u8` to a `usize`:\
    \ `i.into()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcorx5hd5.rs:40:5\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |                         \
    \   ----- expected `isize` because of return type\n...\n40 |     count\n   | \
    \    ^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n40 |     count.try_into().unwrap()\n\
    \   |\n\nerror: aborting due to 5 previous errors\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_counter:\
    \ usize = 0;\n    let mut prime_counter2: usize = 0;\n    let mut prime_counter3:\
    \ usize = 0;\n    let mut prime_counter4: usize = 0;\n    let mut prime_counter5:\
    \ usize = 0;\n    let mut prime_counter6: usize = 0;\n    let mut prime_counter7:\
    \ usize = 0;\n    let mut prime_counter8: usize = 0;\n    let mut prime_counter9:\
    \ usize = 0;\n    let mut prime_counter10: usize = 0;\n    let mut prime_counter11:\
    \ usize = 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13:\
    \ usize = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: u\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5h95n5pg.rs:62:31\n   |\n\
    62 |     let mut prime_counter38: u\n   |                               ^ help:\
    \ add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0412]: cannot find type\
    \ `u` in this scope\n  --> /tmp/tmp5h95n5pg.rs:62:30\n   |\n62 |     let mut prime_counter38:\
    \ u\n   |                              ^ help: a builtin type with a similar name\
    \ exists: `u8`\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from\
    \ an iterator over elements of type `char`\n    --> /tmp/tmp5h95n5pg.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5h95n5pg.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0412.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_counter:\
    \ Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_counter2: Vec<u8>\
    \ = vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_counter3: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_counter4: Vec<u8> = vec![0, 0, 0, 0,\
    \ 0, 0, 0, 0];\n    let mut prime_counter5: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0,\
    \ 0];\n    let mut prime_counter6: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n \
    \   let mut prime_counter7: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let mut\
    \ prime_counter8: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_counter9:\
    \ Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_counter10: Vec<u8>\
    \ = vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_counter11: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_counter12: Vec<u8> = vec![0, 0, 0,\
    \ 0, 0, 0, 0, 0];\n    let mut prime_counter13: Vec<u8> = vec![0, 0, 0, 0, 0,\
    \ 0, 0, 0];\n    let mut prime_counter14: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0,\
    \ 0];\n    let mut prime_counter15: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n\
    \    let mut prime_counter16: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let\
    \ mut prime_counter17: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_counter18:\
    \ Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_counter19: Vec<u8>\
    \ = vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_counter20: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_counter21: Vec<u8> = vec![0, 0, 0,\
    \ 0, 0, 0, 0, 0];\n    let mut prime_counter22: Vec<u8> = vec![0, 0, 0, 0, 0,\
    \ 0, 0, 0];\n    let mut prime_counter23: Vec<u8> = \n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpuzj2p86g.rs:48:1\n\
    \   |\n48 | }\n   | ^ expected expression\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n  --> /tmp/tmpuzj2p86g.rs:23:55\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748837
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_count: isize = 0;\n    let mut prime_digit: u8 = 0;\n    let\
    \ mut prime_digit_count: usize = 0;\n    let mut prime_digit_index: usize = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let \n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpxm930m_9.rs:74:1\n  \
    \ |\n74 | }\n   | ^ expected pattern\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n  --> /tmp/tmpxm930m_9.rs:23:55\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_counter:\
    \ usize = 0;\n    let mut prime_counter2: usize = 0;\n    let mut prime_counter3:\
    \ usize = 0;\n    let mut prime_counter4: usize = 0;\n    let mut prime_counter5:\
    \ usize = 0;\n    let mut prime_counter6: usize = 0;\n    let mut prime_counter7:\
    \ usize = 0;\n    let mut prime_counter8: usize = 0;\n    let mut prime_counter9:\
    \ usize = 0;\n    let mut prime_counter10: usize = 0;\n    let mut prime_counter11:\
    \ usize = 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13:\
    \ usize = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: u\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5h95n5pg.rs:62:31\n   |\n\
    62 |     let mut prime_counter38: u\n   |                               ^ help:\
    \ add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0412]: cannot find type\
    \ `u` in this scope\n  --> /tmp/tmp5h95n5pg.rs:62:30\n   |\n62 |     let mut prime_counter38:\
    \ u\n   |                              ^ help: a builtin type with a similar name\
    \ exists: `u8`\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from\
    \ an iterator over elements of type `char`\n    --> /tmp/tmp5h95n5pg.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5h95n5pg.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0412.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![];\n    let mut prime_counter: usize = 0;\n\
    \    let mut prime_counter2: usize = 0;\n    let mut prime_counter3: usize = 0;\n\
    \    let mut prime_counter4: usize = 0;\n    let mut prime_counter5: usize = 0;\n\
    \    let mut prime_counter6: usize = 0;\n    let mut prime_counter7: usize = 0;\n\
    \    let mut prime_counter8: usize = 0;\n    let mut prime_counter9: usize = 0;\n\
    \    let mut prime_counter10: usize = 0;\n    let mut prime_counter11: usize =\
    \ 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13: usize\
    \ = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: usize = 0;\n    let mut prime_counter39:\
    \ usize = 0;\n    let mut prime_counter40: usize = 0;\n    let mut prime\n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp4biu6__m.rs:65:18\n   |\n\
    65 |     let mut prime\n   |                  ^ help: add `;` here\n66 | }\n \
    \  | - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built\
    \ from an iterator over elements of type `char`\n  --> /tmp/tmp4biu6__m.rs:23:55\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4biu6__m.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748837
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let mut prime_counter:\
    \ usize = 0;\n    let mut prime_counter2: usize = 0;\n    let mut prime_counter3:\
    \ usize = 0;\n    let mut prime_counter4: usize = 0;\n    let mut prime_counter5:\
    \ usize = 0;\n    let mut prime_counter6: usize = 0;\n    let mut prime_counter7:\
    \ usize = 0;\n    let mut prime_counter8: usize = 0;\n    let mut prime_counter9:\
    \ usize = 0;\n    let mut prime_counter10: usize = 0;\n    let mut prime_counter11:\
    \ usize = 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13:\
    \ usize = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: usize = 0;\n    let mut prime_counter39:\
    \ usize = 0;\n    let mut prime_counter40: u\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpx4n45ubt.rs:64:31\n   |\n\
    64 |     let mut prime_counter40: u\n   |                               ^ help:\
    \ add `;` here\n65 | }\n   | - unexpected token\n\nerror[E0412]: cannot find type\
    \ `u` in this scope\n  --> /tmp/tmpx4n45ubt.rs:64:30\n   |\n64 |     let mut prime_counter40:\
    \ u\n   |                              ^ help: a builtin type with a similar name\
    \ exists: `u8`\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from\
    \ an iterator over elements of type `char`\n  --> /tmp/tmpx4n45ubt.rs:23:55\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpx4n45ubt.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0412.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_number: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_number_index\
    \ = 0;\n    let mut prime_number_length = prime_number.len();\n    let mut prime_number_counter\
    \ = 0;\n    let mut prime_number_counter_index = 0;\n    let mut prime_number_counter_length\
    \ = prime_number.len();\n    let mut prime_number_counter_counter = 0;\n    let\
    \ mut prime_number_counter_counter_index = 0;\n    let mut prime_number_counter_counter_length\
    \ = prime_number.len();\n    let mut prime_number_counter_counter_counter = 0;\n\
    \    let mut prime_number_counter_counter_counter_index = 0;\n    let mut prime_number_counter_counter_counter_length\
    \ = prime_number.len();\n    let mut prime_number_counter_counter_counter_counter\
    \ = 0;\n    let mut prime_number_counter_counter_counter_counter_index = 0;\n\
    \    let mut prime_number_counter_counter_counter_counter_length = prime_number.len();\n\
    \    let mut prime_number_counter_counter_counter_counter_counter = 0;\n    let\
    \ mut prime_number_counter_counter_counter_counter_counter_index = 0;\n    let\
    \ mut prime_number_counter_counter_counter_counter_counter_length = prime_number.len();\n\
    \    let mut prime_number_counter_counter_counter_counter_counter_counter = 0;\n\
    \    let mut prime_number_counter_counter_counter_counter_counter_counter_index\
    \ = 0;\n    let mut prime_number_counter_counter_counter_counter_counter_counter_length\
    \ = prime_number.len();\n    let mut prime_number_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    let mut prime_number_counter_counter_counter_counter_counter_counter_counter_index\
    \ = 0;\n    let mut prime_number_counter_counter_counter_counter_counter_counter_counter_counter_length\
    \ = prime_number.len();\n    let mut prime_number_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    let mut prime_number_counter_counter_counter_counter_counter_counter_counter_counter_index\
    \ = 0;\n    let mut prime_number_counter_counter_counter_counter_counter_counter_counter_counter_length\
    \ = prime_number.len();\n    let mut prime_number_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    let mut prime_number_counter_counter_counter_counter_counter_counter_counter_counter_counter_index\
    \ = 0;\n    let mut prime_number_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_length\
    \ = prime_number.len();\n    let mut prime_number_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n  --> /tmp/tmpts1wnsp2.rs:23:55\n   |\n23 |  \
    \   let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n   |       \
    \                                                ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the\
    \ trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpts1wnsp2.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut count = 1;\n    let mut prime: isize = 2;\n    let mut prime_found\
    \ = false;\n    let mut prime_found2 = false;\n    let mut prime_found3 = false;\n\
    \    let mut prime_found4 = false;\n    let mut prime_found5 = false;\n    let\
    \ mut prime_found6 = false;\n    let mut prime_found7 = false;\n    let mut prime_found8\
    \ = false;\n    let mut prime_found9 = false;\n    let mut prime_found10 = false;\n\
    \    let mut prime_found11 = false;\n    let mut prime_found12 = false;\n    let\
    \ mut prime_found13 = false;\n    let mut prime_found14 = false;\n    let mut\
    \ prime_found15 = false;\n    let mut prime_found16 = false;\n    let mut prime_found17\
    \ = false;\n    let mut prime_found18 = false;\n    let mut prime_found19 = false;\n\
    \    let mut prime_found20 = false;\n    let mut prime_found21 = false;\n    let\
    \ mut prime_found22 = false;\n    let mut prime_found23 = false;\n    let mut\
    \ prime_found24 = false;\n    let mut prime_found25 = false;\n    let mut prime_found26\
    \ = false;\n    let mut prime_found27 = false;\n    let mut prime_found28 = false;\n\
    \    let mut prime_found29 = false;\n    let mut prime_found30 = false;\n    let\
    \ mut prime_found31 = false;\n    let mut prime_found32 = false;\n    let mut\
    \ prime_found33 = false;\n    let mut prime_found34 = false;\n    let mut prime_found35\
    \ = false;\n    let mut prime_found36 = false;\n    let mut prime_found37 = false;\n\
    \    let mut prime_found38 = false;\n    let mut prime_found39 = false;\n    let\
    \ mut prime_found40 = false;\n    let mut prime_found41 = false;\n    let mut\
    \ prime_found42 = false;\n    let mut prime_found43 = false;\n    let mut prime_found44\
    \ = false;\n    let mut prime_found45 = false;\n    let mut prime_found46 = false;\n\
    \    let mut prime_found47 = false;\n    let mut prime_found48 = false;\n    let\
    \ mut prime_found49 = false;\n    let mut prime_found50 = false;\n    let mut\
    \ prime_found51 = false;\n    let mut prime_found52 = false;\n    let mut \n}\n\
    \nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpj7eng5lt.rs:79:1\n\
    \   |\n79 | }\n   | ^ expected identifier\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n  --> /tmp/tmpj7eng5lt.rs:23:55\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut count: usize = 0;\n    let mut prime: usize = 2;\n    let mut prime_found\
    \ = false;\n    let mut prime_found2 = false;\n    let mut prime_found3 = false;\n\
    \    let mut prime_found4 = false;\n    let mut prime_found5 = false;\n    let\
    \ mut prime_found6 = false;\n    let mut prime_found7 = false;\n    let mut prime_found8\
    \ = false;\n    let mut prime_found9 = false;\n    let mut prime_found10 = false;\n\
    \    let mut prime_found11 = false;\n    let mut prime_found12 = false;\n    let\
    \ mut prime_found13 = false;\n    let mut prime_found14 = false;\n    let mut\
    \ prime_found15 = false;\n    let mut prime_found16 = false;\n    let mut prime_found17\
    \ = false;\n    let mut prime_found18 = false;\n    let mut prime_found19 = false;\n\
    \    let mut prime_found20 = false;\n    let mut prime_found21 = false;\n    let\
    \ mut prime_found22 = false;\n    let mut prime_found23 = false;\n    let mut\
    \ prime_found24 = false;\n    let mut prime_found25 = false;\n    let mut prime_found26\
    \ = false;\n    let mut prime_found27 = false;\n    let mut prime_found28 = false;\n\
    \    let mut prime_found29 = false;\n    let mut prime_found30 = false;\n    let\
    \ mut prime_found31 = false;\n    let mut prime_found32 = false;\n    let mut\
    \ prime_found33 = false;\n    let mut prime_found34 = false;\n    let mut prime_found35\
    \ = false;\n    let mut prime_found36 = false;\n    let mut prime_found37 = false;\n\
    \    let mut prime_found38 = false;\n    let mut prime_found39 = false;\n    let\
    \ mut prime_found40 = false;\n    let mut prime_found41 = false;\n    let mut\
    \ prime_found42 = false;\n    let mut prime_found43 = false;\n    let mut prime_found44\
    \ = false;\n    let mut prime_found45 = false;\n    let mut prime_found46 = false;\n\
    \    let mut prime_found47 = false;\n    let mut prime_found48 = false;\n    let\
    \ mut prime_found49 = false;\n    let mut prime_found50 = false;\n    let mut\
    \ prime_found51 = false;\n    let mut prime_found52 = false;\n    let \n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp8y2orenz.rs:79:1\n  \
    \ |\n79 | }\n   | ^ expected pattern\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n  --> /tmp/tmp8y2orenz.rs:23:55\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748837
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_count: isize = 0;\n    let mut prime: isize = 2;\n    let mut\
    \ prime_found = false;\n    let mut prime_found2 = false;\n    let mut prime_found3\
    \ = false;\n    let mut prime_found4 = false;\n    let mut prime_found5 = false;\n\
    \    let mut prime_found6 = false;\n    let mut prime_found7 = false;\n    let\
    \ mut prime_found8 = false;\n    let mut prime_found9 = false;\n    let mut prime_found10\
    \ = false;\n    let mut prime_found11 = false;\n    let mut prime_found12 = false;\n\
    \    let mut prime_found13 = false;\n    let mut prime_found14 = false;\n    let\
    \ mut prime_found15 = false;\n    let mut prime_found16 = false;\n    let mut\
    \ prime_found17 = false;\n    let mut prime_found18 = false;\n    let mut prime_found19\
    \ = false;\n    let mut prime_found20 = false;\n    let mut prime_found21 = false;\n\
    \    let mut prime_found22 = false;\n    let mut prime_found23 = false;\n    let\
    \ mut prime_found24 = false;\n    let mut prime_found25 = false;\n    let mut\
    \ prime_found26 = false;\n    let mut prime_found27 = false;\n    let mut prime_found28\
    \ = false;\n    let mut prime_found29 = false;\n    let mut prime_found30 = false;\n\
    \    let mut prime_found31 = false;\n    let mut prime_found32 = false;\n    let\
    \ mut prime_found33 = false;\n    let mut prime_found34 = false;\n    let mut\
    \ prime_found35 = false;\n    let mut prime_found36 = false;\n    let mut prime_found37\
    \ = false;\n    let mut prime_found38 = false;\n    let mut prime_found39 = false;\n\
    \    let mut prime_found40 = false;\n    let mut prime_found41 = false;\n    let\
    \ mut prime_found42 = false;\n    let mut prime_found43 = false;\n    let mut\
    \ prime_found44 = false;\n    let mut prime_found45 = false;\n    let mut prime_found46\
    \ = false;\n    let mut prime_found47 = false;\n    let mut prime_found48 = false;\n\
    \    let mut prime_found49 = false;\n    let mut prime_found50 = false;\n    let\
    \ mut prime_found51 = false;\n    let mut prime_found52 = false;\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n  --> /tmp/tmp7vq8lljv.rs:23:55\n   |\n23 |  \
    \   let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n   |       \
    \                                                ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the\
    \ trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7vq8lljv.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut count: usize = 0;\n    let mut prime: usize = 2;\n    let mut prime_found\
    \ = false;\n    let mut prime_found2 = false;\n    let mut prime_found3 = false;\n\
    \    let mut prime_found4 = false;\n    let mut prime_found5 = false;\n    let\
    \ mut prime_found6 = false;\n    let mut prime_found7 = false;\n    let mut prime_found8\
    \ = false;\n    let mut prime_found9 = false;\n    let mut prime_found10 = false;\n\
    \    let mut prime_found11 = false;\n    let mut prime_found12 = false;\n    let\
    \ mut prime_found13 = false;\n    let mut prime_found14 = false;\n    let mut\
    \ prime_found15 = false;\n    let mut prime_found16 = false;\n    let mut prime_found17\
    \ = false;\n    let mut prime_found18 = false;\n    let mut prime_found19 = false;\n\
    \    let mut prime_found20 = false;\n    let mut prime_found21 = false;\n    let\
    \ mut prime_found22 = false;\n    let mut prime_found23 = false;\n    let mut\
    \ prime_found24 = false;\n    let mut prime_found25 = false;\n    let mut prime_found26\
    \ = false;\n    let mut prime_found27 = false;\n    let mut prime_found28 = false;\n\
    \    let mut prime_found29 = false;\n    let mut prime_found30 = false;\n    let\
    \ mut prime_found31 = false;\n    let mut prime_found32 = false;\n    let mut\
    \ prime_found33 = false;\n    let mut prime_found34 = false;\n    let mut prime_found35\
    \ = false;\n    let mut prime_found36 = false;\n    let mut prime_found37 = false;\n\
    \    let mut prime_found38 = false;\n    let mut prime_found39 = false;\n    let\
    \ mut prime_found40 = false;\n    let mut prime_found41 = false;\n    let mut\
    \ prime_found42 = false;\n    let mut prime_found43 = false;\n    let mut prime_found44\
    \ = false;\n    let mut prime_found45 = false;\n    let mut prime_found46 = false;\n\
    \    let mut prime_found47 = false;\n    let mut prime_found48 = false;\n    let\
    \ mut prime_found49 = false;\n    let mut prime_found50 = false;\n    let mut\
    \ prime_found51 = false;\n    let mut prime_found52 = false;\n    let \n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp8y2orenz.rs:79:1\n  \
    \ |\n79 | }\n   | ^ expected pattern\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n  --> /tmp/tmp8y2orenz.rs:23:55\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748837
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_count: isize = 0;\n    let mut prime_digit: u8 = 0;\n    let\
    \ mut prime_flag: u8 = 0;\n    let mut prime_flag2: u8 = 0;\n    let mut prime_flag3:\
    \ u8 = 0;\n    let mut prime_flag4: u8 = 0;\n    let mut prime_flag5: u8 = 0;\n\
    \    let mut prime_flag6: u8 = 0;\n    let mut prime_flag7: u8 = 0;\n    let mut\
    \ prime_flag8: u8 = 0;\n    let mut prime_flag9: u8 = 0;\n    let mut prime_flag10:\
    \ u8 = 0;\n    let mut prime_flag11: u8 = 0;\n    let mut prime_flag12: u8 = 0;\n\
    \    let mut prime_flag13: u8 = 0;\n    let mut prime_flag14: u8 = 0;\n    let\
    \ mut prime_flag15: u8 = 0;\n    let mut prime_flag16: u8 = 0;\n    let mut prime_flag17:\
    \ u8 = 0;\n    let mut prime_flag18: u8 = 0;\n    let mut prime_flag19: u8 = 0;\n\
    \    let mut prime_flag20: u8 = 0;\n    let mut prime_flag21: u8 = 0;\n    let\
    \ mut prime_flag22: u8 = 0;\n    let mut prime_flag23: u8 = 0;\n    let mut prime_flag24:\
    \ u8 = 0;\n    let mut prime_flag25: u8 = 0;\n    let mut prime_flag26: u8 = 0;\n\
    \    let mut prime_flag27: u8 = 0;\n    let mut prime_flag28: u8 = 0;\n    let\
    \ mut prime_flag29: u8 = 0;\n    let mut prime_flag30: u8 = 0;\n    let mut prime_flag31:\
    \ u8 = 0;\n    let mut prime_flag32: u8 = 0;\n    let mut prime_flag33: u8 = 0;\n\
    \    let mut prime_flag34: u8 = 0;\n    let mut prime_flag35: u8 = 0;\n    let\
    \ mut prime_flag36: u8 = 0;\n    let mut prime_flag37: u8 = 0;\n    let mut prime_flag38:\
    \ u8 = 0;\n    let mut prime_flag39: u8 = 0;\n    let mut prime_flag40: u8 = 0;\n\
    \    let mut prime_flag41: u8 = 0;\n    let mut prime_flag42: u8 = 0;\n    let\
    \ mut prime_flag43: u8 = 0;\n    let mut prime_\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp0m_c_g_4.rs:69:19\n   |\n\
    69 |     let mut prime_\n   |                   ^ help: add `;` here\n70 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0m_c_g_4.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror[E0277]: a value\
    \ of type `Vec<u8>` cannot be built from an iterator over elements of type `char`\n\
    \  --> /tmp/tmp0m_c_g_4.rs:23:55\n   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut count: isize = 0;\n    let mut prime: isize = 2;\n    let mut prime_found\
    \ = false;\n    let mut prime_found2 = false;\n    let mut prime_found3 = false;\n\
    \    let mut prime_found4 = false;\n    let mut prime_found5 = false;\n    let\
    \ mut prime_found6 = false;\n    let mut prime_found7 = false;\n    let mut prime_found8\
    \ = false;\n    let mut prime_found9 = false;\n    let mut prime_found10 = false;\n\
    \    let mut prime_found11 = false;\n    let mut prime_found12 = false;\n    let\
    \ mut prime_found13 = false;\n    let mut prime_found14 = false;\n    let mut\
    \ prime_found15 = false;\n    let mut prime_found16 = false;\n    let mut prime_found17\
    \ = false;\n    let mut prime_found18 = false;\n    let mut prime_found19 = false;\n\
    \    let mut prime_found20 = false;\n    let mut prime_found21 = false;\n    let\
    \ mut prime_found22 = false;\n    let mut prime_found23 = false;\n    let mut\
    \ prime_found24 = false;\n    let mut prime_found25 = false;\n    let mut prime_found26\
    \ = false;\n    let mut prime_found27 = false;\n    let mut prime_found28 = false;\n\
    \    let mut prime_found29 = false;\n    let mut prime_found30 = false;\n    let\
    \ mut prime_found31 = false;\n    let mut prime_found32 = false;\n    let mut\
    \ prime_found33 = false;\n    let mut prime_found34 = false;\n    let mut prime_found35\
    \ = false;\n    let mut prime_found36 = false;\n    let mut prime_found37 = false;\n\
    \    let mut prime_found38 = false;\n    let mut prime_found39 = false;\n    let\
    \ mut prime_found40 = false;\n    let mut prime_found41 = false;\n    let mut\
    \ prime_found42 = false;\n    let mut prime_found43 = false;\n    let mut prime_found44\
    \ = false;\n    let mut prime_found45 = false;\n    let mut prime_found46 = false;\n\
    \    let mut prime_found47 = false;\n    let mut prime_found48 = false;\n    let\
    \ mut prime_found49 = false;\n    let mut prime_found50 = false;\n    let mut\
    \ prime_found51 = false;\n    let mut prime_found52 = false;\n    let \n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpatkwchil.rs:79:1\n  \
    \ |\n79 | }\n   | ^ expected pattern\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n  --> /tmp/tmpatkwchil.rs:23:55\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut counter: usize = 0;\n    let mut prime: usize = 2;\n    let mut prime_counter:\
    \ usize = 2;\n    let mut prime_counter2: usize = 2;\n    let mut prime_counter3:\
    \ usize = 2;\n    let mut prime_counter4: usize = 2;\n    let mut prime_counter5:\
    \ usize = 2;\n    let mut prime_counter6: usize = 2;\n    let mut prime_counter7:\
    \ usize = 2;\n    let mut prime_counter8: usize = 2;\n    let mut prime_counter9:\
    \ usize = 2;\n    let mut prime_counter10: usize = 2;\n    let mut prime_counter11:\
    \ usize = 2;\n    let mut prime_counter12: usize = 2;\n    let mut prime_counter13:\
    \ usize = 2;\n    let mut prime_counter14: usize = 2;\n    let mut prime_counter15:\
    \ usize = 2;\n    let mut prime_counter16: usize = 2;\n    let mut prime_counter17:\
    \ usize = 2;\n    let mut prime_counter18: usize = 2;\n    let mut prime_counter19:\
    \ usize = 2;\n    let mut prime_counter20: usize = 2;\n    let mut prime_counter21:\
    \ usize = 2;\n    let mut prime_counter22: usize = 2;\n    let mut prime_counter23:\
    \ usize = 2;\n    let mut prime_counter24: usize = 2;\n    let mut prime_counter25:\
    \ usize = 2;\n    let mut prime_counter26: usize = 2;\n    let mut prime_counter27:\
    \ usize = 2;\n    let mut prime_counter28: usize = 2;\n    let mut prime_counter29:\
    \ usize = 2;\n    let mut prime_counter30: usize = 2;\n    let mut prime_counter31:\
    \ usize = 2;\n    let mut prime_counter32: usize = 2;\n    let mut prime_counter33:\
    \ usize = 2;\n    let mut prime_counter34: usize = 2;\n    let mut prime_counter35:\
    \ usize = 2;\n    let mut prime_counter36: usize = 2;\n    let mut prime_counter37:\
    \ usize = 2;\n    let mut prime_counter38: usize = 2;\n    let mut prime_counter39:\
    \ usize = 2;\n    let mut prime_counter40: usize = 2;\n\n}\n\nfn main() {\n  \
    \  let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp322thm2j.rs:22:28\n   |\n\
    22 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `char`\n  -->\
    \ /tmp/tmp322thm2j.rs:23:55\n   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: isize = 0;\n    let mut num_digits = num.len();\n\
    \    let mut num_primes = 0;\n    let mut num_primes_digits = 0;\n    let mut\
    \ num_primes_digits_primes = 0;\n    let mut num_primes_digits_primes_primes =\
    \ 0;\n    let mut num_primes_digits_primes_primes_primes = 0;\n    let mut num_primes_digits_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes = 0;\n\
    \    let mut num_primes_digits_primes_primes_primes_primes_primes_primes = 0;\n\
    \    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_prime\n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmppkw4kkhq.rs:44:64\n   |\n\
    44 |     let mut num_primes_digits_primes_primes_primes_primes_prime\n   |   \
    \                                                             ^ help: add `;`\
    \ here\n45 | }\n   | - unexpected token\n\nerror[E0599]: no method named `len`\
    \ found for type `isize` in the current scope\n  --> /tmp/tmppkw4kkhq.rs:24:30\n\
    \   |\n24 |     let mut num_digits = num.len();\n   |                        \
    \      ^^^ method not found in `isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmppkw4kkhq.rs:22:28\n   |\n22 | fn hex_key(num: String) -> isize {\n \
    \  |    -------                 ^^^^^ expected `isize`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_count: isize = 0;\n    let mut prime: isize = 2;\n    let mut\
    \ prime_found = false;\n    let mut prime_found2 = false;\n    let mut prime_found3\
    \ = false;\n    let mut prime_found4 = false;\n    let mut prime_found5 = false;\n\
    \    let mut prime_found6 = false;\n    let mut prime_found7 = false;\n    let\
    \ mut prime_found8 = false;\n    let mut prime_found9 = false;\n    let mut prime_found10\
    \ = false;\n    let mut prime_found11 = false;\n    let mut prime_found12 = false;\n\
    \    let mut prime_found13 = false;\n    let mut prime_found14 = false;\n    let\
    \ mut prime_found15 = false;\n    let mut prime_found16 = false;\n    let mut\
    \ prime_found17 = false;\n    let mut prime_found18 = false;\n    let mut prime_found19\
    \ = false;\n    let mut prime_found20 = false;\n    let mut prime_found21 = false;\n\
    \    let mut prime_found22 = false;\n    let mut prime_found23 = false;\n    let\
    \ mut prime_found24 = false;\n    let mut prime_found25 = false;\n    let mut\
    \ prime_found26 = false;\n    let mut prime_found27 = false;\n    let mut prime_found28\
    \ = false;\n    let mut prime_found29 = false;\n    let mut prime_found30 = false;\n\
    \    let mut prime_found31 = false;\n    let mut prime_found32 = false;\n    let\
    \ mut prime_found33 = false;\n    let mut prime_found34 = false;\n    let mut\
    \ prime_found35 = false;\n    let mut prime_found36 = false;\n    let mut prime_found37\
    \ = false;\n    let mut prime_found38 = false;\n    let mut prime_found39 = false;\n\
    \    let mut prime_found40 = false;\n    let mut prime_found41 = false;\n    let\
    \ mut prime_found42 = false;\n    let mut prime_found43 = false;\n    let mut\
    \ prime_found44 = false;\n    let mut prime_found45 = false;\n    let mut prime_found46\
    \ = false;\n    let mut prime_found47 = false;\n    let mut prime_found48 = false;\n\
    \    let mut prime_found49 = false;\n    let mut prime_found50 = false;\n    let\
    \ mut prime_found51 = false;\n    let mut prime_found52 = false;\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n  --> /tmp/tmp7vq8lljv.rs:23:55\n   |\n23 |  \
    \   let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n   |       \
    \                                                ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the\
    \ trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7vq8lljv.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut nums = num.chars().collect::<Vec<_>>();\n    let mut nums_len\
    \ = nums.len();\n    let mut prime_digits = vec![];\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits_len as usize;\n\
    \    let mut prime_digits_len = prime_digits_len as usize;\n    let mut prime_digits_len\
    \ = prime_digits_len as usize;\n    let mut prime_digits_len = prime_digits_len\
    \ as usize;\n    let mut prime_digits_len = prime_digits_len as usize;\n    let\
    \ mut prime_digits_len = prime_digits_len as usize;\n    let mut prime_digits_len\
    \ = prime_digits_len as usize;\n    let mut prime_digits_len = prime_digits_len\
    \ as usize;\n    let mut prime_digits_len = prime_digits_len as usize;\n    let\
    \ mut prime_digits_len = prime_digits_len as usize;\n    let mut prime_digits_len\
    \ = prime_digits_len as usize;\n    let mut prime_digits_len = prime_digits_len\
    \ as usize;\n    let mut prime_digits_len = prime_digits_len as usize;\n    let\
    \ mut prime_digits_len = prime_digits_len as usize;\n    let mut prime_digits_len\
    \ = prime_digits_len as usize;\n    let mut prime_digits_len = prime_digits_len\
    \ as usize;\n    let mut prime_digits_len = prime_digits_len as usize;\n    let\
    \ mut prime_digits_len = prime_digits_len as usize;\n    let mut prime_digits_len\
    \ = prime_digits_len as usize;\n    let mut prime_digits_len = prime_digits_len\
    \ as usize;\n    let mut prime_digits_len = prime_digits_len as usize;\n    let\
    \ mut prime_digits_len = prime_digits_len as usize;\n    let mut prime_digits_len\
    \ = prime_digits_len as usize;\n    let mut prime_digits_len = prime_digits_len\
    \ as usize;\n    let mut prime_digits_len = prime_digits_len as usize;\n    let\
    \ mut prime_digits_len = prime_digits_len as usize;\n    let mut prime_digits_len\
    \ = prime_digits_len as usize;\n\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw9rtkonq.rs:22:28\n   |\n\
    22 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: isize = 0;\n    let mut prime_digit: usize = 0;\n    let mut\
    \ prime_digit_count: usize = 0;\n    let mut prime_digit_count_max: usize = 10;\n\
    \    let mut prime_digit_count_min: usize = 2;\n    let mut prime_digit_count_max_prime:\
    \ usize = 10;\n    let mut prime_digit_count_min_prime: usize = 2;\n    let mut\
    \ prime_digit_count_max_prime_prime: usize = 10;\n    let mut prime_digit_count_min_prime_prime:\
    \ usize = 2;\n    let mut prime_digit_count_max_prime_prime_prime: usize = 10;\n\
    \    let mut prime_digit_count_min_prime_prime_prime: usize = 2;\n    let mut\
    \ prime_digit_count_max_prime_prime_prime_prime: usize = 10;\n    let mut prime_digit_count_min_prime_prime_prime_prime:\
    \ usize = 2;\n    let mut prime_digit_count_max_prime_prime_prime_prime_prime:\
    \ usize = 10;\n    let mut prime_digit_count_min_prime_prime_prime_prime_prime:\
    \ usize = 2;\n    let mut prime_digit_count_max_prime_prime_prime_prime_prime_prime:\
    \ usize = 10;\n    let mut prime_digit_count_min_prime_prime_prime_prime_prime_prime:\
    \ usize = 2;\n    let mut prime_digit_count_max_prime_prime_prime_prime_prime_prime_prime:\
    \ usize = 10;\n    let mut prime_digit_count_min_prime_prime_prime_prime_prime_prime_prime:\
    \ usize = 2;\n    let mut prime_digit_count_max_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ usize = 10;\n    let mut prime_digit_count_min_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ usize = 2;\n    let mut prime_digit_count_max_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ usize = 10;\n    let mut prime_digit_count_min_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ usize = 2;\n    let mut prime_digit_count_max_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ usize = 10;\n    let mut prime\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpbqjsgdhe.rs:48:18\n   |\n\
    48 |     let mut prime\n   |                  ^ help: add `;` here\n49 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbqjsgdhe.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror[E0277]: a value\
    \ of type `Vec<u8>` cannot be built from an iterator over elements of type `char`\n\
    \  --> /tmp/tmpbqjsgdhe.rs:23:55\n   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut count: usize = 0;\n    let mut prime: usize = 2;\n    let mut prime_found\
    \ = false;\n    let mut prime_found2 = false;\n    let mut prime_found3 = false;\n\
    \    let mut prime_found4 = false;\n    let mut prime_found5 = false;\n    let\
    \ mut prime_found6 = false;\n    let mut prime_found7 = false;\n    let mut prime_found8\
    \ = false;\n    let mut prime_found9 = false;\n    let mut prime_found10 = false;\n\
    \    let mut prime_found11 = false;\n    let mut prime_found12 = false;\n    let\
    \ mut prime_found13 = false;\n    let mut prime_found14 = false;\n    let mut\
    \ prime_found15 = false;\n    let mut prime_found16 = false;\n    let mut prime_found17\
    \ = false;\n    let mut prime_found18 = false;\n    let mut prime_found19 = false;\n\
    \    let mut prime_found20 = false;\n    let mut prime_found21 = false;\n    let\
    \ mut prime_found22 = false;\n    let mut prime_found23 = false;\n    let mut\
    \ prime_found24 = false;\n    let mut prime_found25 = false;\n    let mut prime_found26\
    \ = false;\n    let mut prime_found27 = false;\n    let mut prime_found28 = false;\n\
    \    let mut prime_found29 = false;\n    let mut prime_found30 = false;\n    let\
    \ mut prime_found31 = false;\n    let mut prime_found32 = false;\n    let mut\
    \ prime_found33 = false;\n    let mut prime_found34 = false;\n    let mut prime_found35\
    \ = false;\n    let mut prime_found36 = false;\n    let mut prime_found37 = false;\n\
    \    let mut prime_found38 = false;\n    let mut prime_found39 = false;\n    let\
    \ mut prime_found40 = false;\n    let mut prime_found41 = false;\n    let mut\
    \ prime_found42 = false;\n    let mut prime_found43 = false;\n    let mut prime_found44\
    \ = false;\n    let mut prime_found45 = false;\n    let mut prime_found46 = false;\n\
    \    let mut prime_found47 = false;\n    let mut prime_found48 = false;\n    let\
    \ mut prime_found49 = false;\n    let mut prime_found50 = false;\n    let mut\
    \ prime_found51 = false;\n    let mut prime_found52 = false;\n    let \n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp8y2orenz.rs:79:1\n  \
    \ |\n79 | }\n   | ^ expected pattern\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n  --> /tmp/tmp8y2orenz.rs:23:55\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748837
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_counter:\
    \ usize = 0;\n    let mut prime_counter2: usize = 0;\n    let mut prime_counter3:\
    \ usize = 0;\n    let mut prime_counter4: usize = 0;\n    let mut prime_counter5:\
    \ usize = 0;\n    let mut prime_counter6: usize = 0;\n    let mut prime_counter7:\
    \ usize = 0;\n    let mut prime_counter8: usize = 0;\n    let mut prime_counter9:\
    \ usize = 0;\n    let mut prime_counter10: usize = 0;\n    let mut prime_counter11:\
    \ usize = 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13:\
    \ usize = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: u\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5h95n5pg.rs:62:31\n   |\n\
    62 |     let mut prime_counter38: u\n   |                               ^ help:\
    \ add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0412]: cannot find type\
    \ `u` in this scope\n  --> /tmp/tmp5h95n5pg.rs:62:30\n   |\n62 |     let mut prime_counter38:\
    \ u\n   |                              ^ help: a builtin type with a similar name\
    \ exists: `u8`\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from\
    \ an iterator over elements of type `char`\n    --> /tmp/tmp5h95n5pg.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5h95n5pg.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0412.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num_len = num.len();\n    let mut num_prime: isize = 0;\n    let mut\
    \ num_prime_len = num_len;\n    let mut num_prime_prime: isize = 0;\n    let mut\
    \ num_prime_prime_len = num_len;\n    let mut num_prime_prime_prime: isize = 0;\n\
    \    let mut num_prime_prime_prime_len = num_len;\n    let mut num_prime_prime_prime_prime:\
    \ isize = 0;\n    let mut num_prime_prime_prime_prime_len = num_len;\n    let\
    \ mut num_prime_prime_prime_prime_prime: isize = 0;\n    let mut num_prime_prime_prime_prime_prime_len\
    \ = num_len;\n    let mut num_prime_prime_prime_prime_prime_prime: isize = 0;\n\
    \    let mut num_prime_prime_prime_prime_prime_prime_len = num_len;\n    let mut\
    \ num_prime_prime_prime_prime_prime_prime_prime: isize = 0;\n    let mut num_prime_prime_prime_prime_prime_prime_prime_len\
    \ = num_len;\n    let mut num_prime_prime_prime_prime_prime_prime_prime_len =\
    \ num_len;\n    let mut num_prime_prime_prime_prime_prime_prime_prime_len = num_len;\n\
    \    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_len = num_len;\n\
    \    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_len = num_len;\n\
    \    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_len = num_len;\n\
    \    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime_len = num_len;\n\
    \    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime_len = num_len;\n\
    \    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime_len = num_len;\n\
    \    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_len\
    \ = num_len;\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_len\
    \ = num_len;\n    let mut num_prime_prime\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpie65u66g.rs:49:28\n   |\n\
    49 |     let mut num_prime_prime\n   |                            ^ help: add\
    \ `;` here\n50 | }\n   | - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n  --> /tmp/tmpie65u66g.rs:23:52\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_string().chars().collect();\n  \
    \ |                                                    ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the\
    \ trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpie65u66g.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let mut\
    \ num_prime_2: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23];\n    let mut num_prime_3:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29];\n    let mut num_prime_4:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31];\n    let mut num_prime_5:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37];\n    let mut num_prime_6:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 43];\n    let mut\
    \ num_prime_7: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 43,\
    \ 49];\n    let mut num_prime_8: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23,\
    \ 29, 31, 37, 43, 49, 57];\n    let mut num_prime_9: Vec<u8> = vec![2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 43, 49, 57, 61];\n    let mut num_prime_10:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 43, 49, 57, 61, 67];\n\
    \    let mut num_prime_11: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 43, 49, 57, 61, 67, 71];\n    let mut num_prime_12: Vec<u8> = vec![2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 43, 49, 57, 61, 67, 71, 73];\n    let\
    \ mut num_prime_13: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 43, 49, 57, 61, 67, 71, 73, 79];\n    let mut num_prime_14: Vec<u8> = vec![2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 43, 49, 57, 61, 67, 71, 73, 79, 83];\n\
    \    let mut num_prime_15: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 43, 49, 57, 61, 67, 71, 73, 79, 83, 89];\n    let mu\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_m2soigv.rs:39:11\n   |\n\
    39 |     let mu\n   |           ^ help: add `;` here\n40 | }\n   | - unexpected\
    \ token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n  --> /tmp/tmp_m2soigv.rs:23:55\n   |\n23 |  \
    \   let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n   |       \
    \                                                ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the\
    \ trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_m2soigv.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut prime_count: isize = 0;\n    let mut prime_digit: u8 = 0;\n    let mut\
    \ prime_digit_count: u8 = 0;\n    let mut prime_digit_index: u8 = 0;\n    let\
    \ mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n   \
    \ let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut \n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpoyukyiub.rs:74:1\n\
    \   |\n74 | }\n   | ^ expected identifier\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n  --> /tmp/tmpoyukyiub.rs:23:52\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_string().chars().collect();\n  \
    \ |                                                    ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the\
    \ trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_digits = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\
    \ 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_digits_set\
    \ = prime_digits.iter().cloned().collect::<HashSet<usize>>();\n    let mut prime_digits_count\
    \ = prime_digits.len();\n    let mut prime_digits_index = 0;\n    let mut prime_digits_index2\
    \ = 0;\n    let mut prime_digits_index3 = 0;\n    let mut prime_digits_index4\
    \ = 0;\n    let mut prime_digits_index5 = 0;\n    let mut prime_digits_index6\
    \ = 0;\n    let mut prime_digits_index7 = 0;\n    let mut prime_digits_index8\
    \ = 0;\n    let mut prime_digits_index9 = 0;\n    let mut prime_digits_index10\
    \ = 0;\n    let mut prime_digits_index11 = 0;\n    let mut prime_digits_index12\
    \ = 0;\n    let mut prime_digits_index13 = 0;\n    let mut prime_digits_index14\
    \ = 0;\n    let mut prime_digits_index15 = 0;\n    let mut prime_digits_index16\
    \ = 0;\n    let mut prime_digits_index17 = 0;\n    let mut prime_digits_index18\
    \ = 0;\n    let mut prime_digits_index19 = 0;\n    let mut prime_digits_index20\
    \ = 0;\n    let mut prime_digits_index21 = 0;\n    let mut prime_digits_index22\
    \ = 0;\n    let mut prime_digits_index23 = 0;\n    let mut prime_digits_index24\
    \ = 0;\n    let mut prime_digits_index25 = 0;\n    let mut prime_digits_index26\
    \ = 0;\n    let mut prime_digits_index27 = 0;\n    let mut prime_digits_index28\
    \ = 0;\n    let mut prime_digits_index29 = 0;\n    let mut prime_digits_index30\
    \ = 0;\n    let mut prime_digits_index31 = 0;\n    let mut prime_digits_index32\
    \ = 0;\n    let mut prime_digits_index33 = 0;\n    let mut prime_digits_index34\
    \ = 0;\n    let mut prime_digits_index35 = 0;\n    let mut prime_digits_index36\
    \ = 0;\n    let mut prime_digits_index37 = 0;\n    let mut prime_digits_index\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpk1hgiyf0.rs:64:31\n   |\n\
    64 |     let mut prime_digits_index\n   |                               ^ help:\
    \ add `;` here\n65 | }\n   | - unexpected token\n\nerror[E0412]: cannot find type\
    \ `HashSet` in this scope\n  --> /tmp/tmpk1hgiyf0.rs:25:71\n   |\n25 |     let\
    \ mut prime_digits_set = prime_digits.iter().cloned().collect::<HashSet<usize>>();\n\
    \   |                                                                       ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n  --> /tmp/tmpk1hgiyf0.rs:23:55\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpk1hgiyf0.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0412.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748839
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_len\
    \ = num_prime.len();\n    let mut num_prime_sum = 0;\n    let mut num_prime_product\
    \ = 1;\n    let mut num_prime_product2 = 1;\n    let mut num_prime_product3 =\
    \ 1;\n    let mut num_prime_product4 = 0;\n    let mut num_prime_product5 = 1;\n\
    \    let mut num_prime_product6 = 1;\n    let mut num_prime_product7 = 1;\n  \
    \  let mut num_prime_product8 = 1;\n    let mut num_prime_product9 = 1;\n    let\
    \ mut num_prime_product10 = 1;\n    let mut num_prime_product11 = 1;\n    let\
    \ mut num_prime_product12 = 1;\n    let mut num_prime_product13 = 1;\n    let\
    \ mut num_prime_product14 = 1;\n    let mut num_prime_product15 = 1;\n    let\
    \ mut num_prime_product16 = 1;\n    let mut num_prime_product17 = 1;\n    let\
    \ mut num_prime_product18 = 1;\n    let mut num_prime_product19 = 1;\n    let\
    \ mut num_prime_product20 = 1;\n    let mut num_prime_product21 = 1;\n    let\
    \ mut num_prime_product22 = 1;\n    let mut num_prime_product23 = 1;\n    let\
    \ mut num_prime_product24 = 1;\n    let mut num_prime_product25 = 1;\n    let\
    \ mut num_prime_product26 = 1;\n    let mut num_prime_product27 = 1;\n    let\
    \ mut num_prime_product28 = 1;\n    let mut num_prime_product29 = 1;\n    let\
    \ mut num_prime_product30 = 1;\n    let mut num_prime_product31 = 1;\n    let\
    \ mut num_prime_product32 = 1;\n    let mut num_prime_product33 = 1;\n    let\
    \ mut num_prime_product34 = 1;\n    let mut num_prime_product35 = 1;\n    let\
    \ mut num_prime_product36 = 1;\n    let mut num_prime_product37 = 1;\n    let\
    \ mut num_prime_product38 = 1;\n    let mut num_prime_product39 = 1;\n    let\
    \ mut num_prime_product40 = 1;\n    let mut num_prime_product41 = 1;\n    let\
    \ mut num_prime_product42 = 1;\n    let mut num_prime_product\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpgz5gvfx2.rs:69:30\n   |\n\
    69 |     let mut num_prime_product\n   |                              ^ help:\
    \ add `;` here\n70 | }\n   | - unexpected token\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `char`\n  -->\
    \ /tmp/tmpgz5gvfx2.rs:23:55\n   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgz5gvfx2.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut nums = num.to_string().chars().collect::<Vec<_>>();\n \
    \   let mut primes = vec![true; 26];\n    let mut primes_counter = 0;\n    let\
    \ mut primes_counter2 = 0;\n    let mut primes_counter3 = 0;\n    let mut primes_counter4\
    \ = 0;\n    let mut primes_counter5 = 0;\n    let mut primes_counter6 = 0;\n \
    \   let mut primes_counter7 = 0;\n    let mut primes_counter8 = 0;\n    let mut\
    \ primes_counter9 = 0;\n    let mut primes_counter10 = 0;\n    let mut primes_counter11\
    \ = 0;\n    let mut primes_counter12 = 0;\n    let mut primes_counter13 = 0;\n\
    \    let mut primes_counter14 = 0;\n    let mut primes_counter15 = 0;\n    let\
    \ mut primes_counter16 = 0;\n    let mut primes_counter17 = 0;\n    let mut primes_counter18\
    \ = 0;\n    let mut primes_counter19 = 0;\n    let mut primes_counter20 = 0;\n\
    \    let mut primes_counter21 = 0;\n    let mut primes_counter22 = 0;\n    let\
    \ mut primes_counter23 = 0;\n    let mut primes_counter24 = 0;\n    let mut primes_counter25\
    \ = 0;\n    let mut primes_counter26 = 0;\n    let mut primes_counter27 = 0;\n\
    \    let mut primes_counter28 = 0;\n    let mut primes_counter29 = 0;\n    let\
    \ mut primes_counter30 = 0;\n    let mut primes_counter31 = 0;\n    let mut primes_counter32\
    \ = 0;\n    let mut primes_counter33 = 0;\n    let mut primes_counter34 = 0;\n\
    \    let mut primes_counter35 = 0;\n    let mut primes_counter36 = 0;\n    let\
    \ mut primes_counter37 = 0;\n    let mut primes_counter38 = 0;\n    let mut primes_counter39\
    \ = 0;\n    let mut primes_counter40 = 0;\n    let mut primes_counter41 = 0;\n\
    \    let mut primes_counter42 = 0;\n    let mut primes_counter43 = 0;\n    let\
    \ mut primes_counter44 = 0;\n    let mut primes_counter45 = 0;\n    let mut primes_counter46\
    \ = 0;\n    let mut primes_counter47 = 0;\n    let mut primes_counter48 = 0;\n\
    \    let mut primes_counter49 = 0;\n    let mut primes_counter50 = 0;\n    let\
    \ mut primes_counter51 = 0;\n    let mut primes_counter52 = 0;\n    let mut primes_counter53\
    \ = 0;\n    let mut primes_counter54 = 0;\n\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppl1ei65t.rs:22:28\n   |\n\
    22 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_digit:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\
    \ 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_digit_count: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mu\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpfinip81h.rs:46:11\n   |\n\
    46 |     let mu\n   |           ^ help: add `;` here\n47 | }\n   | - unexpected\
    \ token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n  --> /tmp/tmpfinip81h.rs:23:55\n   |\n23 |  \
    \   let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n   |       \
    \                                                ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the\
    \ trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfinip81h.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748839
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: isize = 0;\n    let mut digits: Vec<isize> = num.to_digits().collect();\n\
    \    let mut primes: Vec<isize> = vec![2, 3];\n    let mut primes_count: isize\
    \ = 0;\n    let mut primes_count_max: isize = 3;\n    let mut primes_count_min:\
    \ isize = 2;\n    let mut primes_count_step: isize = 2;\n    let mut primes_count_max2:\
    \ isize = 3;\n    let mut primes_count_min2: isize = 2;\n    let mut primes_count_step2:\
    \ isize = 2;\n    let mut primes_count_max3: isize = 3;\n    let mut primes_count_min3:\
    \ isize = 2;\n    let mut primes_count_step3: isize = 2;\n    let mut primes_count_max4:\
    \ isize = 3;\n    let mut primes_count_min4: isize = 2;\n    let mut primes_count_step4:\
    \ isize = 2;\n    let mut primes_count_max5: isize = 3;\n    let mut primes_count_min5:\
    \ isize = 2;\n    let mut primes_count_step5: isize = 2;\n    let mut primes_count_max6:\
    \ isize = 3;\n    let mut primes_count_min6: isize = 2;\n    let mut primes_count_step6:\
    \ isize = 2;\n    let mut primes_count_max7: isize = 3;\n    let mut primes_count_min7:\
    \ isize = 2;\n    let mut primes_count_step7: isize = 2;\n    let mut primes_count_max8:\
    \ isize = 3;\n    let mut primes_count_min8: isize = 2;\n    let mut primes_count_step8:\
    \ isize = 2;\n    let mut primes_count_max9: isize = 3;\n    let mut primes_count_min9:\
    \ isize = 2;\n    let mut primes_count_step9: isize = 2;\n    let mut primes_count_max10:\
    \ isize = 3;\n    let mut primes_count_min10: isize = 2;\n    let mut primes_count_step10:\
    \ isize = 2;\n    let mut primes_count_max11: isize = 3;\n    let mut primes_count_min11:\
    \ isize = 2;\n    let mut primes_count_step11: isize = 2;\n    let mut primes_count_max12:\
    \ isize = 3;\n    let mut primes_count_min12: isize = 2;\n    let mut primes_count_step12:\
    \ isize = 2;\n    let mut primes_\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp0hcqgsxm.rs:63:20\n   |\n\
    63 |     let mut primes_\n   |                    ^ help: add `;` here\n64 | }\n\
    \   | - unexpected token\n\nerror[E0599]: no method named `to_digits` found for\
    \ type `isize` in the current scope\n  --> /tmp/tmp0hcqgsxm.rs:24:38\n   |\n24\
    \ |     let mut digits: Vec<isize> = num.to_digits().collect();\n   |        \
    \                              ^^^^^^^^^ method not found in `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0hcqgsxm.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748839
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num: Vec<u8> = num.to_owned();\n    let mut num: Vec<u8> = num.iter().map(|x|\
    \ *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num:\
    \ Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x|\
    \ *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num:\
    \ Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x|\
    \ *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num:\
    \ Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x|\
    \ *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num:\
    \ Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x|\
    \ *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num:\
    \ Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpi9eacsd4.rs:45:42\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |                         \
    \         - closing delimiter possibly meant for this\n...\n45 |     let mut num:\
    \ Vec<u8> = num.iter().map(|x\n   |                                          ^\
    \ unclosed delimiter\n46 | }\n   | ^ mismatched closing delimiter\n\nerror: expected\
    \ one of `:`, `@`, or `|`, found `)`\n  --> /tmp/tmpi9eacsd4.rs:46:1\n   |\n45\
    \ |     let mut num: Vec<u8> = num.iter().map(|x\n   |                       \
    \                      - expected one of `:`, `@`, or `|`\n46 | }\n   | ^ unexpected\
    \ token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n  --> /tmp/tmpi9eacsd4.rs:23:52\n   |\n23 |  \
    \   let mut num: Vec<u8> = num.to_string().chars().collect();\n   |          \
    \                                          ^^^^^^^ value of type `Vec<u8>` cannot\
    \ be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748839
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3];\n    let mut prime_counter: usize =\
    \ 0;\n    let mut prime_counter2: usize = 0;\n    let mut prime_counter3: usize\
    \ = 0;\n    let mut prime_counter4: usize = 0;\n    let mut prime_counter5: usize\
    \ = 0;\n    let mut prime_counter6: usize = 0;\n    let mut prime_counter7: usize\
    \ = 0;\n    let mut prime_counter8: usize = 0;\n    let mut prime_counter9: usize\
    \ = 0;\n    let mut prime_counter10: usize = 0;\n    let mut prime_counter11:\
    \ usize = 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13:\
    \ usize = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: usize = 0;\n    let mut prime_counter39:\
    \ usize = 0;\n    let mut prime_counter40: usize = 0;\n    let mu\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmppiak4yzm.rs:65:11\n   |\n\
    65 |     let mu\n   |           ^ help: add `;` here\n66 | }\n   | - unexpected\
    \ token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n  --> /tmp/tmppiak4yzm.rs:23:55\n   |\n23 |  \
    \   let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n   |       \
    \                                                ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the\
    \ trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmppiak4yzm.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748839
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for struct `Vec<u8>` in the\
    \ current scope\n  --> /tmp/tmp2urilp3z.rs:24:32\n   |\n24 |     let mut num:\
    \ Vec<u8> = num.chars().collect();\n   |                                ^^^^^\
    \ method not found in `Vec<u8>`\n\nerror[E0277]: a value of type `Vec<u8>` cannot\
    \ be built from an iterator over elements of type `char`\n  --> /tmp/tmp2urilp3z.rs:23:52\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_string().chars().collect();\n  \
    \ |                                                    ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the\
    \ trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0599]:\
    \ no method named `chars` found for struct `Vec<u8>` in the current scope\n  -->\
    \ /tmp/tmp2urilp3z.rs:25:32\n   |\n25 |     let mut num: Vec<u8> = num.chars().collect();\n\
    \   |                                ^^^^^ method not found in `Vec<u8>`\n\nerror[E0599]:\
    \ no method named `chars` found for struct `Vec<u8>` in the current scope\n  -->\
    \ /tmp/tmp2urilp3z.rs:26:32\n   |\n26 |     let mut num: Vec<u8> = num.chars().collect();\n\
    \   |                                ^^^^^ method not found in `Vec<u8>`\n\nerror[E0599]:\
    \ no method named `chars` found for struct `Vec<u8>` in the current scope\n  -->\
    \ /tmp/tmp2urilp3z.rs:27:32\n   |\n27 |     let mut num: Vec<u8> = num.chars().collect();\n\
    \   |                                ^^^^^ method not found in `Vec<u8>`\n\nerror[E0599]:\
    \ no method named `chars` found for struct `Vec<u8>` in the current scope\n  -->\
    \ /tmp/tmp2urilp3z.rs:28:32\n   |\n28 |     let mut num: Vec<u8> = num.chars().collect();\n\
    \   |                                ^^^^^ method not found in `Vec<u8>`\n\nerror[E0599]:\
    \ no method named `chars` found for struct `Vec<u8>` in the current scope\n  -->\
    \ /tmp/tmp2urilp3z.rs:29:32\n   |\n29 |     let mut num: Vec<u8> = num.chars().collect();\n\
    \   |                                ^^^^^ method not found in `Vec<u8>`\n\nerror[E0599]:\
    \ no method named `chars` found for struct `Vec<u8>` in the current scope\n  -->\
    \ /tmp/tmp2urilp3z.rs:3"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_counter:\
    \ usize = 0;\n    let mut prime_counter2: usize = 0;\n    let mut prime_counter3:\
    \ usize = 0;\n    let mut prime_counter4: usize = 0;\n    let mut prime_counter5:\
    \ usize = 0;\n    let mut prime_counter6: usize = 0;\n    let mut prime_counter7:\
    \ usize = 0;\n    let mut prime_counter8: usize = 0;\n    let mut prime_counter9:\
    \ usize = 0;\n    let mut prime_counter10: usize = 0;\n    let mut prime_counter11:\
    \ usize = 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13:\
    \ usize = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: u\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5h95n5pg.rs:62:31\n   |\n\
    62 |     let mut prime_counter38: u\n   |                               ^ help:\
    \ add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0412]: cannot find type\
    \ `u` in this scope\n  --> /tmp/tmp5h95n5pg.rs:62:30\n   |\n62 |     let mut prime_counter38:\
    \ u\n   |                              ^ help: a builtin type with a similar name\
    \ exists: `u8`\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from\
    \ an iterator over elements of type `char`\n    --> /tmp/tmp5h95n5pg.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5h95n5pg.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0412.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_prime: Vec<u8> = vec![];\n    let mut num_prime_counter: usize\
    \ = 0;\n    let mut num_prime_counter2: usize = 0;\n    let mut num_prime_counter3:\
    \ usize = 0;\n    let mut num_prime_counter4: usize = 0;\n    let mut num_prime_counter5:\
    \ usize = 0;\n    let mut num_prime_counter6: usize = 0;\n    let mut num_prime_counter7:\
    \ usize = 0;\n    let mut num_prime_counter8: usize = 0;\n    let mut num_prime_counter9:\
    \ usize = 0;\n    let mut num_prime_counter10: usize = 0;\n    let mut num_prime_counter11:\
    \ usize = 0;\n    let mut num_prime_counter12: usize = 0;\n    let mut num_prime_counter13:\
    \ usize = 0;\n    let mut num_prime_counter14: usize = 0;\n    let mut num_prime_counter15:\
    \ usize = 0;\n    let mut num_prime_counter16: usize = 0;\n    let mut num_prime_counter17:\
    \ usize = 0;\n    let mut num_prime_counter18: usize = 0;\n    let mut num_prime_counter19:\
    \ usize = 0;\n    let mut num_prime_counter20: usize = 0;\n    let mut num_prime_counter21:\
    \ usize = 0;\n    let mut num_prime_counter22: usize = 0;\n    let mut num_prime_counter23:\
    \ usize = 0;\n    let mut num_prime_counter24: usize = 0;\n    let mut num_prime_counter25:\
    \ usize = 0;\n    let mut num_prime_counter26: usize = 0;\n    let mut num_prime_counter27:\
    \ usize = 0;\n    let mut num_prime_counter28: usize = 0;\n    let mut num_prime_counter29:\
    \ usize = 0;\n    let mut num_prime_counter30: usize = 0;\n    let mut num_prime_counter31:\
    \ usize = 0;\n    let mut num_prime_counter32: usize = 0;\n    let mut num_prime_counter33:\
    \ usize = 0;\n    let mut num_prime_counter34: usize = 0;\n    let mut num_prime_counter35:\
    \ usize = 0;\n    let mut num_prime_counter36: usize = 0;\n    let mut num_prime_counter37:\
    \ usize = 0;\n    let mu\n}\n\nfn main() {\n    let candidate = hex_key;\n   \
    \ assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8bnkep1i.rs:62:11\n   |\n\
    62 |     let mu\n   |           ^ help: add `;` here\n63 | }\n   | - unexpected\
    \ token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmp8bnkep1i.rs:23:55\n     |\n23\
    \   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |\
    \                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8bnkep1i.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp2grytv08.rs:40:36\n   |\n\
    40 |     let mut num: Vec<u8> = num.iter\n   |                               \
    \     ^ help: add `;` here\n41 | }\n   | - unexpected token\n\nerror[E0277]: a\
    \ value of type `Vec<u8>` cannot be built from an iterator over elements of type\
    \ `char`\n  --> /tmp/tmp2grytv08.rs:23:55\n   |\n23 |     let mut num: Vec<u8>\
    \ = num.to_lowercase().chars().collect();\n   |                              \
    \                         ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n   |\n   = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2grytv08.rs:24:56\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <=\
    \ '9').collect();\n   |                                                      \
    \  ^^^ expected `&u8`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2grytv08.rs:24:68\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <=\
    \ '9').collect();\n   |                                                      \
    \              ^^^ expected `&u8`, found `char`\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `&u8`\n  -->\
    \ /tmp/tmp2grytv08.rs:24:73\n   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&x|\
    \ x >= '0' && x <= '9').collect();\n   |                                     \
    \                                    ^^^^^^^ value of type `Vec<u8>` cannot be\
    \ built from `std::iter::Iterator<Item=&u8>`\n   |\n   = help: the trait `FromIterator<&u8>`\
    \ is not implemented for `Vec<u8>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2grytv08.rs:25:56\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <=\
    \ 'F').collect();\n   |                                                      \
    \  ^^^ expected `&u8`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2grytv08.rs:25:68\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <=\
    \ 'F').collect();\n   |                     "
  stdout: ''
  timestamp: 1659748839
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut nums = num.chars().collect::<Vec<_>>();\n    let mut primes\
    \ = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97];\n    let mut primes_count = primes.len();\n    let\
    \ mut primes_count_2 = primes_count / 2;\n    let mut primes_count_3 = primes_count\
    \ / 3;\n    let mut primes_count_4 = primes_count / 4;\n    let mut primes_count_5\
    \ = primes_count / 5;\n    let mut primes_count_6 = primes_count / 6;\n    let\
    \ mut primes_count_7 = primes_count / 7;\n    let mut primes_count_8 = primes_count\
    \ / 8;\n    let mut primes_count_9 = primes_count / 9;\n    let mut primes_count_10\
    \ = primes_count / 10;\n    let mut primes_count_11 = primes_count / 11;\n   \
    \ let mut primes_count_12 = primes_count / 12;\n    let mut primes_count_13 =\
    \ primes_count / 13;\n    let mut primes_count_14 = primes_count / 14;\n    let\
    \ mut primes_count_15 = primes_count / 15;\n    let mut primes_count_16 = primes_count\
    \ / 16;\n    let mut primes_count_17 = primes_count / 17;\n    let mut primes_count_18\
    \ = primes_count / 18;\n    let mut primes_count_19 = primes_count / 19;\n   \
    \ let mut primes_count_20 = primes_count / 20;\n    let mut primes_count_21 =\
    \ primes_count / 21;\n    let mut primes_count_22 = primes_count / 22;\n    let\
    \ mut primes_count_23 = primes_count / 23;\n    let mut primes_count_24 = primes_count\
    \ / 24;\n    let mut primes_count_25 = primes_count / 25;\n    let mut primes_count_26\
    \ = primes_count / 26;\n    let mut primes_count_27 = primes_count / 27;\n   \
    \ let mut primes_count_28 = primes_count / 28;\n    let mut primes_count_29 =\
    \ primes_count / 29;\n    let mut primes_count_30 = primes_count / 30;\n    let\
    \ mut primes_count_31 = primes_count / 31;\n    let mut primes_count_32 = primes_count\
    \ / 32;\n    let mut primes_count_33\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp717ippug.rs:57:28\n   |\n\
    57 |     let mut primes_count_33\n   |                            ^ help: add\
    \ `;` here\n58 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp717ippug.rs:22:28\n   |\n22 | fn hex_key(num: String) -> isize\
    \ {\n   |    -------                 ^^^^^ expected `isize`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748839
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut counter: usize\
    \ = 0;\n    let mut prime_counter: usize = 0;\n    let mut prime_counter2: usize\
    \ = 0;\n    let mut prime_counter3: usize = 0;\n    let mut prime_counter4: usize\
    \ = 0;\n    let mut prime_counter5: usize = 0;\n    let mut prime_counter6: usize\
    \ = 0;\n    let mut prime_counter7: usize = 0;\n    let mut prime_counter8: usize\
    \ = 0;\n    let mut prime_counter9: usize = 0;\n    let mut prime_counter10: usize\
    \ = 0;\n    let mut prime_counter11: usize = 0;\n    let mut prime_counter12:\
    \ usize = 0;\n    let mut prime_counter13: usize = 0;\n    let mut prime_counter14:\
    \ usize = 0;\n    let mut prime_counter15: usize = 0;\n    let mut prime_counter16:\
    \ usize = 0;\n    let mut prime_counter17: usize = 0;\n    let mut prime_counter18:\
    \ usize = 0;\n    let mut prime_counter19: usize = 0;\n    let mut prime_counter20:\
    \ usize = 0;\n    let mut prime_counter21: usize = 0;\n    let mut prime_counter22:\
    \ usize = 0;\n    let mut prime_counter23: usize = 0;\n    let mut prime_counter24:\
    \ usize = 0;\n    let mut prime_counter25: usize = 0;\n    let mut prime_counter26:\
    \ usize = 0;\n    let mut prime_counter27: usize = 0;\n    let mut prime_counter28:\
    \ usize = 0;\n    let mut prime_counter29: usize = 0;\n    let mut prime_counter30:\
    \ usize = 0;\n    let mut prime_counter31: usize = 0;\n    let mut prime_counter32:\
    \ usize = 0;\n    let mut prime_counter33: usize = 0;\n    let mut prime_counter34:\
    \ usize = 0;\n    let mut prime_counter35: usize = 0;\n    let mut prime_counter36:\
    \ usize = 0;\n    let mut prime_counter37: usize = 0;\n\n}\n\nfn main() {\n  \
    \  let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmps9y6fyxe.rs:23:55\n     |\n23\
    \   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |\
    \                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps9y6fyxe.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: isize = 0;\n    let mut digit: isize = 0;\n    let\
    \ mut prime: isize = 0;\n    let mut prime_found = false;\n    let mut prime_found2\
    \ = false;\n    let mut prime_found3 = false;\n    let mut prime_found4 = false;\n\
    \    let mut prime_found5 = false;\n    let mut prime_found6 = false;\n    let\
    \ mut prime_found7 = false;\n    let mut prime_found8 = false;\n    let mut prime_found9\
    \ = false;\n    let mut prime_found10 = false;\n    let mut prime_found11 = false;\n\
    \    let mut prime_found12 = false;\n    let mut prime_found13 = false;\n    let\
    \ mut prime_found14 = false;\n    let mut prime_found15 = false;\n    let mut\
    \ prime_found16 = false;\n    let mut prime_found17 = false;\n    let mut prime_found18\
    \ = false;\n    let mut prime_found19 = false;\n    let mut prime_found20 = false;\n\
    \    let mut prime_found21 = false;\n    let mut prime_found22 = false;\n    let\
    \ mut prime_found23 = false;\n    let mut prime_found24 = false;\n    let mut\
    \ prime_found25 = false;\n    let mut prime_found26 = false;\n    let mut prime_found27\
    \ = false;\n    let mut prime_found28 = false;\n    let mut prime_found29 = false;\n\
    \    let mut prime_found30 = false;\n    let mut prime_found31 = false;\n    let\
    \ mut prime_found32 = false;\n    let mut prime_found33 = false;\n    let mut\
    \ prime_found34 = false;\n    let mut prime_found35 = false;\n    let mut prime_found36\
    \ = false;\n    let mut prime_found37 = false;\n    let mut prime_found38 = false;\n\
    \    let mut prime_found39 = false;\n    let mut prime_found40 = false;\n    let\
    \ mut prime_found41 = false;\n    let mut prime_found42 = false;\n    let mut\
    \ prime_found43 = false;\n    let mut prime_found44 = false;\n    let mut prime_found45\
    \ = false;\n    let mut prime_found46 = false;\n    let mut prime_found47 = false;\n\
    \    let mut prime_found48 = false;\n    let mut prime_found49 = false;\n    let\
    \ mut prime_found50 = false;\n    let mut prime_found51 = false;\n    let mut\
    \ prime_found52 = false;\n    let mut prime_found53 = false;\n\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp15xefq2_.rs:22:28\n   |\n\
    22 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748839
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num_prime: Vec<u8> = num.to_string().chars().collect();\n    let mut\
    \ num_prime_prime: Vec<u8> = num.to_string().chars().collect();\n    let mut num_prime_prime_prime:\
    \ Vec<u8> = num.to_string().chars().collect();\n    let mut num_prime_prime_prime_prime:\
    \ Vec<u8> = num.to_string().chars().collect();\n    let mut num_prime_prime_prime_prime_prime:\
    \ Vec<u8> = num.to_string().chars().collect();\n    let mut num_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = num.to_string().chars().collect();\n    let mut num_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = num.to_string().chars().collect();\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = num.to_string().chars().collect();\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = num.to_string().chars().collect();\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = num.to_string().chars().collect();\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = num.to_string().chars().collect();\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = num.to_string().chars().collect();\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = num.to_string().chars().collect();\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = num.to_string().chars().collect();\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = num.to_string().chars().collect();\n    let mut num_prime\n}\n\nfn\
    \ main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_qdhc19t.rs:39:22\n   |\n\
    39 |     let mut num_prime\n   |                      ^ help: add `;` here\n40\
    \ | }\n   | - unexpected token\n\nerror[E0599]: the method `to_string` exists\
    \ for struct `Vec<u8>`, but its trait bounds were not satisfied\n   --> /tmp/tmp_qdhc19t.rs:24:38\n\
    \    |\n24  |       let mut num_prime: Vec<u8> = num.to_string().chars().collect();\n\
    \    |                                        ^^^^^^^^^ method cannot be called\
    \ on `Vec<u8>` due to unsatisfied trait bounds\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Vec<u8>: std::fmt::Display`\n\
    \            which is required by `Vec<u8>: ToString`\n            `[u8]: std::fmt::Display`\n\
    \            which is required by `[u8]: ToString`\n\nerror[E0277]: a value of\
    \ type `Vec<u8>` cannot be built from an iterator over elements of type `char`\n\
    \  --> /tmp/tmp_qdhc19t.rs:23:52\n   |\n23 |     let mut num: Vec<u8> = num.to_string().chars().collect();\n\
    \   |                                                    ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0599]:\
    \ the method `to_string` exists for struct `Vec<u8>`, but its trait bounds were\
    \ not satisfied\n   --> /tmp/tmp_qdhc19t.rs:25:44\n    |\n25  |       let mut\
    \ num_prime_prime: Vec<u8> = num.to_string().chars().collect();\n    |       \
    \                                       ^^^^^^^^^ method cannot be called on `Vec<u8>`\
    \ due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds\
    \ were not satisfied:\n            `Vec<u8>: std::fmt::Display`\n            which\
    \ is required by `Vec<u8>: ToString`\n            `[u8]: std::fmt::Display`\n\
    \            which is required by `[u8]: ToString`\n\nerror[E0599]: the method\
    \ `to_string` exists for struct `Vec<u8>`, but its trait bounds were not satisfied\n\
    \   --> /tmp/tmp_qdhc19t.rs:26:50\n    |\n26  |       let mut num_prime_prime_prime:\
    \ Vec<u8> = num.to_string().chars().collect();\n    |         "
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut nums = num.to_string().chars().collect::<Vec<_>>();\n \
    \   let mut nums_iter = nums.iter();\n    let mut num_digits = nums.len();\n \
    \   let mut num_primes = 0;\n    let mut num_primes_iter = 0;\n    let mut num_primes_iter_prime\
    \ = 0;\n    let mut num_primes_iter_prime_prime = 0;\n    let mut num_primes_iter_prime_prime_prime\
    \ = 0;\n    let mut num_primes_iter_prime_prime_prime_prime = 0;\n    let mut\
    \ num_primes_iter_prime_prime_prime_prime_prime = 0;\n    let mut num_primes_iter_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_iter_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_iter_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_iter_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_iter_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_iter_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_iter_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_iter_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_iter_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_iter_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_iter_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_iter_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_iter_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_iter_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_iter_prime_prime_prime_prime_prime_prime_prime_prime_\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp1w0pkh6w.rs:47:77\n   |\n\
    47 |     let mut num_primes_iter_prime_prime_prime_prime_prime_prime_prime_prime_\n\
    \   |                                                                        \
    \     ^ help: add `;` here\n48 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1w0pkh6w.rs:22:28\n   |\n22 | fn hex_key(num: String) ->\
    \ isize {\n   |    -------                 ^^^^^ expected `isize`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748839
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_digits = num.len();\n    let mut prime_digits = false;\n    let\
    \ mut prime_count = 0;\n    let mut prime_digit = -1;\n    let mut prime_digit_count\
    \ = 0;\n    let mut prime_digit_index = 0;\n    let mut prime_digit_index2 = 0;\n\
    \    let mut prime_digit_index3 = 0;\n    let mut prime_digit_index4 = 0;\n  \
    \  let mut prime_digit_index5 = 0;\n    let mut prime_digit_index6 = 0;\n    let\
    \ mut prime_digit_index7 = 0;\n    let mut prime_digit_index8 = 0;\n    let mut\
    \ prime_digit_index9 = 0;\n    let mut prime_digit_index10 = 0;\n    let mut prime_digit_index11\
    \ = 0;\n    let mut prime_digit_index12 = 0;\n    let mut prime_digit_index13\
    \ = 0;\n    let mut prime_digit_index14 = 0;\n    let mut prime_digit_index15\
    \ = 0;\n    let mut prime_digit_index16 = 0;\n    let mut prime_digit_index17\
    \ = 0;\n    let mut prime_digit_index18 = 0;\n    let mut prime_digit_index19\
    \ = 0;\n    let mut prime_digit_index20 = 0;\n    let mut prime_digit_index21\
    \ = 0;\n    let mut prime_digit_index22 = 0;\n    let mut prime_digit_index23\
    \ = 0;\n    let mut prime_digit_index24 = 0;\n    let mut prime_digit_index25\
    \ = 0;\n    let mut prime_digit_index26 = 0;\n    let mut prime_digit_index27\
    \ = 0;\n    let mut prime_digit_index28 = 0;\n    let mut prime_digit_index29\
    \ = 0;\n    let mut prime_digit_index30 = 0;\n    let mut prime_digit_index31\
    \ = 0;\n    let mut prime_digit_index32 = 0;\n    let mut prime_digit_index33\
    \ = 0;\n    let mut prime_digit_index34 = 0;\n    let mut prime_digit_index35\
    \ = 0;\n    let mut prime_digit_index36 = 0;\n    let mut prime_digit_index37\
    \ = 0;\n    let mut prime_digit_index38 = 0;\n    let mut prime_digit_index39\
    \ = 0;\n    let mut prime_digit_index40 = 0;\n    let mut prime_digit_index41\
    \ = 0;\n    let mut prime_digit_index42 = 0;\n    let mut prime_digit_index43\
    \ = 0;\n    let mut prime_digit_index44 = 0;\n    let mut prime_digit_index45\
    \ = 0;\n    let mut prime\n}\n\nfn main() {\n    let candidate = hex_key;\n  \
    \  assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpob_raopa.rs:74:18\n   |\n\
    74 |     let mut prime\n   |                  ^ help: add `;` here\n75 | }\n \
    \  | - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built\
    \ from an iterator over elements of type `char`\n  --> /tmp/tmpob_raopa.rs:23:55\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpob_raopa.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748839
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_digits: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_sum = 0;\n    let mut prime_digits_product\
    \ = 1;\n    let mut prime_digits_product2 = 0;\n    let mut prime_digits_product3\
    \ = 0;\n    let mut prime_digits_product4 = 0;\n    let mut prime_digits_product5\
    \ = 0;\n    let mut prime_digits_product6 = 0;\n    let mut prime_digits_product7\
    \ = 0;\n    let mut prime_digits_product8 = 0;\n    let mut prime_digits_product9\
    \ = 0;\n    let mut prime_digits_product10 = 0;\n    let mut prime_digits_product11\
    \ = 0;\n    let mut prime_digits_product12 = 0;\n    let mut prime_digits_product13\
    \ = 0;\n    let mut prime_digits_product14 = 0;\n    let mut prime_digits_product15\
    \ = 0;\n    let mut prime_digits_product16 = 0;\n    let mut prime_digits_product17\
    \ = 0;\n    let mut prime_digits_product18 = 0;\n    let mut prime_digits_product19\
    \ = 0;\n    let mut prime_digits_product20 = 0;\n    let mut prime_digits_product21\
    \ = 0;\n    let mut prime_digits_product22 = 0;\n    let mut prime_digits_product23\
    \ = 0;\n    let mut prime_digits_product24 = 0;\n    let mut prime_digits_product25\
    \ = 0;\n    let mut prime_digits_product26 = 0;\n    let mut prime_digits_product27\
    \ = 0;\n    let mut prime_digits_product28 = 0;\n    let mut prime_digits_product29\
    \ = 0;\n    let mut prime_digits_product30 = 0;\n    let mut prime_digits_product31\
    \ = 0;\n    let mut prime_digits_product32 = 0;\n    let mut prime_digits_product33\
    \ = 0;\n    let mut prime_digits_product34 = 0;\n    let mut prime_digits_product35\
    \ = 0;\n    let mut prime_digits_product36 = 0;\n    let mut prime_digits_product37\
    \ = 0;\n    let mut prime_digits_product38 = 0;\n    let mut prime_digits_product39\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpabubfl56.rs:65:35\n   |\n\
    65 |     let mut prime_digits_product39\n   |                                \
    \   ^ help: add `;` here\n66 | }\n   | - unexpected token\n\nerror[E0277]: a value\
    \ of type `Vec<u8>` cannot be built from an iterator over elements of type `char`\n\
    \  --> /tmp/tmpabubfl56.rs:23:55\n   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpabubfl56.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748839
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut nums = num.chars().collect::<Vec<_>>();\n    let mut primes\
    \ = vec![true; 16];\n    let mut primes_counter = 0;\n    let mut primes_counter2\
    \ = 0;\n    let mut primes_counter3 = 0;\n    let mut primes_counter4 = 0;\n \
    \   let mut primes_counter5 = 0;\n    let mut primes_counter6 = 0;\n    let mut\
    \ primes_counter7 = 0;\n    let mut primes_counter8 = 0;\n    let mut primes_counter9\
    \ = 0;\n    let mut primes_counter10 = 0;\n    let mut primes_counter11 = 0;\n\
    \    let mut primes_counter12 = 0;\n    let mut primes_counter13 = 0;\n    let\
    \ mut primes_counter14 = 0;\n    let mut primes_counter15 = 0;\n    let mut primes_counter16\
    \ = 0;\n    let mut primes_counter17 = 0;\n    let mut primes_counter18 = 0;\n\
    \    let mut primes_counter19 = 0;\n    let mut primes_counter20 = 0;\n    let\
    \ mut primes_counter21 = 0;\n    let mut primes_counter22 = 0;\n    let mut primes_counter23\
    \ = 0;\n    let mut primes_counter24 = 0;\n    let mut primes_counter25 = 0;\n\
    \    let mut primes_counter26 = 0;\n    let mut primes_counter27 = 0;\n    let\
    \ mut primes_counter28 = 0;\n    let mut primes_counter29 = 0;\n    let mut primes_counter30\
    \ = 0;\n    let mut primes_counter31 = 0;\n    let mut primes_counter32 = 0;\n\
    \    let mut primes_counter33 = 0;\n    let mut primes_counter34 = 0;\n    let\
    \ mut primes_counter35 = 0;\n    let mut primes_counter36 = 0;\n    let mut primes_counter37\
    \ = 0;\n    let mut primes_counter38 = 0;\n    let mut primes_counter39 = 0;\n\
    \    let mut primes_counter40 = 0;\n    let mut primes_counter41 = 0;\n    let\
    \ mut primes_counter42 = 0;\n    let mut primes_counter43 = 0;\n    let mut primes_counter44\
    \ = 0;\n    let mut primes_counter45 = 0;\n    let mut primes_counter46 = 0;\n\
    \    let mut primes_counter47 = 0;\n    let mut primes_counter48 = 0;\n    let\
    \ mut primes_counter49 = 0;\n    let mut primes_counter50 = 0;\n    let mut primes_counter51\
    \ = 0;\n    let mut primes_counter52 = 0;\n    let mut primes_counter53 = 0;\n\
    \    let mut primes_counter54 = 0;\n    let mu\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpbqxngtyk.rs:79:11\n   |\n\
    79 |     let mu\n   |           ^ help: add `;` here\n80 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbqxngtyk.rs:22:28\n \
    \  |\n22 | fn hex_key(num: String) -> isize {\n   |    -------               \
    \  ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748839
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: isize = 0;\n    let mut num_digits = num.len();\n\
    \    let mut num_digits_div2 = 0;\n    let mut num_digits_div3 = 0;\n    let mut\
    \ num_digits_div4 = 0;\n    let mut num_digits_div5 = 0;\n    let mut num_digits_div6\
    \ = 0;\n    let mut num_digits_div7 = 0;\n    let mut num_digits_div8 = 0;\n \
    \   let mut num_digits_div9 = 0;\n    let mut num_digits_div10 = 0;\n    let mut\
    \ num_digits_div11 = 0;\n    let mut num_digits_div12 = 0;\n    let mut num_digits_div13\
    \ = 0;\n    let mut num_digits_div14 = 0;\n    let mut num_digits_div15 = 0;\n\
    \    let mut num_digits_div16 = 0;\n    let mut num_digits_div17 = 0;\n    let\
    \ mut num_digits_div18 = 0;\n    let mut num_digits_div19 = 0;\n    let mut num_digits_div20\
    \ = 0;\n    let mut num_digits_div21 = 0;\n    let mut num_digits_div22 = 0;\n\
    \    let mut num_digits_div23 = 0;\n    let mut num_digits_div24 = 0;\n    let\
    \ mut num_digits_div25 = 0;\n    let mut num_digits_div26 = 0;\n    let mut num_digits_div27\
    \ = 0;\n    let mut num_digits_div28 = 0;\n    let mut num_digits_div29 = 0;\n\
    \    let mut num_digits_div30 = 0;\n    let mut num_digits_div31 = 0;\n    let\
    \ mut num_digits_div32 = 0;\n    let mut num_digits_div33 = 0;\n    let mut num_digits_div34\
    \ = 0;\n    let mut num_digits_div35 = 0;\n    let mut num_digits_div36 = 0;\n\
    \    let mut num_digits_div37 = 0;\n    let mut num_digits_div38 = 0;\n    let\
    \ mut num_digits_div39 = 0;\n    let mut num_digits_div40 = 0;\n    let mut num_digits_div41\
    \ = 0;\n    let mut num_digits_div42 = 0;\n    let mut num_digits_div43 = 0;\n\
    \    let mut num_digits_div44 = 0;\n    let mut num_digits_div45 = 0;\n    let\
    \ mut num_digits_div46 = 0;\n    let mut num_digits_div47 = 0;\n    let mut num_digits_div48\
    \ = 0;\n    let mut num_digits_div49 = 0;\n    let mut num_digits_div50 = 0;\n\
    \    let mut num_digits_\n}\n\nfn main() {\n    let candidate = hex_key;\n   \
    \ assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8ky68ohn.rs:74:24\n   |\n\
    74 |     let mut num_digits_\n   |                        ^ help: add `;` here\n\
    75 | }\n   | - unexpected token\n\nerror[E0599]: no method named `len` found for\
    \ type `isize` in the current scope\n  --> /tmp/tmp8ky68ohn.rs:24:30\n   |\n24\
    \ |     let mut num_digits = num.len();\n   |                              ^^^\
    \ method not found in `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8ky68ohn.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748839
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut nums = num.chars().collect::<Vec<_>>();\n    let mut primes\
    \ = vec![false; 26];\n    let mut primes_counter = vec![0; 26];\n    let mut primes_counter2\
    \ = vec![0; 26];\n    let mut primes_counter3 = vec![0; 26];\n    let mut primes_counter4\
    \ = vec![0; 26];\n    let mut primes_counter5 = vec![0; 26];\n    let mut primes_counter6\
    \ = vec![0; 26];\n    let mut primes_counter7 = vec![0; 26];\n    let mut primes_counter8\
    \ = vec![0; 26];\n    let mut primes_counter9 = vec![0; 26];\n    let mut primes_counter10\
    \ = vec![0; 26];\n    let mut primes_counter11 = vec![0; 26];\n    let mut primes_counter12\
    \ = vec![0; 26];\n    let mut primes_counter13 = vec![0; 26];\n    let mut primes_counter14\
    \ = vec![0; 26];\n    let mut primes_counter15 = vec![0; 26];\n    let mut primes_counter16\
    \ = vec![0; 26];\n    let mut primes_counter17 = vec![0; 26];\n    let mut primes_counter18\
    \ = vec![0; 26];\n    let mut primes_counter19 = vec![0; 26];\n    let mut primes_counter20\
    \ = vec![0; 26];\n    let mut primes_counter21 = vec![0; 26];\n    let mut primes_counter22\
    \ = vec![0; 26];\n    let mut primes_counter23 = vec![0; 26];\n    let mut primes_counter24\
    \ = vec![0; 26];\n    let mut primes_counter25 = vec![0; 26];\n    let mut primes_counter26\
    \ = vec![0; 26];\n    let mut primes_counter27 = vec![0; 26];\n    let mut primes_counter28\
    \ = vec![0; 26];\n    let mut primes_counter29 = vec![0; 26];\n    let mut primes_counter30\
    \ = vec![0; 26];\n    let mut primes_counter31 = vec![0; 26];\n    let mut primes_counter32\
    \ = vec![0; 26];\n    let mut primes_counter33 = vec![0; 26];\n    let mut primes_counter34\
    \ = vec![0; 26];\n    let mut primes_counter35 = vec![0; 26];\n    let mut primes_\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwp6b313p.rs:60:20\n   |\n\
    60 |     let mut primes_\n   |                    ^ help: add `;` here\n61 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwp6b313p.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748839
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let mut\
    \ num_prime_prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let mut num_prime_prime_prime:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let mut num_prime_prime_prime_prime:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let mut num_prime_prime_prime_prime_prime:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let mut num_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let mut num_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmphn3wqqmd.rs:38:88\n   |\n\
    38 |     let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\n\
    \   |                                                                        \
    \                ^ help: add `;` here\n39 | }\n   | - unexpected token\n\nerror[E0277]:\
    \ a value of type `Vec<u8>` cannot be built from an iterator over elements of\
    \ type `char`\n  --> /tmp/tmphn3wqqmd.rs:23:55\n   |\n23 |     let mut num: Vec<u8>\
    \ = num.to_lowercase().chars().collect();\n   |                              \
    \                         ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n   |\n   = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphn3wqqmd.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748839
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut count: usize = 0;\n    let mut prime: usize = 2;\n    let mut prime_found\
    \ = false;\n    let mut prime_found2 = false;\n    let mut prime_found3 = false;\n\
    \    let mut prime_found4 = false;\n    let mut prime_found5 = false;\n    let\
    \ mut prime_found6 = false;\n    let mut prime_found7 = false;\n    let mut prime_found8\
    \ = false;\n    let mut prime_found9 = false;\n    let mut prime_found10 = false;\n\
    \    let mut prime_found11 = false;\n    let mut prime_found12 = false;\n    let\
    \ mut prime_found13 = false;\n    let mut prime_found14 = false;\n    let mut\
    \ prime_found15 = false;\n    let mut prime_found16 = false;\n    let mut prime_found17\
    \ = false;\n    let mut prime_found18 = false;\n    let mut prime_found19 = false;\n\
    \    let mut prime_found20 = false;\n    let mut prime_found21 = false;\n    let\
    \ mut prime_found22 = false;\n    let mut prime_found23 = false;\n    let mut\
    \ prime_found24 = false;\n    let mut prime_found25 = false;\n    let mut prime_found26\
    \ = false;\n    let mut prime_found27 = false;\n    let mut prime_found28 = false;\n\
    \    let mut prime_found29 = false;\n    let mut prime_found30 = false;\n    let\
    \ mut prime_found31 = false;\n    let mut prime_found32 = false;\n    let mut\
    \ prime_found33 = false;\n    let mut prime_found34 = false;\n    let mut prime_found35\
    \ = false;\n    let mut prime_found36 = false;\n    let mut prime_found37 = false;\n\
    \    let mut prime_found38 = false;\n    let mut prime_found39 = false;\n    let\
    \ mut prime_found40 = false;\n    let mut prime_found41 = false;\n    let mut\
    \ prime_found42 = false;\n    let mut prime_found43 = false;\n    let mut prime_found44\
    \ = false;\n    let mut prime_found45 = false;\n    let mut prime_found46 = false;\n\
    \    let mut prime_found47 = false;\n    let mut prime_found48 = false;\n    let\
    \ mut prime_found49 = false;\n    let mut prime_found50 = false;\n    let mut\
    \ prime_found51 = false;\n    let mut prime_found52 = false;\n    let \n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp8y2orenz.rs:79:1\n  \
    \ |\n79 | }\n   | ^ expected pattern\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n  --> /tmp/tmp8y2orenz.rs:23:55\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748837
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpgxfk7iy6.rs:40:36\n   |\n\
    40 |     let mut num: Vec<u8> = num.iter\n   |                               \
    \     ^ help: add `;` here\n41 | }\n   | - unexpected token\n\nerror[E0277]: a\
    \ value of type `Vec<u8>` cannot be built from an iterator over elements of type\
    \ `char`\n  --> /tmp/tmpgxfk7iy6.rs:23:55\n   |\n23 |     let mut num: Vec<u8>\
    \ = num.to_lowercase().chars().collect();\n   |                              \
    \                         ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n   |\n   = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgxfk7iy6.rs:24:56\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <=\
    \ '9').collect();\n   |                                                      \
    \  ^^^ expected `&u8`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgxfk7iy6.rs:24:68\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <=\
    \ '9').collect();\n   |                                                      \
    \              ^^^ expected `&u8`, found `char`\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `&u8`\n  -->\
    \ /tmp/tmpgxfk7iy6.rs:24:73\n   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&x|\
    \ x >= '0' && x <= '9').collect();\n   |                                     \
    \                                    ^^^^^^^ value of type `Vec<u8>` cannot be\
    \ built from `std::iter::Iterator<Item=&u8>`\n   |\n   = help: the trait `FromIterator<&u8>`\
    \ is not implemented for `Vec<u8>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgxfk7iy6.rs:25:56\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <=\
    \ 'F').collect();\n   |                                                      \
    \  ^^^ expected `&u8`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgxfk7iy6.rs:25:68\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <=\
    \ 'F').collect();\n   |                     "
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.in\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found keyword `in`\n  --> /tmp/tmpsxpv55i4.rs:39:32\n\
    \   |\n39 |     let mut num: Vec<u8> = num.in\n   |                          \
    \      ^^ expected identifier, found keyword\n   |\nhelp: escape `in` to use it\
    \ as an identifier\n   |\n39 |     let mut num: Vec<u8> = num.r#in\n   |     \
    \                           ++\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpsxpv55i4.rs:39:34\n\
    \   |\n39 |     let mut num: Vec<u8> = num.in\n   |                          \
    \        ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0277]:\
    \ a value of type `Vec<u8>` cannot be built from an iterator over elements of\
    \ type `char`\n    --> /tmp/tmpsxpv55i4.rs:23:52\n     |\n23   |     let mut num:\
    \ Vec<u8> = num.to_string().chars().collect();\n     |                       \
    \                             ^^^^^^^ value of type `Vec<u8>` cannot be built\
    \ from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsxpv55i4.rs:24:61\n   |\n24 |     let mut num:\
    \ Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n   |\
    \                                                             ^^^ expected `u8`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsxpv55i4.rs:24:73\n\
    \   |\n24 |     let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' &&\
    \ x <= '9').collect();\n   |                                                 \
    \                        ^^^ expected `u8`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpsxpv55i4.rs:25:61\n   |\n25 |     let mut num: Vec<u8>\
    \ = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n   |       \
    \                                                      ^^^ expected `u8`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsxpv55i4.rs:25:73\n\
    \   |\n25 |     let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' &&\
    \ x <= 'F').collect();\n   |              "
  stdout: ''
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_digits: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let\
    \ mut prime_digit_count: Vec<u8> = vec![0, 0, 0, 0];\n    let mut prime_digit_count:\
    \ Vec<u8> = vec![0, 0, 0, 0];\n    let mut prime_digit_count: Vec<u8> = vec![0,\
    \ 0, 0, 0];\n    let mut prime_digit_count: Vec<u8> = vec![0, 0, 0, 0];\n    let\
    \ mut prime_digit_count: Vec<u8> = vec![0, 0, 0, 0];\n    let mut prime_digit_count:\
    \ Vec<u8> = vec![0, 0, 0, 0];\n    let mut prime_digit_count: Vec<u8> = vec![0,\
    \ 0, 0, 0];\n    let mut prime_digit_count: Vec<u8> = vec![0, 0, 0, 0];\n    let\
    \ mut prime_digit_count: Vec<u8> = vec![0, 0, 0, 0];\n    let mut prime_digit_count:\
    \ Vec<u8> = vec![0, 0, 0, 0];\n    let mut prime_digit_count: Vec<u8> = vec![0,\
    \ 0, 0, 0];\n    let mut prime_digit_count: Vec<u8> = vec![0, 0, 0, 0];\n    let\
    \ mut prime_digit_count: Vec<u8> = vec![0, 0, 0, 0];\n    let mut prime_digit_count:\
    \ Vec<u8> = vec![0, 0, 0, 0];\n    let mut prime_digit_count: Vec<u8> = vec![0,\
    \ 0, 0, 0];\n    let mut prime_digit_count: Vec<u8> = vec![0, 0, 0, 0];\n    let\
    \ mut prime_digit_count: Vec<u8> = vec![0, 0, 0, 0];\n    let mut prime_digit_count:\
    \ Vec<u8> = vec![0, 0, 0, 0];\n    let mut prime_digit_count: Vec<u8> = vec![0,\
    \ 0, 0, 0];\n    let mut prime_digit_count: Vec<u8> = vec![0, 0, 0, 0];\n    let\
    \ mut prime_digit_count: Vec<u8> = vec![0, 0, 0, 0];\n    let mut prime_digit_count:\
    \ Vec<u8> = vec![0, 0, 0, 0];\n    let mut prime_digit_count: Vec<u8> = vec![0,\
    \ 0, 0, 0];\n    let mut prime_digit_count: Vec<u8> = vec![0, 0, 0, 0];\n    let\
    \ mut prime_digit_count: Vec<u8> = vec![0, 0, 0, 0];\n    let mut prime_digit_count:\
    \ Vec<u8> = vec![0, 0, 0, 0];\n    let mu\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpmv2svm_6.rs:51:11\n   |\n\
    51 |     let mu\n   |           ^ help: add `;` here\n52 | }\n   | - unexpected\
    \ token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n  --> /tmp/tmpmv2svm_6.rs:23:55\n   |\n23 |  \
    \   let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n   |       \
    \                                                ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the\
    \ trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmv2svm_6.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748839
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.in\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found keyword `in`\n  --> /tmp/tmpsxpv55i4.rs:39:32\n\
    \   |\n39 |     let mut num: Vec<u8> = num.in\n   |                          \
    \      ^^ expected identifier, found keyword\n   |\nhelp: escape `in` to use it\
    \ as an identifier\n   |\n39 |     let mut num: Vec<u8> = num.r#in\n   |     \
    \                           ++\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpsxpv55i4.rs:39:34\n\
    \   |\n39 |     let mut num: Vec<u8> = num.in\n   |                          \
    \        ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0277]:\
    \ a value of type `Vec<u8>` cannot be built from an iterator over elements of\
    \ type `char`\n    --> /tmp/tmpsxpv55i4.rs:23:52\n     |\n23   |     let mut num:\
    \ Vec<u8> = num.to_string().chars().collect();\n     |                       \
    \                             ^^^^^^^ value of type `Vec<u8>` cannot be built\
    \ from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsxpv55i4.rs:24:61\n   |\n24 |     let mut num:\
    \ Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n   |\
    \                                                             ^^^ expected `u8`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsxpv55i4.rs:24:73\n\
    \   |\n24 |     let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' &&\
    \ x <= '9').collect();\n   |                                                 \
    \                        ^^^ expected `u8`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpsxpv55i4.rs:25:61\n   |\n25 |     let mut num: Vec<u8>\
    \ = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n   |       \
    \                                                      ^^^ expected `u8`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsxpv55i4.rs:25:73\n\
    \   |\n25 |     let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' &&\
    \ x <= 'F').collect();\n   |              "
  stdout: ''
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpmcimx23o.rs:38:50\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |                         \
    \         - closing delimiter possibly meant for this\n...\n38 |     let mut num:\
    \ Vec<u8> = num.into_iter().filter(\n   |                                    \
    \              ^ unclosed delimiter\n39 | }\n   | ^ mismatched closing delimiter\n\
    \nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n  -->\
    \ /tmp/tmpmcimx23o.rs:39:1\n   |\n39 | }\n   | ^ expected one of `.`, `;`, `?`,\
    \ `else`, or an operator\n\nerror[E0277]: a value of type `Vec<u8>` cannot be\
    \ built from an iterator over elements of type `char`\n  --> /tmp/tmpmcimx23o.rs:23:52\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_string().chars().collect();\n  \
    \ |                                                    ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the\
    \ trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmcimx23o.rs:24:61\n   |\n24 |     let mut num:\
    \ Vec<u8> = num.into_iter().filter(|&c| c >= '0' && c <= '9').collect();\n   |\
    \                                                             ^^^ expected `u8`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmcimx23o.rs:24:73\n\
    \   |\n24 |     let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= '0' &&\
    \ c <= '9').collect();\n   |                                                 \
    \                        ^^^ expected `u8`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpmcimx23o.rs:25:61\n   |\n25 |     let mut num: Vec<u8>\
    \ = num.into_iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n   |       \
    \                                                      ^^^ expected `u8`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmcimx23o.rs:25:73\n\
    \   |\n25 |     let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= 'A' &&\
    \ c <= 'F').collect();\n   |                                                 \
    \                        ^^^ expected `u8`, found `char`\n\nerr"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num_digits = num.len();\n    let mut num_primes = 0;\n    let mut num_primes_digits\
    \ = 0;\n    let mut num_primes_digits_prime = 0;\n    let mut num_primes_digits_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime = 0;\n    let mut num_primes_digits_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime = 0;\n   \
    \ let mut num_primes_digits_prime_prime_prime_prime_prime_prime = 0;\n    let\
    \ mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime = 0;\n    let\
    \ mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime = 0;\n\
    \    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpyriqk0g7.rs:45:103\n   |\n\
    45 |     let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_\n\
    \   |                                                                        \
    \                               ^ help: add `;` here\n46 | }\n   | - unexpected\
    \ token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n  --> /tmp/tmpyriqk0g7.rs:23:52\n   |\n23 |  \
    \   let mut num: Vec<u8> = num.to_string().chars().collect();\n   |          \
    \                                          ^^^^^^^ value of type `Vec<u8>` cannot\
    \ be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyriqk0g7.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748839
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut nums = num.chars().collect::<Vec<_>>();\n    let mut num_primes\
    \ = 0;\n    let mut num_primes_found = 0;\n    let mut num_primes_found2 = 0;\n\
    \    let mut num_primes_found3 = 0;\n    let mut num_primes_found4 = 0;\n    let\
    \ mut num_primes_found5 = 0;\n    let mut num_primes_found6 = 0;\n    let mut\
    \ num_primes_found7 = 0;\n    let mut num_primes_found8 = 0;\n    let mut num_primes_found9\
    \ = 0;\n    let mut num_primes_found10 = 0;\n    let mut num_primes_found11 =\
    \ 0;\n    let mut num_primes_found12 = 0;\n    let mut num_primes_found13 = 0;\n\
    \    let mut num_primes_found14 = 0;\n    let mut num_primes_found15 = 0;\n  \
    \  let mut num_primes_found16 = 0;\n    let mut num_primes_found17 = 0;\n    let\
    \ mut num_primes_found18 = 0;\n    let mut num_primes_found19 = 0;\n    let mut\
    \ num_primes_found20 = 0;\n    let mut num_primes_found21 = 0;\n    let mut num_primes_found22\
    \ = 0;\n    let mut num_primes_found23 = 0;\n    let mut num_primes_found24 =\
    \ 0;\n    let mut num_primes_found25 = 0;\n    let mut num_primes_found26 = 0;\n\
    \    let mut num_primes_found27 = 0;\n    let mut num_primes_found28 = 0;\n  \
    \  let mut num_primes_found29 = 0;\n    let mut num_primes_found30 = 0;\n    let\
    \ mut num_primes_found31 = 0;\n    let mut num_primes_found32 = 0;\n    let mut\
    \ num_primes_found33 = 0;\n    let mut num_primes_found34 = 0;\n    let mut num_primes_found35\
    \ = 0;\n    let mut num_primes_found36 = 0;\n    let mut num_primes_found37 =\
    \ 0;\n    let mut num_primes_found38 = 0;\n    let mut num_primes_found39 = 0;\n\
    \    let mut num_primes_found40 = 0;\n    let mut num_primes_found41 = 0;\n  \
    \  let mut num_primes_found42 = 0;\n    let mut num_primes_found43 = 0;\n    let\
    \ mut num_primes_found44 = 0;\n    let mut num_primes_found45 = 0;\n    let mut\
    \ num_primes_found46 = 0;\n    let mut num_primes_found47 = 0;\n    let mut num_primes_found48\
    \ = 0;\n    let mut num_primes_found49 = 0;\n    let mut \n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp1cacbsf9.rs:75:1\n\
    \   |\n75 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748839
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut count: usize = 0;\n    let mut prime: usize = 2;\n    let mut prime_found\
    \ = false;\n    while !num.is_empty() {\n        let mut digit: u8 = 0;\n    \
    \    let mut is_prime = true;\n        for &c in num {\n            if c >= '0'\
    \ && c <= '9' {\n                digit += c - '0';\n            } else {\n   \
    \             is_prime = false;\n                break;\n            }\n     \
    \   }\n        if is_prime {\n            prime_found = true;\n        }\n   \
    \     if prime == 2 {\n            if digit == 2 {\n                prime = 2;\n\
    \            }\n        }\n        if prime == 3 {\n            if digit == 3\
    \ {\n                prime = 3;\n            }\n        }\n        if prime ==\
    \ 5 {\n            if digit == 5 {\n                prime = 5;\n            }\n\
    \        }\n        if prime == 7 {\n            if digit == 7 {\n           \
    \     prime = 7;\n            }\n        }\n        if prime == 11 {\n       \
    \     if digit == 11 {\n                prime = 11;\n            }\n        }\n\
    \        if prime == 13 {\n            if digit == 13 {\n                prime\
    \ = 13;\n            }\n        }\n        if prime == 17 {\n            if digit\
    \ == 17 {\n                prime = 17;\n            }\n        }\n        if prime\
    \ == 19 {\n            if digit == 19 {\n                prime = 19;\n       \
    \     }\n        }\n        if prime == 21 {\n            if digit == 21 {\n \
    \               prime = 21;\n            }\n        }\n        if prime == 29\
    \ {\n            if digit == 29 {\n                prime = 29;\n            }\n\
    \        }\n        if prime == 31 {\n            if digit == 31 {\n         \
    \       prime = 31;\n            }\n        }\n        if prime == 37 {\n    \
    \        if digit == 37 {\n                prime = 37;\n            }\n      \
    \  }\n        if prime == 41 {\n            if digit == 41 {\n               \
    \ prime = 41;\n            }\n        }\n        if prime == 43 {\n          \
    \  if digit == 43 {\n                prime = 43;\n            }\n        }\n \
    \       if prime == 47 {\n            if digit == 47 {\n                prime\
    \ = 53;\n            }\n        }\n        if prime == 53 {\n            if digit\
    \ == 53 {\n                prime = 53;\n            }\n        }\n        if prime\
    \ == 59 {\n            if digit == 59 {\n                prime = 59;\n       \
    \     }\n        }\n        if prime == 61 {\n            if digit == 61 {\n \
    \               prime = 61;\n            }\n        }\n        if prime == 67\
    \ {\n            if digit == 67 {\n                prime = 67;\n            }\n\
    \        }\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp9j58ucce.rs:146:3\n\
    \    |\n22  | fn hex_key(num: String) -> isize {\n    |                      \
    \            - unclosed delimiter\n...\n27  |     while !num.is_empty() {\n  \
    \  |                           - this delimiter might not be properly closed...\n\
    ...\n136 | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n146 | }\n    |   ^\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built\
    \ from an iterator over elements of type `char`\n  --> /tmp/tmp9j58ucce.rs:23:52\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_string().chars().collect();\n  \
    \ |                                                    ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the\
    \ trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9j58ucce.rs:30:13\n   |\n30 |         for &c\
    \ in num {\n   |             ^^    --- this expression has type `u8`\n   |   \
    \          |\n   |             expected `u8`, found reference\n   |\n   = note:\
    \   expected type `u8`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9j58ucce.rs:22:28\n   |\n22 | fn hex_key(num: String) ->\
    \ isize {\n   |    -------                 ^^^^^ expected `isize`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748839
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_len\
    \ = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n    let mut\
    \ num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp605kyhux.rs:59:22\n   |\n\
    59 |     let mut num_prime\n   |                      ^ help: add `;` here\n60\
    \ | }\n   | - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot\
    \ be built from an iterator over elements of type `char`\n  --> /tmp/tmp605kyhux.rs:23:55\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp605kyhux.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut count = 1;\n    let mut prime_digits = vec![2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101,\
    \ 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181,\
    \ 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271,\
    \ 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373,\
    \ 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463,\
    \ 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577,\
    \ 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673,\
    \ 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787,\
    \ 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887,\
    \ 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];\n   \
    \ let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let \n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpccaj04gj.rs:38:1\n  \
    \ |\n38 | }\n   | ^ expected pattern\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n  --> /tmp/tmpccaj04gj.rs:23:55\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748839
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num_str: String = String::new();\n    let mut num_str2: String = String::new();\n\
    \    let mut num_str3: String = String::new();\n    let mut num_str4: String =\
    \ String::new();\n    let mut num_str5: String = String::new();\n    let mut num_str6:\
    \ String = String::new();\n    let mut num_str7: String = String::new();\n   \
    \ let mut num_str8: String = String::new();\n    let mut num_str9: String = String::new();\n\
    \    let mut num_str10: String = String::new();\n    let mut num_str11: String\
    \ = String::new();\n    let mut num_str12: String = String::new();\n    let mut\
    \ num_str13: String = String::new();\n    let mut num_str14: String = String::new();\n\
    \    let mut num_str15: String = String::new();\n    let mut num_str16: String\
    \ = String::new();\n    let mut num_str17: String = String::new();\n    let mut\
    \ num_str18: String = String::new();\n    let mut num_str19: String = String::new();\n\
    \    let mut num_str20: String = String::new();\n    let mut num_str21: String\
    \ = String::new();\n    let mut num_str22: String = String::new();\n    let mut\
    \ num_str23: String = String::new();\n    let mut num_str24: String = String::new();\n\
    \    let mut num_str25: String = String::new();\n    let mut num_str26: String\
    \ = String::new();\n    let mut num_str27: String = String::new();\n    let mut\
    \ num_str28: String = String::new();\n    let mut num_str29: String = String::new();\n\
    \    let mut num_str30: String = String::new();\n    let mut num_str31: String\
    \ = String::new();\n    let mut num_str32: String = String::new();\n    let mut\
    \ num_str33: String = String::new();\n    let mut num_str34: String = String::new();\n\
    \    let mut num_str35: String = String::new();\n    let mut num_str36: String\
    \ = String::new();\n    let mut num_str37: String = String::new();\n    let mut\
    \ num_str38: String = String::new();\n    let mut num_\n}\n\nfn main() {\n   \
    \ let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpttyyut86.rs:62:17\n   |\n\
    62 |     let mut num_\n   |                 ^ help: add `;` here\n63 | }\n   |\
    \ - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built\
    \ from an iterator over elements of type `char`\n  --> /tmp/tmpttyyut86.rs:23:52\n\
    \   |\n23 |     let mut num: Vec<u8> = num.to_string().chars().collect();\n  \
    \ |                                                    ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the\
    \ trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpttyyut86.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748837
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: isize = 0;\n    let mut nums: Vec<isize> = num.chars().collect();\n\
    \    let mut prime: isize = 2;\n    let mut primes: Vec<isize> = vec![2, 3];\n\
    \    let mut prime_found = false;\n    let mut prime_found2 = false;\n    let\
    \ mut prime_found3 = false;\n    let mut prime_found4 = false;\n    let mut prime_found5\
    \ = false;\n    let mut prime_found6 = false;\n    let mut prime_found7 = false;\n\
    \    let mut prime_found8 = false;\n    let mut prime_found9 = false;\n    let\
    \ mut prime_found10 = false;\n    let mut prime_found11 = false;\n    let mut\
    \ prime_found12 = false;\n    let mut prime_found13 = false;\n    let mut prime_found14\
    \ = false;\n    let mut prime_found15 = false;\n    let mut prime_found16 = false;\n\
    \    let mut prime_found17 = false;\n    let mut prime_found18 = false;\n    let\
    \ mut prime_found19 = false;\n    let mut prime_found20 = false;\n    let mut\
    \ prime_found21 = false;\n    let mut prime_found22 = false;\n    let mut prime_found23\
    \ = false;\n    let mut prime_found24 = false;\n    let mut prime_found25 = false;\n\
    \    let mut prime_found26 = false;\n    let mut prime_found27 = false;\n    let\
    \ mut prime_found28 = false;\n    let mut prime_found29 = false;\n    let mut\
    \ prime_found30 = false;\n    let mut prime_found31 = false;\n    let mut prime_found32\
    \ = false;\n    let mut prime_found33 = false;\n    let mut prime_found34 = false;\n\
    \    let mut prime_found35 = false;\n    let mut prime_found36 = false;\n    let\
    \ mut prime_found37 = false;\n    let mut prime_found38 = false;\n    let mut\
    \ prime_found39 = false;\n    let mut prime_found40 = false;\n    let mut prime_found41\
    \ = false;\n    let mut prime_found42 = false;\n    let mut prime_found43 = false;\n\
    \    let mut prime_found44 = false;\n    let mut prime_found45 = false;\n    let\
    \ mut prime_found46 = false;\n    let mut prime_found47 = false;\n    let mut\
    \ prime_found48 = false;\n    let mut prime_found49 = false;\n    let mut prime_found50\
    \ = false;\n    let mut prime\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8gn1acsg.rs:77:18\n   |\n\
    77 |     let mut prime\n   |                  ^ help: add `;` here\n78 | }\n \
    \  | - unexpected token\n\nerror[E0599]: no method named `chars` found for type\
    \ `isize` in the current scope\n  --> /tmp/tmp8gn1acsg.rs:24:36\n   |\n24 |  \
    \   let mut nums: Vec<isize> = num.chars().collect();\n   |                  \
    \                  ^^^^^ method not found in `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8gn1acsg.rs:22:28\n   |\n22 | fn hex_key(num: String) ->\
    \ isize {\n   |    -------                 ^^^^^ expected `isize`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748839
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_len\
    \ = prime.len();\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpd6dk1ovq.rs:65:34\n   |\n\
    65 |     let mut prime_len = prime_len\n   |                                 \
    \ ^ help: add `;` here\n66 | }\n   | - unexpected token\n\nerror[E0277]: a value\
    \ of type `Vec<u8>` cannot be built from an iterator over elements of type `char`\n\
    \  --> /tmp/tmpd6dk1ovq.rs:23:55\n   |\n23 |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n   |\n   =\
    \ help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpd6dk1ovq.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748839
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut nums = num.chars().collect::<Vec<_>>();\n    let mut primes\
    \ = vec![];\n    let mut prime_digits = vec![];\n    let mut prime_digit_counts\
    \ = vec![];\n    let mut prime_digit_counts_len = vec![];\n    let mut prime_digit_counts_len_max\
    \ = vec![];\n    let mut prime_digit_counts_len_max_len = vec![];\n    let mut\
    \ prime_digit_counts_len_max_len2 = vec![];\n    let mut prime_digit_counts_len_max_len3\
    \ = vec![];\n    let mut prime_digit_counts_len_max_len4 = vec![];\n    let mut\
    \ prime_digit_counts_len_max_len5 = vec![];\n    let mut prime_digit_counts_len_max_len6\
    \ = vec![];\n    let mut prime_digit_counts_len_max_len7 = vec![];\n    let mut\
    \ prime_digit_counts_len_max_len8 = vec![];\n    let mut prime_digit_counts_len_max_len9\
    \ = vec![];\n    let mut prime_digit_counts_len_max_len10 = vec![];\n    let mut\
    \ prime_digit_counts_len_max_len11 = vec![];\n    let mut prime_digit_counts_len_max_len12\
    \ = vec![];\n    let mut prime_digit_counts_len_max_len13 = vec![];\n    let mut\
    \ prime_digit_counts_len_max_len14 = vec![];\n    let mut prime_digit_counts_len_max_len15\
    \ = vec![];\n    let mut prime_digit_counts_len_max_len16 = vec![];\n    let mut\
    \ prime_digit_counts_len_max_len17 = vec![];\n    let mut prime_digit_counts_len_max_len18\
    \ = vec![];\n    let mut prime_digit_counts_len_max_len19 = vec![];\n    let mut\
    \ prime_digit_counts_len_max_len20 = vec![];\n    let mut prime_digit_counts_len_max_len21\
    \ = vec![];\n    let mut prime_digit_counts_len_max_len22 = vec![];\n    let mut\
    \ prime_digit_counts_len_max_len23 = vec![];\n    let mut prime_digit_counts_len_max_len24\
    \ = vec![];\n    let mut prime_digit_counts_len_max_len25 = vec![];\n    let mut\
    \ prime_digit_counts_len_max_len26 = vec![];\n    let mut prime_digit_count\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpz_6z0sof.rs:55:30\n   |\n\
    55 |     let mut prime_digit_count\n   |                              ^ help:\
    \ add `;` here\n56 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpz_6z0sof.rs:22:28\n   |\n22 | fn hex_key(num: String) -> isize\
    \ {\n   |    -------                 ^^^^^ expected `isize`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748839
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpnsj7n80f.rs:39:36\n   |\n\
    39 |     let mut num: Vec<u8> = num.iter\n   |                               \
    \     ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0277]: a\
    \ value of type `Vec<u8>` cannot be built from an iterator over elements of type\
    \ `char`\n  --> /tmp/tmpnsj7n80f.rs:23:55\n   |\n23 |     let mut num: Vec<u8>\
    \ = num.to_lowercase().chars().collect();\n   |                              \
    \                         ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n   |\n   = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnsj7n80f.rs:24:56\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <=\
    \ '9').collect();\n   |                                                      \
    \  ^^^ expected `&u8`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnsj7n80f.rs:24:68\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <=\
    \ '9').collect();\n   |                                                      \
    \              ^^^ expected `&u8`, found `char`\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `&u8`\n  -->\
    \ /tmp/tmpnsj7n80f.rs:24:73\n   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&c|\
    \ c >= '0' && c <= '9').collect();\n   |                                     \
    \                                    ^^^^^^^ value of type `Vec<u8>` cannot be\
    \ built from `std::iter::Iterator<Item=&u8>`\n   |\n   = help: the trait `FromIterator<&u8>`\
    \ is not implemented for `Vec<u8>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnsj7n80f.rs:25:56\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <=\
    \ 'F').collect();\n   |                                                      \
    \  ^^^ expected `&u8`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnsj7n80f.rs:25:68\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <=\
    \ 'F').collect();\n   |                     "
  stdout: ''
  timestamp: 1659748838
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut nums = num.chars().collect::<Vec<_>>();\n    let mut num_primes\
    \ = 0;\n    let mut num_primes_found = 0;\n    let mut num_primes_found2 = 0;\n\
    \    let mut num_primes_found3 = 0;\n    let mut num_primes_found4 = 0;\n    let\
    \ mut num_primes_found5 = 0;\n    let mut num_primes_found6 = 0;\n    let mut\
    \ num_primes_found7 = 0;\n    let mut num_primes_found8 = 0;\n    let mut num_primes_found9\
    \ = 0;\n    let mut num_primes_found10 = 0;\n    let mut num_primes_found11 =\
    \ 0;\n    let mut num_primes_found12 = 0;\n    let mut num_primes_found13 = 0;\n\
    \    let mut num_primes_found14 = 0;\n    let mut num_primes_found15 = 0;\n  \
    \  let mut num_primes_found16 = 0;\n    let mut num_primes_found17 = 0;\n    let\
    \ mut num_primes_found18 = 0;\n    let mut num_primes_found19 = 0;\n    let mut\
    \ num_primes_found20 = 0;\n    let mut num_primes_found21 = 0;\n    let mut num_primes_found22\
    \ = 0;\n    let mut num_primes_found23 = 0;\n    let mut num_primes_found24 =\
    \ 0;\n    let mut num_primes_found25 = 0;\n    let mut num_primes_found26 = 0;\n\
    \    let mut num_primes_found27 = 0;\n    let mut num_primes_found28 = 0;\n  \
    \  let mut num_primes_found29 = 0;\n    let mut num_primes_found30 = 0;\n    let\
    \ mut num_primes_found31 = 0;\n    let mut num_primes_found32 = 0;\n    let mut\
    \ num_primes_found33 = 0;\n    let mut num_primes_found34 = 0;\n    let mut num_primes_found35\
    \ = 0;\n    let mut num_primes_found36 = 0;\n    let mut num_primes_found37 =\
    \ 0;\n    let mut num_primes_found38 = 0;\n    let mut num_primes_found39 = 0;\n\
    \    let mut num_primes_found40 = 0;\n    let mut num_primes_found41 = 0;\n  \
    \  let mut num_primes_found42 = 0;\n    let mut num_primes_found43 = 0;\n    let\
    \ mut num_primes_found44 = 0;\n    let mut num_primes_found45 = 0;\n    let mut\
    \ num_primes_found46 = 0;\n    let mut num_primes_found47 = 0;\n    let mut num_primes_found48\
    \ = 0;\n    let mut num_primes_found49 = 0;\n    let mut \n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp1cacbsf9.rs:75:1\n\
    \   |\n75 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748839
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_count: isize = 0;\n    let mut prime_digit: u8 = 0;\n    let\
    \ mut prime_digit_count: isize = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value_count: isize = 0;\n    let mut prime_digit_value_prime:\
    \ u8 = 0;\n    let mut prime_digit_value_prime_count: isize = 0;\n    let mut\
    \ prime_digit_value_prime_prime: u8 = 0;\n    let mut prime_digit_value_prime_prime_count:\
    \ isize = 0;\n    let mut prime_digit_value_prime_prime_prime: u8 = 0;\n    let\
    \ mut prime_digit_value_prime_prime_prime_count: isize = 0;\n    let mut prime_digit_value_prime_prime_prime_prime:\
    \ u8 = 0;\n    let mut prime_digit_value_prime_prime_prime_prime_count: isize\
    \ = 0;\n    let mut prime_digit_value_prime_prime_prime_prime_prime: u8 = 0;\n\
    \    let mut prime_digit_value_prime_prime_prime_prime_prime_count: isize = 0;\n\
    \    let mut prime_digit_value_prime_prime_prime_prime_prime_prime: u8 = 0;\n\
    \    let mut prime_digit_value_prime_prime_prime_prime_prime_count: isize = 0;\n\
    \    let mut prime_digit_value_prime_prime_prime_prime_prime_prime: u8 = 0;\n\
    \    let mut prime_digit_value_prime_prime_prime_prime_prime_prime_count: isize\
    \ = 0;\n    let mut prime_digit_value_prime_prime_prime_prime_prime_prime_prime:\
    \ u8 = 0;\n    let mut prime_digit_value_prime_prime_prime_prime_prime_prime_prime_count:\
    \ isize = 0;\n    let mut prime_digit_value_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ u8 = 0;\n    let mut prime_digit_value_prime_prime_prime_prime_prime_prime_prime_prime_count:\
    \ isize = 0;\n    let mut prime_digit_value_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ u8 = 0;\n    let mut prime_digit_value_prime_prime_prime_prime_prime_prime_prime_prime_prime_count:\
    \ isize = 0;\n    let mut prime_digit_value_prime_prime_prime_prime_prime_prime\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpk8rkjk21.rs:49:66\n   |\n\
    49 |     let mut prime_digit_value_prime_prime_prime_prime_prime_prime\n   | \
    \                                                                 ^ help: add\
    \ `;` here\n50 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpk8rkjk21.rs:22:28\n   |\n22 | fn hex_key(num: String) -> isize\
    \ {\n   |    -------                 ^^^^^ expected `isize`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror[E0277]: a value of type `Vec<u8>` cannot be built from an iterator over\
    \ elements of type `char`\n  --> /tmp/tmpk8rkjk21.rs:23:55\n   |\n23 |     let\
    \ mut num: Vec<u8> = num.to_lowercase().chars().collect();\n   |             \
    \                                          ^^^^^^^ value of type `Vec<u8>` cannot\
    \ be built from `std::iter::Iterator<Item=char>`\n   |\n   = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748839
