name: HumanEval_78_hex_key
language: rs
results:
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num: Vec<u8>\
    \ = num.iter().map(|x| *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x|\
    \ *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num:\
    \ Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x|\
    \ *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num:\
    \ Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x|\
    \ *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num:\
    \ Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x|\
    \ *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num:\
    \ Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x|\
    \ *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num:\
    \ Vec<u8> = \n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpi7sdx9zx.rs:46:1\n\
    \   |\n46 | }\n   | ^ expected expression\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n    --> /tmp/tmpi7sdx9zx.rs:23:52\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_string().chars().collect();\n\
    \     |                                                    ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_prime: Vec<u8> = vec![];\n    let mut num_prime_counter: usize\
    \ = 0;\n    let mut num_prime_counter2: usize = 0;\n    let mut num_prime_counter3:\
    \ usize = 0;\n    let mut num_prime_counter4: usize = 0;\n    let mut num_prime_counter5:\
    \ usize = 0;\n    let mut num_prime_counter6: usize = 0;\n    let mut num_prime_counter7:\
    \ usize = 0;\n    let mut num_prime_counter8: usize = 0;\n    let mut num_prime_counter9:\
    \ usize = 0;\n    let mut num_prime_counter10: usize = 0;\n    let mut num_prime_counter11:\
    \ usize = 0;\n    let mut num_prime_counter12: usize = 0;\n    let mut num_prime_counter13:\
    \ usize = 0;\n    let mut num_prime_counter14: usize = 0;\n    let mut num_prime_counter15:\
    \ usize = 0;\n    let mut num_prime_counter16: usize = 0;\n    let mut num_prime_counter17:\
    \ usize = 0;\n    let mut num_prime_counter18: usize = 0;\n    let mut num_prime_counter19:\
    \ usize = 0;\n    let mut num_prime_counter20: usize = 0;\n    let mut num_prime_counter21:\
    \ usize = 0;\n    let mut num_prime_counter22: usize = 0;\n    let mut num_prime_counter23:\
    \ usize = 0;\n    let mut num_prime_counter24: usize = 0;\n    let mut num_prime_counter25:\
    \ usize = 0;\n    let mut num_prime_counter26: usize = 0;\n    let mut num_prime_counter27:\
    \ usize = 0;\n    let mut num_prime_counter28: usize = 0;\n    let mut num_prime_counter29:\
    \ usize = 0;\n    let mut num_prime_counter30: usize = 0;\n    let mut num_prime_counter31:\
    \ usize = 0;\n    let mut num_prime_counter32: usize = 0;\n    let mut num_prime_counter33:\
    \ usize = 0;\n    let mut num_prime_counter34: usize = 0;\n    let mut num_prime_counter35:\
    \ usize = 0;\n    let mut num_prime_counter36: usize = 0;\n    let mut num_prime_counter37:\
    \ usize = 0;\n    let mu\n}\n\nfn main() {\n    let candidate = hex_key;\n   \
    \ assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8bnkep1i.rs:62:11\n   |\n\
    62 |     let mu\n   |           ^ help: add `;` here\n63 | }\n   | - unexpected\
    \ token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmp8bnkep1i.rs:23:55\n     |\n23\
    \   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |\
    \                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8bnkep1i.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_digits: Vec<u8> = vec![2, 3, 4, 5, 7, 11, 13, 17];\n    let\
    \ mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len = prime_digits_len\
    \ as usize;\n    let mut prime_digits_len = prime_digits_len as usize;\n    let\
    \ mut prime_digits_len = prime_digits_len as usize;\n    let mut prime_digits_len\
    \ = prime_digits_len as usize;\n    let mut prime_digits_len = prime_digits_len\
    \ as usize;\n    let mut prime_digits_len = prime_digits_len as usize;\n    let\
    \ mut prime_digits_len = prime_digits_len as usize;\n    let mut prime_digits_len\
    \ = prime_digits_len as usize;\n    let mut prime_digits_len = prime_digits_len\
    \ as usize;\n    let mut prime_digits_len = prime_digits_len as usize;\n    let\
    \ mut prime_digits_len = prime_digits_len as usize;\n    let mut prime_digits_len\
    \ = prime_digits_len as usize;\n    let mut prime_digits_len = prime_digits_len\
    \ as usize;\n    let mut prime_digits_len = prime_digits_len as usize;\n    let\
    \ mut prime_digits_len = prime_digits_len as usize;\n    let mut prime_digits_len\
    \ = prime_digits_len as usize;\n    let mut prime_digits_len = prime_digits_len\
    \ as usize;\n    let mut prime_digits_len = prime_digits_len as usize;\n    let\
    \ mut prime_digits_len = prime_digits_len as usize;\n    let mut prime_digits_len\
    \ = prime_digits_len as usize;\n    let mut prime_digits_len = prime_digits_len\
    \ as usize;\n    let mut prime_digits_len = prime_digits_len as usize;\n    let\
    \ mut prime_digits_len = prime_digits_len as usize;\n    let mut prime_digits_len\
    \ = prime_digits_len as usize;\n    let mut prime_digits_len = prime_digits_len\
    \ as usize;\n    let mut prime_digits_len = prime_digits_len as usize;\n    let\
    \ mut prime_digits_len = prime_digits_len as u\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxda9dlt5.rs:52:53\n   |\n\
    52 |     let mut prime_digits_len = prime_digits_len as u\n   |              \
    \                                       ^ help: add `;` here\n53 | }\n   | - unexpected\
    \ token\n\nerror[E0412]: cannot find type `u` in this scope\n  --> /tmp/tmpxda9dlt5.rs:52:52\n\
    \   |\n52 |     let mut prime_digits_len = prime_digits_len as u\n   |       \
    \                                             ^ help: a builtin type with a similar\
    \ name exists: `u8`\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built\
    \ from an iterator over elements of type `char`\n    --> /tmp/tmpxda9dlt5.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxda9dlt5.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0412.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: isize = 0;\n    let mut num_digits = num.len();\n\
    \    let mut num_digits_div2 = num_digits / 2;\n    let mut num_digits_div4 =\
    \ num_digits / 4;\n    let mut num_digits_div6 = num_digits / 6;\n    let mut\
    \ num_digits_div8 = num_digits / 8;\n    let mut num_digits_div10 = num_digits\
    \ / 10;\n    let mut num_digits_div12 = num_digits / 12;\n    let mut num_digits_div14\
    \ = num_digits / 14;\n    let mut num_digits_div16 = num_digits / 16;\n    let\
    \ mut num_digits_div18 = num_digits / 18;\n    let mut num_digits_div20 = num_digits\
    \ / 20;\n    let mut num_digits_div22 = num_digits / 22;\n    let mut num_digits_div24\
    \ = num_digits / 24;\n    let mut num_digits_div26 = num_digits / 26;\n    let\
    \ mut num_digits_div28 = num_digits / 28;\n    let mut num_digits_div30 = num_digits\
    \ / 30;\n    let mut num_digits_div32 = num_digits / 32;\n    let mut num_digits_div34\
    \ = num_digits / 34;\n    let mut num_digits_div36 = num_digits / 36;\n    let\
    \ mut num_digits_div38 = num_digits / 38;\n    let mut num_digits_div40 = num_digits\
    \ / 40;\n    let mut num_digits_div42 = num_digits / 42;\n    let mut num_digits_div44\
    \ = num_digits / 44;\n    let mut num_digits_div46 = num_digits / 46;\n    let\
    \ mut num_digits_div48 = num_digits / 48;\n    let mut num_digits_div50 = num_digits\
    \ / 50;\n    let mut num_digits_div52 = num_digits / 52;\n    let mut num_digits_div54\
    \ = num_digits / 54;\n    let mut num_digits_div56 = num_digits / 56;\n    let\
    \ mut num_digits_div58 = num_digits / 58;\n    let mut num_digits_div60 = num_digits\
    \ / 60;\n    let mut num_digits_div62 = num_digits / 62;\n    let mut num_digits_div64\
    \ = num_digits / 64;\n    let mut num_digits_div66 = num_digits / 66;\n    let\
    \ mut num_digits_div68 = num_digits / 6\n}\n\nfn main() {\n    let candidate =\
    \ hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpnk5xdr9w.rs:58:46\n   |\n\
    58 |     let mut num_digits_div68 = num_digits / 6\n   |                     \
    \                         ^ help: add `;` here\n59 | }\n   | - unexpected token\n\
    \nerror[E0599]: no method named `len` found for type `isize` in the current scope\n\
    \  --> /tmp/tmpnk5xdr9w.rs:24:30\n   |\n24 |     let mut num_digits = num.len();\n\
    \   |                              ^^^ method not found in `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnk5xdr9w.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut prime_count: isize = 0;\n    let mut prime_digit: u8 = 0;\n    let mut\
    \ prime_digit_count: usize = 0;\n    let mut prime_digit_index: usize = 0;\n \
    \   let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value_count: usize\
    \ = 0;\n    let mut prime_digit_value_prime: u8 = 0;\n    let mut prime_digit_value_prime_count:\
    \ usize = 0;\n    let mut prime_digit_value_prime_prime: u8 = 0;\n    let mut\
    \ prime_digit_value_prime_prime_count: usize = 0;\n    let mut prime_digit_value_prime_prime_prime:\
    \ u8 = 0;\n    let mut prime_digit_value_prime_prime_prime_count: usize = 0;\n\
    \    let mut prime_digit_value_prime_prime_prime_prime: u8 = 0;\n    let mut prime_digit_value_prime_prime_prime_prime_count:\
    \ usize = 0;\n    let mut prime_digit_value_prime_prime_prime_prime_prime: u8\
    \ = 0;\n    let mut prime_digit_value_prime_prime_prime_prime_prime_count: usize\
    \ = 0;\n    let mut prime_digit_value_prime_prime_prime_prime_prime_prime: u8\
    \ = 0;\n    let mut prime_digit_value_prime_prime_prime_prime_prime_count: usize\
    \ = 0;\n    let mut prime_digit_value_prime_prime_prime_prime_prime_prime: u8\
    \ = 0;\n    let mut prime_digit_value_prime_prime_prime_prime_prime_prime_count:\
    \ usize = 0;\n    let mut prime_digit_value_prime_prime_prime_prime_prime_prime_prime:\
    \ u8 = 0;\n    let mut prime_digit_value_prime_prime_prime_prime_prime_prime_prime_count:\
    \ usize = 0;\n    let mut prime_digit_value_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ u8 = 0;\n    let mut prime_digit_value_prime_prime_prime_prime_prime_prime_prime_prime_count:\
    \ usize = 0;\n    let mut prime_digit_value_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ u8 = 0;\n    let mut prime_digit_value_prime_prime_prime_prime_prime_prime_prime_prime_prime_count:\
    \ usize = 0;\n    let mut prime_digit_value_\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp0smwxx44.rs:50:31\n   |\n\
    50 |     let mut prime_digit_value_\n   |                               ^ help:\
    \ add `;` here\n51 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0smwxx44.rs:22:28\n   |\n22 | fn hex_key(num: String) -> isize\
    \ {\n   |    -------                 ^^^^^ expected `isize`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror[E0277]: a value of type `Vec<u8>` cannot be built from an iterator over\
    \ elements of type `char`\n    --> /tmp/tmp0smwxx44.rs:23:52\n     |\n23   | \
    \    let mut num: Vec<u8> = num.to_string().chars().collect();\n     |       \
    \                                             ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: isize = 0;\n    let mut prime_found = false;\n    let mut\
    \ prime_found2 = false;\n    let mut prime_found3 = false;\n    let mut prime_found4\
    \ = false;\n    let mut prime_found5 = false;\n    let mut prime_found6 = false;\n\
    \    let mut prime_found7 = false;\n    let mut prime_found8 = false;\n    let\
    \ mut prime_found9 = false;\n    let mut prime_found10 = false;\n    let mut prime_found11\
    \ = false;\n    let mut prime_found12 = false;\n    let mut prime_found13 = false;\n\
    \    let mut prime_found14 = false;\n    let mut prime_found15 = false;\n    let\
    \ mut prime_found16 = false;\n    let mut prime_found17 = false;\n    let mut\
    \ prime_found18 = false;\n    let mut prime_found19 = false;\n    let mut prime_found20\
    \ = false;\n    let mut prime_found21 = false;\n    let mut prime_found22 = false;\n\
    \    let mut prime_found23 = false;\n    let mut prime_found24 = false;\n    let\
    \ mut prime_found25 = false;\n    let mut prime_found26 = false;\n    let mut\
    \ prime_found27 = false;\n    let mut prime_found28 = false;\n    let mut prime_found29\
    \ = false;\n    let mut prime_found30 = false;\n    let mut prime_found31 = false;\n\
    \    let mut prime_found32 = false;\n    let mut prime_found33 = false;\n    let\
    \ mut prime_found34 = false;\n    let mut prime_found35 = false;\n    let mut\
    \ prime_found36 = false;\n    let mut prime_found37 = false;\n    let mut prime_found38\
    \ = false;\n    let mut prime_found39 = false;\n    let mut prime_found40 = false;\n\
    \    let mut prime_found41 = false;\n    let mut prime_found42 = false;\n    let\
    \ mut prime_found43 = false;\n    let mut prime_found44 = false;\n    let mut\
    \ prime_found45 = false;\n    let mut prime_found46 = false;\n    let mut prime_found47\
    \ = false;\n    let mut prime_found48 = false;\n    let mut prime_found49 = false;\n\
    \    let mut prime_found50 = false;\n    let mut prime_found51 = false;\n    let\
    \ mut prime_found52 = false;\n    let mut prime_found53 = false;\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmprl7xyb0c.rs:23:55\n     |\n23\
    \   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |\
    \                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprl7xyb0c.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut prime_count: isize = 0;\n    let mut prime_digit: u8 = 0;\n    let mut\
    \ prime_digit_count: isize = 0;\n    let mut prime_digit_sum: isize = 0;\n   \
    \ let mut prime_digit_sum2: isize = 0;\n    let mut prime_digit_sum3: isize =\
    \ 0;\n    let mut prime_digit_sum4: isize = 0;\n    let mut prime_digit_sum5:\
    \ isize = 0;\n    let mut prime_digit_sum6: isize = 0;\n    let mut prime_digit_sum7:\
    \ isize = 0;\n    let mut prime_digit_sum8: isize = 0;\n    let mut prime_digit_sum9:\
    \ isize = 0;\n    let mut prime_digit_sum10: isize = 0;\n    let mut prime_digit_sum11:\
    \ isize = 0;\n    let mut prime_digit_sum12: isize = 0;\n    let mut prime_digit_sum13:\
    \ isize = 0;\n    let mut prime_digit_sum14: isize = 0;\n    let mut prime_digit_sum15:\
    \ isize = 0;\n    let mut prime_digit_sum16: isize = 0;\n    let mut prime_digit_sum17:\
    \ isize = 0;\n    let mut prime_digit_sum18: isize = 0;\n    let mut prime_digit_sum19:\
    \ isize = 0;\n    let mut prime_digit_sum20: isize = 0;\n    let mut prime_digit_sum21:\
    \ isize = 0;\n    let mut prime_digit_sum22: isize = 0;\n    let mut prime_digit_sum23:\
    \ isize = 0;\n    let mut prime_digit_sum24: isize = 0;\n    let mut prime_digit_sum25:\
    \ isize = 0;\n    let mut prime_digit_sum26: isize = 0;\n    let mut prime_digit_sum27:\
    \ isize = 0;\n    let mut prime_digit_sum28: isize = 0;\n    let mut prime_digit_sum29:\
    \ isize = 0;\n    let mut prime_digit_sum30: isize = 0;\n    let mut prime_digit_sum31:\
    \ isize = 0;\n    let mut prime_digit_sum32: isize = 0;\n    let mut prime_digit_sum33:\
    \ isize = 0;\n    let mut prime_digit_sum34: isize = 0;\n    let mut prime_digit_sum35:\
    \ isize = 0;\n    let mut prime_digit_sum36: isize = 0;\n}\n\nfn main() {\n  \
    \  let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp697lzw1j.rs:22:28\n   |\n\
    22 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `char`\n  \
    \  --> /tmp/tmp697lzw1j.rs:23:52\n     |\n23   |     let mut num: Vec<u8> = num.to_string().chars().collect();\n\
    \     |                                                    ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut nums = num.chars().collect::<Vec<_>>();\n    let mut num_digits\
    \ = nums.len();\n    let mut num_primes = 0;\n    let mut num_primes_found = 0;\n\
    \    let mut prime_found = false;\n    let mut prime_found2 = false;\n    let\
    \ mut prime_found3 = false;\n    let mut prime_found4 = false;\n    let mut prime_found5\
    \ = false;\n    let mut prime_found6 = false;\n    let mut prime_found7 = false;\n\
    \    let mut prime_found8 = false;\n    let mut prime_found9 = false;\n    let\
    \ mut prime_found10 = false;\n    let mut prime_found11 = false;\n    let mut\
    \ prime_found12 = false;\n    let mut prime_found13 = false;\n    let mut prime_found14\
    \ = false;\n    let mut prime_found15 = false;\n    let mut prime_found16 = false;\n\
    \    let mut prime_found17 = false;\n    let mut prime_found18 = false;\n    let\
    \ mut prime_found19 = false;\n    let mut prime_found20 = false;\n    let mut\
    \ prime_found21 = false;\n    let mut prime_found22 = false;\n    let mut prime_found23\
    \ = false;\n    let mut prime_found24 = false;\n    let mut prime_found25 = false;\n\
    \    let mut prime_found26 = false;\n    let mut prime_found27 = false;\n    let\
    \ mut prime_found28 = false;\n    let mut prime_found29 = false;\n    let mut\
    \ prime_found30 = false;\n    let mut prime_found31 = false;\n    let mut prime_found32\
    \ = false;\n    let mut prime_found33 = false;\n    let mut prime_found34 = false;\n\
    \    let mut prime_found35 = false;\n    let mut prime_found36 = false;\n    let\
    \ mut prime_found37 = false;\n    let mut prime_found38 = false;\n    let mut\
    \ prime_found39 = false;\n    let mut prime_found40 = false;\n    let mut prime_found41\
    \ = false;\n    let mut prime_found42 = false;\n    let mut prime_found43 = false;\n\
    \    let mut prime_found44 = false;\n    let mut prime_found45 = false;\n    let\
    \ mut prime_found46 = false;\n    let mut prime_found47 = false;\n    let mut\
    \ prime_found48 = false;\n    let mut prime_found49 = false;\n    let mut prime_found50\
    \ = false;\n    let mut prime_found51 = false;\n    let mut \n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp1pmsfrdw.rs:79:1\n\
    \   |\n79 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c != 'a' && c != 'b' && c !=\
    \ 'c' && c != 'd' && c != 'e' && c != 'f').collect();\n    let mut num: Vec<u8>\
    \ = num.iter().filter(|&c| c != '0').collect();\n    let mut num: Vec<u8> = num.iter().filter(|&c|\
    \ c != '1').collect();\n    let mut num: Vec<u8> = num.iter().filter(|&c| c !=\
    \ '2').collect();\n    let mut num: Vec<u8> = num.iter().filter(|&c| c != '3').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c != '4').collect();\n    let\
    \ mut num: Vec<u8> = num.iter().filter(|&c| c != '5').collect();\n    let mut\
    \ num: Vec<u8> = num.iter().filter(|&c| c != '6').collect();\n    let mut num:\
    \ Vec<u8> = num.iter().filter(|&c| c != '7').collect();\n    let mut num: Vec<u8>\
    \ = num.iter().filter(|&c| c != '8').collect();\n    let mut num: Vec<u8> = num.iter().filter(|&c|\
    \ c != '9').collect();\n    let mut num: Vec<u8> = num.iter().filter(|&c| c !=\
    \ 'A').collect();\n    let mut num: Vec<u8> = num.iter().filter(|&c| c != 'B').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c != 'C').collect();\n    let\
    \ mut num: Vec<u8> = num.iter().filter(|&c| c != 'D').collect();\n    let mut\
    \ num: Vec<u8> = num.iter().filter(|&c| c != 'E').collect();\n    let mut num:\
    \ Vec<u8> = num.iter().filter(|&c| c != 'F').collect();\n    let mut num: Vec<u8>\
    \ = num.iter().filter(|&c| c != 'a').collect();\n    let mut num: \n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected type, found `}`\n  --> /tmp/tmpos89qgnu.rs:43:1\n   |\n\
    42 |     let mut num: \n   |         ------- while parsing the type for `mut num`\n\
    43 | }\n   | ^ expected type\n\nerror[E0277]: a value of type `Vec<u8>` cannot\
    \ be built from an iterator over elements of type `char`\n    --> /tmp/tmpos89qgnu.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpos89qgnu.rs:24:56\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&c| c != 'a' && c !=\
    \ 'b' && c != 'c' && c != 'd' && c != 'e' && c != 'f').collect();\n   |      \
    \                                                  ^^^ expected `u8`, found `char`\n\
    \nerror[E0277]: can't compare `&u8` with `char`\n  --> /tmp/tmpos89qgnu.rs:24:53\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&c| c != 'a' && c !=\
    \ 'b' && c != 'c' && c != 'd' && c != 'e' && c != 'f').collect();\n   |      \
    \                                               ^^ no implementation for `&u8\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&u8`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpos89qgnu.rs:24:68\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&c| c != 'a' && c !=\
    \ 'b' && c != 'c' && c != 'd' && c != 'e' && c != 'f').collect();\n   |      \
    \                                                              ^^^ expected `u8`,\
    \ found `char`\n\nerror[E0277]: can't compare `&u8` with `char`\n  --> /tmp/tmpos89qgnu.rs:24:65\n\
    \   |\n24 |"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut counter: usize\
    \ = 0;\n    let mut prime_counter: usize = 0;\n    let mut prime_counter2: usize\
    \ = 0;\n    let mut prime_counter3: usize = 0;\n    let mut prime_counter4: usize\
    \ = 0;\n    let mut prime_counter5: usize = 0;\n    let mut prime_counter6: usize\
    \ = 0;\n    let mut prime_counter7: usize = 0;\n    let mut prime_counter8: usize\
    \ = 0;\n    let mut prime_counter9: usize = 0;\n    let mut prime_counter10: usize\
    \ = 0;\n    let mut prime_counter11: usize = 0;\n    let mut prime_counter12:\
    \ usize = 0;\n    let mut prime_counter13: usize = 0;\n    let mut prime_counter14:\
    \ usize = 0;\n    let mut prime_counter15: usize = 0;\n    let mut prime_counter16:\
    \ usize = 0;\n    let mut prime_counter17: usize = 0;\n    let mut prime_counter18:\
    \ usize = 0;\n    let mut prime_counter19: usize = 0;\n    let mut prime_counter20:\
    \ usize = 0;\n    let mut prime_counter21: usize = 0;\n    let mut prime_counter22:\
    \ usize = 0;\n    let mut prime_counter23: usize = 0;\n    let mut prime_counter24:\
    \ usize = 0;\n    let mut prime_counter25: usize = 0;\n    let mut prime_counter26:\
    \ usize = 0;\n    let mut prime_counter27: usize = 0;\n    let mut prime_counter28:\
    \ usize = 0;\n    let mut prime_counter29: usize = 0;\n    let mut prime_counter30:\
    \ usize = 0;\n    let mut prime_counter31: usize = 0;\n    let mut prime_counter32:\
    \ usize = 0;\n    let mut prime_counter33: usize = 0;\n    let mut prime_counter34:\
    \ usize = 0;\n    let mut prime_counter35: usize = 0;\n    let mut prime_counter36:\
    \ usize = 0;\n    let mut prime_counter37: usize = 0;\n\n}\n\nfn main() {\n  \
    \  let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmps9y6fyxe.rs:23:55\n     |\n23\
    \   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |\
    \                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps9y6fyxe.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let mut prime_counter:\
    \ usize = 0;\n    let mut digit: u8 = 0;\n    let mut digit_counter: usize = 0;\n\
    \    let mut digit_prime: u8 = 0;\n    let mut digit_prime_counter: usize = 0;\n\
    \    let mut digit_prime_counter2: usize = 0;\n    let mut digit_prime_counter3:\
    \ usize = 0;\n    let mut digit_prime_counter4: usize = 0;\n    let mut digit_prime_counter5:\
    \ usize = 0;\n    let mut digit_prime_counter6: usize = 0;\n    let mut digit_prime_counter7:\
    \ usize = 0;\n    let mut digit_prime_counter8: usize = 0;\n    let mut digit_prime_counter9:\
    \ usize = 0;\n    let mut digit_prime_counter10: usize = 0;\n    let mut digit_prime_counter11:\
    \ usize = 0;\n    let mut digit_prime_counter12: usize = 0;\n    let mut digit_prime_counter13:\
    \ usize = 0;\n    let mut digit_prime_counter14: usize = 0;\n    let mut digit_prime_counter15:\
    \ usize = 0;\n    let mut digit_prime_counter16: usize = 0;\n    let mut digit_prime_counter17:\
    \ usize = 0;\n    let mut digit_prime_counter18: usize = 0;\n    let mut digit_prime_counter19:\
    \ usize = 0;\n    let mut digit_prime_counter20: usize = 0;\n    let mut digit_prime_counter21:\
    \ usize = 0;\n    let mut digit_prime_counter22: usize = 0;\n    let mut digit_prime_counter23:\
    \ usize = 0;\n    let mut digit_prime_counter24: usize = 0;\n    let mut digit_prime_counter25:\
    \ usize = 0;\n    let mut digit_prime_counter26: usize = 0;\n    let mut digit_prime_counter27:\
    \ usize = 0;\n    let mut digit_prime_counter28: usize = 0;\n    let mut digit_prime_counter29:\
    \ usize = 0;\n    let mut digit_prime_counter30: usize = 0;\n    let mut digit_prime_counter31:\
    \ usize = 0;\n    let mut digit_prime_counter32: usize = 0;\n    let mut digit_prime_counter33:\
    \ usize = 0;\n    let mut digit_prime_counter34: u\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvponr3bx.rs:62:37\n   |\n\
    62 |     let mut digit_prime_counter34: u\n   |                              \
    \       ^ help: add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0412]:\
    \ cannot find type `u` in this scope\n  --> /tmp/tmpvponr3bx.rs:62:36\n   |\n\
    62 |     let mut digit_prime_counter34: u\n   |                              \
    \      ^ help: a builtin type with a similar name exists: `u8`\n\nerror[E0277]:\
    \ a value of type `Vec<u8>` cannot be built from an iterator over elements of\
    \ type `char`\n    --> /tmp/tmpvponr3bx.rs:23:55\n     |\n23   |     let mut num:\
    \ Vec<u8> = num.to_lowercase().chars().collect();\n     |                    \
    \                                   ^^^^^^^ value of type `Vec<u8>` cannot be\
    \ built from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait\
    \ `FromIterator<char>` is not implemented for `Vec<u8>`\n     = help: the trait\
    \ `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound in\
    \ `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvponr3bx.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0412.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num_digits = num.len();\n    let mut prime_digits = 0;\n    let mut\
    \ prime_digits_counter = 0;\n    let mut prime_digits_counter2 = 0;\n    let mut\
    \ prime_digits_counter3 = 0;\n    let mut prime_digits_counter4 = 0;\n    let\
    \ mut prime_digits_counter5 = 0;\n    let mut prime_digits_counter6 = 0;\n   \
    \ let mut prime_digits_counter7 = 0;\n    let mut prime_digits_counter8 = 0;\n\
    \    let mut prime_digits_counter9 = 0;\n    let mut prime_digits_counter10 =\
    \ 0;\n    let mut prime_digits_counter11 = 0;\n    let mut prime_digits_counter12\
    \ = 0;\n    let mut prime_digits_counter13 = 0;\n    let mut prime_digits_counter14\
    \ = 0;\n    let mut prime_digits_counter15 = 0;\n    let mut prime_digits_counter16\
    \ = 0;\n    let mut prime_digits_counter17 = 0;\n    let mut prime_digits_counter18\
    \ = 0;\n    let mut prime_digits_counter19 = 0;\n    let mut prime_digits_counter20\
    \ = 0;\n    let mut prime_digits_counter21 = 0;\n    let mut prime_digits_counter22\
    \ = 0;\n    let mut prime_digits_counter23 = 0;\n    let mut prime_digits_counter24\
    \ = 0;\n    let mut prime_digits_counter25 = 0;\n    let mut prime_digits_counter26\
    \ = 0;\n    let mut prime_digits_counter27 = 0;\n    let mut prime_digits_counter28\
    \ = 0;\n    let mut prime_digits_counter29 = 0;\n    let mut prime_digits_counter30\
    \ = 0;\n    let mut prime_digits_counter31 = 0;\n    let mut prime_digits_counter32\
    \ = 0;\n    let mut prime_digits_counter33 = 0;\n    let mut prime_digits_counter34\
    \ = 0;\n    let mut prime_digits_counter35 = 0;\n    let mut prime_digits_counter36\
    \ = 0;\n    let mut prime_digits_counter37 = 0;\n    let mut prime_digits_counter38\
    \ = 0;\n    let mut prime_digits_counter39 = 0;\n    let mut prime_digits_counter40\
    \ = 0;\n    let mut prime_digits_counter41 = 0;\n    let mut prime_digits_counter42\
    \ = 0;\n    let mut prime_digits_counter43 = 0;\n    let mut prime_digit\n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpb4xai1sp.rs:69:24\n   |\n\
    69 |     let mut prime_digit\n   |                        ^ help: add `;` here\n\
    70 | }\n   | - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot\
    \ be built from an iterator over elements of type `char`\n    --> /tmp/tmpb4xai1sp.rs:23:52\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_string().chars().collect();\n\
    \     |                                                    ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb4xai1sp.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_counter:\
    \ Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_counter_index: usize\
    \ = 0;\n    let mut prime_counter_index2: usize = 0;\n    let mut prime_counter_index3:\
    \ usize = 0;\n    let mut prime_counter_index4: usize = 0;\n    let mut prime_counter_index5:\
    \ usize = 0;\n    let mut prime_counter_index6: usize = 0;\n    let mut prime_counter_index7:\
    \ usize = 0;\n    let mut prime_counter_index8: usize = 0;\n    let mut prime_counter_index9:\
    \ usize = 0;\n    let mut prime_counter_index10: usize = 0;\n    let mut prime_counter_index11:\
    \ usize = 0;\n    let mut prime_counter_index12: usize = 0;\n    let mut prime_counter_index13:\
    \ usize = 0;\n    let mut prime_counter_index14: usize = 0;\n    let mut prime_counter_index15:\
    \ usize = 0;\n    let mut prime_counter_index16: usize = 0;\n    let mut prime_counter_index17:\
    \ usize = 0;\n    let mut prime_counter_index18: usize = 0;\n    let mut prime_counter_index19:\
    \ usize = 0;\n    let mut prime_counter_index20: usize = 0;\n    let mut prime_counter_index21:\
    \ usize = 0;\n    let mut prime_counter_index22: usize = 0;\n    let mut prime_counter_index23:\
    \ usize = 0;\n    let mut prime_counter_index24: usize = 0;\n    let mut prime_counter_index25:\
    \ usize = 0;\n    let mut prime_counter_index26: usize = 0;\n    let mut prime_counter_index27:\
    \ usize = 0;\n    let mut prime_counter_index28: usize = 0;\n    let mut prime_counter_index29:\
    \ usize = 0;\n    let mut prime_counter_index30: usize = 0;\n    let mut prime_counter_index31:\
    \ usize = 0;\n    let mut prime_counter_index32: usize = 0;\n    let mut prime_counter_index33:\
    \ usize = 0;\n    let mut prime_\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmphb22rtc_.rs:59:19\n   |\n\
    59 |     let mut prime_\n   |                   ^ help: add `;` here\n60 | }\n\
    \   | - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be\
    \ built from an iterator over elements of type `char`\n    --> /tmp/tmphb22rtc_.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphb22rtc_.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.in\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found keyword `in`\n  --> /tmp/tmpsxpv55i4.rs:39:32\n\
    \   |\n39 |     let mut num: Vec<u8> = num.in\n   |                          \
    \      ^^ expected identifier, found keyword\n   |\nhelp: escape `in` to use it\
    \ as an identifier\n   |\n39 |     let mut num: Vec<u8> = num.r#in\n   |     \
    \                           ++\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpsxpv55i4.rs:39:34\n\
    \   |\n39 |     let mut num: Vec<u8> = num.in\n   |                          \
    \        ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0277]:\
    \ a value of type `Vec<u8>` cannot be built from an iterator over elements of\
    \ type `char`\n    --> /tmp/tmpsxpv55i4.rs:23:52\n     |\n23   |     let mut num:\
    \ Vec<u8> = num.to_string().chars().collect();\n     |                       \
    \                             ^^^^^^^ value of type `Vec<u8>` cannot be built\
    \ from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsxpv55i4.rs:24:61\n   |\n24 |     let mut num:\
    \ Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n   |\
    \                                                             ^^^ expected `u8`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsxpv55i4.rs:24:73\n\
    \   |\n24 |     let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' &&\
    \ x <= '9').collect();\n   |                                                 \
    \                        ^^^ expected `u8`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpsxpv55i4.rs:25:61\n   |\n25 |     let mut num: Vec<u8>\
    \ = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n   |       \
    \                                                      ^^^ expected `u8`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsxpv55i4.rs:25:73\n\
    \   |\n25 |     let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' &&\
    \ x <= 'F').collect();\n   |              "
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_counter:\
    \ usize = 0;\n    let mut prime_counter2: usize = 0;\n    let mut prime_counter3:\
    \ usize = 0;\n    let mut prime_counter4: usize = 0;\n    let mut prime_counter5:\
    \ usize = 0;\n    let mut prime_counter6: usize = 0;\n    let mut prime_counter7:\
    \ usize = 0;\n    let mut prime_counter8: usize = 0;\n    let mut prime_counter9:\
    \ usize = 0;\n    let mut prime_counter10: usize = 0;\n    let mut prime_counter11:\
    \ usize = 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13:\
    \ usize = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: u\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpq_13wd7x.rs:62:31\n   |\n\
    62 |     let mut prime_counter38: u\n   |                               ^ help:\
    \ add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0412]: cannot find type\
    \ `u` in this scope\n  --> /tmp/tmpq_13wd7x.rs:62:30\n   |\n62 |     let mut prime_counter38:\
    \ u\n   |                              ^ help: a builtin type with a similar name\
    \ exists: `u8`\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from\
    \ an iterator over elements of type `char`\n    --> /tmp/tmpq_13wd7x.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq_13wd7x.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0412.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_counter:\
    \ usize = 0;\n    let mut prime_counter2: usize = 0;\n    let mut prime_counter3:\
    \ usize = 0;\n    let mut prime_counter4: usize = 0;\n    let mut prime_counter5:\
    \ usize = 0;\n    let mut prime_counter6: usize = 0;\n    let mut prime_counter7:\
    \ usize = 0;\n    let mut prime_counter8: usize = 0;\n    let mut prime_counter9:\
    \ usize = 0;\n    let mut prime_counter10: usize = 0;\n    let mut prime_counter11:\
    \ usize = 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13:\
    \ usize = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: u\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5h95n5pg.rs:62:31\n   |\n\
    62 |     let mut prime_counter38: u\n   |                               ^ help:\
    \ add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0412]: cannot find type\
    \ `u` in this scope\n  --> /tmp/tmp5h95n5pg.rs:62:30\n   |\n62 |     let mut prime_counter38:\
    \ u\n   |                              ^ help: a builtin type with a similar name\
    \ exists: `u8`\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from\
    \ an iterator over elements of type `char`\n    --> /tmp/tmp5h95n5pg.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5h95n5pg.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0412.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpmum7nkcc.rs:40:36\n   |\n\
    40 |     let mut num: Vec<u8> = num.iter\n   |                               \
    \     ^ help: add `;` here\n41 | }\n   | - unexpected token\n\nerror[E0277]: a\
    \ value of type `Vec<u8>` cannot be built from an iterator over elements of type\
    \ `char`\n    --> /tmp/tmpmum7nkcc.rs:23:55\n     |\n23   |     let mut num: Vec<u8>\
    \ = num.to_lowercase().chars().collect();\n     |                            \
    \                           ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmum7nkcc.rs:24:56\n   |\n24 |     let mut num:\
    \ Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n   |    \
    \                                                    ^^^ expected `&u8`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmum7nkcc.rs:24:68\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <=\
    \ '9').collect();\n   |                                                      \
    \              ^^^ expected `&u8`, found `char`\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `&u8`\n   \
    \ --> /tmp/tmpmum7nkcc.rs:24:73\n     |\n24   |     let mut num: Vec<u8> = num.iter().filter(|&x|\
    \ x >= '0' && x <= '9').collect();\n     |                                   \
    \                                      ^^^^^^^ value of type `Vec<u8>` cannot\
    \ be built from `std::iter::Iterator<Item=&u8>`\n     |\n     = help: the trait\
    \ `FromIterator<&u8>` is not implemented for `Vec<u8>`\n     = help: the trait\
    \ `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound in\
    \ `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmum7nkcc.rs:25:56\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <=\
    \ 'F').collect();\n   |                               "
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut nums = num.chars().collect::<Vec<_>>();\n    let mut nums_len\
    \ = nums.len();\n    let mut primes = vec![true; nums_len];\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpf7ghoeaq.rs:69:1\n   |\n69\
    \ | }\n   | ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpf7ghoeaq.rs:68:33\n\
    \   |\n68 |     let mut primes_len = primes.\n   |                           \
    \      ^ help: add `;` here\n69 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf7ghoeaq.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut nums = num.chars().collect::<Vec<_>>();\n    let mut nums_len\
    \ = nums.len();\n    let mut primes = vec![false; 26];\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n    let mut primes_len = primes.len();\n    let mut primes_len\
    \ = primes.len();\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp126hhtc8.rs:22:28\n   |\n\
    22 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num_prime: Vec<u8> = Vec::new();\n    let mut num_prime_counter: usize\
    \ = 0;\n    let mut num_prime_counter2: usize = 0;\n    let mut num_prime_counter3:\
    \ usize = 0;\n    let mut num_prime_counter4: usize = 0;\n    let mut num_prime_counter5:\
    \ usize = 0;\n    let mut num_prime_counter6: usize = 0;\n    let mut num_prime_counter7:\
    \ usize = 0;\n    let mut num_prime_counter8: usize = 0;\n    let mut num_prime_counter9:\
    \ usize = 0;\n    let mut num_prime_counter10: usize = 0;\n    let mut num_prime_counter11:\
    \ usize = 0;\n    let mut num_prime_counter12: usize = 0;\n    let mut num_prime_counter13:\
    \ usize = 0;\n    let mut num_prime_counter14: usize = 0;\n    let mut num_prime_counter15:\
    \ usize = 0;\n    let mut num_prime_counter16: usize = 0;\n    let mut num_prime_counter17:\
    \ usize = 0;\n    let mut num_prime_counter18: usize = 0;\n    let mut num_prime_counter19:\
    \ usize = 0;\n    let mut num_prime_counter20: usize = 0;\n    let mut num_prime_counter21:\
    \ usize = 0;\n    let mut num_prime_counter22: usize = 0;\n    let mut num_prime_counter23:\
    \ usize = 0;\n    let mut num_prime_counter24: usize = 0;\n    let mut num_prime_counter25:\
    \ usize = 0;\n    let mut num_prime_counter26: usize = 0;\n    let mut num_prime_counter27:\
    \ usize = 0;\n    let mut num_prime_counter28: usize = 0;\n    let mut num_prime_counter29:\
    \ usize = 0;\n    let mut num_prime_counter30: usize = 0;\n    let mut num_prime_counter31:\
    \ usize = 0;\n    let mut num_prime_counter32: usize = 0;\n    let mut num_prime_counter33:\
    \ usize = 0;\n    let mut num_prime_counter34: usize = 0;\n    let mut num_prime_counter35:\
    \ usize = 0;\n    let mut num_prime_counter36: usize = 0;\n    let mut num_prime_counter37:\
    \ usize = 0;\n    let \n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpz3rmj9d_.rs:63:1\n  \
    \ |\n63 | }\n   | ^ expected pattern\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n    --> /tmp/tmpz3rmj9d_.rs:23:52\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_string().chars().collect();\n\
    \     |                                                    ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
