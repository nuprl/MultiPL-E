language: rs
name: HumanEval_61_correct_bracketing
results:
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    let mut opening_brackets = String::new();\n\
    \    let mut closing_brackets = String::new();\n    while brackets.len() > 0 {\n\
    \        let mut opening_bracket = String::new();\n        let mut closing_bracket\
    \ = String::new();\n        if brackets.starts_with(\"(\") {\n            opening_bracket\
    \ = brackets.chars().next().unwrap();\n            brackets = brackets.chars().next().unwrap();\n\
    \        }\n        if brackets.starts_with(\")\") {\n            closing_bracket\
    \ = brackets.chars().next().unwrap();\n            brackets = brackets.chars().next().unwrap();\n\
    \        }\n        if opening_bracket.len() == 0 && closing_bracket.len() ==\
    \ 0 {\n            return false;\n        }\n        if opening_bracket.len()\
    \ > 0 && closing_bracket.len() > 0 {\n            if opening_bracket != closing_bracket\
    \ {\n                return false;\n            }\n        }\n        if opening_bracket.len()\
    \ > 0 {\n            opening_brackets.push_str(&opening_bracket);\n        }\n\
    \        if closing_bracket.len() > 0 {\n            closing_brackets.push_str(&closing_bracket);\n\
    \        }\n    }\n    opening_brackets == closing_brackets\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbf4z7y7w.rs:19:31\n   |\n\
    16 |         let mut opening_bracket = String::new();\n   |                  \
    \                 ------------- expected due to this value\n...\n19 |        \
    \     opening_bracket = brackets.chars().next().unwrap();\n   |              \
    \                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                               |\n   |         \
    \                      expected struct `String`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbf4z7y7w.rs:20:24\n   |\n12 |     let mut brackets\
    \ = brackets.to_string();\n   |                        -------------------- expected\
    \ due to this value\n...\n20 |             brackets = brackets.chars().next().unwrap();\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                        |\n   |   \
    \                     expected struct `String`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbf4z7y7w.rs:23:31\n   |\n17 |         let mut\
    \ closing_bracket = String::new();\n   |                                   -------------\
    \ expected due to this value\n...\n23 |             closing_bracket = brackets.chars().next().unwrap();\n\
    \   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                            \
    \   |\n   |                               expected struct `String`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbf4z7y7w.rs:24:24\n   |\n12 |\
    \     let mut brackets = brackets.to_string();\n   |                        --------------------\
    \ expected due to this value\n...\n24 |             brackets = brackets.chars().next().unwrap();\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                        |\n   |   \
    \                     expected struct `String`, found `char`\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `ru"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n\
    \    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    [\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\"\
    );\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"\
    ]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\"\
    , \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\"\
    );\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"\
    [\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\"\
    );\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp9c69t4s7.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\"\
    , \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n\
    \    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\"\
    , \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    [\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\"\
    );\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp8iadlwwo.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = Vec::new();\n    for ch in brackets.chars() {\n    \
    \    if ch == '(' {\n            stack.push(0);\n        } else if ch == ')' {\n\
    \            stack.pop();\n        } else {\n            stack.push(stack.last().unwrap()\
    \ + 1);\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpa26ykk2x.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().skip_while(|c| !c.is_ascii_letter()).collect());\n\
    \    loop {\n        if stack.len() == 0 {\n            return false;\n      \
    \  }\n        let mut last = stack.last().unwrap();\n        if last.is_ascii_letter()\
    \ {\n            stack.pop();\n        } else {\n            return false;\n \
    \       }\n        if stack.len() == 0 {\n            return true;\n        }\n\
    \        let mut first = stack.first().unwrap();\n        if first.is_ascii_letter()\
    \ {\n            stack.shift();\n        } else {\n            return false;\n\
    \        }\n        if last != first {\n            return false;\n        }\n\
    \    }\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpzn4_cjyi.rs:13:51\n   |\n13 |     stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).collect());\n   |                                    \
    \               ^^^^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `is_ascii`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut open_brackets = Vec::new();\n    let mut\
    \ close_brackets = Vec::new();\n    let mut open_brackets_size = brackets.chars().filter(|c|\
    \ c == '(').count();\n    let mut close_brackets_size = brackets.chars().filter(|c|\
    \ c == ')').count();\n    let mut open_brackets_chars = Vec::new();\n    let mut\
    \ close_brackets_chars = Vec::new();\n    let mut open_brackets_chars_size = brackets.chars().filter(|c|\
    \ c == '(').count();\n    let mut close_brackets_chars_size = brackets.chars().filter(|c|\
    \ c == ')').count();\n    let mut open_brackets_chars_chars = Vec::new();\n  \
    \  let mut close_brackets_chars_chars = Vec::new();\n    let mut open_brackets_chars_chars_size\
    \ = brackets.chars().filter(|c| c == '(').count();\n    let mut close_brackets_chars_chars_size\
    \ = brackets.chars().filter(|c| c == ')').count();\n    let mut open_brackets_chars_chars_chars\
    \ = Vec::new();\n    let mut close_brackets_chars_chars_chars = Vec::new();\n\
    \    let mut open_brackets_chars_chars_chars_size = brackets.chars().filter(|c|\
    \ c == '(').count();\n    let mut close_brackets_chars_chars_chars_size = brackets.chars().filter(|c|\
    \ c == ')').count();\n    let mut open_brackets_chars_chars_chars_chars = Vec::new();\n\
    \    let mut close_brackets_chars_chars_chars_chars = Vec::new();\n    let mut\
    \ open_brackets_chars_chars_chars_chars_size = brackets.chars().filter(|c| c ==\
    \ '(').count();\n    let mut close_brackets_chars_chars_chars_chars_size = brackets.chars().filter(|c|\
    \ c == ')').count();\n    let mut open_brackets_chars_chars_chars_chars_chars\
    \ = Vec::new();\n    let mut close_brackets_chars_chars_chars_chars_chars = Vec::new();\n\
    \    let mut open_brackets_chars_char\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpiuc5wp73.rs:35:37\n   |\n\
    35 |     let mut open_brackets_chars_char\n   |                              \
    \       ^ help: add `;` here\n36 | }\n   | - unexpected token\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpiuc5wp73.rs:15:64\n   |\n15\
    \ |     let mut open_brackets_size = brackets.chars().filter(|c| c == '(').count();\n\
    \   |                                                                ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpiuc5wp73.rs:16:65\n\
    \   |\n16 |     let mut close_brackets_size = brackets.chars().filter(|c| c ==\
    \ ')').count();\n   |                                                        \
    \         ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpiuc5wp73.rs:19:70\n   |\n19 |     let mut open_brackets_chars_size\
    \ = brackets.chars().filter(|c| c == '(').count();\n   |                     \
    \                                                 ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpiuc5wp73.rs:20:71\n   |\n20\
    \ |     let mut close_brackets_chars_size = brackets.chars().filter(|c| c == ')').count();\n\
    \   |                                                                       ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpiuc5wp73.rs:23:76\n\
    \   |\n23 |     let mut open_brackets_chars_chars_size = brackets.chars().filter(|"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    while let Some(item) = stack.last() {\n        if item == ')' {\n       \
    \     stack.pop();\n        } else {\n            stack.push(item);\n        }\n\
    \    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp4t2p3817.rs:15:17\n\
    \   |\n15 |         if item == ')' {\n   |                 ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp4t2p3817.rs:18:24\n   |\n18 |  \
    \           stack.push(item);\n   |                        ^^^^ expected `char`,\
    \ found `&char`\n   |\nhelp: consider dereferencing the borrow\n   |\n18 |   \
    \          stack.push(*item);\n   |                        +\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = vec![];\n    for ch in brackets.chars() {\n        if ch == '('\
    \ || ch == ')' {\n            stack.push(ch);\n        } else if ch == '{' ||\
    \ ch == '}' {\n            if stack.is_empty() {\n                return false;\n\
    \            }\n            let mut last = stack.pop().unwrap();\n           \
    \ if last != ch {\n                return false;\n            }\n        }\n \
    \   }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp66ocyd9_.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets);\n    while !stack.is_empty()\
    \ {\n        let mut current = stack.pop();\n        if current.is_empty() {\n\
    \            continue;\n        }\n        let mut next = current.clone();\n \
    \       while !next.is_empty() {\n            let mut next = next.clone();\n \
    \           if !next.starts_with('(') {\n                return false;\n     \
    \       }\n            next.pop();\n            if !next.starts_with(')') {\n\
    \                return false;\n            }\n            next.pop();\n     \
    \       stack.push(next);\n        }\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\"\
    )), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_empty` found for enum `Option` in the\
    \ current scope\n  --> /tmp/tmpj1h8uet1.rs:16:20\n   |\n16 |         if current.is_empty()\
    \ {\n   |                    ^^^^^^^^ method not found in `Option<String>`\n\n\
    error[E0599]: no method named `is_empty` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpj1h8uet1.rs:20:21\n   |\n20 |         while !next.is_empty()\
    \ {\n   |                     ^^^^^^^^ method not found in `Option<String>`\n\n\
    error[E0599]: no method named `starts_with` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpj1h8uet1.rs:22:22\n   |\n22 |             if !next.starts_with('(')\
    \ {\n   |                      ^^^^^^^^^^^ method not found in `Option<String>`\n\
    \nerror[E0599]: no method named `pop` found for enum `Option` in the current scope\n\
    \  --> /tmp/tmpj1h8uet1.rs:25:18\n   |\n25 |             next.pop();\n   |   \
    \               ^^^ method not found in `Option<String>`\n\nerror[E0599]: no method\
    \ named `starts_with` found for enum `Option` in the current scope\n  --> /tmp/tmpj1h8uet1.rs:26:22\n\
    \   |\n26 |             if !next.starts_with(')') {\n   |                    \
    \  ^^^^^^^^^^^ method not found in `Option<String>`\n\nerror[E0599]: no method\
    \ named `pop` found for enum `Option` in the current scope\n  --> /tmp/tmpj1h8uet1.rs:29:18\n\
    \   |\n29 |             next.pop();\n   |                  ^^^ method not found\
    \ in `Option<String>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj1h8uet1.rs:30:24\n\
    \   |\n30 |             stack.push(next);\n   |                        ^^^^ expected\
    \ struct `String`, found enum `Option`\n   |\n   = note: expected struct `String`\n\
    \                found enum `Option<String>`\n\nerror: aborting due to 7 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    for c in brackets.chars() {\n        if\
    \ c == '(' {\n            stack.push(0);\n        } else if c == ')' {\n     \
    \       if stack.len() == 0 {\n                return false;\n            }\n\
    \            stack.pop();\n        } else {\n            if stack.len() == 0 {\n\
    \                return false;\n            }\n            stack[stack.len() -\
    \ 1] += 1;\n        }\n    }\n    stack.iter().all(|&x| x == 0)\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `stack` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmp16wza0b0.rs:25:19\n   |\n25 |             stack[stack.len()\
    \ - 1] += 1;\n   |             ------^^^^^^^^^^^-----\n   |             |    \
    \ |\n   |             |     immutable borrow occurs here\n   |             mutable\
    \ borrow occurs here\n   |             mutable borrow later used here\n   |\n\
    help: try adding a local storing this...\n  --> /tmp/tmp16wza0b0.rs:25:19\n  \
    \ |\n25 |             stack[stack.len() - 1] += 1;\n   |                   ^^^^^^^^^^^\n\
    help: ...and then using that local here\n  --> /tmp/tmp16wza0b0.rs:25:13\n   |\n\
    25 |             stack[stack.len() - 1] += 1;\n   |             ^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0502`.\n"
  stdout: ''
- exit_code: 0
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for bracket in brackets.chars() {\n        if bracket\
    \ == '(' {\n            stack.push(bracket);\n        } else if bracket == ')'\
    \ {\n            if stack.is_empty() {\n                return false;\n      \
    \      }\n            stack.pop();\n        } else {\n            return false;\n\
    \        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets == brackets\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpcj2c4sic.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == ')' || c == '(')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpexnsdi2v.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = vec![];\n    stack.push(brackets.chars().filter(|c| c == '(').collect::<String>());\n\
    \    while let Some(last) = stack.pop() {\n        if let Some(next) = stack.pop()\
    \ {\n            if last == next {\n                return false;\n          \
    \  }\n        }\n        stack.push(last.chars().filter(|c| c == ')').collect::<String>());\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp0ekag5lo.rs:13:46\n\
    \   |\n13 |     stack.push(brackets.chars().filter(|c| c == '(').collect::<String>());\n\
    \   |                                              ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmp0ekag5lo.rs:20:46\n   |\n20\
    \ |         stack.push(last.chars().filter(|c| c == ')').collect::<String>());\n\
    \   |                                              ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut opening_brackets = String::new();\n   \
    \ let mut closing_brackets = String::new();\n    let mut opening_brackets_count\
    \ = String::new();\n    let mut closing_brackets_count = String::new();\n    let\
    \ mut opening_brackets_count_stack = Vec::new();\n    let mut closing_brackets_count_stack\
    \ = Vec::new();\n    let mut opening_brackets_count_stack = Vec::new();\n    let\
    \ mut closing_brackets_count_stack = Vec::new();\n    let mut opening_brackets_count_stack\
    \ = Vec::new();\n    let mut closing_brackets_count_stack = Vec::new();\n    let\
    \ mut opening_brackets_count_stack = Vec::new();\n    let mut closing_brackets_count_stack\
    \ = Vec::new();\n    let mut opening_brackets_count_stack = Vec::new();\n    let\
    \ mut closing_brackets_count_stack = Vec::new();\n    let mut opening_brackets_count_stack\
    \ = Vec::new();\n    let mut closing_brackets_count_stack = Vec::new();\n    let\
    \ mut opening_brackets_count_stack = Vec::new();\n    let mut closing_brackets_count_stack\
    \ = Vec::new();\n    let mut opening_brackets_count_stack = Vec::new();\n    let\
    \ mut closing_brackets_count_stack = Vec::new();\n    let mut opening_brackets_count_stack\
    \ = Vec::new();\n    let mut closing_brackets_count_stack = Vec::new();\n    let\
    \ mut opening_brackets_count_stack = Vec::new();\n    let mut closing_brackets_count_stack\
    \ = Vec::new();\n    let mut opening_brackets_count_stack = Vec::new();\n    let\
    \ mut closing_brackets_count_stack = Vec::new();\n    let mut opening_brackets_count_stack\
    \ = Vec::new();\n    let mut closing_brackets_count_stack = Vec::new();\n    let\
    \ mut opening_brackets_count_stack = Vec::new();\n    let mut closing_brackets_count_stack\
    \ = Vec::new();\n    let mut opening_brackets_count_stack = Vec::new();\n\n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbej3w90h.rs:11:44\n   |\n\
    11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_brackets_stack = Vec::new();\n    let mut closed_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack_ptr = &mut open_brackets_stack;\n\
    \    let mut closed_brackets_stack_ptr = &mut closed_brackets_stack;\n    let\
    \ mut brackets_ptr = &mut brackets;\n    while brackets_ptr.len() > 0 {\n    \
    \    let mut open_brackets_ptr = open_brackets_stack_ptr;\n        let mut closed_brackets_ptr\
    \ = closed_brackets_stack_ptr;\n        let mut brackets_ptr = &mut brackets_ptr;\n\
    \        while brackets_ptr.len() > 0 {\n            let mut open_brackets_ptr\
    \ = open_brackets_ptr.as_mut();\n            let mut closed_brackets_ptr = closed_brackets_ptr.as_mut();\n\
    \            let mut brackets_ptr = &mut brackets_ptr;\n            let mut open_bracket\
    \ = String::new();\n            let mut closed_bracket = String::new();\n    \
    \        while brackets_ptr.len() > 0 {\n                let mut open_bracket\
    \ = open_bracket.as_mut();\n                let mut closed_bracket = closed_bracket.as_mut();\n\
    \                let mut brackets_ptr = &mut brackets_ptr;\n                let\
    \ mut open_bracket = open_bracket.clone();\n                let mut closed_bracket\
    \ = closed_bracket.clone();\n                while brackets_ptr.len() > 0 {\n\
    \                    let mut open_bracket = open_bracket.clone();\n          \
    \          let mut closed_bracket = closed_bracket.clone();\n                \
    \    let mut brackets_ptr = &mut brackets_ptr;\n                    let mut open_bracket\
    \ = open_bracket.clone();\n                    let mut closed_bracket = closed_bracket.clone();\n\
    \                    while brackets_ptr.len() > 0 {\n                        let\
    \ mut open_bracket = open_bracket.clone();\n                        let mut closed_bracket\
    \ = closed_bracket.clone();\n                        let mut brackets_ptr = &mut\
    \ brackets_ptr;\n                        let mut open_bracket = open_bracket.clone();\n\
    \                        let mut closed_bracket = \n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\"\
    )), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpzmrukllh.rs:63:3\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - unclosed delimiter\n...\n19 |     while\
    \ brackets_ptr.len() > 0 {\n   |                                  - unclosed delimiter\n\
    ...\n23 |         while brackets_ptr.len() > 0 {\n   |                       \
    \               - unclosed delimiter\n...\n29 |             while brackets_ptr.len()\
    \ > 0 {\n   |                                          - unclosed delimiter\n\
    ...\n35 |                 while brackets_ptr.len() > 0 {\n   |               \
    \                               - unclosed delimiter\n...\n41 |              \
    \       while brackets_ptr.len() > 0 {\n   |                                 \
    \                 - this delimiter might not be properly closed...\n...\n47 |\
    \ }\n   | - ...as it matches this but it has different indentation\n...\n63 |\
    \ }\n   |   ^\n\nerror: expected expression, found `}`\n  --> /tmp/tmpzmrukllh.rs:47:1\n\
    \   |\n47 | }\n   | ^ expected expression\n\nerror[E0599]: no method named `clone`\
    \ found for mutable reference `&mut str` in the current scope\n  --> /tmp/tmpzmrukllh.rs:33:53\n\
    \   |\n33 |                 let mut open_bracket = open_bracket.clone();\n   |\
    \                                                     ^^^^^ method not found in\
    \ `&mut str`\n\nerror[E0599]: no method named `clone` found for mutable reference\
    \ `&mut str` in the current scope\n  --> /tmp/tmpzmrukllh.rs:34:57\n   |\n34 |\
    \                 let mut closed_bracket = closed_bracket.clone();\n   |     \
    \                                                    ^^^^^ method not found in\
    \ `&mut str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzmrukllh.rs:19:5\n\
    \   |\n11 |   fn correct_bracketing(brackets: String) -> bool {\n   |        \
    \                                      ---- expected `bool` because of return\
    \ type\n...\n19 | /     while brackets_ptr.len() > 0 {\n20 | |         let mut\
    \ open_brackets_ptr = open_brackets_stack_ptr;\n21 | |         let mut closed_brackets_ptr\
    \ = closed_brackets_stack_ptr;\n22 | "
  stdout: ''
- exit_code: -1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    while brackets.len() > 2 {\n     \
    \   let mut opening = brackets.chars().next().unwrap();\n        let mut closing\
    \ = brackets.chars().next().unwrap();\n        if opening != closing {\n     \
    \       return false;\n        }\n        brackets = brackets.chars().collect::<String>().to_string();\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Timeout
  stderr: ''
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    for c in brackets.chars() {\n        if stack.is_empty() {\n            return\
    \ false;\n        }\n        if stack.pop() != c {\n            return false;\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkio34iqy.rs:18:27\n   |\n\
    18 |         if stack.pop() != c {\n   |                           ^ expected\
    \ enum `Option`, found `char`\n   |\n   = note: expected enum `Option<char>`\n\
    \              found type `char`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n18 |         if stack.pop() != Some(c) {\n   |                        \
    \   +++++ +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for ch in brackets.chars() {\n        if ch ==\
    \ '(' {\n            stack.push((ch, false));\n        } else if ch == ')' {\n\
    \            if let Some((_, is_open)) = stack.pop() {\n                if !is_open\
    \ {\n                    return false;\n                }\n            } else\
    \ {\n                return false;\n            }\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_4hm_7eu.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    for c in brackets.chars() {\n        if\
    \ c == '(' {\n            stack.push(0);\n        } else if c == ')' {\n     \
    \       if stack.len() == 0 {\n                return false;\n            }\n\
    \            stack.pop();\n        } else {\n            if stack.len() == 0 {\n\
    \                return false;\n            }\n            stack[stack.len() -\
    \ 1] += 1;\n        }\n    }\n    stack.iter().all(|&x| x == 0)\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `stack` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmp6p3u3dc3.rs:25:19\n   |\n25 |             stack[stack.len()\
    \ - 1] += 1;\n   |             ------^^^^^^^^^^^-----\n   |             |    \
    \ |\n   |             |     immutable borrow occurs here\n   |             mutable\
    \ borrow occurs here\n   |             mutable borrow later used here\n   |\n\
    help: try adding a local storing this...\n  --> /tmp/tmp6p3u3dc3.rs:25:19\n  \
    \ |\n25 |             stack[stack.len() - 1] += 1;\n   |                   ^^^^^^^^^^^\n\
    help: ...and then using that local here\n  --> /tmp/tmp6p3u3dc3.rs:25:13\n   |\n\
    25 |             stack[stack.len() - 1] += 1;\n   |             ^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0502`.\n"
  stdout: ''
- exit_code: -1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    while brackets.len() > 0 {\n     \
    \   let mut opening = brackets.chars().next().unwrap();\n        let mut closing\
    \ = brackets.chars().next().unwrap();\n        if opening != closing {\n     \
    \       return false;\n        }\n        brackets = brackets.chars().collect();\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659747845
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    for ch in brackets.chars() {\n        if\
    \ ch == '(' {\n            stack.push(0);\n        } else if ch == ')' {\n   \
    \         if stack.len() == 0 {\n                return false;\n            }\n\
    \            stack.pop();\n        } else {\n            if stack.len() == 0 {\n\
    \                return false;\n            }\n            stack.last().unwrap()\
    \ += 1;\n        }\n    }\n    stack.len() == 0 && true\n}\n\nfn main() {\n  \
    \  let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&usize`\n  --> /tmp/tmpc_50p3z_.rs:25:13\n   |\n25 |             stack.last().unwrap()\
    \ += 1;\n   |             ---------------------^^^^^\n   |             |\n   |\
    \             cannot use `+=` on type `&usize`\n   |\nhelp: `+=` can be used on\
    \ `usize`, you can dereference `stack.last().unwrap()`\n   |\n25 |           \
    \  *stack.last().unwrap() += 1;\n   |             +\n\nerror[E0067]: invalid left-hand\
    \ side of assignment\n  --> /tmp/tmpc_50p3z_.rs:25:35\n   |\n25 |            \
    \ stack.last().unwrap() += 1;\n   |             --------------------- ^^\n   |\
    \             |\n   |             cannot assign to this expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0067, E0368.\n\
    For more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\"\
    , \"<\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\"\
    );\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\");\n  \
    \  brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\"\
    , \">\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\"\
    );\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n\
    \    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    <\", \"<\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"\
    <\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\"\
    );\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\");\n\
    \    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpqbgn3uy_.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpnncv2the.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: -1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    while let Some(open) = stack.pop() {\n        if let Some(close) = brackets.chars().next()\
    \ {\n            if open != close {\n                return false;\n         \
    \   }\n        } else {\n            return false;\n        }\n        stack.push(open);\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659747845
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    let mut open_brackets: Vec<usize> = vec![];\n\
    \    let mut close_brackets: Vec<usize> = vec![];\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_idx:\
    \ usize = 0;\n    let mut close_brackets_idx: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_idx:\
    \ usize = 0;\n    let mut close_brackets_idx: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_idx:\
    \ usize = 0;\n    let mut close_brackets_idx: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_idx:\
    \ usize = 0;\n    let mut close_brackets_idx: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_idx:\
    \ usize = 0;\n    let mut close_brackets_idx: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_idx:\
    \ usize = 0;\n    let mut close_brackets_idx: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_idx:\
    \ usize = 0;\n    let mut close_brackets_idx: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_idx:\
    \ usize = 0;\n    let mut close_brackets_idx: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut \n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp7ha8lqua.rs:50:1\n\
    \   |\n50 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack_size = open_brackets_stack.len();\n\
    \    let mut close_brackets_stack_size = close_brackets_stack.len();\n    let\
    \ mut open_brackets_stack_pos = 0;\n    let mut close_brackets_stack_pos = 0;\n\
    \    let mut open_brackets_stack_end = open_brackets_stack.len();\n    let mut\
    \ close_brackets_stack_end = close_brackets_stack.len();\n    let mut open_brackets_stack_pos\
    \ = 0;\n    let mut close_brackets_stack_pos = 0;\n    let mut open_brackets_stack_end\
    \ = open_brackets_stack.len();\n    let mut close_brackets_stack_end = close_brackets_stack.len();\n\
    \    let mut open_brackets_stack_pos = 0;\n    let mut close_brackets_stack_pos\
    \ = 0;\n    let mut open_brackets_stack_end = open_brackets_stack.len();\n   \
    \ let mut close_brackets_stack_end = close_brackets_stack.len();\n    let mut\
    \ open_brackets_stack_pos = 0;\n    let mut close_brackets_stack_pos = 0;\n  \
    \  let mut open_brackets_stack_end = open_brackets_stack.len();\n    let mut close_brackets_stack_end\
    \ = close_brackets_stack.len();\n    let mut open_brackets_stack_pos = 0;\n  \
    \  let mut close_brackets_stack_pos = 0;\n    let mut open_brackets_stack_end\
    \ = open_brackets_stack.len();\n    let mut close_brackets_stack_end = close_brackets_stack.len();\n\
    \    let mut open_brackets_stack_pos = 0;\n    let mut close_brackets_stack_pos\
    \ = 0;\n    let mut open_brackets_stack_end = open_brackets_stack.len();\n   \
    \ let mut close_brackets_stack_end = close_brackets_stack.len();\n    let mut\
    \ open_brackets_stack_pos = 0;\n    let mut close_brackets_stack_pos = 0;\n  \
    \  let mut open_brackets_stack_end = open_brackets_stack.len();\n    let mut \n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp9616u4qj.rs:46:1\n\
    \   |\n46 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    let mut opening_brackets = Vec::new();\n    let mut closing_brackets = Vec::new();\n\
    \    while let Some(item) = stack.last() {\n        if item == '(' {\n       \
    \     opening_brackets.push(item);\n        } else if item == ')' {\n        \
    \    closing_brackets.push(item);\n        }\n        stack.pop();\n    }\n  \
    \  opening_brackets.len() == closing_brackets.len()\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\"\
    )), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpx4xux2zd.rs:17:17\n\
    \   |\n17 |         if item == '(' {\n   |                 ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpx4xux2zd.rs:19:24\n\
    \   |\n19 |         } else if item == ')' {\n   |                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut open_brackets = Vec::new();\n    let mut\
    \ close_brackets = Vec::new();\n    let mut open_brackets_count = Vec::new();\n\
    \    let mut close_brackets_count = Vec::new();\n    let mut open_brackets_count_max\
    \ = Vec::new();\n    let mut close_brackets_count_max = Vec::new();\n    let mut\
    \ open_brackets_count_min = Vec::new();\n    let mut close_brackets_count_min\
    \ = Vec::new();\n    let mut open_brackets_count_min = Vec::new();\n    let mut\
    \ close_brackets_count_min = Vec::new();\n    let mut open_brackets_count_max\
    \ = Vec::new();\n    let mut close_brackets_count_max = Vec::new();\n    let mut\
    \ open_brackets_count_min = Vec::new();\n    let mut close_brackets_count_min\
    \ = Vec::new();\n    let mut open_brackets_count_max = Vec::new();\n    let mut\
    \ close_brackets_count_max = Vec::new();\n    let mut open_brackets_count_min\
    \ = Vec::new();\n    let mut close_brackets_count_min = Vec::new();\n    let mut\
    \ open_brackets_count_max = Vec::new();\n    let mut close_brackets_count_max\
    \ = Vec::new();\n    let mut open_brackets_count_min = Vec::new();\n    let mut\
    \ close_brackets_count_min = Vec::new();\n    let mut open_brackets_count_max\
    \ = Vec::new();\n    let mut close_brackets_count_max = Vec::new();\n    let mut\
    \ open_brackets_count_min = Vec::new();\n    let mut close_brackets_count_min\
    \ = Vec::new();\n    let mut open_brackets_count_max = Vec::new();\n    let mut\
    \ close_brackets_count_max = Vec::new();\n    let mut open_brackets_count_min\
    \ = Vec::new();\n    let mut close_brackets_count_min = Vec::new();\n    let mut\
    \ open_brackets_count_max = Vec::new();\n    let mut close_brackets_count_max\
    \ = Vec::new();\n    let mut open_brackets_count_min = Vec::new();\n    let mut\
    \ close_brackets_count_min = Vec::new\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpbm5s6wyv.rs:46:48\n   |\n\
    46 |     let mut close_brackets_count_min = Vec::new\n   |                   \
    \                             ^ help: add `;` here\n47 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbm5s6wyv.rs:11:44\n \
    \  |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets);\n    while let Some(mut brackets)\
    \ = stack.pop() {\n        if brackets.is_empty() {\n            continue;\n \
    \       }\n        let mut open_brackets = brackets.chars().filter(|c| c == '(').count();\n\
    \        let mut closed_brackets = brackets.chars().filter(|c| c == ')').count();\n\
    \        if open_brackets == closed_brackets {\n            continue;\n      \
    \  }\n        if open_brackets > closed_brackets {\n            stack.unshift(brackets);\n\
    \        } else {\n            stack.push(brackets);\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpa5d2zpoc.rs:18:63\n\
    \   |\n18 |         let mut open_brackets = brackets.chars().filter(|c| c == '(').count();\n\
    \   |                                                               ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpa5d2zpoc.rs:19:65\n\
    \   |\n19 |         let mut closed_brackets = brackets.chars().filter(|c| c ==\
    \ ')').count();\n   |                                                        \
    \         ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n\nerror[E0599]: no method\
    \ named `unshift` found for struct `Vec<String>` in the current scope\n  --> /tmp/tmpa5d2zpoc.rs:24:19\n\
    \   |\n24 |             stack.unshift(brackets);\n   |                   ^^^^^^^\
    \ method not found in `Vec<String>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\"\
    , \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n\
    \    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\"\
    , \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    [\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\"\
    );\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp8iadlwwo.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().skip_while(|c| !c.is_ascii_letter()).collect::<String>());\n\
    \    while let Some(last) = stack.pop() {\n        let mut current = last;\n \
    \       while let Some(next) = stack.pop() {\n            if next == current {\n\
    \                stack.push(next);\n                break;\n            }\n  \
    \          current = next;\n        }\n        if current != last {\n        \
    \    return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpl7vov1l_.rs:13:51\n   |\n13 |     stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).collect::<String>());\n   |                          \
    \                         ^^^^^^^^^^^^^^^ method not found in `&char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = vec![];\n    let mut open_brackets = String::new();\n    let mut\
    \ close_brackets = String::new();\n    for c in brackets.chars() {\n        if\
    \ c == '(' {\n            stack.push(c);\n            open_brackets.push(c);\n\
    \        } else if c == ')' {\n            if stack.len() == 0 {\n           \
    \     return false;\n            }\n            stack.pop();\n            close_brackets.push(c);\n\
    \        } else if stack.len() > 0 {\n            stack.push(c);\n        }\n\
    \    }\n    if stack.len() != 0 {\n        return false;\n    }\n    if open_brackets\
    \ != close_brackets {\n        return false;\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmptte8ywcz.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ {\n        c != '(' && c != ')'\n    })\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpd86gsals.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    while let Some(open) = stack.last() {\n        if open != ')' {\n       \
    \     return false;\n        }\n        stack.pop();\n    }\n    true\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpquph9fjq.rs:15:17\n\
    \   |\n15 |         if open != ')' {\n   |                 ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == ')' || c == '(')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpexnsdi2v.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == '(' || c == '[' || c == '{' || c == '<')\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpflbzys1n.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == ')' || c == '(')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpexnsdi2v.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    loop {\n        if let Some(next) = stack.last().unwrap().next() {\n    \
    \        if next == ')' {\n                stack.pop();\n            } else {\n\
    \                stack.push(next);\n            }\n        } else {\n        \
    \    break;\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\"\
    )), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `next` found for reference `&char` in the\
    \ current scope\n  --> /tmp/tmpph58eapk.rs:15:51\n   |\n15 |         if let Some(next)\
    \ = stack.last().unwrap().next() {\n   |                                     \
    \              ^^^^ method not found in `&char`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    let mut open_brackets: Vec<usize> = vec![];\n\
    \    let mut close_brackets: Vec<usize> = vec![];\n    let mut open_brackets_idx:\
    \ usize = 0;\n    let mut close_brackets_idx: usize = 0;\n    let mut open_brackets_idx2:\
    \ usize = 0;\n    let mut close_brackets_idx2: usize = 0;\n    let mut open_brackets_idx3:\
    \ usize = 0;\n    let mut close_brackets_idx3: usize = 0;\n    let mut open_brackets_idx4:\
    \ usize = 0;\n    let mut close_brackets_idx4: usize = 0;\n    let mut open_brackets_idx5:\
    \ usize = 0;\n    let mut close_brackets_idx5: usize = 0;\n    let mut open_brackets_idx6:\
    \ usize = 0;\n    let mut close_brackets_idx6: usize = 0;\n    let mut open_brackets_idx7:\
    \ usize = 0;\n    let mut close_brackets_idx7: usize = 0;\n    let mut open_brackets_idx8:\
    \ usize = 0;\n    let mut close_brackets_idx8: usize = 0;\n    let mut open_brackets_idx9:\
    \ usize = 0;\n    let mut close_brackets_idx9: usize = 0;\n    let mut open_brackets_idx10:\
    \ usize = 0;\n    let mut close_brackets_idx10: usize = 0;\n    let mut open_brackets_idx11:\
    \ usize = 0;\n    let mut close_brackets_idx11: usize = 0;\n    let mut open_brackets_idx12:\
    \ usize = 0;\n    let mut close_brackets_idx12: usize = 0;\n    let mut open_brackets_idx13:\
    \ usize = 0;\n    let mut close_brackets_idx13: usize = 0;\n    let mut open_brackets_idx14:\
    \ usize = 0;\n    let mut close_brackets_idx14: usize = 0;\n    let mut open_brackets_idx15:\
    \ usize = 0;\n    let mut close_brackets_idx15: usize = 0;\n    let mut open_brackets_idx16:\
    \ usize = 0;\n    let mut close_bra\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpl4jfu7kz.rs:46:22\n   |\n\
    46 |     let mut close_bra\n   |                      ^ help: add `;` here\n47\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl4jfu7kz.rs:11:44\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening_brackets = brackets.chars().filter(|c| c == '(').collect::<Vec<_>>();\n\
    \    let mut closing_brackets = brackets.chars().filter(|c| c == ')').collect::<Vec<_>>();\n\
    \    let mut opening_brackets_iter = opening_brackets.iter();\n    let mut closing_brackets_iter\
    \ = closing_brackets.iter();\n    while opening_brackets_iter.any() || closing_brackets_iter.any()\
    \ {\n        if opening_brackets_iter.any() {\n            if closing_brackets_iter.any()\
    \ {\n                opening_brackets_iter.next();\n                closing_brackets_iter.next();\n\
    \            } else {\n                opening_brackets_iter.next();\n       \
    \     }\n        } else if closing_brackets_iter.any() {\n            closing_brackets_iter.next();\n\
    \        }\n    }\n    opening_brackets.len() == closing_brackets.len()\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmplqp9tynq.rs:12:62\n\
    \   |\n12 |     let mut opening_brackets = brackets.chars().filter(|c| c == '(').collect::<Vec<_>>();\n\
    \   |                                                              ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmplqp9tynq.rs:13:62\n\
    \   |\n13 |     let mut closing_brackets = brackets.chars().filter(|c| c == ')').collect::<Vec<_>>();\n\
    \   |                                                              ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0061]: this function takes 1 argument but 0 arguments\
    \ were supplied\n    --> /tmp/tmplqp9tynq.rs:16:33\n     |\n16   |     while opening_brackets_iter.any()\
    \ || closing_brackets_iter.any() {\n     |                                 ^^^-\
    \ supplied 0 arguments\n     |                                 |\n     |     \
    \                            expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments\
    \ were supplied\n    --> /tmp/tmplqp9tynq.rs:16:64\n     |\n16   |     while opening_brackets_iter.any()\
    \ || closing_brackets_iter.any() {\n     |                                   \
    \                             ^^^- supplied 0 arguments\n     |              \
    \                                                  |\n     |                 \
    \                                               expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror[E0061]: this function takes 1\
    \ argument but 0 arguments were supplied\n    --> /tmp/tmplqp9tynq.rs:17:34\n\
    \     |\n17   |         if opening_brackets_iter.any() {\n     |             \
    \                     ^^^- supplied 0 arguments\n     |                      \
    \            |\n     |                                  expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0061]: this function\
    \ takes 1 ar"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening_brackets = brackets.chars().filter(|c| *c != '(');\n    let mut\
    \ closing_brackets = brackets.chars().filter(|c| *c != ')');\n    let mut opening_brackets_iter\
    \ = opening_brackets.iter();\n    let mut closing_brackets_iter = closing_brackets.iter();\n\
    \    let mut opening_brackets_next = opening_brackets_iter.next();\n    let mut\
    \ closing_brackets_next = closing_brackets_iter.next();\n    while opening_brackets_next\
    \ != None && closing_brackets_next != None {\n        if opening_brackets_next.unwrap()\
    \ == closing_brackets_next.unwrap() {\n            opening_brackets_next = opening_brackets_iter.next();\n\
    \            closing_brackets_next = closing_brackets_iter.next();\n        }\
    \ else {\n            opening_brackets_next = opening_brackets_iter.next();\n\
    \            closing_brackets_next = closing_brackets_iter.next();\n         \
    \   return false;\n        }\n    }\n    opening_brackets_next == None && closing_brackets_next\
    \ == None\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `Filter` in the current\
    \ scope\n  --> /tmp/tmpuy0_a63h.rs:14:54\n   |\n14 |     let mut opening_brackets_iter\
    \ = opening_brackets.iter();\n   |                                           \
    \           ^^^^ private field, not a method\n\nerror[E0599]: no method named\
    \ `iter` found for struct `Filter` in the current scope\n  --> /tmp/tmpuy0_a63h.rs:15:54\n\
    \   |\n15 |     let mut closing_brackets_iter = closing_brackets.iter();\n   |\
    \                                                      ^^^^ private field, not\
    \ a method\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().take_while(|c| !c.is_ascii_letter()).collect::<String>());\n\
    \    while let Some(item) = stack.pop() {\n        if item != ')' {\n        \
    \    return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpjeco43g_.rs:13:51\n   |\n13 |     stack.push(brackets.chars().take_while(|c|\
    \ !c.is_ascii_letter()).collect::<String>());\n   |                          \
    \                         ^^^^^^^^^^^^^^^ method not found in `&char`\n\nerror[E0277]:\
    \ can't compare `String` with `char`\n  --> /tmp/tmpjeco43g_.rs:15:17\n   |\n\
    15 |         if item != ')' {\n   |                 ^^ no implementation for `String\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `String`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    while brackets.len() > 2 {\n     \
    \   let mut opening = brackets.chars().nth(0).unwrap();\n        let mut closing\
    \ = brackets.chars().nth(1).unwrap();\n        if opening != closing {\n     \
    \       return false;\n        }\n        brackets = brackets.chars().nth(2).unwrap();\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm4xe808m.rs:19:20\n   |\n\
    19 |         brackets = brackets.chars().nth(2).unwrap();\n   |              \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                    |\n   |                    expected\
    \ struct `String`, found `char`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == ')' || c == '(')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpexnsdi2v.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    while brackets.len() > 0 {\n     \
    \   let mut opening = brackets.chars().next().unwrap();\n        let mut closing\
    \ = brackets.chars().next().unwrap();\n        while opening != closing {\n  \
    \          if opening == '(' && closing == ')' {\n                brackets = brackets.replace(\"\
    (\", \"\");\n                brackets = brackets.replace(\")\", \"\");\n     \
    \           brackets = brackets.replace(\"(\", \"\");\n                brackets\
    \ = brackets.replace(\")\", \"\");\n                brackets = brackets.replace(\"\
    (\", \"\");\n                brackets = brackets.replace(\")\", \"\");\n     \
    \           brackets = brackets.replace(\"(\", \"\");\n                brackets\
    \ = brackets.replace(\")\", \"\");\n                brackets = brackets.replace(\"\
    (\", \"\");\n                brackets = brackets.replace(\")\", \"\");\n     \
    \           brackets = brackets.replace(\"(\", \"\");\n                brackets\
    \ = brackets.replace(\")\", \"\");\n                brackets = brackets.replace(\"\
    (\", \"\");\n                brackets = brackets.replace(\")\", \"\");\n     \
    \           brackets = brackets.replace(\"(\", \"\");\n                brackets\
    \ = brackets.replace(\")\", \"\");\n                brackets = brackets.replace(\"\
    (\", \"\");\n                brackets = brackets.replace(\")\", \"\");\n     \
    \           brackets = brackets.replace(\"(\", \"\");\n                brackets\
    \ = brackets.replace(\")\", \"\");\n                brackets = brackets.replace(\"\
    (\", \"\");\n                brackets = brackets.replace(\")\", \"\");\n     \
    \           brackets = brackets.replace(\"(\", \"\");\n                brackets\
    \ = brackets.replace(\")\", \"\");\n                brackets = brackets.replace(\"\
    (\", \"\");\n                brackets = brackets.replace(\")\", \"\");\n     \
    \           brackets = brackets.replace(\"(\", \"\");\n                brackets\
    \ = brackets.replace(\")\", \"\");\n                brackets = brackets.replace(\"\
    (\", \"\");\n                brackets = brackets.replace(\")\", \"\");\n     \
    \           brackets = brackets.replace(\"(\", \"\");\n                brackets\
    \ = brackets.replace(\")\", \"\");\n                brackets = brackets.replace(\"\
    (\", \"\");\n                brackets = brackets.replace(\")\", \"\");\n     \
    \           brackets = brackets.replace(\"(\", \"\");\n                brackets\
    \ = brackets.replace(\")\", \"\");\n                brackets = brackets.replace(\"\
    (\", \"\");\n                brackets = brackets.replace(\")\", \"\");\n     \
    \           brackets = brackets.replace(\"(\", \"\");\n                brackets\
    \ = brackets.replace(\")\", \"\");\n                brackets = brackets.replace(\"\
    (\", \"\");\n                brackets = brackets.replace(\")\", \"\");\n     \
    \           brackets = brackets.replace(\"(\", \"\");\n                brackets\
    \ = brackets.replace(\")\", \"\");\n                brackets = brackets.replace(\"\
    (\", \"\");\n                bracket\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpzdl5snyp.rs:80:3\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - unclosed delimiter\n12 |     let mut\
    \ brackets = brackets.to_string();\n13 |     while brackets.len() > 0 {\n   |\
    \                              - unclosed delimiter\n...\n16 |         while opening\
    \ != closing {\n   |                                  - unclosed delimiter\n17\
    \ |             if opening == '(' && closing == ')' {\n   |                  \
    \                               - this delimiter might not be properly closed...\n\
    ...\n64 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    80 | }\n   |   ^\n\nerror[E0425]: cannot find value `bracket` in this scope\n\
    \  --> /tmp/tmpzdl5snyp.rs:63:17\n   |\n63 |                 bracket\n   |   \
    \              ^^^^^^^ help: a local variable with a similar name exists: `brackets`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpzdl5snyp.rs:13:5\n   |\n11 | \
    \  fn correct_bracketing(brackets: String) -> bool {\n   |                   \
    \                           ---- expected `bool` because of return type\n12 |\
    \       let mut brackets = brackets.to_string();\n13 | /     while brackets.len()\
    \ > 0 {\n14 | |         let mut opening = brackets.chars().next().unwrap();\n\
    15 | |         let mut closing = brackets.chars().next().unwrap();\n16 | |   \
    \      while opening != closing {\n...  |\n79 | |     assert_eq!(candidate(String::from(\"\
    ()()(()())()))()\")), false);\n80 | | }\n   | |__^ expected `bool`, found `()`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 0
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for bracket in brackets.chars() {\n        if bracket\
    \ == '(' {\n            stack.push(bracket);\n        } else if bracket == ')'\
    \ {\n            if stack.len() == 0 {\n                return false;\n      \
    \      }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ != 0 {\n                return false;\n            }\n        }\n    }\n   \
    \ stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747840
- exit_code: -1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    while !brackets.is_empty() {\n   \
    \     if brackets.starts_with(\"(\") {\n            brackets = brackets[1..].to_string();\n\
    \        } else {\n            brackets = brackets[0..].to_string();\n       \
    \ }\n    }\n    brackets == \"\"\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659747845
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    for bracket in brackets.chars() {\n        if bracket == '(' {\n        \
    \    open_brackets.push('(');\n        } else if bracket == ')' {\n          \
    \  close_brackets.push(')');\n        } else {\n            open_brackets.push(bracket);\n\
    \            close_brackets.push(bracket);\n        }\n    }\n    open_brackets.chars().all(|c|\
    \ close_brackets.chars().any(|c| c == c))\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpirg9fqzq.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut opening_brackets = String::new();\n   \
    \ let mut closing_brackets = String::new();\n    let mut opening_brackets_count\
    \ = String::new();\n    let mut closing_brackets_count = String::new();\n    let\
    \ mut opening_brackets_count_stack = Vec::new();\n    let mut closing_brackets_count_stack\
    \ = Vec::new();\n\n    for bracket in brackets.chars() {\n        if bracket ==\
    \ '(' {\n            stack.push(bracket);\n            opening_brackets_count.push(bracket);\n\
    \            opening_brackets_count_stack.push(opening_brackets_count);\n    \
    \    } else if bracket == ')' {\n            if opening_brackets_count_stack.len()\
    \ == 0 {\n                return false;\n            }\n            let opening_brackets_count\
    \ = opening_brackets_count_stack.pop();\n            let opening_brackets = opening_brackets_count.clone();\n\
    \            if stack.len() == 0 {\n                closing_brackets_count.push(opening_brackets);\n\
    \                closing_brackets_count_stack.push(closing_brackets_count);\n\
    \            } else {\n                let closing_brackets_count = closing_brackets_count_stack.pop();\n\
    \                let closing_brackets = closing_brackets_count.clone();\n    \
    \            if opening_brackets == closing_brackets {\n                    stack.push(bracket);\n\
    \                } else {\n                    return false;\n               \
    \ }\n            }\n        } else {\n            if stack.len() == 0 {\n    \
    \            opening_brackets.push(bracket);\n            } else {\n         \
    \       let closing_brackets = closing_brackets_count.clone();\n             \
    \   if bracket == ')' {\n                    if opening_brackets == closing_brackets\
    \ {\n                        stack.push(bracket);\n                    } else\
    \ {\n                        return false;\n                    }\n          \
    \      } else {\n                    if opening_brackets == closing_brackets {\n\
    \                        stack.push(bracket);\n                    } else {\n\
    \                        return false;\n                    }\n              \
    \  }\n            }\n        }\n    }\n    stack.len() == 0 && opening_brackets.len()\
    \ == 0 && closing_brackets.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd19arssl.rs:32:45\n   |\n\
    32 |                 closing_brackets_count.push(opening_brackets);\n   |    \
    \                                         ^^^^^^^^^^^^^^^^ expected `char`, found\
    \ enum `Option`\n   |\n   = note: expected type `char`\n              found enum\
    \ `Option<String>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\"\
    , \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n\
    \    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\"\
    , \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    [\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\"\
    );\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp8iadlwwo.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    while brackets.len() > 2 {\n     \
    \   if brackets.ends_with('(') && brackets.ends_with(')')\n            || brackets.ends_with('[')\
    \ && brackets.ends_with(']')\n            || brackets.ends_with('{') && brackets.ends_with('}')\n\
    \        {\n            return false;\n        }\n        brackets = brackets.replace(\"\
    )\", \"\").replace(\"(\", \"\").replace(\"[\", \"\")\n            .replace(\"\
    {\", \"\").to_string();\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpny07cz1o.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 0
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = vec![];\n    for ch in brackets.chars() {\n        if ch == '('\
    \ {\n            stack.push('(');\n        } else if ch == ')' {\n           \
    \ if stack.is_empty() {\n                return false;\n            }\n      \
    \      stack.pop();\n        } else if ch == '[' {\n            stack.push('[');\n\
    \        } else if ch == ']' {\n            if stack.is_empty() {\n          \
    \      return false;\n            }\n            stack.pop();\n        } else\
    \ if ch == '{' {\n            stack.push('{');\n        } else if ch == '}' {\n\
    \            if stack.is_empty() {\n                return false;\n          \
    \  }\n            stack.pop();\n        }\n    }\n    stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"(\");\n  \
    \  brackets.replace(\"]\", \")\");\n    brackets.replace(\"{\", \"(\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"[\");\n    brackets.replace(\")\"\
    , \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"[\", \"{\");\n    brackets.replace(\"]\", \"}\"\
    );\n    brackets.replace(\"{\", \"[\");\n    brackets.replace(\"}\", \"]\");\n\
    \    brackets.replace(\"(\", \"{\");\n    brackets.replace(\")\", \"}\");\n  \
    \  brackets.replace(\"[\", \"{\");\n    brackets.replace(\"]\", \"}\");\n    brackets.replace(\"\
    {\", \"(\");\n    brackets.replace(\"}\", \")\");\n    brackets.replace(\"[\"\
    , \"(\");\n    brackets.replace(\"]\", \")\");\n    brackets.replace(\"(\", \"\
    [\");\n    brackets.replace(\")\", \"]\");\n    brackets.replace(\"{\", \"{\"\
    );\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"[\", \"{\");\n\
    \    brackets.replace(\"]\", \"}\");\n    brackets.replace(\"(\", \"{\");\n  \
    \  brackets.replace(\")\", \"}\");\n    brackets.replace(\"[\", \"{\");\n    brackets.replace(\"\
    ]\", \"}\");\n    brackets.replace(\"(\", \"[\");\n    brackets.replace(\")\"\
    , \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"[\", \"{\");\n    brackets.replace(\"]\", \"}\"\
    );\n    brackets.replace(\"(\", \"{\");\n    brackets.replace(\")\", \"}\");\n\
    \    brackets.replace(\"[\", \"{\");\n    brackets.replace(\"]\", \"}\");\n  \
    \  brackets.replace(\"(\", \"[\");\n    brackets.replace(\")\", \"]\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"[\"\
    , \"{\");\n    brackets.replace(\"]\", \"}\");\n    brackets.replace(\"(\", \"\
    {\");\n    brackets.replace(\")\", \"}\");\n    brackets.replace(\"[\", \"{\"\
    );\n    brackets.replace(\"]\", \"}\");\n    brackets.replace(\"(\", \"[\");\n\
    \    brackets.replace(\")\", \"]\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmppyekqulb.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\"\
    , \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n\
    \    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\"\
    , \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    [\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\"\
    );\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp8iadlwwo.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_brackets_stack = Vec::new();\n    let mut closed_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack_size = open_brackets_stack.len();\n\
    \    let mut closed_brackets_stack_size = closed_brackets_stack.len();\n    let\
    \ mut i = 0;\n    let mut j = 0;\n    while i < brackets.len() {\n        if brackets[i]\
    \ == '(' {\n            open_brackets.push(brackets[i]);\n            open_brackets_stack.push(i);\n\
    \            i += 1;\n        } else if brackets[i] == ')' {\n            if open_brackets_stack.is_empty()\
    \ {\n                return false;\n            }\n            let open_bracket\
    \ = open_brackets_stack.pop();\n            if open_brackets_stack.len() != open_brackets_stack_size\
    \ {\n                return false;\n            }\n            if open_brackets_stack.is_empty()\
    \ {\n                closed_brackets.push(brackets[i]);\n                closed_brackets_stack.push(open_bracket);\n\
    \                open_brackets_stack_size = open_brackets_stack.len();\n     \
    \           closed_brackets_stack_size = closed_brackets_stack.len();\n      \
    \          i += 1;\n            } else {\n                let open_bracket = open_brackets_stack.pop();\n\
    \                closed_brackets_stack.push(open_bracket);\n                open_brackets_stack_size\
    \ = open_brackets_stack.len();\n                closed_brackets_stack_size = closed_brackets_stack.len();\n\
    \                i += 1;\n            }\n        } else {\n            if open_brackets_stack.is_empty()\
    \ {\n                return false;\n            }\n            let open_bracket\
    \ = open_brackets_stack.pop();\n            if open_brackets_stack.len() != open_brackets_stack_size\
    \ {\n                return false;\n            }\n            if open_brackets_stack.is_empty()\
    \ {\n                closed_brackets.push(brackets[i]);\n                closed_brackets_stack.push(open_bracket);\n\
    \                open_brackets_stack_size = open_brackets_stack.len();\n     \
    \           closed_brackets_stack_size = closed_brackets_stack.len();\n      \
    \          i += 1;\n            } else {\n                let open_bracket = open_brackets_stack.pop();\n\
    \                closed_brackets_stack.push(open_bracket);\n                open_brackets_stack_size\
    \ = open_bracket\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpm0hh60iy.rs:80:3\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - unclosed delimiter\n...\n20 |     while\
    \ i < brackets.len() {\n   |                              - unclosed delimiter\n\
    ...\n46 |         } else {\n   |                - unclosed delimiter\n...\n60\
    \ |             } else {\n   |                    - this delimiter might not be\
    \ properly closed...\n...\n64 | }\n   | - ...as it matches this but it has different\
    \ indentation\n...\n80 | }\n   |   ^\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmpm0hh60iy.rs:21:12\n   |\n21 |         if\
    \ brackets[i] == '(' {\n   |            ^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n \
    \ --> /tmp/tmpm0hh60iy.rs:22:32\n   |\n22 |             open_brackets.push(brackets[i]);\n\
    \   |                                ^^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpm0hh60iy.rs:25:19\n\
    \   |\n25 |         } else if brackets[i] == ')' {\n   |                   ^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpm0hh60iy.rs:34:38\n   |\n34 |            \
    \     closed_brackets.push(brackets[i]);\n   |                               \
    \       ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmpm0hh60iy.rs:55:38\n   |\n\
    55 |                 closed_brackets.push(brackets[i]);\n   |                \
    \                      ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\"\
    );\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\"\
    , \"}\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\"\
    );\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpfg9249mn.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    for bracket in brackets.chars() {\n        if bracket == '(' {\n        \
    \    open_brackets.push('(');\n        } else if bracket == ')' {\n          \
    \  close_brackets.push(')');\n        } else {\n            open_brackets.push(bracket);\n\
    \            close_brackets.push(bracket);\n        }\n    }\n    open_brackets.len()\
    \ == close_brackets.len()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpluk9lxjk.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut opening_brackets = Vec::new();\n    let\
    \ mut closing_brackets = Vec::new();\n    let mut opening_brackets_count = Vec::new();\n\
    \    let mut closing_brackets_count = Vec::new();\n    let mut opening_brackets_count_max\
    \ = Vec::new();\n    let mut closing_brackets_count_max = Vec::new();\n    let\
    \ mut opening_brackets_count_min = Vec::new();\n    let mut closing_brackets_count_min\
    \ = Vec::new();\n    let mut opening_brackets_count_max_min = Vec::new();\n  \
    \  let mut closing_brackets_count_max_min = Vec::new();\n    let mut opening_brackets_count_max_min_max\
    \ = Vec::new();\n    let mut closing_brackets_count_max_min_max = Vec::new();\n\
    \    let mut opening_brackets_count_max_min_max_max = Vec::new();\n    let mut\
    \ closing_brackets_count_max_min_max_max = Vec::new();\n    let mut opening_brackets_count_max_min_max_max_max\
    \ = Vec::new();\n    let mut closing_brackets_count_max_min_max_max_max = Vec::new();\n\
    \    let mut opening_brackets_count_max_min_max_max_max_max = Vec::new();\n  \
    \  let mut closing_brackets_count_max_min_max_max_max_max = Vec::new();\n    let\
    \ mut opening_brackets_count_max_min_max_max_max_max = Vec::new();\n    let mut\
    \ closing_brackets_count_max_min_max_max_max_max = Vec::new();\n    let mut opening_brackets_count_max_min_max_max_max_max_max\
    \ = Vec::new();\n    let mut closing_brackets_count_max_min_max_max_max_max_max\
    \ = Vec::new();\n    let mut opening_brackets_count_max_min_max_max_max_max_max\
    \ = Vec::new();\n    let mut closing_brackets_count_max_min_max_max_max_max_max\
    \ = Vec::new();\n    let mut opening_brackets_count_max_min_max_max_max_max_max\
    \ = Vec::new();\n    let mut closing_brackets_count_max_min_max_max_max_max_max\
    \ = Vec::new();\n    let mut opening_brackets_count_max_min_max_max_max_max_max_max\
    \ = Vec::new();\n    let mut closing_bra\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmparek38u4.rs:40:24\n   |\n\
    40 |     let mut closing_bra\n   |                        ^ help: add `;` here\n\
    41 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmparek38u4.rs:11:44\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_iter = brackets.char_indices().filter_map(|i| {\n \
    \       if i.0 != 0 {\n            Some(String::from(i.1))\n        } else {\n\
    \            None\n        }\n    });\n    let mut close_brackets_iter = brackets.char_indices().filter_map(|i|\
    \ {\n        if i.0 != 0 {\n            Some(String::from(i.1))\n        } else\
    \ {\n            None\n        }\n    });\n    let mut open_brackets_next = open_brackets_iter.next();\n\
    \    let mut close_brackets_next = close_brackets_iter.next();\n    while open_brackets_next.is_some()\
    \ {\n        open_brackets += open_brackets_next.unwrap();\n        open_brackets_next\
    \ = open_brackets_iter.next();\n    }\n    while close_brackets_next.is_some()\
    \ {\n        close_brackets += close_brackets_next.unwrap();\n        close_brackets_next\
    \ = close_brackets_iter.next();\n    }\n    open_brackets == close_brackets\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplhl1glql.rs:31:26\n   |\n\
    31 |         open_brackets += open_brackets_next.unwrap();\n   |             \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |                          |\n \
    \  |                          expected `&str`, found struct `String`\n   |   \
    \                       help: consider borrowing here: `&open_brackets_next.unwrap()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmplhl1glql.rs:35:27\n   |\n35 |\
    \         close_brackets += close_brackets_next.unwrap();\n   |              \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |                           |\n\
    \   |                           expected `&str`, found struct `String`\n   | \
    \                          help: consider borrowing here: `&close_brackets_next.unwrap()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    let mut opening_brackets_iter = brackets.char_indices();\n    let mut closing_brackets_iter\
    \ = brackets.char_indices();\n    let mut opening_brackets_next = opening_brackets_iter.next();\n\
    \    let mut closing_brackets_next = closing_brackets_iter.next();\n    while\
    \ opening_brackets_next.is_some() && closing_brackets_next.is_some() {\n     \
    \   let opening_bracket = opening_brackets_next.unwrap();\n        let closing_bracket\
    \ = closing_brackets_next.unwrap();\n        if opening_bracket.0 != closing_bracket.0\
    \ {\n            opening_brackets += opening_bracket.0;\n            closing_brackets\
    \ += closing_bracket.0;\n        }\n        opening_brackets_next = opening_brackets_iter.next();\n\
    \        closing_brackets_next = closing_brackets_iter.next();\n    }\n    opening_brackets.len()\
    \ == closing_brackets.len()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvi573tkm.rs:22:33\n   |\n\
    22 |             opening_brackets += opening_bracket.0;\n   |                \
    \                 ^^^^^^^^^^^^^^^^^ expected `&str`, found `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvi573tkm.rs:23:33\n   |\n23 |             closing_brackets\
    \ += closing_bracket.0;\n   |                                 ^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found `usize`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    let mut open_brackets: Vec<usize> = vec![];\n\
    \    let mut close_brackets: Vec<usize> = vec![];\n    let mut open_brackets_idx:\
    \ Vec<usize> = vec![];\n    let mut close_brackets_idx: Vec<usize> = vec![];\n\
    \    let mut open_brackets_idx: Vec<usize> = vec![];\n    let mut close_brackets_idx:\
    \ Vec<usize> = vec![];\n    let mut open_brackets_idx: Vec<usize> = vec![];\n\
    \    let mut close_brackets_idx: Vec<usize> = vec![];\n    let mut open_brackets_idx:\
    \ Vec<usize> = vec![];\n    let mut close_brackets_idx: Vec<usize> = vec![];\n\
    \    let mut open_brackets_idx: Vec<usize> = vec![];\n    let mut close_brackets_idx:\
    \ Vec<usize> = vec![];\n    let mut open_brackets_idx: Vec<usize> = vec![];\n\
    \    let mut close_brackets_idx: Vec<usize> = vec![];\n    let mut open_brackets_idx:\
    \ Vec<usize> = vec![];\n    let mut close_brackets_idx: Vec<usize> = vec![];\n\
    \    let mut open_brackets_idx: Vec<usize> = vec![];\n    let mut close_brackets_idx:\
    \ Vec<usize> = vec![];\n    let mut open_brackets_idx: Vec<usize> = vec![];\n\
    \    let mut close_brackets_idx: Vec<usize> = vec![];\n    let mut open_brackets_idx:\
    \ Vec<usize> = vec![];\n    let mut close_brackets_idx: Vec<usize> = vec![];\n\
    \    let mut open_brackets_idx: Vec<usize> = vec![];\n    let mut close_brackets_idx:\
    \ Vec<usize> = vec![];\n    let mut open_brackets_idx: Vec<usize> = vec![];\n\
    \    let \n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp4sswwtc3.rs:39:1\n  \
    \ |\n39 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = vec![];\n    let mut open_brackets = String::new();\n    let mut\
    \ close_brackets = String::new();\n    stack.push(brackets);\n    while let Some(mut\
    \ brackets) = stack.pop() {\n        if brackets.is_empty() {\n            continue;\n\
    \        }\n        let mut open_bracket = String::new();\n        let mut close_bracket\
    \ = String::new();\n        for c in brackets.chars() {\n            if c == '('\
    \ {\n                open_bracket.push(c);\n            } else if c == ')' {\n\
    \                close_bracket.push(c);\n            } else {\n              \
    \  open_bracket.push(c);\n                close_bracket.push(c);\n           \
    \ }\n        }\n        if open_bracket.len() != close_bracket.len() {\n     \
    \       return false;\n        }\n        open_brackets.push(open_bracket);\n\
    \        close_brackets.push(close_bracket);\n    }\n    open_brackets.len() ==\
    \ close_brackets.len()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_i9zw6rt.rs:35:28\n   |\n\
    35 |         open_brackets.push(open_bracket);\n   |                         \
    \   ^^^^^^^^^^^^ expected `char`, found struct `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_i9zw6rt.rs:36:29\n   |\n36 |         close_brackets.push(close_bracket);\n\
    \   |                             ^^^^^^^^^^^^^ expected `char`, found struct\
    \ `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \n    for bracket in brackets.chars() {\n        if bracket == '(' {\n       \
    \     open_brackets.push('(');\n        } else if bracket == ')' {\n         \
    \   close_brackets.push(')');\n        } else {\n            open_brackets.push(bracket);\n\
    \        }\n    }\n\n    open_brackets.len() == close_brackets.len()\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmptd9awcp2.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().collect::<Vec<_>>());\n\
    \    while let Some(mut chars) = stack.pop() {\n        if chars.len() == 0 {\n\
    \            continue;\n        }\n        let mut opening = chars.clone();\n\
    \        let mut closing = chars.clone();\n        opening.pop();\n        closing.pop();\n\
    \        if opening.len() != closing.len() {\n            return false;\n    \
    \    }\n        for opening, closing in chars.iter().zip(closing.iter()) {\n \
    \           if opening != closing {\n                return false;\n         \
    \   }\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: unexpected `,` in pattern\n  --> /tmp/tmpqb0li7b8.rs:25:20\n   |\n\
    25 |         for opening, closing in chars.iter().zip(closing.iter()) {\n   |\
    \                    ^\n   |\nhelp: try adding parentheses to match on a tuple...\n\
    \   |\n25 |         for (opening, closing) in chars.iter().zip(closing.iter())\
    \ {\n   |             ~~~~~~~~~~~~~~~~~~\nhelp: ...or a vertical bar to match\
    \ on multiple alternatives\n   |\n25 |         for opening | closing in chars.iter().zip(closing.iter())\
    \ {\n   |             ~~~~~~~~~~~~~~~~~\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\"\
    );\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\"\
    , \"}\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\"\
    );\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpfg9249mn.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ {\n        c != '(' && c != ')'\n    })\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpd86gsals.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpnncv2the.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for ch in brackets.chars() {\n        if ch ==\
    \ '(' {\n            stack.push((ch, false));\n        } else if ch == ')' {\n\
    \            if let Some((_, is_open)) = stack.pop() {\n                if !is_open\
    \ {\n                    return false;\n                }\n            } else\
    \ {\n                return false;\n            }\n        } else {\n        \
    \    return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp18ltwc92.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack_size = open_brackets_stack.len();\n\
    \    let mut close_brackets_stack_size = close_brackets_stack.len();\n    let\
    \ mut i = 0;\n    while i < brackets.len() {\n        let mut j = i;\n       \
    \ while j < brackets.len() && brackets[j] == brackets[j + 1] {\n            j\
    \ += 1\n        }\n        let open_bracket = brackets[i .. j];\n        open_brackets_stack.push(open_bracket);\n\
    \        i += j - i;\n        if open_brackets_stack_size == close_brackets_stack_size\
    \ {\n            return false;\n        }\n    }\n    while open_brackets_stack.len()\
    \ > 0 {\n        let open_bracket = open_brackets_stack.pop();\n        close_brackets_stack.push(open_bracket);\n\
    \        open_brackets_stack_size -= 1;\n    }\n    while close_brackets_stack.len()\
    \ > 0 {\n        let close_bracket = close_brackets_stack.pop();\n        open_brackets_stack_size\
    \ += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp883elqs_.rs:21:37\n\
    \   |\n21 |         while j < brackets.len() && brackets[j] == brackets[j + 1]\
    \ {\n   |                                     ^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n \
    \ --> /tmp/tmp883elqs_.rs:21:52\n   |\n21 |         while j < brackets.len() &&\
    \ brackets[j] == brackets[j + 1] {\n   |                                     \
    \               ^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n  -->\
    \ /tmp/tmp883elqs_.rs:24:13\n   |\n24 |         let open_bracket = brackets[i\
    \ .. j];\n   |             ^^^^^^^^^^^^ doesn't have a size known at compile-time\n\
    \   |\n   = help: the trait `Sized` is not implemented for `str`\n   = note: all\
    \ local variables must have a statically known size\n   = help: unsized locals\
    \ are gated as an unstable feature\nhelp: consider borrowing here\n   |\n24 |\
    \         let open_bracket = &brackets[i .. j];\n   |                        \
    \    +\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmp883elqs_.rs:16:60\n   |\n16 |     let mut open_brackets_stack_size\
    \ = open_brackets_stack.len();\n   |                                         \
    \                   ^^^ doesn't have a size known at compile-time\n   |\n   =\
    \ help: the trait `Sized` is not implemented for `str`\n\nerror[E0277]: the size\
    \ for values of type `str` cannot be known at compilation time\n  --> /tmp/tmp883elqs_.rs:25:34\n\
    \   |\n25 |         open_brackets_stack.push(open_bracket);\n   |            \
    \                      ^^^^^^^^^^^^ doesn't have a size known at compile-time\n\
    \   |\n   = help: the trait `Sized` is not implemented for `str`\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n   -->\
    \ /tmp/tmp883elqs_"
  stdout: ''
  timestamp: 1659747840
- exit_code: 0
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    for c in brackets.chars() {\n        if\
    \ c == '(' {\n            stack.push(0);\n        } else if c == ')' {\n     \
    \       if stack.len() == 0 {\n                return false;\n            }\n\
    \            stack.pop();\n        } else {\n            if stack.len() == 0 {\n\
    \                return false;\n            }\n            stack.push(stack.len()\
    \ - 1);\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"(\");\n  \
    \  brackets.replace(\"]\", \")\");\n    brackets.replace(\"{\", \"(\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"[\");\n    brackets.replace(\")\"\
    , \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"[\", \"{\");\n    brackets.replace(\"]\", \"}\"\
    );\n    brackets.replace(\"{\", \"[\");\n    brackets.replace(\"}\", \"]\");\n\
    \    brackets.replace(\"(\", \"{\");\n    brackets.replace(\")\", \"}\");\n  \
    \  brackets.replace(\"[\", \"{\");\n    brackets.replace(\"]\", \"}\");\n    brackets.replace(\"\
    {\", \"(\");\n    brackets.replace(\"}\", \")\");\n    brackets.replace(\"(\"\
    , \"[\");\n    brackets.replace(\")\", \"]\");\n    brackets.replace(\"[\", \"\
    (\");\n    brackets.replace(\"]\", \")\");\n    brackets.replace(\"{\", \"(\"\
    );\n    brackets.replace(\"}\", \"]\");\n    brackets.replace(\"(\", \"{\");\n\
    \    brackets.replace(\")\", \"}\");\n    brackets.replace(\"[\", \"{\");\n  \
    \  brackets.replace(\"]\", \"}\");\n    brackets.replace(\"{\", \"(\");\n    brackets.replace(\"\
    }\", \")\");\n    brackets.replace(\"(\", \"[\");\n    brackets.replace(\"]\"\
    , \"]\");\n    brackets.replace(\"{\", \"(\");\n    brackets.replace(\"}\", \"\
    ]\");\n    brackets.replace(\"(\", \"{\");\n    brackets.replace(\")\", \"}\"\
    );\n    brackets.replace(\"[\", \"{\");\n    brackets.replace(\"]\", \"}\");\n\
    \    brackets.replace(\"{\", \"(\");\n    brackets.replace(\"}\", \")\");\n  \
    \  brackets.replace(\"(\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"\
    {\", \"(\");\n    brackets.replace(\"}\", \"]\");\n    brackets.replace(\"(\"\
    , \"{\");\n    brackets.replace(\")\", \"}\");\n    brackets.replace(\"[\", \"\
    {\");\n    brackets.replace(\"]\", \"}\");\n    brackets.replace(\"{\", \"(\"\
    );\n    brackets.replace(\"}\", \")\");\n    brackets.replace(\"(\", \"[\");\n\
    \    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"(\");\n  \
    \  brackets.replace(\"}\", \"]\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpd_etto5x.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    while brackets.len() > 0 {\n     \
    \   let mut opening = brackets.chars().nth(0).unwrap();\n        let mut closing\
    \ = brackets.chars().nth(1).unwrap();\n        if opening != closing {\n     \
    \       return false;\n        }\n        brackets = brackets.chars().nth(2).unwrap();\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkc3blc0d.rs:19:20\n   |\n\
    19 |         brackets = brackets.chars().nth(2).unwrap();\n   |              \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                    |\n   |                    expected\
    \ struct `String`, found `char`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().skip_while(|c| !c.is_ascii_letter()).collect::<Vec<_>>());\n\
    \    while let Some(item) = stack.pop() {\n        if item == \"(\" {\n      \
    \      stack.push(\")\");\n        } else if item == \")\" {\n            stack.push(\"\
    (\");\n        } else {\n            return false;\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpl3gtjd2z.rs:13:51\n   |\n13 |     stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).collect::<Vec<_>>());\n   |                          \
    \                         ^^^^^^^^^^^^^^^ method not found in `&char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpl3gtjd2z.rs:16:24\n   |\n16 |             stack.push(\"\
    )\");\n   |                        ^^^ expected struct `Vec`, found `&str`\n \
    \  |\n   = note: expected struct `Vec<char>`\n           found reference `&'static\
    \ str`\n\nerror[E0277]: can't compare `Vec<char>` with `&str`\n  --> /tmp/tmpl3gtjd2z.rs:15:17\n\
    \   |\n15 |         if item == \"(\" {\n   |                 ^^ no implementation\
    \ for `Vec<char> == &str`\n   |\n   = help: the trait `PartialEq<&str>` is not\
    \ implemented for `Vec<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl3gtjd2z.rs:18:24\n\
    \   |\n18 |             stack.push(\"(\");\n   |                        ^^^ expected\
    \ struct `Vec`, found `&str`\n   |\n   = note: expected struct `Vec<char>`\n \
    \          found reference `&'static str`\n\nerror[E0277]: can't compare `Vec<char>`\
    \ with `&str`\n  --> /tmp/tmpl3gtjd2z.rs:17:24\n   |\n17 |         } else if item\
    \ == \")\" {\n   |                        ^^ no implementation for `Vec<char>\
    \ == &str`\n   |\n   = help: the trait `PartialEq<&str>` is not implemented for\
    \ `Vec<char>`\n\nerror: aborting due to 5 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == ')' || c == '(')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpexnsdi2v.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\"\
    , \"<\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\"\
    );\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\");\n  \
    \  brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\"\
    , \">\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\"\
    );\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n\
    \    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    <\", \"<\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"\
    <\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\"\
    );\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\");\n\
    \    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpqbgn3uy_.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph_na6lpe.rs:11:44\n   |\n\
    11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_brackets_stack = Vec::new();\n    let mut closed_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack_size = open_brackets_stack.len();\n\
    \    let mut closed_brackets_stack_size = closed_brackets_stack.len();\n\n   \
    \ for bracket in brackets {\n        if bracket == '(' {\n            open_brackets.push(bracket);\n\
    \            open_brackets_stack.push(bracket);\n            open_brackets_stack_size.push(bracket.len());\n\
    \        } else if bracket == ')' {\n            if open_brackets_stack_size.len()\
    \ == 0 {\n                return false;\n            }\n            open_brackets_stack_size.pop();\n\
    \            closed_brackets_stack.push(open_brackets_stack.pop());\n        }\
    \ else if bracket == '[' {\n            open_brackets.push(bracket);\n       \
    \     open_brackets_stack.push(bracket);\n            open_brackets_stack_size.push(bracket.len());\n\
    \        } else if bracket == ']' {\n            if open_brackets_stack_size.len()\
    \ == 0 {\n                return false;\n            }\n            open_brackets_stack_size.pop();\n\
    \            closed_brackets_stack.push(open_brackets_stack.pop());\n        }\
    \ else if bracket == '{' {\n            open_brackets.push(bracket);\n       \
    \     open_brackets_stack.push(bracket);\n            open_brackets_stack_size.push(bracket.len());\n\
    \        } else if bracket == '}' {\n            if open_brackets_stack_size.len()\
    \ == 0 {\n                return false;\n            }\n            open_brackets_stack_size.pop();\n\
    \            closed_brackets_stack.push(open_brackets_stack.pop());\n        }\n\
    \    }\n\n    if open_brackets_stack_size.len() != closed_brackets_stack.len()\
    \ {\n        return false;\n    }\n\n    for open_bracket in open_brackets_stack\
    \ {\n        if closed_brackets_stack.contains(&open_bracket) {\n            return\
    \ false;\n        }\n    }\n\n    return true;\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n   --> /tmp/tmp4y_uy38_.rs:19:20\n\
    \    |\n19  |     for bracket in brackets {\n    |                    ^^^^^^^^\
    \ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n \
    \   = help: the trait `Iterator` is not implemented for `String`\n    = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `String`\n\
    note: required by `into_iter`\n\nerror[E0599]: no method named `push` found for\
    \ type `usize` in the current scope\n  --> /tmp/tmp4y_uy38_.rs:23:38\n   |\n23\
    \ |             open_brackets_stack_size.push(bracket.len());\n   |          \
    \                            ^^^^ method not found in `usize`\n\nerror[E0599]:\
    \ no method named `len` found for type `char` in the current scope\n  --> /tmp/tmp4y_uy38_.rs:23:51\n\
    \   |\n23 |             open_brackets_stack_size.push(bracket.len());\n   |  \
    \                                                 ^^^ method not found in `char`\n\
    \nerror[E0599]: no method named `len` found for type `usize` in the current scope\n\
    \  --> /tmp/tmp4y_uy38_.rs:25:41\n   |\n25 |             if open_brackets_stack_size.len()\
    \ == 0 {\n   |                                         ^^^ method not found in\
    \ `usize`\n\nerror[E0599]: no method named `pop` found for type `usize` in the\
    \ current scope\n  --> /tmp/tmp4y_uy38_.rs:28:38\n   |\n28 |             open_brackets_stack_size.pop();\n\
    \   |                                      ^^^ help: there is an associated function\
    \ with a similar name: `pow`\n\nerror[E0599]: no method named `push` found for\
    \ type `usize` in the current scope\n  --> /tmp/tmp4y_uy38_.rs:33:38\n   |\n33\
    \ |             open_brackets_stack_size.push(bracket.len());\n   |          \
    \                            ^^^^ method not found in `usize`\n\nerror[E0599]:\
    \ no method named `len` found for type `char` in the current scope\n  --> /tmp/tmp4y_uy38_.rs:33:51\n\
    \   |\n33 |             open_brackets_stack_size.push(bracket.len());\n   |  \
    \                                                 ^^^ method not found in `char`\n\
    \nerror[E0599]: no method named `len` found for type `usize` i"
  stdout: ''
  timestamp: 1659747840
- exit_code: 0
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for bracket in brackets.chars() {\n        if bracket\
    \ == '(' {\n            stack.push(bracket);\n        } else if bracket == ')'\
    \ {\n            if stack.len() == 0 {\n                return false;\n      \
    \      }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ != 0 {\n                return false;\n            }\n        }\n    }\n   \
    \ stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\"\
    , \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n\
    \    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\"\
    , \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    [\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\"\
    );\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp8iadlwwo.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == ')' || c == '(')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpexnsdi2v.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\"\
    , \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n\
    \    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\"\
    , \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    [\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\"\
    );\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp8iadlwwo.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == '(' || c == '[' || c == '{')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1gh5cb63.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening_brackets = brackets.chars().filter(|c| c == '(');\n    let mut closing_brackets\
    \ = brackets.chars().filter(|c| c == ')');\n    let mut opening_brackets_iter\
    \ = opening_brackets.iter();\n    let mut closing_brackets_iter = closing_brackets.iter();\n\
    \    let mut opening_brackets_next = opening_brackets_iter.next();\n    let mut\
    \ closing_brackets_next = closing_brackets_iter.next();\n    while opening_brackets_next\
    \ != Some(None) || closing_brackets_next != Some(None) {\n        if opening_brackets_next\
    \ == Some(None) {\n            if closing_brackets_next == Some(None) {\n    \
    \            // No more brackets to close\n                return false;\n   \
    \         }\n            // Closing bracket is missing\n            closing_brackets_iter.next();\n\
    \        } else if closing_brackets_next == Some(None) {\n            // Opening\
    \ bracket is missing\n            opening_brackets_iter.next();\n        } else\
    \ {\n            // Both brackets are present\n            if opening_brackets_next\
    \ == closing_brackets_next {\n                // Both brackets are equal\n   \
    \             opening_brackets_iter.next();\n                closing_brackets_iter.next();\n\
    \            } else {\n                // One of the brackets is missing\n   \
    \             return false;\n            }\n        }\n        opening_brackets_next\
    \ = opening_brackets_iter.next();\n        closing_brackets_next = closing_brackets_iter.next();\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmphfp3hstt.rs:12:62\n\
    \   |\n12 |     let mut opening_brackets = brackets.chars().filter(|c| c == '(');\n\
    \   |                                                              ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmphfp3hstt.rs:13:62\n\
    \   |\n13 |     let mut closing_brackets = brackets.chars().filter(|c| c == ')');\n\
    \   |                                                              ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0599]: no method named `iter` found for struct `Filter`\
    \ in the current scope\n  --> /tmp/tmphfp3hstt.rs:14:54\n   |\n14 |     let mut\
    \ opening_brackets_iter = opening_brackets.iter();\n   |                     \
    \                                 ^^^^ private field, not a method\n\nerror[E0599]:\
    \ no method named `iter` found for struct `Filter` in the current scope\n  -->\
    \ /tmp/tmphfp3hstt.rs:15:54\n   |\n15 |     let mut closing_brackets_iter = closing_brackets.iter();\n\
    \   |                                                      ^^^^ private field,\
    \ not a method\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_count = Vec::new();\n    let mut close_brackets_count\
    \ = Vec::new();\n    let mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_count = Vec::new();\n    let mut close_brackets_count\
    \ = Vec::new();\n    let mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_count = Vec::new();\n    let mut close_brackets_count\
    \ = Vec::new();\n    let mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_count = Vec::new();\n    let mut close_brackets_count\
    \ = Vec::new();\n    let mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_count = Vec::new();\n    let mut close_brackets_count\
    \ = Vec::new();\n    let mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_count = Vec::new();\n    let mut close_brackets_count\
    \ = Vec::new();\n    let mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_count = Vec::new();\n    let mut close_brackets_count\
    \ = Vec::new();\n    let mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_count = Vec::new();\n    let mut close_brackets_count\
    \ = Vec::new();\n    let mut open_brackets_stack = Vec::new();\n    let mut close_bracket\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp6ju0o5ld.rs:47:26\n   |\n\
    47 |     let mut close_bracket\n   |                          ^ help: add `;`\
    \ here\n48 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp6ju0o5ld.rs:11:44\n   |\n11 | fn correct_bracketing(brackets: String)\
    \ -> bool {\n   |    ------------------                      ^^^^ expected `bool`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == ')' || c == '(')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpexnsdi2v.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpnncv2the.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    let mut open_brackets: Vec<usize> = vec![];\n\
    \    let mut close_brackets: Vec<usize> = vec![];\n    let mut open_bracket =\
    \ String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut bracket\
    \ = String::new();\n    let mut brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut bracket\
    \ = String::new();\n    let mut brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut bracket\
    \ = String::new();\n    let mut brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut bracket\
    \ = String::new();\n    let mut brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut bracket\
    \ = String::new();\n    let mut brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut bracket\
    \ = String::new();\n    let mut brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut \n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp222icati.rs:54:1\n\
    \   |\n54 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut open_brackets = Vec::new();\n    let mut\
    \ close_brackets = Vec::new();\n    for bracket in brackets {\n        if bracket\
    \ == '(' {\n            stack.push(bracket);\n            open_brackets.push(bracket);\n\
    \        } else if bracket == ')' {\n            if stack.len() == 0 {\n     \
    \           return false;\n            }\n            close_brackets.push(stack.pop());\n\
    \        } else if bracket == '[' {\n            stack.push(bracket);\n      \
    \  } else if bracket == ']' {\n            if stack.len() == 0 {\n           \
    \     return false;\n            }\n            close_brackets.push(stack.pop());\n\
    \        } else if bracket == '{' {\n            stack.push(bracket);\n      \
    \  } else if bracket == '}' {\n            if stack.len() == 0 {\n           \
    \     return false;\n            }\n            close_brackets.push(stack.pop());\n\
    \        }\n    }\n    if stack.len() != 0 {\n        return false;\n    }\n \
    \   if open_brackets.len() != close_brackets.len() {\n        return false;\n\
    \    }\n    for open_bracket in open_brackets {\n        if close_brackets.iter().any(|close_bracket|\
    \ open_bracket == close_bracket) {\n            return false;\n        }\n   \
    \ }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n   \
    \ assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n   --> /tmp/tmp9r9zz63u.rs:15:20\n\
    \    |\n15  |     for bracket in brackets {\n    |                    ^^^^^^^^\
    \ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n \
    \   = help: the trait `Iterator` is not implemented for `String`\n    = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `String`\n\
    note: required by `into_iter`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\"\
    , \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n\
    \    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\"\
    , \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    [\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\"\
    );\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp8iadlwwo.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    let mut opening_brackets = String::new();\n\
    \    let mut closing_brackets = String::new();\n    while brackets.len() > 0 {\n\
    \        let mut opening_bracket = String::new();\n        let mut closing_bracket\
    \ = String::new();\n        let mut opening_brackets = String::new();\n      \
    \  let mut closing_brackets = String::new();\n        while brackets.len() > 0\
    \ {\n            let mut opening_bracket = String::new();\n            let mut\
    \ closing_bracket = String::new();\n            let mut opening_brackets = String::new();\n\
    \            let mut closing_brackets = String::new();\n            if brackets.starts_with(\"\
    (\") {\n                opening_bracket = brackets.chars().next().unwrap();\n\
    \                opening_brackets = opening_brackets.to_string() + opening_bracket.to_string();\n\
    \                closing_bracket = String::from(\")\");\n                closing_brackets\
    \ = closing_brackets.to_string() + closing_bracket.to_string();\n            }\
    \ else if brackets.starts_with(\")\") {\n                opening_bracket = String::from(\"\
    (\");\n                opening_brackets = opening_brackets.to_string() + opening_bracket.to_string();\n\
    \                closing_bracket = brackets.chars().next().unwrap();\n       \
    \         closing_brackets = closing_brackets.to_string() + closing_bracket.to_string();\n\
    \            } else {\n                panic!(\"Bracketing error!\");\n      \
    \      }\n            brackets = brackets.chars().next().unwrap();\n        }\n\
    \        if opening_brackets.len() > 0 {\n            opening_brackets = opening_brackets.to_string();\n\
    \        }\n        if closing_brackets.len() > 0 {\n            closing_brackets\
    \ = closing_brackets.to_string();\n        }\n        if opening_brackets.len()\
    \ > 0 && closing_brackets.len() > 0 {\n            return false;\n        }\n\
    \        if opening_brackets.len() > 0 {\n            opening_brackets = opening_brackets.to_string();\n\
    \        }\n        if closing_brackets.len() > 0 {\n            closing_brackets\
    \ = closing_brackets.to_string();\n        }\n        if opening_brackets.len()\
    \ > 0 && closing_brackets.len() > 0 {\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpfvktm49d.rs:72:3\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - unclosed delimiter\n...\n15 |     while\
    \ brackets.len() > 0 {\n   |                              - unclosed delimiter\n\
    ...\n55 |         if opening_brackets.len() > 0 && closing_brackets.len() > 0\
    \ {\n   |                                                                    \
    \ - this delimiter might not be properly closed...\n56 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n72 | }\n   |   ^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfvktm49d.rs:26:35\n   |\n26 |              \
    \   opening_bracket = brackets.chars().next().unwrap();\n   |                \
    \                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                                   |\n   |     \
    \                              expected struct `String`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfvktm49d.rs:27:67\n   |\n27 |              \
    \   opening_brackets = opening_brackets.to_string() + opening_bracket.to_string();\n\
    \   |                                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                                                                   |\n  \
    \ |                                                                   expected\
    \ `&str`, found struct `String`\n   |                                        \
    \                           help: consider borrowing here: `&opening_bracket.to_string()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpfvktm49d.rs:29:67\n   |\n29 |\
    \                 closing_brackets = closing_brackets.to_string() + closing_bracket.to_string();\n\
    \   |                                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                                                                   |\n  \
    \ |                                                                   expected\
    \ `&str`, found struct `String`\n   |                         "
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"(\");\n  \
    \  brackets.replace(\"]\", \")\");\n    brackets.replace(\"{\", \"(\");\n    brackets.replace(\"\
    }\", \")\");\n    brackets.replace(\"(\", \"[\");\n    brackets.replace(\")\"\
    , \"]\");\n    brackets.replace(\"[\", \"{\");\n    brackets.replace(\"]\", \"\
    }\");\n    brackets.replace(\"{\", \"[\");\n    brackets.replace(\"}\", \"]\"\
    );\n    brackets.replace(\"(\", \"{\");\n    brackets.replace(\")\", \"}\");\n\
    \    brackets.replace(\"{\", \"(\");\n    brackets.replace(\"}\", \")\");\n  \
    \  brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\"\
    , \"[\");\n    brackets.replace(\")\", \"]\");\n    brackets.replace(\"[\", \"\
    {\");\n    brackets.replace(\"]\", \"}\");\n    brackets.replace(\"{\", \"(\"\
    );\n    brackets.replace(\"}\", \")\");\n    brackets.replace(\"(\", \"[\");\n\
    \    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"[\");\n    brackets.replace(\"\
    ]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\"\
    , \"}\");\n    brackets.replace(\"(\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"(\", \"[\");\n    brackets.replace(\"]\", \"]\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"(\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\"\
    , \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"[\"\
    );\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_g2gi1rn.rs:11:44\n   |\n\
    11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 0
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for bracket in brackets.chars() {\n        if bracket\
    \ == '(' {\n            stack.push(bracket);\n        } else if bracket == ')'\
    \ {\n            if stack.len() == 0 {\n                return false;\n      \
    \      }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ != 0 {\n                return false;\n            }\n        }\n    }\n   \
    \ stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    while !brackets.is_empty() {\n   \
    \     let mut opening = brackets.chars().next().unwrap();\n        let mut closing\
    \ = brackets.chars().next().unwrap();\n        while !opening.is_ascii() && !closing.is_ascii()\
    \ {\n            opening = brackets.chars().next().unwrap();\n            closing\
    \ = brackets.chars().next().unwrap();\n        }\n        if opening.is_ascii()\
    \ && closing.is_ascii() {\n            if opening.is_ascii_alphanumeric() && closing.is_ascii_alphanumeric()\
    \ {\n                if opening.is_ascii_upper() && closing.is_ascii_lower() {\n\
    \                    if opening.is_ascii_lower() && closing.is_ascii_upper() {\n\
    \                        brackets = brackets.chars().skip_while(|c| !c.is_ascii_alphanumeric()).collect();\n\
    \                    } else if opening.is_ascii_upper() && closing.is_ascii_lower()\
    \ {\n                        brackets = brackets.chars().skip_while(|c| !c.is_ascii_alphanumeric()).collect();\n\
    \                    } else if opening.is_ascii_upper() && closing.is_ascii_upper()\
    \ {\n                        brackets = brackets.chars().skip_while(|c| !c.is_ascii_alphanumeric()).collect();\n\
    \                    } else if opening.is_ascii_lower() && closing.is_ascii_lower()\
    \ {\n                        brackets = brackets.chars().skip_while(|c| !c.is_ascii_alphanumeric()).collect();\n\
    \                    } else if opening.is_ascii_lower() && closing.is_ascii_upper()\
    \ {\n                        brackets = brackets.chars().skip_while(|c| !c.is_ascii_alphanumeric()).collect();\n\
    \                    } else if opening.is_ascii_upper() && closing.is_ascii_upper()\
    \ {\n                        brackets = brackets.chars().skip_while(|c| !c.is_ascii_alphanumeric()).collect();\n\
    \                    } else if opening.is_ascii_lower() && closing.is_ascii_upper()\
    \ {\n                        brackets = brackets.chars().skip_while(|c| !c.is_ascii_alphanumeric()).collect();\n\
    \                    } else if opening.is_ascii_lower() && closing.is_ascii_lower()\
    \ {\n                        brackets = brackets.chars().skip_while(|c| !c.is_ascii_alphanumeric()).collect();\n\
    \                    } else if opening.is_ascii_upper() && closing.is_ascii_upper()\
    \ {\n                        brackets = brackets.chars().skip_while(|c| !c.is_ascii_alphanumeric()).collect();\n\
    \                    } else if opening.is_ascii_lower() && closing.is_ascii_upper()\
    \ {\n                        brackets = brackets.chars().skip_while(|c| !c.is_ascii_alphanumeric()).collect\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpq948ly_c.rs:59:3\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - unclosed delimiter\n12 |     let mut\
    \ brackets = brackets.to_string();\n13 |     while !brackets.is_empty() {\n  \
    \ |                                - unclosed delimiter\n...\n20 |         if\
    \ opening.is_ascii() && closing.is_ascii() {\n   |                           \
    \                          - unclosed delimiter\n21 |             if opening.is_ascii_alphanumeric()\
    \ && closing.is_ascii_alphanumeric() {\n   |                                 \
    \                                                  - unclosed delimiter\n22 |\
    \                 if opening.is_ascii_upper() && closing.is_ascii_lower() {\n\
    \   |                                                                        \
    \ - unclosed delimiter\n...\n41 |                     } else if opening.is_ascii_lower()\
    \ && closing.is_ascii_upper() {\n   |                                        \
    \                                            - this delimiter might not be properly\
    \ closed...\n42 |                         brackets = brackets.chars().skip_while(|c|\
    \ !c.is_ascii_alphanumeric()).collect\n43 | }\n   | - ...as it matches this but\
    \ it has different indentation\n...\n59 | }\n   |   ^\n\nerror[E0599]: no method\
    \ named `is_ascii_upper` found for type `char` in the current scope\n  --> /tmp/tmpq948ly_c.rs:22:28\n\
    \   |\n22 |                 if opening.is_ascii_upper() && closing.is_ascii_lower()\
    \ {\n   |                            ^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `is_ascii_uppercase`\n\nerror[E0599]: no method\
    \ named `is_ascii_lower` found for type `char` in the current scope\n  --> /tmp/tmpq948ly_c.rs:22:56\n\
    \   |\n22 |                 if opening.is_ascii_upper() && closing.is_ascii_lower()\
    \ {\n   |                                                        ^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_lower` fou"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpnncv2the.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\"\
    , \"<\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\"\
    );\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\");\n  \
    \  brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\"\
    , \">\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\"\
    );\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n\
    \    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    <\", \"<\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"\
    <\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\"\
    );\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\");\n\
    \    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpqbgn3uy_.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\"\
    );\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\"\
    , \"}\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\"\
    );\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpfg9249mn.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    let mut open_brackets: Vec<usize> = vec![];\n\
    \    let mut close_brackets: Vec<usize> = vec![];\n\n    for bracket in brackets.chars()\
    \ {\n        if bracket == '(' {\n            stack.push(bracket);\n         \
    \   open_brackets.push(bracket);\n        } else if bracket == ')' {\n       \
    \     if open_brackets.len() == 0 {\n                return false;\n         \
    \   }\n            close_brackets.push(bracket);\n            open_brackets.pop();\n\
    \        } else if bracket == '[' {\n            stack.push(bracket);\n      \
    \  } else if bracket == ']' {\n            if open_brackets.len() == 0 {\n   \
    \             return false;\n            }\n            close_brackets.push(bracket);\n\
    \            open_brackets.pop();\n        } else if bracket == '{' {\n      \
    \      stack.push(bracket);\n        } else if bracket == '}' {\n            if\
    \ open_brackets.len() == 0 {\n                return false;\n            }\n \
    \           close_brackets.push(bracket);\n            open_brackets.pop();\n\
    \        }\n    }\n\n    if stack.len() != close_brackets.len() {\n        return\
    \ false;\n    }\n\n    for open_bracket in open_brackets.iter() {\n        if\
    \ close_brackets.iter().any(|c| c == open_bracket) {\n            return false;\n\
    \        }\n    }\n\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwry27o3f.rs:18:24\n   |\n\
    18 |             stack.push(bracket);\n   |                        ^^^^^^^ expected\
    \ `usize`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwry27o3f.rs:19:32\n\
    \   |\n19 |             open_brackets.push(bracket);\n   |                   \
    \             ^^^^^^^ expected `usize`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwry27o3f.rs:24:33\n   |\n24 |             close_brackets.push(bracket);\n\
    \   |                                 ^^^^^^^ expected `usize`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwry27o3f.rs:27:24\n   |\n27 |\
    \             stack.push(bracket);\n   |                        ^^^^^^^ expected\
    \ `usize`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwry27o3f.rs:32:33\n\
    \   |\n32 |             close_brackets.push(bracket);\n   |                  \
    \               ^^^^^^^ expected `usize`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwry27o3f.rs:35:24\n   |\n35 |             stack.push(bracket);\n\
    \   |                        ^^^^^^^ expected `usize`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwry27o3f.rs:40:33\n   |\n40 |             close_brackets.push(bracket);\n\
    \   |                                 ^^^^^^^ expected `usize`, found `char`\n\
    \nerror: aborting due to 7 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpnncv2the.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut open_brackets = Vec::new();\n    let mut\
    \ close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n  \
    \  let mut close_bracket = String::new();\n    let mut open_brackets_size = brackets.chars().filter(|c|\
    \ c == '(').count();\n    let mut close_brackets_size = brackets.chars().filter(|c|\
    \ c == ')').count();\n    let mut open_brackets_size2 = open_brackets_size;\n\
    \    let mut close_brackets_size2 = close_brackets_size;\n    let mut open_brackets_size3\
    \ = open_brackets_size;\n    let mut close_brackets_size3 = close_brackets_size;\n\
    \    let mut open_brackets_size4 = open_brackets_size;\n    let mut close_brackets_size4\
    \ = close_brackets_size;\n    let mut open_brackets_size5 = open_brackets_size;\n\
    \    let mut close_brackets_size5 = close_brackets_size;\n    let mut open_brackets_size6\
    \ = open_brackets_size;\n    let mut close_brackets_size6 = close_brackets_size;\n\
    \    let mut open_brackets_size7 = open_brackets_size;\n    let mut close_brackets_size7\
    \ = close_brackets_size;\n    let mut open_brackets_size8 = open_brackets_size;\n\
    \    let mut close_brackets_size8 = close_brackets_size;\n    let mut open_brackets_size9\
    \ = open_brackets_size;\n    let mut close_brackets_size9 = close_brackets_size;\n\
    \    let mut open_brackets_size10 = open_brackets_size;\n    let mut close_brackets_size10\
    \ = close_brackets_size;\n    let mut open_brackets_size11 = open_brackets_size;\n\
    \    let mut close_brackets_size11 = close_brackets_size;\n    let mut open_brackets_size12\
    \ = open_brackets_size;\n    let mut close_brackets_size12 = close_brackets_size;\n\
    \    let mut open_brackets_size13 = open_brackets_size;\n    let mut close_brackets_size13\
    \ = \n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpclt6trm2.rs:43:1\n\
    \   |\n43 | }\n   | ^ expected expression\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpclt6trm2.rs:17:64\n   |\n17 |     let mut open_brackets_size\
    \ = brackets.chars().filter(|c| c == '(').count();\n   |                     \
    \                                           ^^ no implementation for `&char ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpclt6trm2.rs:18:65\n\
    \   |\n18 |     let mut close_brackets_size = brackets.chars().filter(|c| c ==\
    \ ')').count();\n   |                                                        \
    \         ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n\nerror: aborting due to 3\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = vec![];\n    for ch in brackets.chars() {\n        if ch == '('\
    \ || ch == ')' {\n            stack.push(ch);\n        } else {\n            if\
    \ stack.len() == 0 {\n                return false;\n            }\n         \
    \   let top = stack.pop().unwrap();\n            if top != ch {\n            \
    \    return false;\n            }\n        }\n    }\n    stack.len() == 0\n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpiozdwun_.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 0
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for bracket in brackets.chars() {\n        if bracket\
    \ == '(' {\n            stack.push(bracket);\n        } else if bracket == ')'\
    \ {\n            if stack.is_empty() {\n                return false;\n      \
    \      }\n            stack.pop();\n        } else {\n            return false;\n\
    \        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut opening_brackets = String::new();\n   \
    \ let mut closing_brackets = String::new();\n    let mut opening_brackets_count\
    \ = String::new();\n    let mut closing_brackets_count = String::new();\n    let\
    \ mut opening_brackets_count_stack = Vec::new();\n    let mut closing_brackets_count_stack\
    \ = Vec::new();\n    let mut opening_brackets_count_stack = Vec::new();\n    let\
    \ mut closing_brackets_count_stack = Vec::new();\n    let mut opening_brackets_count_stack\
    \ = Vec::new();\n    let mut closing_brackets_count_stack = Vec::new();\n    let\
    \ mut opening_brackets_count_stack = Vec::new();\n    let mut closing_brackets_count_stack\
    \ = Vec::new();\n    let mut opening_brackets_count_stack = Vec::new();\n    let\
    \ mut closing_brackets_count_stack = Vec::new();\n    let mut opening_brackets_count_stack\
    \ = Vec::new();\n    let mut closing_brackets_count_stack = Vec::new();\n    let\
    \ mut opening_brackets_count_stack = Vec::new();\n    let mut closing_brackets_count_stack\
    \ = Vec::new();\n    let mut opening_brackets_count_stack = Vec::new();\n    let\
    \ mut closing_brackets_count_stack = Vec::new();\n    let mut opening_brackets_count_stack\
    \ = Vec::new();\n    let mut closing_brackets_count_stack = Vec::new();\n    let\
    \ mut opening_brackets_count_stack = Vec::new();\n    let mut closing_brackets_count_stack\
    \ = Vec::new();\n    let mut opening_brackets_count_stack = Vec::new();\n    let\
    \ mut closing_brackets_count_stack = Vec::new();\n    let mut opening_brackets_count_stack\
    \ = Vec::new();\n    let mut closing_brackets_count_stack = Vec::new();\n    let\
    \ mut opening_brackets_count_stack = Vec::new();\n    let mut closing_brackets_count_stack\
    \ = Vec::new();\n    let mut opening_brackets_count_stack = Vec::new();\n\n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbej3w90h.rs:11:44\n   |\n\
    11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    while brackets.len() > 0 {\n     \
    \   let mut opening = brackets.chars().next().unwrap();\n        let mut closing\
    \ = brackets.chars().next().unwrap();\n        if opening != closing {\n     \
    \       return false;\n        }\n        brackets = brackets.chars().next().unwrap();\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9n52wj7v.rs:19:20\n   |\n\
    19 |         brackets = brackets.chars().next().unwrap();\n   |              \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                    |\n   |                    expected\
    \ struct `String`, found `char`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    let mut opening_brackets = String::new();\n\
    \    let mut closing_brackets = String::new();\n    while brackets.len() > 0 {\n\
    \        let mut opening_bracket = String::new();\n        let mut closing_bracket\
    \ = String::new();\n        let mut opening_brackets = String::new();\n      \
    \  let mut closing_brackets = String::new();\n        while brackets.len() > 0\
    \ {\n            let mut opening_bracket = String::new();\n            let mut\
    \ closing_bracket = String::new();\n            let mut opening_brackets = String::new();\n\
    \            let mut closing_brackets = String::new();\n            if brackets.starts_with(\"\
    (\") {\n                opening_brackets.push('(');\n                closing_brackets.push(')');\n\
    \                brackets.split_off(1);\n            } else {\n              \
    \  opening_brackets.push(')');\n                closing_brackets.push('(');\n\
    \                brackets.split_off(1);\n            }\n            for opening_bracket\
    \ in opening_brackets.chars() {\n                for closing_bracket in closing_brackets.chars()\
    \ {\n                    if opening_bracket == closing_bracket {\n           \
    \             break;\n                    }\n                }\n             \
    \   if opening_bracket.len() == 0 {\n                    return false;\n     \
    \           }\n            }\n        }\n        opening_brackets = opening_brackets.to_string();\n\
    \        closing_brackets = closing_brackets.to_string();\n        if opening_brackets.len()\
    \ != closing_brackets.len() {\n            return false;\n        }\n        brackets\
    \ = brackets.to_string();\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `char` in the current\
    \ scope\n  --> /tmp/tmppgn7u903.rs:40:36\n   |\n40 |                 if opening_bracket.len()\
    \ == 0 {\n   |                                    ^^^ method not found in `char`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \n    for bracket in brackets.chars().filter(|c| *c != '(' && c != ')') {\n  \
    \      if *bracket == '(' {\n            opening_brackets.push('(');\n       \
    \ } else {\n            opening_brackets.push(')');\n        }\n    }\n\n    for\
    \ bracket in brackets.chars().filter(|c| *c == ')') {\n        if *bracket ==\
    \ '(' {\n            closing_brackets.push('(');\n        } else {\n         \
    \   closing_brackets.push(')');\n        }\n    }\n\n    opening_brackets == closing_brackets\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp24fofhtr.rs:15:63\n\
    \   |\n15 |     for bracket in brackets.chars().filter(|c| *c != '(' && c != ')')\
    \ {\n   |                                                               ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n\nerror[E0614]: type `char` cannot be dereferenced\n\
    \  --> /tmp/tmp24fofhtr.rs:16:12\n   |\n16 |         if *bracket == '(' {\n  \
    \ |            ^^^^^^^^\n\nerror[E0614]: type `char` cannot be dereferenced\n\
    \  --> /tmp/tmp24fofhtr.rs:24:12\n   |\n24 |         if *bracket == '(' {\n  \
    \ |            ^^^^^^^^\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0614.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets == brackets\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpcj2c4sic.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_count = Vec::new();\n    let mut close_brackets_count\
    \ = Vec::new();\n    let mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_count = Vec::new();\n    let mut close_brackets_count\
    \ = Vec::new();\n    let mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_count = Vec::new();\n    let mut close_brackets_count\
    \ = Vec::new();\n    let mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_count = Vec::new();\n    let mut close_brackets_count\
    \ = Vec::new();\n    let mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_count = Vec::new();\n    let mut close_brackets_count\
    \ = Vec::new();\n    let mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_count = Vec::new();\n    let mut close_brackets_count\
    \ = Vec::new();\n    let mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_count = Vec::new();\n    let mut close_brackets_count\
    \ = Vec::new();\n    let mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_count = Vec::new();\n    let mut close_brackets_count\
    \ = Vec::new();\n    let mut open_brackets_stack = Vec::new();\n    let mut close_bracket\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp6ju0o5ld.rs:47:26\n   |\n\
    47 |     let mut close_bracket\n   |                          ^ help: add `;`\
    \ here\n48 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp6ju0o5ld.rs:11:44\n   |\n11 | fn correct_bracketing(brackets: String)\
    \ -> bool {\n   |    ------------------                      ^^^^ expected `bool`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = Vec::new();\n    for c in brackets.chars() {\n     \
    \   if c == '(' {\n            stack.push(0);\n        } else if c == ')' {\n\
    \            if stack.len() == 0 {\n                return false;\n          \
    \  }\n            stack.pop();\n        } else {\n            if stack.len() ==\
    \ 0 {\n                return false;\n            }\n            stack[stack.len()\
    \ - 1] += 1;\n        }\n    }\n    stack.iter().all(|&x| x == 0)\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `stack` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmpkdz6lx1b.rs:25:19\n   |\n25 |             stack[stack.len()\
    \ - 1] += 1;\n   |             ------^^^^^-----------\n   |             |    \
    \ |\n   |             |     immutable borrow occurs here\n   |             mutable\
    \ borrow occurs here\n   |             mutable borrow later used here\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets == brackets\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpcj2c4sic.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    for ch in brackets.chars() {\n        if\
    \ ch == '(' {\n            stack.push(0);\n        } else if ch == ')' {\n   \
    \         if stack.len() == 0 {\n                return false;\n            }\n\
    \            let top = stack.len();\n            stack.pop();\n            if\
    \ top != 0 {\n                return false;\n            }\n        }\n    }\n\
    \    stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp43oen5ye.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747841
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    for ch in brackets.chars() {\n        if\
    \ ch == '(' {\n            stack.push(0);\n        } else if ch == ')' {\n   \
    \         if stack.len() == 0 {\n                return false;\n            }\n\
    \            let index = stack.pop();\n            if index == 0 {\n         \
    \       return false;\n            }\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            let index\
    \ = stack.pop();\n            stack.push(index);\n        }\n    }\n    stack.len()\
    \ == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwhpb2frz.rs:21:25\n   |\n\
    21 |             if index == 0 {\n   |                         ^\n   |       \
    \                  |\n   |                         expected enum `Option`, found\
    \ integer\n   |                         help: try using a variant of the expected\
    \ enum: `Some(0)`\n   |\n   = note: expected enum `Option<usize>`\n          \
    \    found type `{integer}`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwhpb2frz.rs:29:24\n\
    \   |\n29 |             stack.push(index);\n   |                        ^^^^^\
    \ expected `usize`, found enum `Option`\n   |\n   = note: expected type `usize`\n\
    \              found enum `Option<usize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    while brackets.len() > 0 {\n     \
    \   let mut opening = brackets.chars().next().unwrap();\n        let mut closing\
    \ = brackets.chars().next().unwrap();\n        if opening != closing {\n     \
    \       return false;\n        }\n        brackets = brackets.chars().next().unwrap();\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9n52wj7v.rs:19:20\n   |\n\
    19 |         brackets = brackets.chars().next().unwrap();\n   |              \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                    |\n   |                    expected\
    \ struct `String`, found `char`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    let mut opening_brackets_stack = Vec::new();\n    let mut closing_brackets_stack\
    \ = Vec::new();\n    let mut opening_brackets_stack_ptr = &mut opening_brackets_stack;\n\
    \    let mut closing_brackets_stack_ptr = &mut closing_brackets_stack;\n    let\
    \ mut opening_brackets_ptr = &mut opening_brackets;\n    let mut closing_brackets_ptr\
    \ = &mut closing_brackets;\n    let mut opening_brackets_ptr = &mut opening_brackets;\n\
    \    let mut closing_brackets_ptr = &mut closing_brackets;\n    let mut opening_brackets_ptr\
    \ = &mut opening_brackets;\n    let mut closing_brackets_ptr = &mut closing_brackets;\n\
    \    let mut opening_brackets_ptr = &mut opening_brackets;\n    let mut closing_brackets_ptr\
    \ = &mut closing_brackets;\n    let mut opening_brackets_ptr = &mut opening_brackets;\n\
    \    let mut closing_brackets_ptr = &mut closing_brackets;\n    let mut opening_brackets_ptr\
    \ = &mut opening_brackets;\n    let mut closing_brackets_ptr = &mut closing_brackets;\n\
    \    let mut opening_brackets_ptr = &mut opening_brackets;\n    let mut closing_brackets_ptr\
    \ = &mut closing_brackets;\n    let mut opening_brackets_ptr = &mut opening_brackets;\n\
    \    let mut closing_brackets_ptr = &mut closing_brackets;\n    let mut opening_brackets_ptr\
    \ = &mut opening_brackets;\n    let mut closing_brackets_ptr = &mut closing_brackets;\n\
    \    let mut opening_brackets_ptr = &mut opening_brackets;\n    let mut closing_brackets_ptr\
    \ = &mut closing_brackets;\n    let mut opening_bracket\n}\n\nfn main() {\n  \
    \  let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp27ejwvob.rs:38:28\n   |\n\
    38 |     let mut opening_bracket\n   |                            ^ help: add\
    \ `;` here\n39 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp27ejwvob.rs:11:44\n   |\n11 | fn correct_bracketing(brackets: String)\
    \ -> bool {\n   |    ------------------                      ^^^^ expected `bool`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().skip_while(|c| c !=\
    \ '(').collect::<String>());\n    while let Some(item) = stack.pop() {\n     \
    \   if item != '(' {\n            return false;\n        }\n        stack.push(brackets.chars().skip_while(|c|\
    \ c != ')').collect::<String>());\n    }\n    stack.is_empty()\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpllvw8x9x.rs:13:50\n\
    \   |\n13 |     stack.push(brackets.chars().skip_while(|c| c != '(').collect::<String>());\n\
    \   |                                                  ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `String` with `char`\n  --> /tmp/tmpllvw8x9x.rs:15:17\n\
    \   |\n15 |         if item != '(' {\n   |                 ^^ no implementation\
    \ for `String == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `String`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpllvw8x9x.rs:18:54\n\
    \   |\n18 |         stack.push(brackets.chars().skip_while(|c| c != ')').collect::<String>());\n\
    \   |                                                      ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut opening = brackets.chars().filter(|c| c\
    \ == '(').collect::<Vec<_>>();\n    let mut closing = brackets.chars().filter(|c|\
    \ c == ')').collect::<Vec<_>>();\n    let mut open = Vec::new();\n    let mut\
    \ close = Vec::new();\n    let mut opening = opening.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut closing = closing.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ open = Vec::new();\n    let mut close = Vec::new();\n    let mut opening = opening.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut closing = closing.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ open = Vec::new();\n    let mut close = Vec::new();\n    let mut opening = opening.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut closing = closing.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ open = Vec::new();\n    let mut close = Vec::new();\n    let mut opening = opening.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut closing = closing.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ open = Vec::new();\n    let mut close = Vec::new();\n    let mut opening = opening.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut closing = closing.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ open = Vec::new();\n    let mut close = Vec::new();\n    let mut opening = opening.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut closing = closing.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ open = Vec::new();\n    let mut close = Vec::new();\n    let mut opening = opening.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut closing = closing.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ open = Vec::new();\n    let mut close = Vec::new();\n    let mut opening = opening.iter().cloned().collect\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxdz52k9x.rs:45:54\n   |\n\
    45 |     let mut opening = opening.iter().cloned().collect\n   |             \
    \                                         ^ help: add `;` here\n46 | }\n   | -\
    \ unexpected token\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpxdz52k9x.rs:13:53\n\
    \   |\n13 |     let mut opening = brackets.chars().filter(|c| c == '(').collect::<Vec<_>>();\n\
    \   |                                                     ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpxdz52k9x.rs:14:53\n\
    \   |\n14 |     let mut closing = brackets.chars().filter(|c| c == ')').collect::<Vec<_>>();\n\
    \   |                                                     ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0615]: attempted to take value of method `collect` on\
    \ type `Cloned<std::slice::Iter<'_, char>>`\n  --> /tmp/tmpxdz52k9x.rs:45:47\n\
    \   |\n45 |     let mut opening = opening.iter().cloned().collect\n   |      \
    \                                         ^^^^^^^ method, not a field\n   |\n\
    help: use parentheses to call the method\n   |\n45 |     let mut opening = opening.iter().cloned().collect()\n\
    \   |                                                      ++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxdz52k9x.rs:11:44\n   |\n11 | fn correct_bracketing(brackets:\
    \ String) -> bool {\n   |    ------------------                      ^^^^ expected\
    \ `bool`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0615.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 0
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for c in brackets.chars() {\n        if c == '('\
    \ {\n            stack.push(c);\n        } else if c == ')' {\n            if\
    \ stack.len() == 0 {\n                return false;\n            }\n         \
    \   stack.pop();\n        } else {\n            if stack.len() == 0 {\n      \
    \          return false;\n            }\n            stack.pop();\n          \
    \  stack.push(c);\n        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747841
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\"\
    );\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\"\
    , \"}\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\"\
    );\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpfg9249mn.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    for bracket in brackets {\n        if bracket == '(' {\n            open_brackets.push('(');\n\
    \        } else if bracket == ')' {\n            close_brackets.push(')');\n \
    \       } else {\n            open_brackets.push(bracket);\n            close_brackets.push(bracket);\n\
    \        }\n    }\n    open_brackets == close_brackets\n}\n\nfn main() {\n   \
    \ let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n   --> /tmp/tmp_8udo5y3.rs:14:20\n\
    \    |\n14  |     for bracket in brackets {\n    |                    ^^^^^^^^\
    \ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n \
    \   = help: the trait `Iterator` is not implemented for `String`\n    = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `String`\n\
    note: required by `into_iter`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n\
    \    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"[\", \"\
    [\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"\
    ]\", \"]\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"[\"\
    , \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"{\", \"{\"\
    );\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmppdse2eg5.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut opening = brackets.chars().enumerate().filter(|(_,\
    \ c)| c != '(').collect::<Vec<_>>();\n    let mut closing = brackets.chars().enumerate().filter(|(_,\
    \ c)| c != ')').collect::<Vec<_>>();\n    let mut opening_stack = Vec::new();\n\
    \    let mut closing_stack = Vec::new();\n    loop {\n        if closing.len()\
    \ == 0 {\n            return opening.len() == 0;\n        }\n        if opening.len()\
    \ == 0 {\n            return false;\n        }\n        if opening.len() == closing.len()\
    \ {\n            if opening.len() == 1 {\n                opening_stack.push(opening.pop().unwrap());\n\
    \            } else {\n                closing_stack.push(closing.pop().unwrap());\n\
    \            }\n        } else {\n            if opening.len() == 1 {\n      \
    \          opening_stack.push(opening.pop().unwrap());\n            } else {\n\
    \                closing_stack.push(closing.pop().unwrap());\n            }\n\
    \            if opening_stack.len() == 1 {\n                opening.push(opening_stack.pop().unwrap());\n\
    \            } else {\n                closing.push(closing_stack.pop().unwrap());\n\
    \            }\n        }\n    }\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpqp3060up.rs:13:70\n\
    \   |\n13 |     let mut opening = brackets.chars().enumerate().filter(|(_, c)|\
    \ c != '(').collect::<Vec<_>>();\n   |                                       \
    \                               ^^ no implementation for `&char == char`\n   |\n\
    \   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpqp3060up.rs:14:70\n   |\n14\
    \ |     let mut closing = brackets.chars().enumerate().filter(|(_, c)| c != ')').collect::<Vec<_>>();\n\
    \   |                                                                      ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().skip_while(|c| !c.is_ascii_letter()).collect());\n\
    \    while let Some(item) = stack.pop() {\n        if item != ')' {\n        \
    \    return false;\n        }\n        if stack.len() == 0 {\n            return\
    \ true;\n        }\n        stack.push(stack.last().unwrap().chars().skip_while(|c|\
    \ !c.is_ascii_letter()).collect());\n    }\n    false\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\"\
    )), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmp4sqh2kj_.rs:13:51\n   |\n13 |     stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).collect());\n   |                                    \
    \               ^^^^^^^^^^^^^^^ method not found in `&char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659747841
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == ')' || c == '(')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpexnsdi2v.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_size = brackets.chars().filter(|c| c == '(').count();\n\
    \    let mut close_brackets_size = brackets.chars().filter(|c| c == ')').count();\n\
    \    let mut open_brackets_index = 0;\n    let mut close_brackets_index = 0;\n\
    \    let mut open_brackets_index_end = 0;\n    let mut close_brackets_index_end\
    \ = 0;\n    let mut open_brackets_index_start = 0;\n    let mut close_brackets_index_start\
    \ = 0;\n    let mut open_brackets_index_end = 0;\n    let mut close_brackets_index_end\
    \ = 0;\n    let mut open_brackets_index_start = 0;\n    let mut close_brackets_index_start\
    \ = 0;\n    let mut open_brackets_index_end = 0;\n    let mut close_brackets_index_end\
    \ = 0;\n    let mut open_brackets_index_start = 0;\n    let mut close_brackets_index_start\
    \ = 0;\n    let mut open_brackets_index_end = 0;\n    let mut close_brackets_index_end\
    \ = 0;\n    let mut open_brackets_index_start = 0;\n    let mut close_brackets_index_start\
    \ = 0;\n    let mut open_brackets_index_end = 0;\n    let mut close_brackets_index_end\
    \ = 0;\n    let mut open_brackets_index_start = 0;\n    let mut close_brackets_index_start\
    \ = 0;\n    let mut open_brackets_index_end = 0;\n    let mut close_brackets_index_end\
    \ = 0;\n    let mut open_brackets_index_start = 0;\n    let mut close_brackets_index_start\
    \ = 0;\n    let mut open_brackets_index_end = 0;\n    let mut close_brackets_index_end\
    \ = 0;\n    let mut open_brackets_index_start = 0;\n    let mut close_brackets_index_start\
    \ = 0;\n    let mut open_brackets_index_end = 0;\n    let mut close_brackets_index_end\
    \ = 0;\n    let mut open_brackets_index_start = 0;\n    let mut close_brackets_index_start\
    \ = 0;\n    let mut open_brackets_index_end = 0;\n    let mut close_brackets_index_end\
    \ = 0;\n    let mut open_brackets_index_\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpbl6gh7o4.rs:52:33\n   |\n\
    52 |     let mut open_brackets_index_\n   |                                 ^\
    \ help: add `;` here\n53 | }\n   | - unexpected token\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmpbl6gh7o4.rs:14:64\n   |\n14 |     let mut\
    \ open_brackets_size = brackets.chars().filter(|c| c == '(').count();\n   |  \
    \                                                              ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpbl6gh7o4.rs:15:65\n\
    \   |\n15 |     let mut close_brackets_size = brackets.chars().filter(|c| c ==\
    \ ')').count();\n   |                                                        \
    \         ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbl6gh7o4.rs:11:44\n   |\n11 | fn correct_bracketing(brackets:\
    \ String) -> bool {\n   |    ------------------                      ^^^^ expected\
    \ `bool`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747841
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == ')' || c == '(')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpexnsdi2v.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    let mut open_brackets: Vec<usize> = vec![];\n\
    \    let mut close_brackets: Vec<usize> = vec![];\n\n    for bracket in brackets.chars()\
    \ {\n        if bracket == '(' {\n            stack.push(bracket);\n         \
    \   open_brackets.push(bracket);\n        } else if bracket == ')' {\n       \
    \     if stack.len() == 0 {\n                return false;\n            }\n  \
    \          close_brackets.push(stack.last().unwrap());\n            stack.pop();\n\
    \        } else if bracket == '[' {\n            stack.push(bracket);\n      \
    \  } else if bracket == ']' {\n            if stack.len() == 0 {\n           \
    \     return false;\n            }\n            close_brackets.push(stack.last().unwrap());\n\
    \            stack.pop();\n        } else if bracket == '{' {\n            stack.push(bracket);\n\
    \        } else if bracket == '}' {\n            if stack.len() == 0 {\n     \
    \           return false;\n            }\n            close_brackets.push(stack.last().unwrap());\n\
    \            stack.pop();\n        }\n    }\n\n    if stack.len() != 0 {\n   \
    \     return false;\n    }\n\n    for open_bracket in open_brackets {\n      \
    \  if close_brackets.contains(&open_bracket) {\n            return false;\n  \
    \      }\n    }\n\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2_r55w67.rs:18:24\n   |\n\
    18 |             stack.push(bracket);\n   |                        ^^^^^^^ expected\
    \ `usize`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2_r55w67.rs:19:32\n\
    \   |\n19 |             open_brackets.push(bracket);\n   |                   \
    \             ^^^^^^^ expected `usize`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2_r55w67.rs:24:33\n   |\n24 |             close_brackets.push(stack.last().unwrap());\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^ expected `usize`,\
    \ found `&usize`\n   |\nhelp: consider dereferencing the borrow\n   |\n24 |  \
    \           close_brackets.push(*stack.last().unwrap());\n   |               \
    \                  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2_r55w67.rs:27:24\n\
    \   |\n27 |             stack.push(bracket);\n   |                        ^^^^^^^\
    \ expected `usize`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2_r55w67.rs:32:33\n\
    \   |\n32 |             close_brackets.push(stack.last().unwrap());\n   |    \
    \                             ^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `&usize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n32 |             close_brackets.push(*stack.last().unwrap());\n\
    \   |                                 +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp2_r55w67.rs:35:24\n   |\n35 |             stack.push(bracket);\n   |\
    \                        ^^^^^^^ expected `usize`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2_r55w67.rs:40:33\n   |\n40 |             close_brackets.push(stack.last().unwrap());\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^ expected `usize`,\
    \ found `&usize`\n   |\nhelp: consider dereferencing the borrow\n   |\n40 |  \
    \           close_brackets.push(*stack.last().unwrap());\n   |               \
    \                  +\n\nerror: aborting due to 7 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747841
- exit_code: -1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().collect::<Vec<_>>());\n\
    \    while stack.len() > 0 {\n        let mut current = stack.pop().unwrap();\n\
    \        if current.len() == 0 {\n            continue;\n        }\n        let\
    \ mut next = current.clone();\n        while !next.is_empty() {\n            let\
    \ mut next = next.clone();\n            if next[0] == ')' {\n                next.pop();\n\
    \            } else {\n                break;\n            }\n        }\n    \
    \    if next.len() != 0 {\n            stack.push(next);\n        }\n    }\n \
    \   stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659747846
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpnncv2the.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpnncv2the.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\"\
    , \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n\
    \    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\"\
    , \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    [\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\"\
    );\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp8iadlwwo.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = brackets.chars().filter(|c| c == '(').count();\n    let\
    \ mut closed_brackets = brackets.chars().filter(|c| c == ')').count();\n    while\
    \ open_brackets > closed_brackets {\n        closed_brackets--;\n    }\n    open_brackets\
    \ == closed_brackets\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpaccyg8nm.rs:15:26\n\
    \   |\n15 |         closed_brackets--;\n   |                          ^ expected\
    \ expression\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpaccyg8nm.rs:12:59\n\
    \   |\n12 |     let mut open_brackets = brackets.chars().filter(|c| c == '(').count();\n\
    \   |                                                           ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpaccyg8nm.rs:13:61\n\
    \   |\n13 |     let mut closed_brackets = brackets.chars().filter(|c| c == ')').count();\n\
    \   |                                                             ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747841
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut opening_brackets = Vec::new();\n    let\
    \ mut closing_brackets = Vec::new();\n\n    for bracket in brackets.chars() {\n\
    \        if bracket == '(' {\n            stack.push(bracket);\n            opening_brackets.push(bracket);\n\
    \        } else if bracket == ')' {\n            if stack.len() == 0 {\n     \
    \           return false;\n            }\n            closing_brackets.push(stack.pop());\n\
    \        } else if bracket == '[' {\n            if stack.len() == 0 {\n     \
    \           return false;\n            }\n            stack.push(bracket);\n \
    \       } else if bracket == ']' {\n            if stack.len() == 0 {\n      \
    \          return false;\n            }\n            closing_brackets.push(stack.pop());\n\
    \        }\n    }\n\n    if stack.len() != 0 {\n        return false;\n    }\n\
    \n    if opening_brackets.len() != closing_brackets.len() {\n        return false;\n\
    \    }\n\n    for opening_bracket in opening_brackets {\n        if closing_brackets.iter().any(|c|\
    \ c == opening_bracket) {\n            return false;\n        }\n    }\n\n   \
    \ true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&Option<char>` with `char`\n  --> /tmp/tmp3d1olxhi.rs:47:46\n\
    \   |\n47 |         if closing_brackets.iter().any(|c| c == opening_bracket) {\n\
    \   |                                              ^^ no implementation for `&Option<char>\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&Option<char>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747841
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\"\
    , \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n\
    \    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\"\
    , \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    [\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\"\
    );\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp8iadlwwo.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
- exit_code: 0
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    for c in brackets.chars() {\n        if\
    \ c == '(' {\n            stack.push(0);\n        } else if c == ')' {\n     \
    \       if stack.len() == 0 {\n                return false;\n            }\n\
    \            stack.pop();\n        } else {\n            if stack.len() != 0 {\n\
    \                return false;\n            }\n            stack.push(c as usize);\n\
    \        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747841
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut opening_brackets = Vec::new();\n    let\
    \ mut closing_brackets = Vec::new();\n    stack.push(brackets.chars().enumerate().filter(|(_,\
    \ c)| c == '(').collect::<Vec<_>>());\n    while stack.len() > 0 {\n        let\
    \ (idx, c) = stack.pop().unwrap();\n        if c == '(' {\n            opening_brackets.push(idx);\n\
    \        } else if c == ')' {\n            closing_brackets.push(idx);\n     \
    \   }\n    }\n    opening_brackets.len() == closing_brackets.len()\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpymoo5ld1.rs:15:63\n\
    \   |\n15 |     stack.push(brackets.chars().enumerate().filter(|(_, c)| c == '(').collect::<Vec<_>>());\n\
    \   |                                                               ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpymoo5ld1.rs:17:13\n\
    \   |\n17 |         let (idx, c) = stack.pop().unwrap();\n   |             ^^^^^^^^\
    \   -------------------- this expression has type `Vec<(usize, char)>`\n   | \
    \            |\n   |             expected struct `Vec`, found tuple\n   |\n  \
    \ = note: expected struct `Vec<(usize, char)>`\n               found tuple `(_,\
    \ _)`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747841
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpnncv2the.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpnncv2the.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\"\
    );\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\"\
    , \"}\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\"\
    );\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpfg9249mn.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 0
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for bracket in brackets.chars() {\n        if bracket\
    \ == '(' {\n            stack.push(bracket);\n        } else if bracket == ')'\
    \ {\n            if stack.len() == 0 {\n                return false;\n      \
    \      }\n            stack.pop();\n        } else {\n            return false;\n\
    \        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747841
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for ch in brackets {\n        if ch == '(' {\n\
    \            stack.push((ch, false));\n        } else if ch == ')' {\n       \
    \     if let Some((_, is_open)) = stack.pop() {\n                if !is_open {\n\
    \                    return false;\n                }\n            } else {\n\
    \                return false;\n            }\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n   --> /tmp/tmp18poefyn.rs:13:15\n\
    \    |\n13  |     for ch in brackets {\n    |               ^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help:\
    \ the trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747841
- exit_code: 0
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for bracket in brackets.chars() {\n        if bracket\
    \ == '(' {\n            stack.push(bracket);\n        } else if bracket == ')'\
    \ {\n            if stack.len() == 0 {\n                return false;\n      \
    \      }\n            stack.pop();\n        } else if stack.len() == 0 {\n   \
    \         return false;\n        }\n    }\n    stack.len() == 0\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747841
- exit_code: 0
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = vec![];\n    for bracket in brackets.chars() {\n        if bracket\
    \ == '(' {\n            stack.push(bracket);\n        } else if bracket == ')'\
    \ {\n            if stack.is_empty() {\n                return false;\n      \
    \      }\n            stack.pop();\n        } else {\n            return false;\n\
    \        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747841
- exit_code: -1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    let mut opening_brackets_stack = Vec::new();\n    let mut closing_brackets_stack\
    \ = Vec::new();\n\n    for bracket in brackets.chars() {\n        match bracket\
    \ {\n            '(' | ')' | '*' | '+' | '?' | '.' | '[' | ']' | '^' | '$' | '|'\
    \ => {\n                opening_brackets.push(bracket);\n            }\n     \
    \       _ => {\n                closing_brackets.push(bracket);\n            }\n\
    \        }\n    }\n\n    while opening_brackets.len() > 0 || closing_brackets.len()\
    \ > 0 {\n        if opening_brackets.len() > 0 {\n            if opening_brackets_stack.len()\
    \ == 0 {\n                opening_brackets_stack.push(opening_brackets.clone());\n\
    \            }\n            opening_brackets = opening_brackets_stack.pop().unwrap();\n\
    \        }\n        if closing_brackets.len() > 0 {\n            if closing_brackets_stack.len()\
    \ == 0 {\n                closing_brackets_stack.push(closing_brackets.clone());\n\
    \            }\n            closing_brackets = closing_brackets_stack.pop().unwrap();\n\
    \        }\n    }\n\n    opening_brackets.len() == closing_brackets.len()\n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659747846
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\"\
    , \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n\
    \    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\"\
    , \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    [\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\"\
    );\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp8iadlwwo.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"(\");\n  \
    \  brackets.replace(\"]\", \")\");\n    brackets.replace(\"{\", \"(\");\n    brackets.replace(\"\
    }\", \")\");\n    brackets.replace(\"(\", \"[\");\n    brackets.replace(\")\"\
    , \"]\");\n    brackets.replace(\"[\", \"{\");\n    brackets.replace(\"]\", \"\
    }\");\n    brackets.replace(\"{\", \"[\");\n    brackets.replace(\"}\", \"]\"\
    );\n    brackets.replace(\"(\", \"{\");\n    brackets.replace(\")\", \"}\");\n\
    \    brackets.replace(\"{\", \"(\");\n    brackets.replace(\"}\", \")\");\n  \
    \  brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"\
    (\", \"[\");\n    brackets.replace(\")\", \"]\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"[\", \"\
    [\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\"\
    , \"}\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n\
    \    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"[\"\
    , \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"{\", \"{\"\
    );\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"[\", \"[\");\n\
    \    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl9ui5u_y.rs:11:44\n   |\n\
    11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747841
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    while brackets.len() > 2 {\n     \
    \   if brackets.starts_with(\"(\") && brackets.ends_with(\")\") {\n          \
    \  brackets = brackets.replace(\"(\", \"\").replace(\")\", \"\");\n        } else\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp1vb12mi9.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747841
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().skip_while(|c| !c.is_ascii_digit()).collect::<String>());\n\
    \    while let Some(last) = stack.pop() {\n        let mut next = Vec::new();\n\
    \        for c in &last {\n            if !c.is_ascii_digit() {\n            \
    \    next.push(c);\n            } else {\n                let mut stack = Vec::new();\n\
    \                stack.push(c);\n                while let Some(last) = stack.pop()\
    \ {\n                    if !last.is_ascii_digit() {\n                       \
    \ next.push(last);\n                    }\n                }\n            }\n\
    \        }\n        if next == last {\n            return false;\n        }\n\
    \        stack.push(next.clone());\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\"\
    )), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpb4l8sdm0.rs:16:18\n\
    \    |\n16  |         for c in &last {\n    |                  ^^^^^ `&String`\
    \ is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by `into_iter`\n\nerror[E0277]:\
    \ can't compare `Vec<_>` with `String`\n  --> /tmp/tmpb4l8sdm0.rs:29:17\n   |\n\
    29 |         if next == last {\n   |                 ^^ no implementation for\
    \ `Vec<_> == String`\n   |\n   = help: the trait `PartialEq<String>` is not implemented\
    \ for `Vec<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb4l8sdm0.rs:32:20\n\
    \   |\n32 |         stack.push(next.clone());\n   |                    ^^^^^^^^^^^^\
    \ expected struct `String`, found struct `Vec`\n   |\n   = note: expected struct\
    \ `String`\n              found struct `Vec<_>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747841
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    for bracket in brackets.chars() {\n        if bracket == '(' {\n        \
    \    open_brackets.push('(');\n        } else if bracket == ')' {\n          \
    \  close_brackets.push(')');\n        } else {\n            open_brackets.push(bracket);\n\
    \            close_brackets.push(bracket);\n        }\n    }\n    open_brackets.chars().all(|c|\
    \ close_brackets.chars().any(|c| c == c))\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpirg9fqzq.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 0
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for bracket in brackets.chars() {\n        if bracket\
    \ == '(' {\n            stack.push(bracket);\n        } else if bracket == ')'\
    \ {\n            if stack.len() == 0 {\n                return false;\n      \
    \      }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ != 0 {\n                return false;\n            }\n        }\n    }\n   \
    \ stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747840
- exit_code: 0
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = vec![];\n    for ch in brackets.chars() {\n        if ch == '('\
    \ {\n            stack.push('(');\n        } else if ch == ')' {\n           \
    \ if stack.is_empty() {\n                return false;\n            }\n      \
    \      stack.pop();\n        } else if ch == '[' {\n            stack.push('[');\n\
    \        } else if ch == ']' {\n            if stack.is_empty() {\n          \
    \      return false;\n            }\n            stack.pop();\n        } else\
    \ if ch == '{' {\n            stack.push('{');\n        } else if ch == '}' {\n\
    \            if stack.is_empty() {\n                return false;\n          \
    \  }\n            stack.pop();\n        }\n    }\n    stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets);\n    while let Some(brackets)\
    \ = stack.pop() {\n        if brackets.chars().any(|c| !c.is_ascii_letter()) {\n\
    \            return false;\n        }\n        if brackets.len() == 1 {\n    \
    \        continue;\n        }\n        let mut current = brackets.chars().nth(1);\n\
    \        if current.is_ascii_letter() {\n            stack.push(brackets.chars().skip(1).take(current.len()\
    \ + 1));\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpkp11snzd.rs:15:40\n   |\n15 |         if brackets.chars().any(|c|\
    \ !c.is_ascii_letter()) {\n   |                                        ^^^^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `is_ascii_letter`\
    \ found for enum `Option` in the current scope\n  --> /tmp/tmpkp11snzd.rs:22:20\n\
    \   |\n22 |         if current.is_ascii_letter() {\n   |                    ^^^^^^^^^^^^^^^\
    \ method not found in `Option<char>`\n\nerror[E0599]: no method named `len` found\
    \ for enum `Option` in the current scope\n  --> /tmp/tmpkp11snzd.rs:23:62\n  \
    \ |\n23 |             stack.push(brackets.chars().skip(1).take(current.len() +\
    \ 1));\n   |                                                              ^^^\
    \ method not found in `Option<char>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpkp11snzd.rs:23:24\n   |\n23 |             stack.push(brackets.chars().skip(1).take(current.len()\
    \ + 1));\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found struct `std::iter::Take`\n   |\n   = note: expected\
    \ struct `String`\n              found struct `std::iter::Take<Skip<Chars<'_>>>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747841
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening_brackets = brackets.chars().filter(|c| c == '(');\n    let mut closing_brackets\
    \ = brackets.chars().filter(|c| c == ')');\n    let mut opening_brackets_iter\
    \ = opening_brackets.clone().collect::<Vec<_>>();\n    let mut closing_brackets_iter\
    \ = closing_brackets.clone().collect::<Vec<_>>();\n    let mut opening_brackets_iter\
    \ = opening_brackets_iter.into_iter();\n    let mut closing_brackets_iter = closing_brackets_iter.into_iter();\n\
    \    let mut opening_brackets_iter = opening_brackets_iter.zip::<_, ()>(&mut closing_brackets_iter);\n\
    \    let mut opening_brackets_iter = opening_brackets_iter.filter(|(_, closing_bracket)|\
    \ {\n        opening_brackets_iter.any(|(_, opening_bracket)| opening_bracket\
    \ == closing_bracket)\n    });\n    opening_brackets_iter.any(|(_, opening_bracket)|\
    \ opening_bracket == '(')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpvqxtu7sg.rs:12:62\n\
    \   |\n12 |     let mut opening_brackets = brackets.chars().filter(|c| c == '(');\n\
    \   |                                                              ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpvqxtu7sg.rs:13:62\n\
    \   |\n13 |     let mut closing_brackets = brackets.chars().filter(|c| c == ')');\n\
    \   |                                                              ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0107]: this associated function takes 1 generic argument\
    \ but 2 generic arguments were supplied\n   --> /tmp/tmpvqxtu7sg.rs:18:59\n  \
    \  |\n18  |     let mut opening_brackets_iter = opening_brackets_iter.zip::<_,\
    \ ()>(&mut closing_brackets_iter);\n    |                                    \
    \                       ^^^      -- help: remove this generic argument\n    |\
    \                                                           |\n    |         \
    \                                                  expected 1 generic argument\n\
    \    |\nnote: associated function defined here, with 1 generic parameter: `U`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpvqxtu7sg.rs:20:77\n   |\n20 |\
    \         opening_brackets_iter.any(|(_, opening_bracket)| opening_bracket ==\
    \ closing_bracket)\n   |                                                     \
    \                        ^^^^^^^^^^^^^^^ expected `char`, found `&char`\n   |\n\
    help: consider dereferencing the borrow\n   |\n20 |         opening_brackets_iter.any(|(_,\
    \ opening_bracket)| opening_bracket == *closing_bracket)\n   |               \
    \                                                              +\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0107, E0277,\
    \ E0308.\nFor more information about an error, try `rustc --explain E0107`.\n"
  stdout: ''
  timestamp: 1659747841
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    while brackets.len() > 0 {\n     \
    \   let mut opening = brackets.chars().next().unwrap();\n        let mut closing\
    \ = brackets.chars().next().unwrap();\n        if opening != closing {\n     \
    \       return false;\n        }\n        brackets = brackets.chars().next().unwrap();\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9n52wj7v.rs:19:20\n   |\n\
    19 |         brackets = brackets.chars().next().unwrap();\n   |              \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                    |\n   |                    expected\
    \ struct `String`, found `char`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \n    for bracket in brackets.chars() {\n        if bracket == '(' {\n       \
    \     open_brackets.push('(');\n        } else if bracket == ')' {\n         \
    \   close_brackets.push(')');\n        } else if bracket == '[' {\n          \
    \  open_brackets.push('[');\n        } else if bracket == ']' {\n            close_brackets.push(']');\n\
    \        } else if bracket == '{' {\n            open_brackets.push('{');\n  \
    \      } else if bracket == '}' {\n            close_brackets.push('}');\n   \
    \     }\n    }\n\n    open_brackets.len() == close_brackets.len()\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp8x_7tv55.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747841
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    let mut opening_brackets = String::new();\n\
    \    let mut closing_brackets = String::new();\n    while brackets.len() > 0 {\n\
    \        let mut opening_bracket = String::new();\n        let mut closing_bracket\
    \ = String::new();\n        if brackets.starts_with(\"(\") {\n            opening_bracket\
    \ = brackets.chars().next().unwrap();\n            brackets = brackets.chars().next().unwrap();\n\
    \        }\n        if brackets.starts_with(\")\") {\n            closing_bracket\
    \ = brackets.chars().next().unwrap();\n            brackets = brackets.chars().next().unwrap();\n\
    \        }\n        if opening_bracket.len() != closing_bracket.len() {\n    \
    \        return false;\n        }\n        opening_brackets += opening_bracket;\n\
    \        closing_brackets += closing_bracket;\n    }\n    opening_brackets ==\
    \ closing_brackets\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxyt64r_4.rs:19:31\n   |\n\
    19 |             opening_bracket = brackets.chars().next().unwrap();\n   |   \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                               |\n\
    \   |                               expected struct `String`, found `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpxyt64r_4.rs:20:24\n   |\n20 |  \
    \           brackets = brackets.chars().next().unwrap();\n   |               \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                        |\n   |                        expected\
    \ struct `String`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxyt64r_4.rs:23:31\n\
    \   |\n23 |             closing_bracket = brackets.chars().next().unwrap();\n\
    \   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                            \
    \   |\n   |                               expected struct `String`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpxyt64r_4.rs:24:24\n   |\n24 |\
    \             brackets = brackets.chars().next().unwrap();\n   |             \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                        |\n   |                        expected\
    \ struct `String`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxyt64r_4.rs:29:29\n\
    \   |\n29 |         opening_brackets += opening_bracket;\n   |               \
    \              ^^^^^^^^^^^^^^^\n   |                             |\n   |     \
    \                        expected `&str`, found struct `String`\n   |        \
    \                     help: consider borrowing here: `&opening_bracket`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxyt64r_4.rs:30:29\n   |\n30 |         closing_brackets\
    \ += closing_bracket;\n   |                             ^^^^^^^^^^^^^^^\n   |\
    \                             |\n   |                             expected `&str`,\
    \ found struct `"
  stdout: ''
  timestamp: 1659747841
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == '(' || c == '[' || c == '{' || c == '<')\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpflbzys1n.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 0
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    for ch in brackets.chars() {\n        if\
    \ ch == '(' {\n            stack.push(0);\n        } else if ch == ')' {\n   \
    \         if stack.len() == 0 {\n                return false;\n            }\n\
    \            stack.pop();\n        } else {\n            if stack.len() == 0 {\n\
    \                return false;\n            }\n            stack.push(stack.len()\
    \ - 1);\n        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747841
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    stack.push(0);\n    while let Some(index)\
    \ = stack.pop() {\n        if brackets.chars().nth(index).unwrap() == '(' {\n\
    \            stack.push(index + 1);\n        } else if brackets.chars().nth(index).unwrap()\
    \ == ')' {\n            stack.pop();\n        } else {\n            return false;\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpakgdjv6k.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747841
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == ')' || c == '(')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpexnsdi2v.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == ')' || c == '(')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpexnsdi2v.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == ')' || c == '(')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpexnsdi2v.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 0
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = vec![];\n    for bracket in brackets.chars() {\n        if bracket\
    \ == '(' {\n            stack.push(bracket);\n        } else if bracket == ')'\
    \ {\n            if stack.is_empty() {\n                return false;\n      \
    \      }\n            stack.pop();\n        } else {\n            return false;\n\
    \        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747841
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut open_brackets = Vec::new();\n    let mut\
    \ close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n  \
    \  let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = \n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpo99sln5g.rs:52:1\n\
    \   |\n52 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659747841
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    let mut opening_brackets = String::new();\n\
    \    let mut closing_brackets = String::new();\n    while brackets.len() > 0 {\n\
    \        let mut opening_bracket = String::new();\n        let mut closing_bracket\
    \ = String::new();\n        let mut opening_brackets = String::new();\n      \
    \  let mut closing_brackets = String::new();\n        while brackets.len() > 0\
    \ {\n            if brackets.starts_with(\"(\") {\n                opening_bracket.push(brackets.chars().next().unwrap());\n\
    \                opening_brackets.push(opening_bracket);\n                brackets\
    \ = brackets.chars().next().unwrap();\n            } else if brackets.starts_with(\"\
    )\") {\n                closing_bracket.push(brackets.chars().next().unwrap());\n\
    \                closing_brackets.push(closing_bracket);\n                brackets\
    \ = brackets.chars().next().unwrap();\n            } else {\n                brackets\
    \ = brackets.chars().next().unwrap();\n            }\n        }\n        if opening_brackets.len()\
    \ != closing_brackets.len() {\n            return false;\n        }\n        for\
    \ opening_bracket in opening_brackets.iter() {\n            if !closing_brackets.contains(&opening_bracket)\
    \ {\n                return false;\n            }\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4ykh3p3u.rs:23:39\n   |\n\
    23 |                 opening_brackets.push(opening_bracket);\n   |           \
    \                            ^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp4ykh3p3u.rs:24:28\n   |\n24 |\
    \                 brackets = brackets.chars().next().unwrap();\n   |         \
    \                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                            |\n   |            \
    \                expected struct `String`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4ykh3p3u.rs:27:39\n   |\n27 |                 closing_brackets.push(closing_bracket);\n\
    \   |                                       ^^^^^^^^^^^^^^^ expected `char`, found\
    \ struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4ykh3p3u.rs:28:28\n\
    \   |\n28 |                 brackets = brackets.chars().next().unwrap();\n   |\
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                            |\n   |\
    \                            expected struct `String`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4ykh3p3u.rs:30:28\n   |\n30 |              \
    \   brackets = brackets.chars().next().unwrap();\n   |                       \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                            |\n   |                            expected struct\
    \ `String`, found `char`\n\nerror[E0599]: no method named `iter` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmp4ykh3p3u.rs:36:49\n   |\n36 | \
    \        for opening_bracket in opening_brackets.iter() {\n   |              \
    \                                   ^^^^ method not found in `String`\n\nerror:\
    \ aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747841
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut opening_brackets = Vec::new();\n    let\
    \ mut closing_brackets = Vec::new();\n    let mut opening_bracket = String::new();\n\
    \    let mut closing_bracket = String::new();\n    let mut opening_closing_bracket\
    \ = String::new();\n    let mut opening_closing_brackets = Vec::new();\n    let\
    \ mut opening_closing_bracket = String::new();\n    let mut opening_closing_brackets\
    \ = Vec::new();\n    let mut opening_closing_bracket = String::new();\n    let\
    \ mut opening_closing_brackets = Vec::new();\n    let mut opening_closing_bracket\
    \ = String::new();\n    let mut opening_closing_brackets = Vec::new();\n    let\
    \ mut opening_closing_bracket = String::new();\n    let mut opening_closing_brackets\
    \ = Vec::new();\n    let mut opening_closing_bracket = String::new();\n    let\
    \ mut opening_closing_brackets = Vec::new();\n    let mut opening_closing_bracket\
    \ = String::new();\n    let mut opening_closing_brackets = Vec::new();\n    let\
    \ mut opening_closing_bracket = String::new();\n    let mut opening_closing_brackets\
    \ = Vec::new();\n    let mut opening_closing_bracket = String::new();\n    let\
    \ mut opening_closing_brackets = Vec::new();\n    let mut opening_closing_bracket\
    \ = String::new();\n    let mut opening_closing_brackets = Vec::new();\n    let\
    \ mut opening_closing_bracket = String::new();\n    let mut opening_closing_brackets\
    \ = Vec::new();\n    let mut opening_closing_bracket = String::new();\n    let\
    \ mut opening_closing_brackets = Vec::new();\n    let mut opening_closing_bracket\
    \ = String::new();\n    let mut opening_closing_brackets = Vec::new();\n    let\
    \ mut opening_closing_bracket = String::new();\n    let mut opening_closing_brackets\
    \ = Vec::new();\n    let mut opening_closing_bracket = String::new();\n    let\
    \ mut opening_closing_brackets = Vec::new\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpqj7br16b.rs:46:48\n   |\n\
    46 |     let mut opening_closing_brackets = Vec::new\n   |                   \
    \                             ^ help: add `;` here\n47 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqj7br16b.rs:11:44\n \
    \  |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747841
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().skip_while(|c| c !=\
    \ '(').collect::<String>());\n    while let Some(last) = stack.pop() {\n     \
    \   if let Some(next) = stack.pop() {\n            if last != next {\n       \
    \         return false;\n            }\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpzzlxblar.rs:13:50\n\
    \   |\n13 |     stack.push(brackets.chars().skip_while(|c| c != '(').collect::<String>());\n\
    \   |                                                  ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747841
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    while brackets.len() > 0 {\n\
    \        let mut open_bracket = String::new();\n        let mut close_bracket\
    \ = String::new();\n        let mut open_brackets = String::new();\n        let\
    \ mut close_brackets = String::new();\n        while brackets.len() > 0 {\n  \
    \          if brackets.starts_with(\"(\") {\n                open_brackets.push(brackets.clone());\n\
    \                brackets = brackets.clone();\n            } else if brackets.starts_with(\"\
    )\") {\n                close_brackets.push(brackets.clone());\n             \
    \   brackets = brackets.clone();\n            } else {\n                open_bracket\
    \ = open_bracket.clone();\n                close_bracket = close_bracket.clone();\n\
    \                open_brackets = open_brackets.clone();\n                close_brackets\
    \ = close_brackets.clone();\n            }\n        }\n        if open_brackets.len()\
    \ != close_brackets.len() {\n            return false;\n        }\n        for\
    \ open_bracket in open_brackets.chars() {\n            if !close_brackets.contains(&open_bracket)\
    \ {\n                return false;\n            }\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjuuda1k5.rs:22:36\n   |\n\
    22 |                 open_brackets.push(brackets.clone());\n   |             \
    \                       ^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpjuuda1k5.rs:25:37\n   |\n25 |\
    \                 close_brackets.push(brackets.clone());\n   |               \
    \                      ^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \nerror[E0277]: expected a `Fn<(char,)>` closure, found `char`\n  --> /tmp/tmpjuuda1k5.rs:38:41\n\
    \   |\n38 |             if !close_brackets.contains(&open_bracket) {\n   |   \
    \                                      ^^^^^^^^^^^^^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n   |\n   = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n   = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n   = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&char`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747841
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    let mut opening_brackets = String::new();\n\
    \    let mut closing_brackets = String::new();\n    while brackets.len() > 0 {\n\
    \        let mut opening_bracket = String::new();\n        let mut closing_bracket\
    \ = String::new();\n        if brackets.starts_with(\"(\") {\n            opening_bracket\
    \ = brackets.chars().next().unwrap();\n            brackets = brackets.chars().next().unwrap();\n\
    \        }\n        if brackets.starts_with(\")\") {\n            closing_bracket\
    \ = brackets.chars().next().unwrap();\n            brackets = brackets.chars().next().unwrap();\n\
    \        }\n        if opening_bracket.len() != closing_bracket.len() {\n    \
    \        return false;\n        }\n        opening_brackets += opening_bracket;\n\
    \        closing_brackets += closing_bracket;\n    }\n    opening_brackets ==\
    \ closing_brackets\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxyt64r_4.rs:19:31\n   |\n\
    19 |             opening_bracket = brackets.chars().next().unwrap();\n   |   \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                               |\n\
    \   |                               expected struct `String`, found `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpxyt64r_4.rs:20:24\n   |\n20 |  \
    \           brackets = brackets.chars().next().unwrap();\n   |               \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                        |\n   |                        expected\
    \ struct `String`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxyt64r_4.rs:23:31\n\
    \   |\n23 |             closing_bracket = brackets.chars().next().unwrap();\n\
    \   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                            \
    \   |\n   |                               expected struct `String`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpxyt64r_4.rs:24:24\n   |\n24 |\
    \             brackets = brackets.chars().next().unwrap();\n   |             \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                        |\n   |                        expected\
    \ struct `String`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxyt64r_4.rs:29:29\n\
    \   |\n29 |         opening_brackets += opening_bracket;\n   |               \
    \              ^^^^^^^^^^^^^^^\n   |                             |\n   |     \
    \                        expected `&str`, found struct `String`\n   |        \
    \                     help: consider borrowing here: `&opening_bracket`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxyt64r_4.rs:30:29\n   |\n30 |         closing_brackets\
    \ += closing_bracket;\n   |                             ^^^^^^^^^^^^^^^\n   |\
    \                             |\n   |                             expected `&str`,\
    \ found struct `"
  stdout: ''
  timestamp: 1659747841
- exit_code: 0
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    for c in brackets.chars() {\n        if\
    \ c == '(' {\n            stack.push(brackets.len());\n        } else if c ==\
    \ ')' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.pop();\n\
    \        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747841
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening_brackets = brackets.chars().filter(|c| c == '(').collect::<Vec<_>>();\n\
    \    let mut closing_brackets = brackets.chars().filter(|c| c == ')').collect::<Vec<_>>();\n\
    \    let mut opening_brackets_iter = opening_brackets.iter();\n    let mut closing_brackets_iter\
    \ = closing_brackets.iter();\n    let mut opening_brackets_next = opening_brackets_iter.next();\n\
    \    let mut closing_brackets_next = closing_brackets_iter.next();\n    while\
    \ opening_brackets_next != None && closing_brackets_next != None {\n        if\
    \ opening_brackets_next.unwrap() != closing_brackets_next.unwrap() {\n       \
    \     return false;\n        }\n        opening_brackets_next = opening_brackets_iter.next();\n\
    \        closing_brackets_next = closing_brackets_iter.next();\n    }\n    opening_brackets_next\
    \ == None && closing_brackets_next == None\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpan8ecxz5.rs:12:62\n\
    \   |\n12 |     let mut opening_brackets = brackets.chars().filter(|c| c == '(').collect::<Vec<_>>();\n\
    \   |                                                              ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpan8ecxz5.rs:13:62\n\
    \   |\n13 |     let mut closing_brackets = brackets.chars().filter(|c| c == ')').collect::<Vec<_>>();\n\
    \   |                                                              ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747841
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets);\n    while let Some(brackets)\
    \ = stack.pop() {\n        if brackets.chars().any(|c| !c.is_ascii_letter()) {\n\
    \            return false;\n        }\n        if brackets.len() != 1 {\n    \
    \        return false;\n        }\n        let mut bracket = brackets[0];\n  \
    \      if bracket != '(' && bracket != ')' {\n            return false;\n    \
    \    }\n        if let Some(open) = stack.pop() {\n            if open != bracket\
    \ {\n                return false;\n            }\n        }\n        if let Some(close)\
    \ = stack.pop() {\n            if close != bracket {\n                return false;\n\
    \            }\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for type `char` in\
    \ the current scope\n  --> /tmp/tmp0636v0vn.rs:15:40\n   |\n15 |         if brackets.chars().any(|c|\
    \ !c.is_ascii_letter()) {\n   |                                        ^^^^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `{integer}`\n  --> /tmp/tmp0636v0vn.rs:21:27\n   |\n21 |         let mut\
    \ bracket = brackets[0];\n   |                           ^^^^^^^^^^^ `String`\
    \ cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747841
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == '(' || c == '[' || c == '{' || c == '<')\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpflbzys1n.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ {\n        c != '(' && c != ')'\n    })\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpd86gsals.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    let mut open_brackets: Vec<usize> = vec![];\n\
    \    let mut close_brackets: Vec<usize> = vec![];\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_bra\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmphcojp3gf.rs:50:22\n   |\n\
    50 |     let mut close_bra\n   |                      ^ help: add `;` here\n51\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphcojp3gf.rs:11:44\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747841
- exit_code: 0
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for ch in brackets.chars() {\n        if ch ==\
    \ '(' {\n            stack.push(ch);\n        } else if ch == ')' {\n        \
    \    if stack.len() == 0 {\n                return false;\n            }\n   \
    \         stack.pop();\n        } else {\n            return false;\n        }\n\
    \    }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747841
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    for bracket in brackets.chars() {\n        if bracket == '(' {\n        \
    \    open_brackets.push('(');\n        } else if bracket == ')' {\n          \
    \  close_brackets.push(')');\n        } else {\n            open_brackets.push(bracket);\n\
    \            close_brackets.push(bracket);\n        }\n    }\n    open_brackets.chars().all(|c|\
    \ close_brackets.chars().any(|c| c == c))\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpirg9fqzq.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack_ptr = &mut open_brackets_stack;\n\
    \    let mut close_brackets_stack_ptr = &mut close_brackets_stack;\n    let mut\
    \ open_brackets_ptr = &mut open_brackets;\n    let mut close_brackets_ptr = &mut\
    \ close_brackets;\n    let mut open_brackets_ptr = &mut open_brackets;\n    let\
    \ mut close_brackets_ptr = &mut close_brackets;\n    let mut open_brackets_ptr\
    \ = &mut open_brackets;\n    let mut close_brackets_ptr = &mut close_brackets;\n\
    \    let mut open_brackets_ptr = &mut open_brackets;\n    let mut close_brackets_ptr\
    \ = &mut close_brackets;\n    let mut open_brackets_ptr = &mut open_brackets;\n\
    \    let mut close_brackets_ptr = &mut close_brackets;\n    let mut open_brackets_ptr\
    \ = &mut open_brackets;\n    let mut close_brackets_ptr = &mut close_brackets;\n\
    \    let mut open_brackets_ptr = &mut open_brackets;\n    let mut close_brackets_ptr\
    \ = &mut close_brackets;\n    let mut open_brackets_ptr = &mut open_brackets;\n\
    \    let mut close_brackets_ptr = &mut close_brackets;\n    let mut open_brackets_ptr\
    \ = &mut open_brackets;\n    let mut close_brackets_ptr = &mut close_brackets;\n\
    \    let mut open_brackets_ptr = &mut open_brackets;\n    let mut close_brackets_ptr\
    \ = &mut close_brackets;\n    let mut open_brackets_ptr = &mut open_brackets;\n\
    \    let mut close_brackets_ptr = &mut \n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpw4bhbluh.rs:40:1\n\
    \   |\n40 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659747841
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().skip_while(|c| !c.is_ascii_letter()).collect::<Vec<_>>());\n\
    \    while let Some(last) = stack.pop() {\n        if let Some(first) = stack.pop()\
    \ {\n            if first != last {\n                return false;\n         \
    \   }\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmp1r15asqo.rs:13:51\n   |\n13 |     stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).collect::<Vec<_>>());\n   |                          \
    \                         ^^^^^^^^^^^^^^^ method not found in `&char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659747841
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets);\n    while let Some(brackets)\
    \ = stack.pop() {\n        if brackets.len() == 1 {\n            return brackets.chars().all(|c|\
    \ c == '(') || brackets.chars().all(|c| c == ')');\n        }\n        if brackets.len()\
    \ == 2 {\n            if brackets.chars().all(|c| c == '(') {\n              \
    \  stack.push(brackets.replace(\"(\", \"(\"));\n            } else if brackets.chars().all(|c|\
    \ c == ')') {\n                stack.push(brackets.replace(\")\", \")\"));\n \
    \           }\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6nmk50fi.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747841
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    let mut opening_brackets_stack = Vec::new();\n    let mut closing_brackets_stack\
    \ = Vec::new();\n    let mut opening_brackets_stack_size = opening_brackets_stack.len();\n\
    \    let mut closing_brackets_stack_size = closing_brackets_stack.len();\n\n \
    \   for bracket in brackets.chars() {\n        if bracket == '(' {\n         \
    \   opening_brackets.push(bracket);\n            opening_brackets_stack.push(bracket);\n\
    \            opening_brackets_stack_size.push(bracket);\n        } else if bracket\
    \ == ')' {\n            if opening_brackets_stack_size.len() == 0 {\n        \
    \        return false;\n            }\n            opening_brackets_stack_size.pop();\n\
    \            opening_brackets_stack.pop();\n            opening_brackets_stack_size.push(opening_brackets_stack_size.last().unwrap());\n\
    \        } else if bracket == '[' {\n            closing_brackets.push(bracket);\n\
    \            closing_brackets_stack.push(bracket);\n            closing_brackets_stack_size.push(bracket);\n\
    \        } else if bracket == ']' {\n            if closing_brackets_stack_size.len()\
    \ == 0 {\n                return false;\n            }\n            closing_brackets_stack_size.pop();\n\
    \            closing_brackets_stack.pop();\n            closing_brackets_stack_size.push(closing_brackets_stack_size.last().unwrap());\n\
    \        } else if bracket == '{' {\n            closing_brackets.push(bracket);\n\
    \            closing_brackets_stack.push(bracket);\n            closing_brackets_stack_size.push(bracket);\n\
    \        } else if bracket == '}' {\n            if closing_brackets_stack_size.len()\
    \ == 0 {\n                return false;\n            }\n            closing_brackets_stack_size.pop();\n\
    \            closing_brackets_stack.pop();\n            closing_brackets_stack_size.push(closing_brackets_stack_size.last().unwrap());\n\
    \        }\n    }\n\n    if opening_brackets_stack_size.len() != closing_brackets_stack_size.len()\
    \ {\n        return false;\n    }\n\n    for opening_bracket in opening_bra\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n  --> /tmp/tmpvwi704vz.rs:61:1\n   |\n\
    61 | }\n   | ^ expected `{`\n\nerror[E0599]: no method named `push` found for\
    \ type `usize` in the current scope\n  --> /tmp/tmpvwi704vz.rs:23:41\n   |\n23\
    \ |             opening_brackets_stack_size.push(bracket);\n   |             \
    \                            ^^^^ method not found in `usize`\n\nerror[E0599]:\
    \ no method named `len` found for type `usize` in the current scope\n  --> /tmp/tmpvwi704vz.rs:25:44\n\
    \   |\n25 |             if opening_brackets_stack_size.len() == 0 {\n   |    \
    \                                        ^^^ method not found in `usize`\n\nerror[E0599]:\
    \ no method named `pop` found for type `usize` in the current scope\n  --> /tmp/tmpvwi704vz.rs:28:41\n\
    \   |\n28 |             opening_brackets_stack_size.pop();\n   |             \
    \                            ^^^ help: there is an associated function with a\
    \ similar name: `pow`\n\nerror[E0599]: no method named `push` found for type `usize`\
    \ in the current scope\n  --> /tmp/tmpvwi704vz.rs:30:41\n   |\n30 |          \
    \   opening_brackets_stack_size.push(opening_brackets_stack_size.last().unwrap());\n\
    \   |                                         ^^^^ method not found in `usize`\n\
    \nerror[E0599]: the method `last` exists for type `usize`, but its trait bounds\
    \ were not satisfied\n  --> /tmp/tmpvwi704vz.rs:30:74\n   |\n30 |            \
    \ opening_brackets_stack_size.push(opening_brackets_stack_size.last().unwrap());\n\
    \   |                                                                        \
    \  ^^^^ method cannot be called on `usize` due to unsatisfied trait bounds\n \
    \  |\n   = note: the following trait bounds were not satisfied:\n           `usize:\
    \ Iterator`\n           which is required by `&mut usize: Iterator`\n\nerror[E0599]:\
    \ no method named `push` found for type `usize` in the current scope\n  --> /tmp/tmpvwi704vz.rs:34:41\n\
    \   |\n34 |             closing_brackets_stack_size.push(bracket);\n   |     \
    \                                    ^^^^ method not found in `usize`\n\nerror[E0599]:\
    \ no method named `len` found for type `usize` in the current s"
  stdout: ''
  timestamp: 1659747841
- exit_code: 0
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    for bracket in brackets.chars() {\n   \
    \     if bracket == '(' {\n            stack.push(0);\n        } else if bracket\
    \ == ')' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.push(stack.len()\
    \ - 1);\n        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747841
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_iter = brackets.chars().enumerate();\n    let mut close_brackets_iter\
    \ = brackets.chars().enumerate();\n    let mut open_brackets_next = open_brackets_iter.next();\n\
    \    let mut close_brackets_next = close_brackets_iter.next();\n    while open_brackets_next.is_some()\
    \ && close_brackets_next.is_some() {\n        let (open_char, open_char_pos) =\
    \ open_brackets_next.unwrap();\n        let (close_char, close_char_pos) = close_brackets_next.unwrap();\n\
    \        if open_char == close_char {\n            open_brackets.push_str(&open_char.to_string());\n\
    \            open_brackets_next = open_brackets_iter.next();\n            close_brackets_next\
    \ = close_brackets_iter.next();\n        } else {\n            if open_brackets.len()\
    \ > 0 {\n                open_brackets.push_str(\")\");\n            }\n     \
    \       if close_brackets.len() > 0 {\n                close_brackets.push_str(\"\
    (\");\n            }\n            open_brackets.push_str(&open_char.to_string());\n\
    \            close_brackets.push_str(&close_char.to_string());\n            open_brackets_next\
    \ = open_brackets_iter.next();\n            close_brackets_next = close_brackets_iter.next();\n\
    \        }\n    }\n    open_brackets.len() == close_brackets.len()\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpgyqd3dxx.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747841
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack\
    \ = Vec::new();\n    for bracket in brackets.chars() {\n        if bracket ==\
    \ '(' {\n            open_brackets.push(bracket);\n            open_brackets_stack.push(bracket);\n\
    \        } else if bracket == ')' {\n            if open_brackets_stack.len()\
    \ == 0 {\n                return false;\n            }\n            close_brackets.push(bracket);\n\
    \            close_brackets_stack.push(bracket);\n            open_brackets_stack.pop();\n\
    \        } else if bracket == '[' {\n            if open_brackets_stack.len()\
    \ == 0 {\n                return false;\n            }\n            open_brackets.push(bracket);\n\
    \        } else if bracket == ']' {\n            if close_brackets_stack.len()\
    \ == 0 {\n                return false;\n            }\n            close_brackets.push(bracket);\n\
    \            close_brackets_stack.pop();\n        }\n    }\n    if open_brackets_stack.len()\
    \ != close_brackets_stack.len() {\n        return false;\n    }\n    for open_bracket\
    \ in open_brackets_stack {\n        if close_brackets_stack.contains(&open_bracket)\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpdytts3x7.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747841
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"(\");\n  \
    \  brackets.replace(\"]\", \")\");\n    brackets.replace(\"{\", \"(\");\n    brackets.replace(\"\
    }\", \")\");\n    brackets.replace(\"(\", \"[\");\n    brackets.replace(\")\"\
    , \"]\");\n    brackets.replace(\"[\", \"{\");\n    brackets.replace(\"]\", \"\
    }\");\n    brackets.replace(\"{\", \"[\");\n    brackets.replace(\"}\", \"]\"\
    );\n    brackets.replace(\"(\", \"{\");\n    brackets.replace(\")\", \"}\");\n\
    \    brackets.replace(\"{\", \"(\");\n    brackets.replace(\"}\", \")\");\n  \
    \  brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\"\
    , \"[\");\n    brackets.replace(\")\", \"]\");\n    brackets.replace(\"[\", \"\
    {\");\n    brackets.replace(\"]\", \"}\");\n    brackets.replace(\"{\", \"(\"\
    );\n    brackets.replace(\"}\", \")\");\n    brackets.replace(\"(\", \"{\");\n\
    \    brackets.replace(\")\", \"}\");\n    brackets.replace(\"{\", \"(\");\n  \
    \  brackets.replace(\"}\", \")\");\n    brackets.replace(\"[\", \"{\");\n    brackets.replace(\"\
    ]\", \"}\");\n    brackets.replace(\"{\", \"(\");\n    brackets.replace(\"}\"\
    , \")\");\n    brackets.replace(\"(\", \"[\");\n    brackets.replace(\")\", \"\
    ]\");\n    brackets.replace(\"[\", \"{\");\n    brackets.replace(\"]\", \"}\"\
    );\n    brackets.replace(\"{\", \"(\");\n    brackets.replace(\"}\", \")\");\n\
    \    brackets.replace(\"(\", \"{\");\n    brackets.replace(\")\", \"}\");\n  \
    \  brackets.replace(\"{\", \"(\");\n    brackets.replace(\"}\", \")\");\n    brackets.replace(\"\
    [\", \"{\");\n    brackets.replace(\"]\", \"}\");\n    brackets.replace(\"{\"\
    , \"(\");\n    brackets.replace(\"}\", \")\");\n    brackets.replace(\"(\", \"\
    [\");\n    brackets.replace(\")\", \"]\");\n    brackets.replace(\"[\", \"{\"\
    );\n    brackets.replace(\"]\", \"}\");\n    brackets.replace(\"{\", \"(\");\n\
    \    brackets.replace(\"}\", \")\");\n    brackets.replace(\"(\", \"{\");\n  \
    \  brackets.replace(\")\", \"}\");\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk94c4_f1.rs:11:44\n   |\n\
    11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747841
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut open_brackets = Vec::new();\n    let mut\
    \ close_brackets = Vec::new();\n    let mut open_brackets_count = Vec::new();\n\
    \    let mut close_brackets_count = Vec::new();\n    let mut open_brackets_count_max\
    \ = Vec::new();\n    let mut close_brackets_count_max = Vec::new();\n    let mut\
    \ open_brackets_count_min = Vec::new();\n    let mut close_brackets_count_min\
    \ = Vec::new();\n    let mut open_brackets_count_min = Vec::new();\n    let mut\
    \ open_brackets_count_max = Vec::new();\n    let mut close_brackets_count_max\
    \ = Vec::new();\n    let mut open_brackets_count_min = Vec::new();\n    let mut\
    \ close_brackets_count_min = Vec::new();\n    let mut open_brackets_count_max\
    \ = Vec::new();\n    let mut close_brackets_count_max = Vec::new();\n    let mut\
    \ open_brackets_count_min = Vec::new();\n    let mut close_brackets_count_min\
    \ = Vec::new();\n    let mut open_brackets_count_max = Vec::new();\n    let mut\
    \ close_brackets_count_max = Vec::new();\n    let mut open_brackets_count_min\
    \ = Vec::new();\n    let mut close_brackets_count_min = Vec::new();\n    let mut\
    \ open_brackets_count_max = Vec::new();\n    let mut close_brackets_count_max\
    \ = Vec::new();\n    let mut open_brackets_count_min = Vec::new();\n    let mut\
    \ close_brackets_count_min = Vec::new();\n    let mut open_brackets_count_max\
    \ = Vec::new();\n    let mut close_brackets_count_max = Vec::new();\n    let mut\
    \ open_brackets_count_min = Vec::new();\n    let mut close_brackets_count_min\
    \ = Vec::new();\n    let mut open_brackets_count_max = Vec::new();\n    let mut\
    \ close_brackets_count_max = Vec::new();\n    let mut open_brackets_count_min\
    \ = Vec::new();\n    let mut close_brackets_count_min = Vec::new();\n    let mut\
    \ open_brackets_count_max = Vec::new\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpi3o3_hk2.rs:46:47\n   |\n\
    46 |     let mut open_brackets_count_max = Vec::new\n   |                    \
    \                           ^ help: add `;` here\n47 | }\n   | - unexpected token\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpi3o3_hk2.rs:11:44\n   |\n11 |\
    \ fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747841
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for ch in brackets {\n        if ch == '(' {\n\
    \            stack.push((ch, false));\n        } else if ch == ')' {\n       \
    \     if let Some((_, is_open)) = stack.pop() {\n                if is_open {\n\
    \                    return false;\n                }\n            } else {\n\
    \                return false;\n            }\n        } else {\n            return\
    \ false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n   --> /tmp/tmp5_7l7dbn.rs:13:15\n\
    \    |\n13  |     for ch in brackets {\n    |               ^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help:\
    \ the trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747841
- exit_code: 0
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = vec![];\n    for bracket in brackets.chars() {\n        if bracket\
    \ == '(' {\n            stack.push(bracket);\n        } else if bracket == ')'\
    \ {\n            if stack.len() == 0 {\n                return false;\n      \
    \      }\n            stack.pop();\n        } else if bracket == '[' {\n     \
    \       stack.push(bracket);\n        } else if bracket == ']' {\n           \
    \ if stack.len() == 0 {\n                return false;\n            }\n      \
    \      stack.pop();\n        } else if bracket == '{' {\n            stack.push(bracket);\n\
    \        } else if bracket == '}' {\n            if stack.len() == 0 {\n     \
    \           return false;\n            }\n            stack.pop();\n        }\n\
    \    }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747841
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().enumerate().filter(|(_,\
    \ c)| c == '(').collect::<Vec<_>>());\n    while stack.len() > 0 {\n        let\
    \ mut last = stack.last().unwrap();\n        if last.1 == ')' {\n            stack.pop();\n\
    \        } else {\n            stack.push(brackets.chars().enumerate().filter(|(_,\
    \ c)| c == last.1).collect::<Vec<_>>());\n        }\n    }\n    stack.len() ==\
    \ 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp47wsmk2g.rs:13:63\n\
    \   |\n13 |     stack.push(brackets.chars().enumerate().filter(|(_, c)| c == '(').collect::<Vec<_>>());\n\
    \   |                                                               ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0609]: no field `1` on type `&Vec<(usize, char)>`\n  -->\
    \ /tmp/tmp47wsmk2g.rs:16:17\n   |\n16 |         if last.1 == ')' {\n   |     \
    \            ^ unknown field\n\nerror[E0609]: no field `1` on type `&Vec<(usize,\
    \ char)>`\n  --> /tmp/tmp47wsmk2g.rs:19:79\n   |\n19 |             stack.push(brackets.chars().enumerate().filter(|(_,\
    \ c)| c == last.1).collect::<Vec<_>>());\n   |                               \
    \                                                ^ unknown field\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0609.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747841
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets == brackets\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpcj2c4sic.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\"\
    , \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n\
    \    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\"\
    , \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    [\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\"\
    );\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp8iadlwwo.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
- exit_code: 0
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for bracket in brackets.chars() {\n        if bracket\
    \ == '(' {\n            stack.push(bracket);\n        } else if bracket == ')'\
    \ {\n            if stack.len() == 0 {\n                return false;\n      \
    \      }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ != 0 {\n                return false;\n            }\n        }\n    }\n   \
    \ stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_iter = brackets.char_indices();\n    let mut close_brackets_iter\
    \ = brackets.char_indices();\n    let mut open_brackets_next = open_brackets_iter.next();\n\
    \    let mut close_brackets_next = close_brackets_iter.next();\n    while open_brackets_next\
    \ != None && close_brackets_next != None {\n        if open_brackets_next.index\
    \ == close_brackets_next.index {\n            open_brackets += open_brackets_next.to_string();\n\
    \            close_brackets += close_brackets_next.to_string();\n            open_brackets_next\
    \ = open_brackets_iter.next();\n            close_brackets_next = close_brackets_iter.next();\n\
    \        } else {\n            if open_brackets_next.index > close_brackets_next.index\
    \ {\n                open_brackets += open_brackets_next.to_string();\n      \
    \          open_brackets_next = open_brackets_iter.next();\n            } else\
    \ {\n                close_brackets += close_brackets_next.to_string();\n    \
    \            close_brackets_next = close_brackets_iter.next();\n            }\n\
    \        }\n    }\n    open_brackets == close_brackets\n}\n\nfn main() {\n   \
    \ let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `index` on type `Option<(usize, char)>`\n  --> /tmp/tmpcld6vn41.rs:19:31\n\
    \   |\n19 |         if open_brackets_next.index == close_brackets_next.index {\n\
    \   |                               ^^^^^\n\nerror[E0609]: no field `index` on\
    \ type `Option<(usize, char)>`\n  --> /tmp/tmpcld6vn41.rs:19:60\n   |\n19 |  \
    \       if open_brackets_next.index == close_brackets_next.index {\n   |     \
    \                                                       ^^^^^\n\nerror[E0599]:\
    \ the method `to_string` exists for enum `Option<(usize, char)>`, but its trait\
    \ bounds were not satisfied\n   --> /tmp/tmpcld6vn41.rs:20:49\n    |\n20  |  \
    \             open_brackets += open_brackets_next.to_string();\n    |        \
    \                                           ^^^^^^^^^ method cannot be called\
    \ on `Option<(usize, char)>` due to unsatisfied trait bounds\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `Option<(usize,\
    \ char)>: std::fmt::Display`\n            which is required by `Option<(usize,\
    \ char)>: ToString`\n\nerror[E0599]: the method `to_string` exists for enum `Option<(usize,\
    \ char)>`, but its trait bounds were not satisfied\n   --> /tmp/tmpcld6vn41.rs:21:51\n\
    \    |\n21  |               close_brackets += close_brackets_next.to_string();\n\
    \    |                                                     ^^^^^^^^^ method cannot\
    \ be called on `Option<(usize, char)>` due to unsatisfied trait bounds\n    |\n\
    \    = note: the following trait bounds were not satisfied:\n            `Option<(usize,\
    \ char)>: std::fmt::Display`\n            which is required by `Option<(usize,\
    \ char)>: ToString`\n\nerror[E0609]: no field `index` on type `Option<(usize,\
    \ char)>`\n  --> /tmp/tmpcld6vn41.rs:25:35\n   |\n25 |             if open_brackets_next.index\
    \ > close_brackets_next.index {\n   |                                   ^^^^^\n\
    \nerror[E0609]: no field `index` on type `Option<(usize, char)>`\n  --> /tmp/tmpcld6vn41.rs:25:63\n\
    \   |\n25 |             if open_brackets_next.index > close_brackets_next.index\
    \ {\n   |                                                             "
  stdout: ''
  timestamp: 1659747841
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpnncv2the.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    for bracket in brackets {\n        if bracket == '(' {\n            open_brackets.push('(');\n\
    \        } else if bracket == ')' {\n            close_brackets.push(')');\n \
    \       } else {\n            open_brackets.push(bracket);\n            close_brackets.push(bracket);\n\
    \        }\n    }\n    open_brackets == close_brackets\n}\n\nfn main() {\n   \
    \ let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n   --> /tmp/tmp_8udo5y3.rs:14:20\n\
    \    |\n14  |     for bracket in brackets {\n    |                    ^^^^^^^^\
    \ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n \
    \   = help: the trait `Iterator` is not implemented for `String`\n    = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `String`\n\
    note: required by `into_iter`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659747840
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    let mut open_brackets: Vec<usize> = vec![];\n\
    \    let mut close_brackets: Vec<usize> = vec![];\n    let mut open_brackets_idx:\
    \ usize = 0;\n    let mut close_brackets_idx: usize = 0;\n    let mut open_brackets_len:\
    \ usize = 0;\n    let mut close_brackets_len: usize = 0;\n    let mut open_brackets_idx2:\
    \ usize = 0;\n    let mut close_brackets_idx2: usize = 0;\n    let mut open_brackets_len2:\
    \ usize = 0;\n    let mut close_brackets_len2: usize = 0;\n    let mut open_brackets_idx3:\
    \ usize = 0;\n    let mut close_brackets_idx3: usize = 0;\n    let mut open_brackets_len3:\
    \ usize = 0;\n    let mut close_brackets_len3: usize = 0;\n    let mut open_brackets_idx4:\
    \ usize = 0;\n    let mut close_brackets_idx4: usize = 0;\n    let mut open_brackets_len4:\
    \ usize = 0;\n    let mut close_brackets_len4: usize = 0;\n    let mut open_brackets_idx5:\
    \ usize = 0;\n    let mut close_brackets_idx5: usize = 0;\n    let mut open_brackets_len5:\
    \ usize = 0;\n    let mut close_brackets_len5: usize = 0;\n    let mut open_brackets_idx6:\
    \ usize = 0;\n    let mut close_brackets_idx6: usize = 0;\n    let mut open_brackets_len6:\
    \ usize = 0;\n    let mut close_brackets_len6: usize = 0;\n    let mut open_brackets_idx7:\
    \ usize = 0;\n    let mut close_brackets_idx7: usize = 0;\n    let mut open_brackets_len7:\
    \ usize = 0;\n    let mut close_brackets_len7: usize = 0;\n    let mut open_brackets_idx8:\
    \ usize = 0;\n    let mut close_brackets_idx8: usize = 0;\n    let mut open_brackets_len8:\
    \ usize = 0;\n    let mut close_brackets_len8: usize = 0;\n    let \n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp49lqxr1_.rs:48:1\n  \
    \ |\n48 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659747841
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"(\");\n  \
    \  brackets.replace(\"]\", \")\");\n    brackets.replace(\"{\", \"(\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"[\");\n    brackets.replace(\")\"\
    , \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"[\", \"{\");\n    brackets.replace(\"]\", \"}\"\
    );\n    brackets.replace(\"(\", \"{\");\n    brackets.replace(\")\", \"}\");\n\
    \    brackets.replace(\"{\", \"[\");\n    brackets.replace(\"}\", \"]\");\n  \
    \  brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"\
    (\", \"[\");\n    brackets.replace(\")\", \"]\");\n    brackets.replace(\"{\"\
    , \"(\");\n    brackets.replace(\"}\", \"(\");\n    brackets.replace(\"[\", \"\
    (\");\n    brackets.replace(\"]\", \"(\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \"(\");\n    brackets.replace(\"{\", \"(\");\n\
    \    brackets.replace(\"}\", \"(\");\n    brackets.replace(\"[\", \"(\");\n  \
    \  brackets.replace(\"]\", \"(\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \"(\");\n    brackets.replace(\"{\", \"(\");\n    brackets.replace(\"}\"\
    , \"(\");\n    brackets.replace(\"[\", \"(\");\n    brackets.replace(\"]\", \"\
    (\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"(\"\
    );\n    brackets.replace(\"{\", \"(\");\n    brackets.replace(\"}\", \"(\");\n\
    \    brackets.replace(\"[\", \"(\");\n    brackets.replace(\"]\", \"(\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"(\");\n    brackets.replace(\"\
    {\", \"(\");\n    brackets.replace(\"}\", \"(\");\n    brackets.replace(\"[\"\
    , \"(\");\n    brackets.replace(\"]\", \"(\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \"(\");\n    brackets.replace(\"{\", \"(\"\
    );\n    brackets.replace(\"}\", \"(\");\n    brackets.replace(\"[\", \"(\");\n\
    \    brackets.replace(\"]\", \"(\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \"(\"\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmp3czjgbfo.rs:68:21\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - closing delimiter possibly meant for\
    \ this\n...\n68 |     brackets.replace(\")\", \"(\"\n   |                    \
    \ ^ unclosed delimiter\n69 | }\n   | ^ mismatched closing delimiter\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3czjgbfo.rs:68:5\n   |\n11 |   fn correct_bracketing(brackets:\
    \ String) -> bool {\n   |                                              ---- expected\
    \ `bool` because of return type\n...\n68 | /     brackets.replace(\")\", \"(\"\
    \n69 | | }\n   | |_^ expected `bool`, found struct `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659747841
- exit_code: -1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    while !brackets.is_empty() {\n   \
    \     let mut current = brackets.chars().next().unwrap();\n        if current\
    \ == '(' {\n            brackets = brackets.replace(\"(\", \"(\");\n        }\
    \ else if current == ')' {\n            brackets = brackets.replace(\")\", \"\
    )\");\n        } else {\n            return false;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659747846
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == '(' || c == '[' || c == '{' || c == '<' || c == '>' || c == ')' || c ==\
    \ ']' || c == '}' || c == '>' || c == ']')\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpgey9dhpv.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659747841
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = \n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp5bc0cn8g.rs:52:1\n\
    \   |\n52 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659747841
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"(\");\n  \
    \  brackets.replace(\"]\", \")\");\n    brackets.replace(\"{\", \"(\");\n    brackets.replace(\"\
    }\", \")\");\n    brackets.replace(\"(\", \"[\");\n    brackets.replace(\")\"\
    , \"]\");\n    brackets.replace(\"[\", \"{\");\n    brackets.replace(\"]\", \"\
    }\");\n    brackets.replace(\"{\", \"[\");\n    brackets.replace(\"}\", \"]\"\
    );\n    brackets.replace(\"(\", \"{\");\n    brackets.replace(\")\", \"}\");\n\
    \    brackets.replace(\"{\", \"(\");\n    brackets.replace(\"}\", \")\");\n  \
    \  brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\"\
    , \"[\");\n    brackets.replace(\")\", \"]\");\n    brackets.replace(\"[\", \"\
    (\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"(\"\
    );\n    brackets.replace(\"}\", \")\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"\
    ]\", \"]\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"[\", \"\
    [\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpadgobs08.rs:11:44\n   |\n\
    11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659747841
