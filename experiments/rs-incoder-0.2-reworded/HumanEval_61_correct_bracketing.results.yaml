name: HumanEval_61_correct_bracketing
language: rs
results:
- program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    let mut opening_brackets = String::new();\n\
    \    let mut closing_brackets = String::new();\n    while brackets.len() > 0 {\n\
    \        let mut opening_bracket = String::new();\n        let mut closing_bracket\
    \ = String::new();\n        if brackets.starts_with(\"(\") {\n            opening_bracket\
    \ = brackets.chars().next().unwrap();\n            brackets = brackets.chars().next().unwrap();\n\
    \        }\n        if brackets.starts_with(\")\") {\n            closing_bracket\
    \ = brackets.chars().next().unwrap();\n            brackets = brackets.chars().next().unwrap();\n\
    \        }\n        if opening_bracket.len() == 0 && closing_bracket.len() ==\
    \ 0 {\n            return false;\n        }\n        if opening_bracket.len()\
    \ > 0 && closing_bracket.len() > 0 {\n            if opening_bracket != closing_bracket\
    \ {\n                return false;\n            }\n        }\n        if opening_bracket.len()\
    \ > 0 {\n            opening_brackets.push_str(&opening_bracket);\n        }\n\
    \        if closing_bracket.len() > 0 {\n            closing_brackets.push_str(&closing_bracket);\n\
    \        }\n    }\n    opening_brackets == closing_brackets\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbf4z7y7w.rs:19:31\n   |\n\
    16 |         let mut opening_bracket = String::new();\n   |                  \
    \                 ------------- expected due to this value\n...\n19 |        \
    \     opening_bracket = brackets.chars().next().unwrap();\n   |              \
    \                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                               |\n   |         \
    \                      expected struct `String`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbf4z7y7w.rs:20:24\n   |\n12 |     let mut brackets\
    \ = brackets.to_string();\n   |                        -------------------- expected\
    \ due to this value\n...\n20 |             brackets = brackets.chars().next().unwrap();\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                        |\n   |   \
    \                     expected struct `String`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbf4z7y7w.rs:23:31\n   |\n17 |         let mut\
    \ closing_bracket = String::new();\n   |                                   -------------\
    \ expected due to this value\n...\n23 |             closing_bracket = brackets.chars().next().unwrap();\n\
    \   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                            \
    \   |\n   |                               expected struct `String`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbf4z7y7w.rs:24:24\n   |\n12 |\
    \     let mut brackets = brackets.to_string();\n   |                        --------------------\
    \ expected due to this value\n...\n24 |             brackets = brackets.chars().next().unwrap();\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                        |\n   |   \
    \                     expected struct `String`, found `char`\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `ru"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n\
    \    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    [\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\"\
    );\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"\
    ]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\"\
    , \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\"\
    );\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"\
    [\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\"\
    );\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp9c69t4s7.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\"\
    , \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n\
    \    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\"\
    , \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    [\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\"\
    );\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp8iadlwwo.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = Vec::new();\n    for ch in brackets.chars() {\n    \
    \    if ch == '(' {\n            stack.push(0);\n        } else if ch == ')' {\n\
    \            stack.pop();\n        } else {\n            stack.push(stack.last().unwrap()\
    \ + 1);\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpa26ykk2x.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().skip_while(|c| !c.is_ascii_letter()).collect());\n\
    \    loop {\n        if stack.len() == 0 {\n            return false;\n      \
    \  }\n        let mut last = stack.last().unwrap();\n        if last.is_ascii_letter()\
    \ {\n            stack.pop();\n        } else {\n            return false;\n \
    \       }\n        if stack.len() == 0 {\n            return true;\n        }\n\
    \        let mut first = stack.first().unwrap();\n        if first.is_ascii_letter()\
    \ {\n            stack.shift();\n        } else {\n            return false;\n\
    \        }\n        if last != first {\n            return false;\n        }\n\
    \    }\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpzn4_cjyi.rs:13:51\n   |\n13 |     stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).collect());\n   |                                    \
    \               ^^^^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `is_ascii`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut open_brackets = Vec::new();\n    let mut\
    \ close_brackets = Vec::new();\n    let mut open_brackets_size = brackets.chars().filter(|c|\
    \ c == '(').count();\n    let mut close_brackets_size = brackets.chars().filter(|c|\
    \ c == ')').count();\n    let mut open_brackets_chars = Vec::new();\n    let mut\
    \ close_brackets_chars = Vec::new();\n    let mut open_brackets_chars_size = brackets.chars().filter(|c|\
    \ c == '(').count();\n    let mut close_brackets_chars_size = brackets.chars().filter(|c|\
    \ c == ')').count();\n    let mut open_brackets_chars_chars = Vec::new();\n  \
    \  let mut close_brackets_chars_chars = Vec::new();\n    let mut open_brackets_chars_chars_size\
    \ = brackets.chars().filter(|c| c == '(').count();\n    let mut close_brackets_chars_chars_size\
    \ = brackets.chars().filter(|c| c == ')').count();\n    let mut open_brackets_chars_chars_chars\
    \ = Vec::new();\n    let mut close_brackets_chars_chars_chars = Vec::new();\n\
    \    let mut open_brackets_chars_chars_chars_size = brackets.chars().filter(|c|\
    \ c == '(').count();\n    let mut close_brackets_chars_chars_chars_size = brackets.chars().filter(|c|\
    \ c == ')').count();\n    let mut open_brackets_chars_chars_chars_chars = Vec::new();\n\
    \    let mut close_brackets_chars_chars_chars_chars = Vec::new();\n    let mut\
    \ open_brackets_chars_chars_chars_chars_size = brackets.chars().filter(|c| c ==\
    \ '(').count();\n    let mut close_brackets_chars_chars_chars_chars_size = brackets.chars().filter(|c|\
    \ c == ')').count();\n    let mut open_brackets_chars_chars_chars_chars_chars\
    \ = Vec::new();\n    let mut close_brackets_chars_chars_chars_chars_chars = Vec::new();\n\
    \    let mut open_brackets_chars_char\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpiuc5wp73.rs:35:37\n   |\n\
    35 |     let mut open_brackets_chars_char\n   |                              \
    \       ^ help: add `;` here\n36 | }\n   | - unexpected token\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpiuc5wp73.rs:15:64\n   |\n15\
    \ |     let mut open_brackets_size = brackets.chars().filter(|c| c == '(').count();\n\
    \   |                                                                ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpiuc5wp73.rs:16:65\n\
    \   |\n16 |     let mut close_brackets_size = brackets.chars().filter(|c| c ==\
    \ ')').count();\n   |                                                        \
    \         ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpiuc5wp73.rs:19:70\n   |\n19 |     let mut open_brackets_chars_size\
    \ = brackets.chars().filter(|c| c == '(').count();\n   |                     \
    \                                                 ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpiuc5wp73.rs:20:71\n   |\n20\
    \ |     let mut close_brackets_chars_size = brackets.chars().filter(|c| c == ')').count();\n\
    \   |                                                                       ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpiuc5wp73.rs:23:76\n\
    \   |\n23 |     let mut open_brackets_chars_chars_size = brackets.chars().filter(|"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    while let Some(item) = stack.last() {\n        if item == ')' {\n       \
    \     stack.pop();\n        } else {\n            stack.push(item);\n        }\n\
    \    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp4t2p3817.rs:15:17\n\
    \   |\n15 |         if item == ')' {\n   |                 ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp4t2p3817.rs:18:24\n   |\n18 |  \
    \           stack.push(item);\n   |                        ^^^^ expected `char`,\
    \ found `&char`\n   |\nhelp: consider dereferencing the borrow\n   |\n18 |   \
    \          stack.push(*item);\n   |                        +\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = vec![];\n    for ch in brackets.chars() {\n        if ch == '('\
    \ || ch == ')' {\n            stack.push(ch);\n        } else if ch == '{' ||\
    \ ch == '}' {\n            if stack.is_empty() {\n                return false;\n\
    \            }\n            let mut last = stack.pop().unwrap();\n           \
    \ if last != ch {\n                return false;\n            }\n        }\n \
    \   }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp66ocyd9_.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets);\n    while !stack.is_empty()\
    \ {\n        let mut current = stack.pop();\n        if current.is_empty() {\n\
    \            continue;\n        }\n        let mut next = current.clone();\n \
    \       while !next.is_empty() {\n            let mut next = next.clone();\n \
    \           if !next.starts_with('(') {\n                return false;\n     \
    \       }\n            next.pop();\n            if !next.starts_with(')') {\n\
    \                return false;\n            }\n            next.pop();\n     \
    \       stack.push(next);\n        }\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\"\
    )), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_empty` found for enum `Option` in the\
    \ current scope\n  --> /tmp/tmpj1h8uet1.rs:16:20\n   |\n16 |         if current.is_empty()\
    \ {\n   |                    ^^^^^^^^ method not found in `Option<String>`\n\n\
    error[E0599]: no method named `is_empty` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpj1h8uet1.rs:20:21\n   |\n20 |         while !next.is_empty()\
    \ {\n   |                     ^^^^^^^^ method not found in `Option<String>`\n\n\
    error[E0599]: no method named `starts_with` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpj1h8uet1.rs:22:22\n   |\n22 |             if !next.starts_with('(')\
    \ {\n   |                      ^^^^^^^^^^^ method not found in `Option<String>`\n\
    \nerror[E0599]: no method named `pop` found for enum `Option` in the current scope\n\
    \  --> /tmp/tmpj1h8uet1.rs:25:18\n   |\n25 |             next.pop();\n   |   \
    \               ^^^ method not found in `Option<String>`\n\nerror[E0599]: no method\
    \ named `starts_with` found for enum `Option` in the current scope\n  --> /tmp/tmpj1h8uet1.rs:26:22\n\
    \   |\n26 |             if !next.starts_with(')') {\n   |                    \
    \  ^^^^^^^^^^^ method not found in `Option<String>`\n\nerror[E0599]: no method\
    \ named `pop` found for enum `Option` in the current scope\n  --> /tmp/tmpj1h8uet1.rs:29:18\n\
    \   |\n29 |             next.pop();\n   |                  ^^^ method not found\
    \ in `Option<String>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj1h8uet1.rs:30:24\n\
    \   |\n30 |             stack.push(next);\n   |                        ^^^^ expected\
    \ struct `String`, found enum `Option`\n   |\n   = note: expected struct `String`\n\
    \                found enum `Option<String>`\n\nerror: aborting due to 7 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    for c in brackets.chars() {\n        if\
    \ c == '(' {\n            stack.push(0);\n        } else if c == ')' {\n     \
    \       if stack.len() == 0 {\n                return false;\n            }\n\
    \            stack.pop();\n        } else {\n            if stack.len() == 0 {\n\
    \                return false;\n            }\n            stack[stack.len() -\
    \ 1] += 1;\n        }\n    }\n    stack.iter().all(|&x| x == 0)\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `stack` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmp16wza0b0.rs:25:19\n   |\n25 |             stack[stack.len()\
    \ - 1] += 1;\n   |             ------^^^^^^^^^^^-----\n   |             |    \
    \ |\n   |             |     immutable borrow occurs here\n   |             mutable\
    \ borrow occurs here\n   |             mutable borrow later used here\n   |\n\
    help: try adding a local storing this...\n  --> /tmp/tmp16wza0b0.rs:25:19\n  \
    \ |\n25 |             stack[stack.len() - 1] += 1;\n   |                   ^^^^^^^^^^^\n\
    help: ...and then using that local here\n  --> /tmp/tmp16wza0b0.rs:25:13\n   |\n\
    25 |             stack[stack.len() - 1] += 1;\n   |             ^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for bracket in brackets.chars() {\n        if bracket\
    \ == '(' {\n            stack.push(bracket);\n        } else if bracket == ')'\
    \ {\n            if stack.is_empty() {\n                return false;\n      \
    \      }\n            stack.pop();\n        } else {\n            return false;\n\
    \        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets == brackets\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpcj2c4sic.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == ')' || c == '(')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpexnsdi2v.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = vec![];\n    stack.push(brackets.chars().filter(|c| c == '(').collect::<String>());\n\
    \    while let Some(last) = stack.pop() {\n        if let Some(next) = stack.pop()\
    \ {\n            if last == next {\n                return false;\n          \
    \  }\n        }\n        stack.push(last.chars().filter(|c| c == ')').collect::<String>());\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp0ekag5lo.rs:13:46\n\
    \   |\n13 |     stack.push(brackets.chars().filter(|c| c == '(').collect::<String>());\n\
    \   |                                              ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmp0ekag5lo.rs:20:46\n   |\n20\
    \ |         stack.push(last.chars().filter(|c| c == ')').collect::<String>());\n\
    \   |                                              ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut opening_brackets = String::new();\n   \
    \ let mut closing_brackets = String::new();\n    let mut opening_brackets_count\
    \ = String::new();\n    let mut closing_brackets_count = String::new();\n    let\
    \ mut opening_brackets_count_stack = Vec::new();\n    let mut closing_brackets_count_stack\
    \ = Vec::new();\n    let mut opening_brackets_count_stack = Vec::new();\n    let\
    \ mut closing_brackets_count_stack = Vec::new();\n    let mut opening_brackets_count_stack\
    \ = Vec::new();\n    let mut closing_brackets_count_stack = Vec::new();\n    let\
    \ mut opening_brackets_count_stack = Vec::new();\n    let mut closing_brackets_count_stack\
    \ = Vec::new();\n    let mut opening_brackets_count_stack = Vec::new();\n    let\
    \ mut closing_brackets_count_stack = Vec::new();\n    let mut opening_brackets_count_stack\
    \ = Vec::new();\n    let mut closing_brackets_count_stack = Vec::new();\n    let\
    \ mut opening_brackets_count_stack = Vec::new();\n    let mut closing_brackets_count_stack\
    \ = Vec::new();\n    let mut opening_brackets_count_stack = Vec::new();\n    let\
    \ mut closing_brackets_count_stack = Vec::new();\n    let mut opening_brackets_count_stack\
    \ = Vec::new();\n    let mut closing_brackets_count_stack = Vec::new();\n    let\
    \ mut opening_brackets_count_stack = Vec::new();\n    let mut closing_brackets_count_stack\
    \ = Vec::new();\n    let mut opening_brackets_count_stack = Vec::new();\n    let\
    \ mut closing_brackets_count_stack = Vec::new();\n    let mut opening_brackets_count_stack\
    \ = Vec::new();\n    let mut closing_brackets_count_stack = Vec::new();\n    let\
    \ mut opening_brackets_count_stack = Vec::new();\n    let mut closing_brackets_count_stack\
    \ = Vec::new();\n    let mut opening_brackets_count_stack = Vec::new();\n\n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbej3w90h.rs:11:44\n   |\n\
    11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_brackets_stack = Vec::new();\n    let mut closed_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack_ptr = &mut open_brackets_stack;\n\
    \    let mut closed_brackets_stack_ptr = &mut closed_brackets_stack;\n    let\
    \ mut brackets_ptr = &mut brackets;\n    while brackets_ptr.len() > 0 {\n    \
    \    let mut open_brackets_ptr = open_brackets_stack_ptr;\n        let mut closed_brackets_ptr\
    \ = closed_brackets_stack_ptr;\n        let mut brackets_ptr = &mut brackets_ptr;\n\
    \        while brackets_ptr.len() > 0 {\n            let mut open_brackets_ptr\
    \ = open_brackets_ptr.as_mut();\n            let mut closed_brackets_ptr = closed_brackets_ptr.as_mut();\n\
    \            let mut brackets_ptr = &mut brackets_ptr;\n            let mut open_bracket\
    \ = String::new();\n            let mut closed_bracket = String::new();\n    \
    \        while brackets_ptr.len() > 0 {\n                let mut open_bracket\
    \ = open_bracket.as_mut();\n                let mut closed_bracket = closed_bracket.as_mut();\n\
    \                let mut brackets_ptr = &mut brackets_ptr;\n                let\
    \ mut open_bracket = open_bracket.clone();\n                let mut closed_bracket\
    \ = closed_bracket.clone();\n                while brackets_ptr.len() > 0 {\n\
    \                    let mut open_bracket = open_bracket.clone();\n          \
    \          let mut closed_bracket = closed_bracket.clone();\n                \
    \    let mut brackets_ptr = &mut brackets_ptr;\n                    let mut open_bracket\
    \ = open_bracket.clone();\n                    let mut closed_bracket = closed_bracket.clone();\n\
    \                    while brackets_ptr.len() > 0 {\n                        let\
    \ mut open_bracket = open_bracket.clone();\n                        let mut closed_bracket\
    \ = closed_bracket.clone();\n                        let mut brackets_ptr = &mut\
    \ brackets_ptr;\n                        let mut open_bracket = open_bracket.clone();\n\
    \                        let mut closed_bracket = \n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\"\
    )), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpzmrukllh.rs:63:3\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - unclosed delimiter\n...\n19 |     while\
    \ brackets_ptr.len() > 0 {\n   |                                  - unclosed delimiter\n\
    ...\n23 |         while brackets_ptr.len() > 0 {\n   |                       \
    \               - unclosed delimiter\n...\n29 |             while brackets_ptr.len()\
    \ > 0 {\n   |                                          - unclosed delimiter\n\
    ...\n35 |                 while brackets_ptr.len() > 0 {\n   |               \
    \                               - unclosed delimiter\n...\n41 |              \
    \       while brackets_ptr.len() > 0 {\n   |                                 \
    \                 - this delimiter might not be properly closed...\n...\n47 |\
    \ }\n   | - ...as it matches this but it has different indentation\n...\n63 |\
    \ }\n   |   ^\n\nerror: expected expression, found `}`\n  --> /tmp/tmpzmrukllh.rs:47:1\n\
    \   |\n47 | }\n   | ^ expected expression\n\nerror[E0599]: no method named `clone`\
    \ found for mutable reference `&mut str` in the current scope\n  --> /tmp/tmpzmrukllh.rs:33:53\n\
    \   |\n33 |                 let mut open_bracket = open_bracket.clone();\n   |\
    \                                                     ^^^^^ method not found in\
    \ `&mut str`\n\nerror[E0599]: no method named `clone` found for mutable reference\
    \ `&mut str` in the current scope\n  --> /tmp/tmpzmrukllh.rs:34:57\n   |\n34 |\
    \                 let mut closed_bracket = closed_bracket.clone();\n   |     \
    \                                                    ^^^^^ method not found in\
    \ `&mut str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzmrukllh.rs:19:5\n\
    \   |\n11 |   fn correct_bracketing(brackets: String) -> bool {\n   |        \
    \                                      ---- expected `bool` because of return\
    \ type\n...\n19 | /     while brackets_ptr.len() > 0 {\n20 | |         let mut\
    \ open_brackets_ptr = open_brackets_stack_ptr;\n21 | |         let mut closed_brackets_ptr\
    \ = closed_brackets_stack_ptr;\n22 | "
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    while brackets.len() > 2 {\n     \
    \   let mut opening = brackets.chars().next().unwrap();\n        let mut closing\
    \ = brackets.chars().next().unwrap();\n        if opening != closing {\n     \
    \       return false;\n        }\n        brackets = brackets.chars().collect::<String>().to_string();\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    for c in brackets.chars() {\n        if stack.is_empty() {\n            return\
    \ false;\n        }\n        if stack.pop() != c {\n            return false;\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkio34iqy.rs:18:27\n   |\n\
    18 |         if stack.pop() != c {\n   |                           ^ expected\
    \ enum `Option`, found `char`\n   |\n   = note: expected enum `Option<char>`\n\
    \              found type `char`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n18 |         if stack.pop() != Some(c) {\n   |                        \
    \   +++++ +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for ch in brackets.chars() {\n        if ch ==\
    \ '(' {\n            stack.push((ch, false));\n        } else if ch == ')' {\n\
    \            if let Some((_, is_open)) = stack.pop() {\n                if !is_open\
    \ {\n                    return false;\n                }\n            } else\
    \ {\n                return false;\n            }\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_4hm_7eu.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"(\" and \")\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    for c in brackets.chars() {\n        if\
    \ c == '(' {\n            stack.push(0);\n        } else if c == ')' {\n     \
    \       if stack.len() == 0 {\n                return false;\n            }\n\
    \            stack.pop();\n        } else {\n            if stack.len() == 0 {\n\
    \                return false;\n            }\n            stack[stack.len() -\
    \ 1] += 1;\n        }\n    }\n    stack.iter().all(|&x| x == 0)\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `stack` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmp6p3u3dc3.rs:25:19\n   |\n25 |             stack[stack.len()\
    \ - 1] += 1;\n   |             ------^^^^^^^^^^^-----\n   |             |    \
    \ |\n   |             |     immutable borrow occurs here\n   |             mutable\
    \ borrow occurs here\n   |             mutable borrow later used here\n   |\n\
    help: try adding a local storing this...\n  --> /tmp/tmp6p3u3dc3.rs:25:19\n  \
    \ |\n25 |             stack[stack.len() - 1] += 1;\n   |                   ^^^^^^^^^^^\n\
    help: ...and then using that local here\n  --> /tmp/tmp6p3u3dc3.rs:25:13\n   |\n\
    25 |             stack[stack.len() - 1] += 1;\n   |             ^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
