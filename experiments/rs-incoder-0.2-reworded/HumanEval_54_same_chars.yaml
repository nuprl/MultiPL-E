name: HumanEval_54_same_chars
language: rs
prompt: "/// Check if two words have the same characters.\n/// >>> same_chars(String::from(\"\
  eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\"))\n/// true\n/// >>> same_chars(String::from(\"\
  abcd\"), String::from(\"dddddddabc\"))\n/// true\n/// >>> same_chars(String::from(\"\
  dddddddabc\"), String::from(\"abcd\"))\n/// true\n/// >>> same_chars(String::from(\"\
  eabcd\"), String::from(\"dddddddabc\"))\n/// false\n/// >>> same_chars(String::from(\"\
  abcd\"), String::from(\"dddddddabce\"))\n/// false\n/// >>> same_chars(String::from(\"\
  eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\"))\n/// false\nfn same_chars(s0:\
  \ String, s1: String) -> bool {\n"
tests: "}\n\nfn main() {\n    let candidate = same_chars;\n    assert_eq!(candidate(String::from(\"\
  eabcdzzzz\"), String::from(\"dddzzzzzzzddeddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
  abcd\"), String::from(\"dddddddabc\")), true);\n    assert_eq!(candidate(String::from(\"\
  dddddddabc\"), String::from(\"abcd\")), true);\n    assert_eq!(candidate(String::from(\"\
  eabcd\"), String::from(\"dddddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
  abcd\"), String::from(\"dddddddabcf\")), false);\n    assert_eq!(candidate(String::from(\"\
  eabcdzzzz\"), String::from(\"dddzzzzzzzddddabc\")), false);\n    assert_eq!(candidate(String::from(\"\
  aabb\"), String::from(\"aaccc\")), false);\n}\n"
completions: ['    s0.chars().zip(s1.chars()).all(|(a, b)| a == b)', '    s0.chars().zip(s1.chars()).all(|(a,
    b)| a == b)', '    s0.chars().zip(s1.chars()).all(|(a, b)| a == b)', '    s0.chars().zip(s1.chars()).all(|(a,
    b)| a == b)', '    s0.chars().zip(s1.chars()).all(|(a, b)| a == b)', "    if s0.len()\
    \ != s1.len() {\n        return false;\n    }\n    let mut i = 0;\n    while i\
    \ < s0.len() && i < s1.len() {\n        if s0[i] != s1[i] {\n            return\
    \ false;\n        }\n        i += 1;\n    }\n    true", "    let mut s0_iter =\
    \ s0.chars().enumerate();\n    let mut s1_iter = s1.chars().enumerate();\n   \
    \ while let Some((i0, c0)) = s0_iter.next() {\n        let Some((i1, c1)) = s1_iter.next();\n\
    \        if c0 != c1 {\n            return false;\n        }\n    }\n    true",
  '    s0.chars().zip(s1.chars()).all(|(a, b)| a == b)', '    s0.chars().zip(s1.chars()).all(|(a,
    b)| a == b)', '    s0.chars().zip(s1.chars()).all(|(a, b)| a == b)', '    s0.chars().zip(s1.chars()).all(|(a,
    b)| a == b)', "    if s0.len() != s1.len() {\n        return false;\n    }\n \
    \   let mut i = 0;\n    while i < s0.len() && i < s1.len() {\n        if s0.chars().nth(i)\
    \ != s1.chars().nth(i) {\n            return false;\n        }\n        i += 1;\n\
    \    }\n    true", '    s0.chars().zip(s1.chars()).all(|(a, b)| a == b)', '    s0.chars().zip(s1.chars()).all(|(a,
    b)| a == b)', '    s0.chars().zip(s1.chars()).all(|(a, b)| a == b)', '    s0.chars().zip(s1.chars()).all(|(a,
    b)| a == b)', '    s0.chars().zip(s1.chars()).all(|(a, b)| a == b)', '    s0.chars().zip(s1.chars()).all(|(a,
    b)| a == b)', '    s0.chars().zip(s1.chars()).all(|(a, b)| a == b)', "    let\
    \ mut s0_iter = s0.chars();\n    let mut s1_iter = s1.chars();\n    while let\
    \ Some(mut s0) = s0_iter.next() {\n        if let Some(mut s1) = s1_iter.next()\
    \ {\n            if s0.eq_ignore_ascii_case(s1) {\n                s0_iter.next();\n\
    \                s1_iter.next();\n            } else {\n                return\
    \ false;\n            }\n        } else {\n            return false;\n       \
    \ }\n    }\n    true"]
stop_tokens:
- "\n}"
