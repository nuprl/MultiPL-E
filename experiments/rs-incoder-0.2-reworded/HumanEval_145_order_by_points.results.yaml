name: HumanEval_145_order_by_points
language: rs
results:
- program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x| {\n        let mut\
    \ sum = 0;\n        for x in nums_copy {\n            sum += x;\n        }\n \
    \       sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmpvyleq7k1.rs:12:28\n   |\n\
    12 |     nums_copy.sort_by_key(|x| {\n   |                            ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of\
    \ `nums_copy`, a captured variable in an `FnMut` closure\n   --> /tmp/tmpvyleq7k1.rs:14:18\n\
    \    |\n11  |       let mut nums_copy = nums.clone();\n    |           -------------\
    \ captured outer variable\n12  |       nums_copy.sort_by_key(|x| {\n    |  ___________________________-\n\
    13  | |         let mut sum = 0;\n14  | |         for x in nums_copy {\n    |\
    \ |                  ^^^^^^^^^\n    | |                  |\n    | |          \
    \        `nums_copy` moved due to this implicit call to `.into_iter()`\n    |\
    \ |                  move occurs because `nums_copy` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n15  | |             sum += x;\n16  | |\
    \         }\n17  | |         sum\n18  | |     });\n    | |_____- captured by this\
    \ `FnMut` closure\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `nums_copy`\nhelp: consider iterating over a slice of the\
    \ `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n14  |   \
    \      for x in &nums_copy {\n    |                  +\n\nerror[E0505]: cannot\
    \ move out of `nums_copy` because it is borrowed\n  --> /tmp/tmpvyleq7k1.rs:12:27\n\
    \   |\n12 |       nums_copy.sort_by_key(|x| {\n   |       -                  \
    \   ^^^ move out of `nums_copy` occurs here\n   |  _____|\n   | |\n13 | |    \
    \     let mut sum = 0;\n14 | |         for x in nums_copy {\n   | |          \
    \        --------- move occurs due to use in closure\n15 | |             sum +=\
    \ x;\n16 | |         }\n17 | |         sum\n18 | |     });\n   | |______- borrow\
    \ of `nums_copy` occurs here\n\nerror[E0382]: use of moved value: `nums_copy`\n\
    \  --> /tmp/tmpvyleq7k1.rs:19:5\n   |\n11 |     let mut nums_copy = nums.clone();\n\
    \   |         ------------- move occurs because `nums_copy` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trai"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums_copy = nums.clone();\n    nums_copy.sort_by_key(|&x| {\n        let mut\
    \ sum = 0;\n        for &d in &nums_copy {\n            sum += d;\n        }\n\
    \        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmpy1vnelgf.rs:12:29\n   |\n\
    12 |     nums_copy.sort_by_key(|&x| {\n   |                             ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0502]: cannot borrow `nums_copy`\
    \ as immutable because it is also borrowed as mutable\n  --> /tmp/tmpy1vnelgf.rs:12:27\n\
    \   |\n12 |       nums_copy.sort_by_key(|&x| {\n   |       -         -----------\
    \ ^^^^ immutable borrow occurs here\n   |       |         |\n   |  _____|    \
    \     mutable borrow later used by call\n   | |\n13 | |         let mut sum =\
    \ 0;\n14 | |         for &d in &nums_copy {\n   | |                    ---------\
    \ second borrow occurs due to use of `nums_copy` in closure\n15 | |          \
    \   sum += d;\n16 | |         }\n17 | |         sum\n18 | |     });\n   | |______-\
    \ mutable borrow occurs here\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len() {\n\
    \        sum += nums_copy[index];\n        nums_sorted.swap(index, nums_sorted.iter().position(|&x|\
    \ x + sum).unwrap());\n        index += 1;\n    }\n    nums_sorted\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplrt7dtf7.rs:17:66\n   |\n\
    17 |         nums_sorted.swap(index, nums_sorted.iter().position(|&x| x + sum).unwrap());\n\
    \   |                                                                  ^^^^^^^\
    \ expected `bool`, found `isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len() {\n\
    \        sum += nums_copy[index];\n        if sum > 0 {\n            nums_sorted.swap(index,\
    \ nums_sorted.iter().position(|&x| x + sum).unwrap());\n        }\n        index\
    \ += 1;\n    }\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps41mheys.rs:18:70\n   |\n\
    18 |             nums_sorted.swap(index, nums_sorted.iter().position(|&x| x +\
    \ sum).unwrap());\n   |                                                      \
    \                ^^^^^^^ expected `bool`, found `isize`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut min_sum = nums.iter().min().unwrap();\n    let mut\
    \ min_sum_pos = 0;\n    let mut max_sum = nums.iter().max().unwrap();\n    let\
    \ mut max_sum_pos = 0;\n    let mut min_num = nums.iter().min().unwrap();\n  \
    \  let mut min_num_pos = 0;\n    let mut max_num = nums.iter().max().unwrap();\n\
    \    let mut max_num_pos = 0;\n    let mut min_num = nums.iter().min().unwrap();\n\
    \    let mut min_num_pos = 0;\n    let mut max_num = nums.iter().max().unwrap();\n\
    \    let mut max_num_pos = 0;\n    let mut min_num = nums.iter().min().unwrap();\n\
    \    let mut min_num_pos = 0;\n    let mut max_num = nums.iter().max().unwrap();\n\
    \    let mut max_num_pos = 0;\n    let mut min_num = nums.iter().min().unwrap();\n\
    \    let mut min_num_pos = 0;\n    let mut max_num = nums.iter().max().unwrap();\n\
    \    let mut max_num_pos = 0;\n    let mut min_num = nums.iter().min().unwrap();\n\
    \    let mut min_num_pos = 0;\n    let mut max_num = nums.iter().max().unwrap();\n\
    \    let mut max_num_pos = 0;\n    let mut min_num = nums.iter().min().unwrap();\n\
    \    let mut min_num_pos = 0;\n    let mut max_num = nums.iter().max().unwrap();\n\
    \    let mut max_num_pos = 0;\n    let mut min_num = nums.iter().min().unwrap();\n\
    \    let mut min_num_pos = 0;\n    let mut max_num = nums.iter().max().unwrap();\n\
    \    let mut max_num_pos = 0;\n    let mut min_num = nums.iter().min().unwrap();\n\
    \    let mut min_num_pos = 0;\n    let mut max_num = nums.iter().max().unwrap();\n\
    \    let mut max_num_pos = 0;\n    let mut min_num = nums.iter().min().unwrap();\n\
    \    let mut min_num_pos = 0;\n    let mut max_num = nums.iter().max().unwrap();\n\
    \    let mut max_num_pos = 0;\n    let mut min_num = nums.iter().min().unwrap();\n\
    \    let mut min_num_pos = 0;\n    let mut max_num = nums.iter().max().unwrap();\n\
    \    let mut max_num_pos = 0;\n    let \n}\n\nfn main() {\n    let candidate =\
    \ order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp6a2tsq67.rs:59:1\n  \
    \ |\n59 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut min_sum = nums.iter().min().unwrap();\n    let mut\
    \ max_sum = nums.iter().max().unwrap();\n\n    while nums_copy.len() > 0 {\n \
    \       let mut min_num = nums_copy.iter().min().unwrap();\n        let mut max_num\
    \ = nums_copy.iter().max().unwrap();\n        let mut min_idx = nums_sorted.iter().position(|&x|\
    \ x == min_num).unwrap();\n        let mut max_idx = nums_sorted.iter().position(|&x|\
    \ x == max_num).unwrap();\n        let mut min_sum = nums_sorted[min_idx].checked_add(&sum).unwrap();\n\
    \        let mut max_sum = nums_sorted[max_idx].checked_add(&sum).unwrap();\n\n\
    \        if min_sum < max_sum {\n            nums_sorted.swap(min_idx, max_idx);\n\
    \            nums_sorted.swap(min_idx, max_idx);\n        }\n\n        sum +=\
    \ nums_copy.pop().unwrap();\n    }\n\n    nums_sorted\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplic2i7ls.rs:20:65\n   |\n\
    20 |         let mut min_idx = nums_sorted.iter().position(|&x| x == min_num).unwrap();\n\
    \   |                                                                 ^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n20 |         let mut min_idx = nums_sorted.iter().position(|&x| x == *min_num).unwrap();\n\
    \   |                                                                 +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplic2i7ls.rs:21:65\n   |\n21 |         let mut\
    \ max_idx = nums_sorted.iter().position(|&x| x == max_num).unwrap();\n   |   \
    \                                                              ^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    21 |         let mut max_idx = nums_sorted.iter().position(|&x| x == *max_num).unwrap();\n\
    \   |                                                                 +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplic2i7ls.rs:22:60\n   |\n22 |         let mut\
    \ min_sum = nums_sorted[min_idx].checked_add(&sum).unwrap();\n   |           \
    \                                                 ^^^^ expected `isize`, found\
    \ `&{integer}`\n   |\nhelp: consider removing the borrow\n   |\n22 -         let\
    \ mut min_sum = nums_sorted[min_idx].checked_add(&sum).unwrap();\n22 +       \
    \  let mut min_sum = nums_sorted[min_idx].checked_add(sum).unwrap();\n   | \n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmplic2i7ls.rs:23:60\n   |\n23 |  \
    \       let mut max_sum = nums_sorted[max_idx].checked_add(&sum).unwrap();\n \
    \  |                                                            ^^^^ expected\
    \ `isize`, found `&{integer}`\n   |\nhelp: consider removing the borrow\n   |\n\
    23 -         let mut max_sum = nums_sorted[max_idx].checked_add(&sum).unwrap();\n\
    23 +         let mut max_sum = nums_sorted[max_idx].checked_add(sum).unwrap();\n\
    \   | \n\nerror: aborting due to 4 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len() {\n\
    \        let mut digit = 0;\n        while nums_copy[index] >= 10 {\n        \
    \    digit += nums_copy[index] / 10;\n            index += 1;\n        }\n   \
    \     nums_sorted[index] = digit;\n        sum += digit;\n        index += 1;\n\
    \    }\n    nums_sorted.sort_by_key(|&x| sum + x);\n    nums_sorted\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 1, 11]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmpi655vb71.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut max_sum = 0;\n\
    \    let mut min_sum = 0;\n    let mut min_idx = nums.len() - 1;\n    let mut\
    \ max_idx = nums.len() - 1;\n\n    while nums_copy.len() > 0 {\n        sum +=\
    \ nums_copy.pop().unwrap();\n        if sum > max_sum {\n            max_sum =\
    \ sum;\n            max_idx = nums_copy.len() - 1;\n        }\n        if sum\
    \ < min_sum {\n            min_sum = sum;\n            min_idx = nums_copy.len()\
    \ - 1;\n        }\n    }\n\n    let mut nums_copy = nums.clone();\n    let mut\
    \ sum = 0;\n    let mut max_sum = 0;\n    let mut min_sum = 0;\n    let mut min_idx\
    \ = nums.len() - 1;\n    let mut max_idx = nums.len() - 1;\n\n    while nums_copy.len()\
    \ > 0 {\n        sum += nums_copy.pop().unwrap();\n        if sum > max_sum {\n\
    \            max_sum = sum;\n            max_idx = nums_copy.len() - 1;\n    \
    \    }\n        if sum < min_sum {\n            min_sum = sum;\n            min_idx\
    \ = nums_copy.len() - 1;\n        }\n    }\n\n    if min_sum == max_sum {\n  \
    \      return nums;\n    }\n\n    if min_sum < 0 {\n        nums[min_idx] = -nums[min_idx];\n\
    \    }\n\n    if max_sum > 0 {\n        nums[max_idx] = -nums[max_idx];\n    }\n\
    \n    nums[min_idx..max_idx + 1]\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvlk7pj3r.rs:61:5\n   |\n\
    10 | fn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n   |              \
    \                           ---------- expected `Vec<isize>` because of return\
    \ type\n...\n61 |     nums[min_idx..max_idx + 1]\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_vec()`\n   |     |\n   |     expected\
    \ struct `Vec`, found slice `[isize]`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \               found slice `[isize]`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums_sorted = nums.clone();\n    let mut sum = 0;\n    for &i in nums_sorted\
    \ {\n        sum += i;\n    }\n    nums_sorted.sort_by_key(|&i| {\n        sum\
    \ - i;\n    });\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp222nznao.rs:13:9\n   |\n\
    13 |     for &i in nums_sorted {\n   |         ^^    ----------- this expression\
    \ has type `Option<isize>`\n   |         |\n   |         expected `isize`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `i`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut max_sum = 0;\n    let mut max_index = 0;\n    let\
    \ mut min_sum = 0;\n    let mut min_index = 0;\n    for i in nums_copy {\n   \
    \     sum += i;\n        if sum > max_sum {\n            max_sum = sum;\n    \
    \        max_index = i;\n        }\n        if sum < min_sum {\n            min_sum\
    \ = sum;\n            min_index = i;\n        }\n    }\n    for i in nums_copy\
    \ {\n        if i == max_index {\n            nums_sorted.swap(i, max_index);\n\
    \        }\n        if i == min_index {\n            nums_sorted.swap(i, min_index);\n\
    \        }\n    }\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjg5nftgw.rs:31:30\n   |\n\
    31 |             nums_sorted.swap(i, max_index);\n   |                       \
    \       ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n31 |      \
    \       nums_sorted.swap(i.try_into().unwrap(), max_index);\n   |            \
    \                   ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpjg5nftgw.rs:31:33\n   |\n31 |             nums_sorted.swap(i, max_index);\n\
    \   |                                 ^^^^^^^^^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n31 |             nums_sorted.swap(i, max_index.try_into().unwrap());\n\
    \   |                                          ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjg5nftgw.rs:34:30\n   |\n34 |             nums_sorted.swap(i,\
    \ min_index);\n   |                              ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n34 |             nums_sorted.swap(i.try_into().unwrap(),\
    \ min_index);\n   |                               ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjg5nftgw.rs:34:33\n   |\n34 |             nums_sorted.swap(i,\
    \ min_index);\n   |                                 ^^^^^^^^^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n34 |             nums_sorted.swap(i,\
    \ min_index.try_into().unwrap());\n   |                                      \
    \    ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut index = 0;\n  \
    \  while index < nums_copy.len() {\n        sum += nums_copy[index];\n       \
    \ index += 1;\n    }\n    let mut result = vec![];\n    while sum > 0 {\n    \
    \    let mut index = nums_copy.len();\n        while index > 0 {\n           \
    \ if nums_copy[index - 1] > sum {\n                index -= 1;\n            }\
    \ else {\n                break;\n            }\n        }\n        result.push(nums_copy[index]);\n\
    \        sum -= nums_copy[index];\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmpx68s04xj.rs:36:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut max_sum = 0;\n\
    \    let mut max_index = 0;\n    let mut min_sum = 0;\n    let mut min_index =\
    \ 0;\n    for i in nums_copy {\n        sum += i;\n        if sum > max_sum {\n\
    \            max_sum = sum;\n            max_index = i;\n        }\n        if\
    \ sum < min_sum {\n            min_sum = sum;\n            min_index = i;\n  \
    \      }\n    }\n    nums_copy.swap_remove(max_index);\n    nums_copy.swap_remove(min_index);\n\
    \    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3zygfklv.rs:28:27\n   |\n\
    28 |     nums_copy.swap_remove(max_index);\n   |                           ^^^^^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n28 |     nums_copy.swap_remove(max_index.try_into().unwrap());\n\
    \   |                                    ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3zygfklv.rs:29:27\n   |\n29 |     nums_copy.swap_remove(min_index);\n\
    \   |                           ^^^^^^^^^ expected `usize`, found `isize`\n  \
    \ |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n29 |     nums_copy.swap_remove(min_index.try_into().unwrap());\n\
    \   |                                    ++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x| {\n        let mut\
    \ sum = 0;\n        for x in nums_copy {\n            sum += x;\n        }\n \
    \       sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmpcu3kj0k9.rs:12:28\n   |\n\
    12 |     nums_copy.sort_by_key(|x| {\n   |                            ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of\
    \ `nums_copy`, a captured variable in an `FnMut` closure\n   --> /tmp/tmpcu3kj0k9.rs:14:18\n\
    \    |\n11  |       let mut nums_copy = nums.clone();\n    |           -------------\
    \ captured outer variable\n12  |       nums_copy.sort_by_key(|x| {\n    |  ___________________________-\n\
    13  | |         let mut sum = 0;\n14  | |         for x in nums_copy {\n    |\
    \ |                  ^^^^^^^^^\n    | |                  |\n    | |          \
    \        `nums_copy` moved due to this implicit call to `.into_iter()`\n    |\
    \ |                  move occurs because `nums_copy` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n15  | |             sum += x;\n16  | |\
    \         }\n17  | |         sum\n18  | |     });\n    | |_____- captured by this\
    \ `FnMut` closure\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `nums_copy`\nhelp: consider iterating over a slice of the\
    \ `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n14  |   \
    \      for x in &nums_copy {\n    |                  +\n\nerror[E0505]: cannot\
    \ move out of `nums_copy` because it is borrowed\n  --> /tmp/tmpcu3kj0k9.rs:12:27\n\
    \   |\n12 |       nums_copy.sort_by_key(|x| {\n   |       -                  \
    \   ^^^ move out of `nums_copy` occurs here\n   |  _____|\n   | |\n13 | |    \
    \     let mut sum = 0;\n14 | |         for x in nums_copy {\n   | |          \
    \        --------- move occurs due to use in closure\n15 | |             sum +=\
    \ x;\n16 | |         }\n17 | |         sum\n18 | |     });\n   | |______- borrow\
    \ of `nums_copy` occurs here\n\nerror[E0382]: use of moved value: `nums_copy`\n\
    \  --> /tmp/tmpcu3kj0k9.rs:19:5\n   |\n11 |     let mut nums_copy = nums.clone();\n\
    \   |         ------------- move occurs because `nums_copy` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trai"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut max_sum = 0;\n    let mut min_sum = 0;\n    let mut\
    \ min_idx = -1;\n    let mut max_idx = -1;\n    let mut min_sum_idx = -1;\n  \
    \  let mut max_sum_idx = -1;\n    let mut min_sum_idx_idx = -1;\n    let mut max_sum_idx_idx\
    \ = -1;\n    let mut min_sum_idx_idx = -1;\n    let mut max_sum_idx_idx = -1;\n\
    \    let mut min_sum_idx_idx = -1;\n    let mut max_sum_idx_idx = -1;\n    let\
    \ mut min_sum_idx_idx = -1;\n    let mut max_sum_idx_idx = -1;\n    let mut min_sum_idx_idx\
    \ = -1;\n    let mut max_sum_idx_idx = -1;\n    let mut min_sum_idx_idx = -1;\n\
    \    let mut max_sum_idx_idx = -1;\n    let mut min_sum_idx_idx = -1;\n    let\
    \ mut max_sum_idx_idx = -1;\n    let mut min_sum_idx_idx = -1;\n    let mut max_sum_idx_idx\
    \ = -1;\n    let mut min_sum_idx_idx = -1;\n    let mut max_sum_idx_idx = -1;\n\
    \    let mut min_sum_idx_idx = -1;\n    let mut max_sum_idx_idx = -1;\n    let\
    \ mut min_sum_idx_idx = -1;\n    let mut max_sum_idx_idx = -1;\n    let mut min_sum_idx_idx\
    \ = -1;\n    let mut max_sum_idx_idx = -1;\n    let mut min_sum_idx_idx = -1;\n\
    \    let mut max_sum_idx_idx = -1;\n    let mut min_sum_idx_idx = -1;\n    let\
    \ mut max_sum_idx_idx = -1;\n    let mut min_sum_idx_idx = -1;\n    let mut max_sum_idx_idx\
    \ = -1;\n    let mut min_sum_idx_idx = -1;\n    let mut max_sum_idx_idx = -1;\n\
    \    let mut min_sum_idx_idx = -1;\n    let mut max_sum_idx_idx = -1;\n    let\
    \ mut min_sum_idx_idx = -1;\n    let mut max_sum_idx_idx = -1;\n    let mut min_sum_idx_idx\
    \ = -1;\n    let mut max_sum_idx_idx = -1;\n    let mut min_sum_idx_idx = -1;\n\
    \    let mut max_sum_idx_idx = -1;\n    let mut min_sum_idx_idx = -1;\n    let\
    \ mut max_sum_idx_idx = -1;\n    let mut min_sum_idx_idx = -1;\n    let mut max_sum_idx_idx\
    \ = -1;\n    let mut min_sum_idx_idx = -1;\n    let mut max_sum_idx_idx = -1;\n\
    \    let mut min_sum_idx_idx = -1;\n    let mut max_sum_idx_idx = -1;\n    let\
    \ mut min_sum_idx_idx = -1;\n\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp991jzur.rs:10:41\n   |\n\
    10 | fn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n   |    ---------------\
    \                      ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len() {\n\
    \        sum += nums_copy[index];\n        if sum < 0 {\n            sum = 0;\n\
    \            index += 1;\n        } else {\n            nums_sorted.swap(index,\
    \ nums_sorted.iter().position(|&x| x > sum).unwrap());\n            index += 1;\n\
    \        }\n    }\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp_e6fjv2p.rs:11:9\n\
    \   |\n11 |     let mut nums_copy = nums.clone();\n   |         ----^^^^^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0502]: cannot borrow `nums_sorted` as immutable because\
    \ it is also borrowed as mutable\n  --> /tmp/tmp_e6fjv2p.rs:21:37\n   |\n21 |\
    \             nums_sorted.swap(index, nums_sorted.iter().position(|&x| x > sum).unwrap());\n\
    \   |             ------------------------^^^^^^^^^^^^^^^^^^---------------------------------\n\
    \   |             |           |           |\n   |             |           |  \
    \         immutable borrow occurs here\n   |             |           mutable borrow\
    \ later used by call\n   |             mutable borrow occurs here\n   |\nhelp:\
    \ try adding a local storing this argument...\n  --> /tmp/tmp_e6fjv2p.rs:21:37\n\
    \   |\n21 |             nums_sorted.swap(index, nums_sorted.iter().position(|&x|\
    \ x > sum).unwrap());\n   |                                     ^^^^^^^^^^^^^^^^^^\n\
    help: ...and then using that local as the argument to this call\n  --> /tmp/tmp_e6fjv2p.rs:21:13\n\
    \   |\n21 |             nums_sorted.swap(index, nums_sorted.iter().position(|&x|\
    \ x > sum).unwrap());\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x| {\n        let mut\
    \ sum = 0;\n        for x in nums_copy {\n            sum += x;\n        }\n \
    \       sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmp0pyi2634.rs:12:28\n   |\n\
    12 |     nums_copy.sort_by_key(|x| {\n   |                            ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of\
    \ `nums_copy`, a captured variable in an `FnMut` closure\n   --> /tmp/tmp0pyi2634.rs:14:18\n\
    \    |\n11  |       let mut nums_copy = nums.clone();\n    |           -------------\
    \ captured outer variable\n12  |       nums_copy.sort_by_key(|x| {\n    |  ___________________________-\n\
    13  | |         let mut sum = 0;\n14  | |         for x in nums_copy {\n    |\
    \ |                  ^^^^^^^^^\n    | |                  |\n    | |          \
    \        `nums_copy` moved due to this implicit call to `.into_iter()`\n    |\
    \ |                  move occurs because `nums_copy` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n15  | |             sum += x;\n16  | |\
    \         }\n17  | |         sum\n18  | |     });\n    | |_____- captured by this\
    \ `FnMut` closure\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `nums_copy`\nhelp: consider iterating over a slice of the\
    \ `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n14  |   \
    \      for x in &nums_copy {\n    |                  +\n\nerror[E0505]: cannot\
    \ move out of `nums_copy` because it is borrowed\n  --> /tmp/tmp0pyi2634.rs:12:27\n\
    \   |\n12 |       nums_copy.sort_by_key(|x| {\n   |       -                  \
    \   ^^^ move out of `nums_copy` occurs here\n   |  _____|\n   | |\n13 | |    \
    \     let mut sum = 0;\n14 | |         for x in nums_copy {\n   | |          \
    \        --------- move occurs due to use in closure\n15 | |             sum +=\
    \ x;\n16 | |         }\n17 | |         sum\n18 | |     });\n   | |______- borrow\
    \ of `nums_copy` occurs here\n\nerror[E0382]: use of moved value: `nums_copy`\n\
    \  --> /tmp/tmp0pyi2634.rs:19:5\n   |\n11 |     let mut nums_copy = nums.clone();\n\
    \   |         ------------- move occurs because `nums_copy` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trai"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x| {\n        let mut\
    \ sum = 0;\n        for &n in &nums_copy {\n            sum += n.checked_mul(10).unwrap();\n\
    \        }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmpy4_0l6dt.rs:12:28\n   |\n\
    12 |     nums_copy.sort_by_key(|x| {\n   |                            ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0502]: cannot borrow `nums_copy`\
    \ as immutable because it is also borrowed as mutable\n  --> /tmp/tmpy4_0l6dt.rs:12:27\n\
    \   |\n12 |       nums_copy.sort_by_key(|x| {\n   |       -         -----------\
    \ ^^^ immutable borrow occurs here\n   |       |         |\n   |  _____|     \
    \    mutable borrow later used by call\n   | |\n13 | |         let mut sum = 0;\n\
    14 | |         for &n in &nums_copy {\n   | |                    --------- second\
    \ borrow occurs due to use of `nums_copy` in closure\n15 | |             sum +=\
    \ n.checked_mul(10).unwrap();\n16 | |         }\n17 | |         sum\n18 | |  \
    \   });\n   | |______- mutable borrow occurs here\n\nerror: aborting due to previous\
    \ error; 1 warning emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x| {\n        let mut\
    \ sum = 0;\n        for &n in &nums_copy {\n            sum += *n as isize;\n\
    \        }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpa9ww13ck.rs:15:20\n\
    \   |\n15 |             sum += *n as isize;\n   |                    ^^\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0614`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut index = 0;\n  \
    \  while index < nums_copy.len() {\n        let digit = nums_copy[index].unwrap();\n\
    \        sum += digit;\n        if sum > 0 {\n            nums_copy[index] = nums_copy[index].clone()\
    \ + 1;\n        } else {\n            sum -= digit;\n        }\n        index\
    \ += 1;\n    }\n    nums_copy.sort_by_key(|&x| x.partial_cmp(&sum).unwrap());\n\
    \    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpihb0tmmc.rs:15:38\n   |\n15 |         let digit = nums_copy[index].unwrap();\n\
    \   |                                      ^^^^^^ method not found in `isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function which sorts the given vector of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original vector.\n/// For example:\n/// >>> order_by_points(vec![1,\
    \ 11, -1, -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// vec![]\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n    let mut\
    \ nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n    let\
    \ mut sum = 0;\n    let mut index = 0;\n    while nums_sorted.len() > 0 {\n  \
    \      sum += nums_sorted.pop();\n        if sum < 0 {\n            sum = 0;\n\
    \            index += 1;\n        }\n        nums_sorted.push(index);\n    }\n\
    \    nums_sorted.reverse();\n    nums_copy\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot add-assign `Option<isize>` to `{integer}`\n  --> /tmp/tmp4xct367s.rs:16:13\n\
    \   |\n16 |         sum += nums_sorted.pop();\n   |             ^^ no implementation\
    \ for `{integer} += Option<isize>`\n   |\n   = help: the trait `AddAssign<Option<isize>>`\
    \ is not implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n           \
    \  <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n             <f64\
    \ as AddAssign>\n             <i128 as AddAssign<&i128>>\n             <i128 as\
    \ AddAssign>\n             <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n\
    \           and 20 others\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
