language: rs
name: HumanEval_87_get_row
results:
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ coords = vec![];\n    let mut row_coords = vec![];\n    let mut col_coords =\
    \ vec![];\n    for row in lst {\n        let mut row_coord = vec![];\n       \
    \ let mut col_coord = vec![];\n        for col in row {\n            if col ==\
    \ x {\n                row_coord.push((row, col));\n                col_coord.push((row,\
    \ col));\n            }\n        }\n        row_coords.push(row_coord);\n    \
    \    col_coords.push(col_coord);\n    }\n    coords.sort_by(|a, b| a.0.cmp(&b.0));\n\
    \    row_coords.sort_by(|a, b| b.0.cmp(&a.0));\n    col_coords.sort_by(|a, b|\
    \ b.0.cmp(&a.0));\n    coords\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `&T`\n  --> /tmp/tmpkc6ffjr_.rs:32:21\n\
    \   |\n32 |     coords.sort_by(|a, b| a.0.cmp(&b.0));\n   |                  \
    \   ^ consider giving this closure parameter the explicit type `&T`, where the\
    \ type parameter `T` is specified\n   |\n   = note: type must be known at this\
    \ point\n\nerror[E0609]: no field `0` on type `&_`\n  --> /tmp/tmpkc6ffjr_.rs:32:29\n\
    \   |\n32 |     coords.sort_by(|a, b| a.0.cmp(&b.0));\n   |                  \
    \           ^\n\nerror[E0609]: no field `0` on type `&Vec<(Vec<isize>, isize)>`\n\
    \  --> /tmp/tmpkc6ffjr_.rs:33:33\n   |\n33 |     row_coords.sort_by(|a, b| b.0.cmp(&a.0));\n\
    \   |                                 ^ unknown field\n\nerror[E0609]: no field\
    \ `0` on type `&Vec<(Vec<isize>, isize)>`\n  --> /tmp/tmpkc6ffjr_.rs:33:42\n \
    \  |\n33 |     row_coords.sort_by(|a, b| b.0.cmp(&a.0));\n   |               \
    \                           ^ unknown field\n\nerror[E0609]: no field `0` on type\
    \ `&Vec<(Vec<isize>, isize)>`\n  --> /tmp/tmpkc6ffjr_.rs:34:33\n   |\n34 |   \
    \  col_coords.sort_by(|a, b| b.0.cmp(&a.0));\n   |                           \
    \      ^ unknown field\n\nerror[E0609]: no field `0` on type `&Vec<(Vec<isize>,\
    \ isize)>`\n  --> /tmp/tmpkc6ffjr_.rs:34:42\n   |\n34 |     col_coords.sort_by(|a,\
    \ b| b.0.cmp(&a.0));\n   |                                          ^ unknown\
    \ field\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed\
    \ explanations: E0282, E0609.\nFor more information about an error, try `rustc\
    \ --explain E0282`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut row_idx_max\
    \ = 0;\n    let mut row_idx_min = 0;\n    let mut col_max = 0;\n    let mut col_min\
    \ = 0;\n    let mut col_max2 = 0;\n    let mut col_min2 = 0;\n    let mut col_max3\
    \ = 0;\n    let mut col_min3 = 0;\n    let mut col_max4 = 0;\n    let mut col_min4\
    \ = 0;\n    let mut col_max5 = 0;\n    let mut col_min5 = 0;\n    let mut col_max6\
    \ = 0;\n    let mut col_min6 = 0;\n    let mut col_max7 = 0;\n    let mut col_min7\
    \ = 0;\n    let mut col_max8 = 0;\n    let mut col_min8 = 0;\n    let mut col_max9\
    \ = 0;\n    let mut col_min9 = 0;\n    let mut col_max10 = 0;\n    let mut col_min10\
    \ = 0;\n    let mut col_max11 = 0;\n    let mut col_min11 = 0;\n    let mut col_max12\
    \ = 0;\n    let mut col_min12 = 0;\n    let mut col_max13 = 0;\n    let mut col_min13\
    \ = 0;\n    let mut col_max14 = 0;\n    let mut col_min14 = 0;\n    let mut col_max15\
    \ = 0;\n    let mut col_min15 = 0;\n    let mut col_max16 = 0;\n    let mut col_min16\
    \ = 0;\n    let mut col_max17 = 0;\n    let mut col_min17 = 0;\n    let mut col_max18\
    \ = 0;\n    let mut col_min18 = 0;\n    let mut col_max19 = 0;\n    let mut col_min19\
    \ = 0;\n    let mut col_max20 = 0;\n    let mut col_min20 = 0;\n    let mut col_max21\
    \ = 0;\n    let mut col_min21 = 0;\n    let mut col_max22 = 0;\n    let mut col_min22\
    \ = 0;\n    let mut col_max23 = 0;\n    let mut col_min23 = 0;\n    let mut col_max24\
    \ = 0;\n    let mut col_min24 = 0;\n    let mut col_max25 = 0;\n    let mut col_min25\
    \ = 0;\n    let mut col_max26 = 0;\n    let mut col_min26 = 0;\n    let mut col_max27\
    \ = 0;\n    let mut col_min27 = 0;\n    let mut col_max28 = 0;\n    let mut col_min28\
    \ = 0;\n    let mut col_max29 = 0;\n    let mut col_min29 = 0;\n    let mut col_max30\
    \ = 0;\n    let mut col_min30 = 0;\n    let mu\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpsa7tzda6.rs:81:11\n   |\n\
    81 |     let mu\n   |           ^ help: add `;` here\n82 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsa7tzda6.rs:16:47\n \
    \  |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n\
    \   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n\
    \    let mut row_idx = 0;\n    let mut col_idx = 0;\n    while col_idx < cols\
    \ {\n        if row_idx == rows {\n            break;\n        }\n        let\
    \ mut row_start = row_idx;\n        let mut row_end = row_idx;\n        let mut\
    \ col_start = col_idx;\n        let mut col_end = col_idx;\n        if row_idx\
    \ < rows {\n            row_end = row_idx + 1;\n        }\n        if col_idx\
    \ < cols {\n            col_end = col_idx + 1;\n        }\n        if row_start\
    \ > row_end {\n            break;\n        }\n        if col_start > col_end {\n\
    \            break;\n        }\n        if row_start == row_end && col_start ==\
    \ col_end {\n            if lst[row_start][col_start] == x {\n               \
    \ result.push((row_start, col_start));\n            }\n        }\n        row_idx\
    \ = row_end;\n        col_idx = col_end;\n    }\n    result.sort_by_key(|&(x,\
    \ y)| x.0);\n    result.sort_by_key(|&(x, y)| y.0);\n    result\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0610]: `usize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmpb_g_48j7.rs:50:36\n   |\n50 |     result.sort_by_key(|&(x, y)|\
    \ x.0);\n   |                                    ^\n\nerror[E0610]: `usize` is\
    \ a primitive type and therefore doesn't have fields\n  --> /tmp/tmpb_g_48j7.rs:51:36\n\
    \   |\n51 |     result.sort_by_key(|&(x, y)| y.0);\n   |                     \
    \               ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb_g_48j7.rs:52:5\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n52 |     result\n   |   \
    \  ^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n              found struct `Vec<(usize, usize)>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0610.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows = lst.len();\n    let mut cols = lst[0].len();\n    let mut coords = vec![];\n\
    \    let mut row_coords = vec![];\n    let mut col_coords = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sort\
    \ = vec![];\n    let mut col_sort = vec![];\n    let mut row_sort_idx = vec![];\n\
    \    let mut col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n    let\
    \ mut col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n    let mut\
    \ col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n    let mut col_sort_idx\
    \ = vec![];\n    let mut row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n\
    \    let mut row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n    let\
    \ mut row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n    let mut\
    \ row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n    let mut row_sort_idx\
    \ = vec![];\n    let mut col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n\
    \    let mut col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n    let\
    \ mut col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n    let mut\
    \ col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n    let mut col_sort_idx\
    \ = vec![];\n    let mut row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n\
    \    let mut row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n    let\
    \ mut row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n    let mut\
    \ row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n    let mut row_sort_idx\
    \ = vec![];\n    let mut col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n\
    \    let mut col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n    let\
    \ mut col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n    let mut\
    \ col_sort_idx = vec![];\n    let mut row_sort_\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpucvttksj.rs:68:22\n   |\n\
    68 |     let mut row_sort_\n   |                      ^ help: add `;` here\n69\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpucvttksj.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n\
    \    let mut row_idx = 0;\n    let mut col_idx = 0;\n    while col_idx < cols\
    \ {\n        if row_idx < rows {\n            let row = lst[row_idx];\n      \
    \      let col = row[col_idx];\n            if col == x {\n                result.push((row_idx,\
    \ col_idx));\n            }\n            col_idx += 1;\n        } else {\n   \
    \         break;\n        }\n        row_idx += 1;\n    }\n    result.sort_by_key(|&(x,\
    \ y)| x.0);\n    result.sort_by_key(|&(x, y)| y.0);\n    result\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0610]: `usize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmpn9wxkjtd.rs:35:36\n   |\n35 |     result.sort_by_key(|&(x, y)|\
    \ x.0);\n   |                                    ^\n\nerror[E0610]: `usize` is\
    \ a primitive type and therefore doesn't have fields\n  --> /tmp/tmpn9wxkjtd.rs:36:36\n\
    \   |\n36 |     result.sort_by_key(|&(x, y)| y.0);\n   |                     \
    \               ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn9wxkjtd.rs:37:5\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n37 |     result\n   |   \
    \  ^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n              found struct `Vec<(usize, usize)>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0610.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    for row in lst {\n        let mut row = row.clone();\n\
    \        let mut row_sorted = row.clone();\n        row_sorted.sort_by_key(|&x|\
    \ x.0);\n        let mut row_reversed = row_sorted.clone();\n        row_reversed.reverse();\n\
    \        for row in row_reversed {\n            if row.0 == x {\n            \
    \    result.push((row.0, row.1));\n                break;\n            }\n   \
    \     }\n    }\n    result.sort_by_key(|&x| x.0);\n    result.sort_by_key(|&x|\
    \ x.1);\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0610]: `isize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmpq7l45eja.rs:21:39\n   |\n21 |         row_sorted.sort_by_key(|&x|\
    \ x.0);\n   |                                       ^\n\nerror[E0610]: `isize`\
    \ is a primitive type and therefore doesn't have fields\n  --> /tmp/tmpq7l45eja.rs:25:20\n\
    \   |\n25 |             if row.0 == x {\n   |                    ^\n\nerror[E0610]:\
    \ `isize` is a primitive type and therefore doesn't have fields\n  --> /tmp/tmpq7l45eja.rs:26:34\n\
    \   |\n26 |                 result.push((row.0, row.1));\n   |               \
    \                   ^\n\nerror[E0610]: `isize` is a primitive type and therefore\
    \ doesn't have fields\n  --> /tmp/tmpq7l45eja.rs:26:41\n   |\n26 |           \
    \      result.push((row.0, row.1));\n   |                                    \
    \     ^\n\nerror: aborting due to 4 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0610`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows = lst.len();\n    let mut cols = lst[0].len();\n    let mut coords = vec![];\n\
    \    let mut row_coords = vec![];\n    let mut col_coords = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sor\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpa1objz2n.rs:68:20\n   |\n\
    68 |     let mut row_sor\n   |                    ^ help: add `;` here\n69 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa1objz2n.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows = lst.len();\n    let mut cols = lst[0].len();\n    let mut coords = vec![];\n\
    \    let mut row_coords = vec![];\n    let mut col_coords = vec![];\n    let mut\
    \ row_sort = vec![];\n    let mut col_sort = vec![];\n    let mut row_sort_idx\
    \ = 0;\n    let mut col_sort_idx = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    while i < rows {\n        let mut row_sort = vec![];\n        let mut col_sort\
    \ = vec![];\n        let mut row_sort_idx = 0;\n        let mut col_sort_idx =\
    \ 0;\n        while j < cols {\n            if lst[i][j] == x {\n            \
    \    row_sort.push((i, j));\n                row_sort_idx += 1;\n            \
    \    col_sort.push((j, i));\n                col_sort_idx += 1;\n            }\n\
    \            j += 1;\n        }\n        row_sort.sort_by_key(|&(_, y)| y);\n\
    \        col_sort.sort_by_key(|&(_, x)| x);\n        row_sort.reverse();\n   \
    \     col_sort.reverse();\n        row_sort.push(row_sort_idx);\n        col_sort.push(col_sort_idx);\n\
    \        coords.push(row_sort.clone());\n        coords.push(col_sort.clone());\n\
    \        i += 1;\n        j = 0;\n    }\n    coords\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk5mi74pc.rs:46:23\n   |\n\
    46 |         row_sort.push(row_sort_idx);\n   |                       ^^^^^^^^^^^^\
    \ expected tuple, found integer\n   |\n   = note: expected tuple `(usize, usize)`\n\
    \               found type `{integer}`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpk5mi74pc.rs:47:23\n   |\n47 |         col_sort.push(col_sort_idx);\n\
    \   |                       ^^^^^^^^^^^^ expected tuple, found integer\n   |\n\
    \   = note: expected tuple `(usize, usize)`\n               found type `{integer}`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpk5mi74pc.rs:53:5\n   |\n16 | fn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |     \
    \                                          ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n53 |     coords\n   |     ^^^^^^ expected\
    \ tuple, found struct `Vec`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \              found struct `Vec<Vec<(usize, usize)>>`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows = lst.len();\n    let mut cols = lst[0].len();\n    let mut coords = vec![];\n\
    \    let mut row_coords = vec![];\n    let mut col_coords = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorter:\
    \ Vec<(isize, isize)> = vec![];\n    let mut col_sorter: Vec<(isize, isize)> =\
    \ vec![];\n    let mut row = 0;\n    let mut col = 0;\n    let mut i = 0;\n  \
    \  let mut j = 0;\n    while i < rows {\n        row_sorter.clear();\n       \
    \ col_sorter.clear();\n        row_sorter.push((i, x));\n        col_sorter.push((x,\
    \ i));\n        row_sorted = row_sorter.iter().cloned().collect();\n        col_sorted\
    \ = col_sorter.iter().cloned().collect();\n        row_coords.clear();\n     \
    \   col_coords.clear();\n        row_coords.push((row, x));\n        col_coords.push((x,\
    \ row));\n        row_coords.sort_by(|a, b| a.1.cmp(&b.1));\n        col_coords.sort_by(|a,\
    \ b| b.1.cmp(&a.1));\n        row_coords.reverse();\n        col_coords.reverse();\n\
    \        row_coords.sort_by(|a, b| b.0.cmp(&a.0));\n        col_coords.sort_by(|a,\
    \ b| a.0.cmp(&b.0));\n        row_coords.reverse();\n        col_coords.reverse();\n\
    \        row_coords.sort_by(|a, b| b.1.cmp(&a.1));\n        col_coords.sort_by(|a,\
    \ b| a.1.cmp(&b.1));\n        row_coords.reverse();\n        col_coords.reverse();\n\
    \        row_coords.sort_by(|a, b| b.0.cmp(&a.0));\n        col_coords.sort_by(|a,\
    \ b| a.0.cmp(&b.0));\n        row_coords.reverse();\n        col_coords.reverse();\n\
    \        row_coords.sort_by(|a, b| b.1.cmp(&a.1));\n        col_coords.sort_by(|a,\
    \ b| a.1.cmp(&b.1));\n        row_coords.reverse();\n        col_coords.reverse();\n\
    \        row_coords.sort_by(|a, b| b.0.cmp(&a.0));\n        col_coords.sort_by(|a,\
    \ b| a.0.cmp(&b.0));\n        row_coords.reverse();\n        col_coords.reverse();\n\
    \        row_coords.sort_by(|a, b| b.1.cmp(&a.1));\n        col_coords.sort_by(|a,\
    \ b| a.1.cmp(&b.1));\n        row_coords.reverse();\n        \n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpoier_41i.rs:79:3\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                                                   -\
    \ unclosed delimiter\n...\n30 |     while i < rows {\n   |                   \
    \ - this delimiter might not be properly closed...\n...\n69 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n79 | }\n   |   ^\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpoier_41i.rs:33:26\n   |\n33 |  \
    \       row_sorter.push((i, x));\n   |                          ^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n33 |         row_sorter.push((i.try_into().unwrap(),\
    \ x));\n   |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpoier_41i.rs:34:29\n   |\n34 |         col_sorter.push((x,\
    \ i));\n   |                             ^ expected `isize`, found `usize`\n \
    \  |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n34 |         col_sorter.push((x, i.try_into().unwrap()));\n\
    \   |                              ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpoier_41i.rs:16:47\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>,\
    \ x: isize) -> Vec<(isize, isize)> {\n   |    -------                        \
    \            ^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<(isize, isize)>`\n           found unit\
    \ type `()`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res = vec![];\n    let mut row = 0;\n    let mut col = 0;\n    let mut i = 0;\n\
    \    while i < lst.len() {\n        if row == x {\n            i += 1;\n     \
    \       continue;\n        }\n        let mut j = i;\n        while j < lst.len()\
    \ {\n            if col == x {\n                res.push((row, col));\n      \
    \          i += 1;\n                j += 1;\n                continue;\n     \
    \       }\n            if lst[j][col] > lst[j][col + 1] {\n                j +=\
    \ 1;\n                continue;\n            }\n            i += 1;\n        \
    \    col += 1;\n        }\n        row += 1;\n        col = 0;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp1tvkhs6g.rs:34:16\n\
    \   |\n34 |             if lst[j][col] > lst[j][col + 1] {\n   |             \
    \   ^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n \
    \  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp1tvkhs6g.rs:34:30\n\
    \   |\n34 |             if lst[j][col] > lst[j][col + 1] {\n   |             \
    \                 ^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut row_len\
    \ = 0;\n    let mut col_len = 0;\n    let mut col_len_idx = 0;\n    let mut col_len_idx_max\
    \ = 0;\n    let mut col_len_idx_min = 0;\n    let mut row_len_idx = 0;\n    let\
    \ mut row_len_idx_max = 0;\n    let mut row_len_idx_min = 0;\n    let mut row_idx\
    \ = 0;\n    let mut col_idx = 0;\n    let mut col_len = 0;\n    let mut col_len_idx\
    \ = 0;\n    let mut col_len_idx_max = 0;\n    let mut col_len_idx_min = 0;\n \
    \   let mut row_len_idx = 0;\n    let mut row_len_idx_max = 0;\n    let mut row_len_idx_min\
    \ = 0;\n    let mut row_idx = 0;\n    let mut col_idx = 0;\n    let mut col_len\
    \ = 0;\n    let mut col_len_idx = 0;\n    let mut col_len_idx_max = 0;\n    let\
    \ mut col_len_idx_min = 0;\n    let mut row_len_idx = 0;\n    let mut row_len_idx_max\
    \ = 0;\n    let mut row_len_idx_min = 0;\n    let mut row_idx = 0;\n    let mut\
    \ col_idx = 0;\n    let mut col_len = 0;\n    let mut col_len_idx = 0;\n    let\
    \ mut col_len_idx_max = 0;\n    let mut col_len_idx_min = 0;\n    let mut row_len_idx\
    \ = 0;\n    let mut row_len_idx_max = 0;\n    let mut row_len_idx_min = 0;\n \
    \   let mut row_idx = 0;\n    let mut col_idx = 0;\n    let mut col_len = 0;\n\
    \    let mut col_len_idx = 0;\n    let mut col_len_idx_max = 0;\n    let mut col_len_idx_min\
    \ = 0;\n    let mut row_len_idx = 0;\n    let mut row_len_idx_max = 0;\n    let\
    \ mut row_len_idx_min = 0;\n    let mut row_idx = 0;\n    let mut col_idx = 0;\n\
    \    let mut col_len = 0;\n    let mut col_len_idx = 0;\n    let mut col_len_idx_max\
    \ = 0;\n    let mut col_len_idx_min = 0;\n    let mut row_len_idx = 0;\n    let\
    \ mut row_len_idx_max = 0;\n    let mut row_len_idx_min = 0;\n    let mut row_idx\
    \ = 0;\n    let mut col_idx = 0;\n    let mut col_len = 0;\n    let mut col_len_idx\
    \ = 0;\n    let mut col_len_idx_max = 0;\n    let mut col_len_idx_min = 0;\n \
    \   let mut row_len_idx = 0;\n    let mu\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp0oj4sd6x.rs:79:11\n   |\n\
    79 |     let mu\n   |           ^ help: add `;` here\n80 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0oj4sd6x.rs:16:47\n \
    \  |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n\
    \   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut row_idx = 1;\n    let mut col_idx = 1;\n    let\
    \ mut row_len = lst.len();\n    let mut col_len = lst[0].len();\n    let mut row_start\
    \ = vec![];\n    let mut col_start = vec![];\n    while row_idx < row_len {\n\
    \        let mut row_end = vec![];\n        while col_idx < col_len {\n      \
    \      if row_idx == row_idx {\n                row_start.push(col_idx);\n   \
    \             col_start.push(row_idx);\n            }\n            if col_idx\
    \ < col_len {\n                if row_idx == row_idx {\n                    row_end.push(col_idx);\n\
    \                }\n                if row_idx < row_len {\n                 \
    \   if row_idx == row_idx {\n                        row_end.push(row_idx);\n\
    \                    }\n                    if row_idx < row_len {\n         \
    \               if row_idx == row_idx {\n                            row_end.push(row_idx);\n\
    \                        }\n                        if row_idx < row_len {\n \
    \                           if row_idx == row_idx {\n                        \
    \        row_end.push(row_idx);\n                            }\n             \
    \               if row_idx < row_len {\n                                if row_idx\
    \ == row_idx {\n                                    row_end.push(row_idx);\n \
    \                               }\n                                if row_idx\
    \ < row_len {\n                                    if row_idx == row_idx {\n \
    \                                       row_end.push(row_idx);\n             \
    \                       }\n                                    if row_idx < row_len\
    \ {\n                                        if row_idx == row_idx {\n       \
    \                                     row_end.push(row_idx);\n               \
    \                         }\n                                        if row_idx\
    \ < row_len {\n                                            if row_idx == row_idx\
    \ {\n                                                row_end.push(row_idx);\n\
    \                                            }\n                             \
    \               if row_idx < row_len {\n                                     \
    \           if row_idx == row_idx {\n                                        \
    \            row_end.push(row_idx);\n                                        \
    \        }\n                                                if row_idx < row_len\
    \ {\n                                                    if row_idx == row_idx\
    \ {\n                                                        row_end.push(row_idx);\n\
    \                                                    }\n                     \
    \                               if row_idx < row_len {\n                     \
    \                                   if row_idx == row_idx {\n                \
    \                                            row_end.push(row_idx);\n        \
    \                                                }\n                         \
    \                               if row_idx < row_len {\n                     \
    \                                       if row_idx == row_idx {\n            \
    \                                                    row_end.push(row_idx);\n\
    \                                                            }\n             \
    \                                               if row_idx < row_len {\n     \
    \                                                           if row_idx == row_idx\
    \ {\n                                                                    row_end.push(row_idx);\n\
    \                                                                }\n         \
    \                                                       if row_idx < row_len {\n\
    \                                                                    if row_idx\
    \ == row_idx {\n                                                             \
    \           row_end.push(row_idx);\n                                         \
    \                           }\n                                              \
    \                      if row_idx < \n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpl8p1x47v.rs:98:3\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                                                   -\
    \ unclosed delimiter\n...\n24 |     while row_idx < row_len {\n   |          \
    \                   - unclosed delimiter\n25 |         let mut row_end = vec![];\n\
    26 |         while col_idx < col_len {\n   |                                 -\
    \ unclosed delimiter\n...\n31 |             if col_idx < col_len {\n   |     \
    \                             - unclosed delimiter\n...\n35 |                \
    \ if row_idx < row_len {\n   |                                      - unclosed\
    \ delimiter\n...\n39 |                     if row_idx < row_len {\n   |      \
    \                                    - unclosed delimiter\n...\n43 |         \
    \                if row_idx < row_len {\n   |                                \
    \              - unclosed delimiter\n...\n47 |                             if\
    \ row_idx < row_len {\n   |                                                  -\
    \ unclosed delimiter\n...\n51 |                                 if row_idx < row_len\
    \ {\n   |                                                      - unclosed delimiter\n\
    ...\n55 |                                     if row_idx < row_len {\n   |   \
    \                                                       - unclosed delimiter\n\
    ...\n59 |                                         if row_idx < row_len {\n   |\
    \                                                              - unclosed delimiter\n\
    ...\n63 |                                             if row_idx < row_len {\n\
    \   |                                                                  - unclosed\
    \ delimiter\n...\n67 |                                                 if row_idx\
    \ < row_len {\n   |                                                          \
    \            - unclosed delimiter\n...\n71 |                                 \
    \                    if row_idx < row_len {\n   |                            \
    \                                              - unclosed delimit"
  stdout: ''
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx: usize = 0;\n    let\
    \ mut col: usize = 0;\n    let mut col_max: usize = 0;\n    let mut row_max =\
    \ lst.len();\n    let mut col_min = row_max;\n    let mut col_max_idx: usize =\
    \ 0;\n    let mut col_min_idx: usize = 0;\n    let mut row_min_idx: usize = 0;\n\
    \    let mut col_max_idx: usize = 0;\n    let mut row_min_idx: usize = 0;\n  \
    \  let mut row_min_idx: usize = 0;\n    let mut row_min_idx: usize = 0;\n    let\
    \ mut row_min_idx: usize = 0;\n    let mut row_min_idx: usize = 0;\n    let mut\
    \ row_min_idx: usize = 0;\n    let mut row_min_idx: usize = 0;\n    let mut row_min_idx:\
    \ usize = 0;\n    let mut row_min_idx: usize = 0;\n    let mut row_min_idx: usize\
    \ = 0;\n    let mut row_min_idx: usize = 0;\n    let mut row_min_idx: usize =\
    \ 0;\n    let mut row_min_idx: usize = 0;\n    let mut row_min_idx: usize = 0;\n\
    \    let mut row_min_idx: usize = 0;\n    let mut row_min_idx: usize = 0;\n  \
    \  let mut row_min_idx: usize = 0;\n    let mut row_min_idx: usize = 0;\n    let\
    \ mut row_min_idx: usize = 0;\n    let mut row_min_idx: usize = 0;\n    let mut\
    \ row_min_idx: usize = 0;\n    let mut row_min_idx: usize = 0;\n    let mut row_min_idx:\
    \ usize = 0;\n    let mut row_min_idx: usize = 0;\n    let mut row_min_idx: usize\
    \ = 0;\n    let mut row_min_idx: usize = 0;\n    let mut row_min_idx: usize =\
    \ 0;\n    let mut row_min_idx: usize = 0;\n    let mut row_min_idx: usize = 0;\n\
    \    let mut row_min_idx: usize = 0;\n    let mut row_min_idx: usize = 0;\n  \
    \  let mut row_min_idx: usize = 0;\n    let mut row_min_idx: usize = 0;\n    let\
    \ mut row_min_idx: usize = 0;\n    let mut row_min_idx: usize = 0;\n    let mut\
    \ row_min_idx: usize = 0;\n    let mut row_min_idx: \n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected type, found `}`\n  --> /tmp/tmpywl9_bnt.rs:64:1\n   |\n\
    63 |     let mut row_min_idx: \n   |         --------------- while parsing the\
    \ type for `mut row_min_idx`\n64 | }\n   | ^ expected type\n\nerror: aborting\
    \ due to previous error\n\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    let mut row_len = lst.len();\n    let mut col_len = lst[0].len();\n\
    \    while row_idx < row_len {\n        let mut row_idx = row_idx;\n        while\
    \ col_idx < col_len {\n            if row_idx == row_len {\n                row_idx\
    \ = 0;\n                col_idx = 0;\n            }\n            if col_idx ==\
    \ col_len {\n                row_idx++;\n                col_idx = 0;\n      \
    \      }\n            if lst[row_idx][col_idx] == x {\n                row.push((row_idx,\
    \ col_idx));\n                col_idx++;\n                break;\n           \
    \ }\n            col_idx++;\n        }\n    }\n    row.sort_by_key(|&(x, y)| x.0);\n\
    \    row.sort_by_key(|&(x, y)| y.0);\n    row.iter().map(|&(x, y)| {\n       \
    \ (x.0, y.0)\n    }).collect()\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmprl3vmt_7.rs:30:24\n\
    \   |\n30 |                 row_idx++;\n   |                        ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n30 |               \
    \  { let tmp = row_idx; row_idx += 1; tmp };\n   |                 +++++++++++\
    \        ~~~~~~~~~~~~~~~~~~~~~\n30 -                 row_idx++;\n30 +        \
    \         row_idx += 1;\n   | \n\nerror: Rust has no postfix increment operator\n\
    \  --> /tmp/tmprl3vmt_7.rs:35:24\n   |\n35 |                 col_idx++;\n   |\
    \                        ^^ not a valid postfix operator\n   |\nhelp: use `+=\
    \ 1` instead\n   |\n35 |                 { let tmp = col_idx; col_idx += 1; tmp\
    \ };\n   |                 +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n35 -    \
    \             col_idx++;\n35 +                 col_idx += 1;\n   | \n\nerror:\
    \ Rust has no postfix increment operator\n  --> /tmp/tmprl3vmt_7.rs:38:20\n  \
    \ |\n38 |             col_idx++;\n   |                    ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n38 |             { let tmp =\
    \ col_idx; col_idx += 1; tmp };\n   |             +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n\
    38 -             col_idx++;\n38 +             col_idx += 1;\n   | \n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprl3vmt_7.rs:34:27\n   |\n34 |              \
    \   row.push((row_idx, col_idx));\n   |                           ^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n34 |                 row.push((row_idx.try_into().unwrap(),\
    \ col_idx));\n   |                                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprl3vmt_7.rs:34:36\n   |\n34 |              \
    \   row.push((row_idx, col_idx));\n   |                                    ^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n34 |           \
    \      row.push((row_idx, col_idx.try_into().unwrap()));\n   |               \
    \                            +++++"
  stdout: ''
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n\
    \    let mut row_idx = vec![0; rows];\n    let mut col_idx = vec![0; cols];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![0; rows];\n    let mut col_idx = vec![0; cols];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_idx\
    \ = vec![0; rows];\n    let mut col_idx = vec![0; cols];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_idx = vec![0; rows];\n\
    \    let mut col_idx = vec![0; cols];\n    let mut row_sorted = vec![];\n    let\
    \ mut col_sorted = vec![];\n    let mut row_idx = vec![0; rows];\n    let mut\
    \ col_idx = vec![0; cols];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![0; rows];\n    let mut col_idx = vec![0;\
    \ cols];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_idx = vec![0; rows];\n    let mut col_idx = vec![0; cols];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![0; rows];\n    let mut col_idx = vec![0; cols];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_idx\
    \ = vec![0; rows];\n    let mut col_idx = vec![0; cols];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_idx = vec![0; rows];\n\
    \    let mut col_idx = vec![0; cols];\n    let mut row_sorted = vec![];\n    let\
    \ mut col_sorted = vec![];\n    let mut row_idx = vec![0; rows];\n    let mut\
    \ col_idx = vec![0; cols];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![0; rows];\n    let mut col_idx = vec![0;\
    \ cols];\n    let mu\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpmux8bbb_.rs:66:11\n   |\n\
    66 |     let mu\n   |           ^ help: add `;` here\n67 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmux8bbb_.rs:16:47\n \
    \  |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n\
    \   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut\
    \ col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n  \
    \  let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut\
    \ col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n  \
    \  let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut\
    \ col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n  \
    \  let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut\
    \ col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n  \
    \  let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let \n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpzfv6u_ru.rs:72:1\n  \
    \ |\n72 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut row_idx_max\
    \ = 0;\n    let mut col_max = 0;\n    let mut col_min = 0;\n    let mut col_sum\
    \ = 0;\n    let mut col_sum_max = 0;\n    let mut row_sum = 0;\n    let mut row_sum_max\
    \ = 0;\n    let mut row_max = 0;\n    let mut row_min = 0;\n    let mut row_min_index\
    \ = 0;\n    let mut col_min_index = 0;\n    let mut col_sum_index = 0;\n    let\
    \ mut col_sum_min_index = 0;\n    let mut row_sum_index = 0;\n    let mut row_sum_min_index\
    \ = 0;\n    let mut row_max_index = 0;\n    let mut row_min_index = 0;\n    for\
    \ row in lst {\n        let mut col_max = 0;\n        let mut col_min = 0;\n \
    \       let mut col_sum = 0;\n        let mut col_sum_max = 0;\n        let mut\
    \ row_sum = 0;\n        let mut row_sum_max = 0;\n        let mut row_max = 0;\n\
    \        let mut row_min = 0;\n        let mut row_min_index = 0;\n        let\
    \ mut col_min_index = 0;\n        let mut col_sum_index = 0;\n        let mut\
    \ col_sum_min_index = 0;\n        let mut row_sum_index = 0;\n        let mut\
    \ row_sum_min_index = 0;\n        let mut row_max_index = 0;\n        let mut\
    \ row_min_index = 0;\n        for col in row {\n            if col > col_max {\n\
    \                col_max = col;\n            }\n            if col < col_min {\n\
    \                col_min = col;\n            }\n            col_sum += col;\n\
    \            if col > col_sum_max {\n                col_sum_max = col;\n    \
    \        }\n            if col < col_sum_min {\n                col_sum_min =\
    \ col;\n            }\n            row_sum += col;\n            if col > row_sum_max\
    \ {\n                row_sum_max = col;\n            }\n            if col < row_sum_min\
    \ {\n                row_sum_min = col;\n            }\n            row_max =\
    \ col;\n            if col > row_max {\n                row_max = col;\n     \
    \       }\n            if col < row_min {\n                row_min = col;\n  \
    \          }\n            if col > row_min_index {\n                row_min_index\
    \ = col;\n            }\n            if col < col_min_index {\n              \
    \  col_min_index = col;\n            }\n            if col > col_sum_index {\n\
    \                col_sum_index = col;\n            }\n            if col < col_sum_min_index\
    \ {\n                col_sum_min_index = col;\n            }\n            if col\
    \ > \n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpr0rcnqiw.rs:104:3\n\
    \    |\n16  | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    |                                                                   -\
    \ unclosed delimiter\n...\n36  |     for row in lst {\n    |                 \
    \   - unclosed delimiter\n...\n53  |         for col in row {\n    |         \
    \               - this delimiter might not be properly closed...\n...\n94  | }\n\
    \    | - ...as it matches this but it has different indentation\n...\n104 | }\n\
    \    |   ^\n\nerror: expected expression, found `}`\n  --> /tmp/tmpr0rcnqiw.rs:94:1\n\
    \   |\n94 | }\n   | ^ expected expression\n\nerror[E0425]: cannot find value `col_sum_min`\
    \ in this scope\n  --> /tmp/tmpr0rcnqiw.rs:64:22\n   |\n64 |             if col\
    \ < col_sum_min {\n   |                      ^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `col_sum_max`\n\nerror[E0425]: cannot find value\
    \ `col_sum_min` in this scope\n  --> /tmp/tmpr0rcnqiw.rs:65:17\n   |\n65 |   \
    \              col_sum_min = col;\n   |                 ^^^^^^^^^^^ help: a local\
    \ variable with a similar name exists: `col_sum_max`\n\nerror[E0425]: cannot find\
    \ value `row_sum_min` in this scope\n  --> /tmp/tmpr0rcnqiw.rs:71:22\n   |\n71\
    \ |             if col < row_sum_min {\n   |                      ^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `row_sum_max`\n\nerror[E0425]:\
    \ cannot find value `row_sum_min` in this scope\n  --> /tmp/tmpr0rcnqiw.rs:72:17\n\
    \   |\n72 |                 row_sum_min = col;\n   |                 ^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `row_sum_max`\n\nerror[E0308]:\
    \ mismatched types\n   --> /tmp/tmpr0rcnqiw.rs:36:5\n    |\n16  |   fn get_row(lst:\
    \ Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    |                 \
    \                                ------------------- expected `Vec<(isize, isize)>`\
    \ because of return type\n...\n36  | /     for row in lst {\n37  | |         let\
    \ mut col_max = 0;\n38  | |         let mut col_min = 0;\n39  | |         let\
    \ mut col_sum = 0;\n...   |\n103 | |     assert"
  stdout: ''
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    for row in lst {\n        let mut cols = vec![];\n   \
    \     for col in row.iter().cloned() {\n            cols.push((col, row.iter().cloned().filter(|&x|\
    \ x == x).count()));\n        }\n        cols.sort_by_key(|&(_, count)| -count);\n\
    \        cols.sort_by_key(|&(_, count)| count);\n        result.push(cols.iter().cloned().map(|&(_,\
    \ count)| {\n            (count, row.iter().cloned().filter(|&x| x == x).count())\n\
    \        }).collect::<Vec<_>>());\n    }\n    result.sort_by_key(|&(_, count)|\
    \ -count);\n    result.sort_by_key(|&(_, count)| count);\n    result.iter().cloned().map(|&(_,\
    \ count)| {\n        (count, vec![])\n    }).collect::<Vec<_>>()\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmpp1z77wo_.rs:23:40\n\
    \   |\n23 |         cols.sort_by_key(|&(_, count)| -count);\n   |            \
    \                            ^^^^^^ cannot apply unary operator `-`\n   |\n  \
    \ = note: unsigned values cannot be negated\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpp1z77wo_.rs:25:47\n   |\n25 |         result.push(cols.iter().cloned().map(|&(_,\
    \ count)| {\n   |                                               ^^^^^^^^^^-\n\
    \   |                                               |         |\n   |        \
    \                                       |         expected due to this\n   | \
    \                                              expected tuple, found reference\n\
    \   |\n   = note:  expected tuple `(isize, usize)`\n           found reference\
    \ `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp1z77wo_.rs:29:26\n  \
    \ |\n29 |     result.sort_by_key(|&(_, count)| -count);\n   |                \
    \          ^^^^^^^^^-\n   |                          |        |\n   |        \
    \                  |        expected due to this\n   |                       \
    \   expected struct `Vec`, found tuple\n   |\n   = note: expected struct `Vec<(_,\
    \ usize)>`\n               found tuple `(_, _)`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpp1z77wo_.rs:30:26\n   |\n30 |     result.sort_by_key(|&(_, count)|\
    \ count);\n   |                          ^^^^^^^^^-\n   |                    \
    \      |        |\n   |                          |        expected due to this\n\
    \   |                          expected struct `Vec`, found tuple\n   |\n   =\
    \ note: expected struct `Vec<(_, usize)>`\n               found tuple `(_, _)`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpp1z77wo_.rs:31:33\n   |\n31 |\
    \     result.iter().cloned().map(|&(_, count)| {\n   |                       \
    \          ^^^^^^^^^^-\n   |                                 |         |\n   |\
    \                                 |         expected due to this\n   |       \
    \                          expected struct `Vec`, found reference\n   |\n   =\
    \ note: expected struct `Vec<(_, usize)>`\n           found r"
  stdout: ''
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n\
    \    let mut row_idx = 0;\n    let mut col_idx = 0;\n    while row_idx < rows\
    \ {\n        while col_idx < cols {\n            if lst[row_idx][col_idx] == x\
    \ {\n                result.push((row_idx, col_idx));\n                break;\n\
    \            }\n            col_idx += 1;\n        }\n        col_idx = 0;\n \
    \       row_idx += 1;\n    }\n    result.sort_by_key(|&(x, y)| x.0);\n    result.sort_by_key(|&(x,\
    \ y)| y.0);\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0610]: `usize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmpokev0spl.rs:33:36\n   |\n33 |     result.sort_by_key(|&(x, y)|\
    \ x.0);\n   |                                    ^\n\nerror[E0610]: `usize` is\
    \ a primitive type and therefore doesn't have fields\n  --> /tmp/tmpokev0spl.rs:34:36\n\
    \   |\n34 |     result.sort_by_key(|&(x, y)| y.0);\n   |                     \
    \               ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpokev0spl.rs:35:5\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n35 |     result\n   |   \
    \  ^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n              found struct `Vec<(usize, usize)>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0610.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut row_idx2\
    \ = 0;\n    let mut row_idx3 = 0;\n    let mut row_idx4 = 0;\n    let mut row_idx5\
    \ = 0;\n    let mut row_idx6 = 0;\n    let mut row_idx7 = 0;\n    let mut row_idx8\
    \ = 0;\n    let mut row_idx9 = 0;\n    let mut row_idx10 = 0;\n    let mut row_idx11\
    \ = 0;\n    let mut row_idx12 = 0;\n    let mut row_idx13 = 0;\n    let mut row_idx14\
    \ = 0;\n    let mut row_idx15 = 0;\n    let mut row_idx16 = 0;\n    let mut row_idx17\
    \ = 0;\n    let mut row_idx18 = 0;\n    let mut row_idx19 = 0;\n    let mut row_idx20\
    \ = 0;\n    let mut row_idx21 = 0;\n    let mut row_idx22 = 0;\n    let mut row_idx23\
    \ = 0;\n    let mut row_idx24 = 0;\n    let mut row_idx25 = 0;\n    let mut row_idx26\
    \ = 0;\n    let mut row_idx27 = 0;\n    let mut row_idx28 = 0;\n    let mut row_idx29\
    \ = 0;\n    let mut row_idx30 = 0;\n    let mut row_idx31 = 0;\n    let mut row_idx32\
    \ = 0;\n    let mut row_idx33 = 0;\n    let mut row_idx34 = 0;\n    let mut row_idx35\
    \ = 0;\n    let mut row_idx36 = 0;\n    let mut row_idx37 = 0;\n    let mut row_idx38\
    \ = 0;\n    let mut row_idx39 = 0;\n    let mut row_idx40 = 0;\n    let mut row_idx41\
    \ = 0;\n    let mut row_idx42 = 0;\n    let mut row_idx43 = 0;\n    let mut row_idx44\
    \ = 0;\n    let mut row_idx45 = 0;\n    let mut row_idx46 = 0;\n    let mut row_idx47\
    \ = 0;\n    let mut row_idx48 = 0;\n    let mut row_idx49 = 0;\n    let mut row_idx50\
    \ = 0;\n    let mut row_idx51 = 0;\n    let mut row_idx52 = 0;\n    let mut row_idx53\
    \ = 0;\n    let mut row_idx54 = 0;\n    let mut row_idx55 = 0;\n    let mut row_idx56\
    \ = 0;\n    let mut row_idx57 = 0;\n    let mut row_idx58 = 0;\n    let mut row_idx59\
    \ = 0;\n    let mut row_idx60 = 0;\n    let mut row_idx61 = 0;\n    let mut row_idx62\
    \ = 0;\n    let mut row_\n}\n\nfn main() {\n    let candidate = get_row;\n   \
    \ assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1,\
    \ 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmppjyfu577.rs:80:17\n   |\n\
    80 |     let mut row_\n   |                 ^ help: add `;` here\n81 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppjyfu577.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows = lst.len();\n    let mut cols = lst[0].len();\n    let mut coords = vec![];\n\
    \    let mut row_coords = vec![];\n    let mut col_coords = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sor\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpa1objz2n.rs:68:20\n   |\n\
    68 |     let mut row_sor\n   |                    ^ help: add `;` here\n69 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa1objz2n.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    for row\
    \ in lst {\n        row_idx += row.iter().enumerate().map(|(i, _)| i);\n     \
    \   row_sorted = row_sorted.into_iter().sorted();\n        row_sorted.for_each(|i|\
    \ {\n            col_idx += row.iter().enumerate().map(|(_, j)| j);\n        \
    \    col_sorted = col_sorted.into_iter().sorted();\n            col_sorted.for_each(|j|\
    \ {\n                if i == j {\n                    result.push((row_idx[i],\
    \ col_idx[j]));\n                }\n            });\n        });\n    }\n    result.sort_by(|a,\
    \ b| b.1.cmp(&a.1));\n    result.sort_by(|a, b| b.2.cmp(&a.2));\n    result\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `Vec<_>`\n  --> /tmp/tmpumqqb0rq.rs:23:9\n   |\n23 |         row_idx += row.iter().enumerate().map(|(i,\
    \ _)| i);\n   |         -------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  \
    \ |         |\n   |         cannot use `+=` on type `Vec<_>`\n\nerror[E0599]:\
    \ no method named `sorted` found for struct `std::vec::IntoIter` in the current\
    \ scope\n  --> /tmp/tmpumqqb0rq.rs:24:45\n   |\n24 |         row_sorted = row_sorted.into_iter().sorted();\n\
    \   |                                             ^^^^^^ method not found in `std::vec::IntoIter<_>`\n\
    \nerror[E0599]: the method `for_each` exists for struct `Vec<_>`, but its trait\
    \ bounds were not satisfied\n   --> /tmp/tmpumqqb0rq.rs:25:20\n    |\n25  |  \
    \         row_sorted.for_each(|i| {\n    |                      ^^^^^^^^ method\
    \ cannot be called on `Vec<_>` due to unsatisfied trait bounds\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `Vec<_>: Iterator`\n\
    \            which is required by `&mut Vec<_>: Iterator`\n            `[_]: Iterator`\n\
    \            which is required by `&mut [_]: Iterator`\n\nerror[E0368]: binary\
    \ assignment operation `+=` cannot be applied to type `Vec<_>`\n  --> /tmp/tmpumqqb0rq.rs:26:13\n\
    \   |\n26 |             col_idx += row.iter().enumerate().map(|(_, j)| j);\n \
    \  |             -------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |     \
    \        |\n   |             cannot use `+=` on type `Vec<_>`\n\nerror[E0599]:\
    \ no method named `sorted` found for struct `std::vec::IntoIter` in the current\
    \ scope\n  --> /tmp/tmpumqqb0rq.rs:27:49\n   |\n27 |             col_sorted =\
    \ col_sorted.into_iter().sorted();\n   |                                     \
    \            ^^^^^^ method not found in `std::vec::IntoIter<_>`\n\nerror[E0599]:\
    \ the method `for_each` exists for struct `Vec<_>`, but its trait bounds were\
    \ not satisfied\n   --> /tmp/tmpumqqb0rq.rs:28:24\n    |\n28  |              \
    \ col_sorted.for_each(|j| {\n    |                          ^^^^^^^^ method cannot\
    \ be called on `Vec<_>` due to unsatisfied trait boun"
  stdout: ''
  timestamp: 1659749648
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows = lst.len();\n    let mut cols = lst[0].len();\n    let mut result = vec![];\n\
    \    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n\
    \    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut\
    \ col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n  \
    \  let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut\
    \ col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n  \
    \  let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut\
    \ col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n  \
    \  let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mu\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwsp2bs41.rs:71:11\n   |\n\
    71 |     let mu\n   |           ^ help: add `;` here\n72 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwsp2bs41.rs:16:47\n \
    \  |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n\
    \   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749648
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idxs = vec![];\n    let mut col_idxs = vec![];\n    let mut row_idxs_sorted\
    \ = vec![];\n    let mut col_idxs_sorted = vec![];\n    let mut row_idxs_sorted\
    \ = vec![];\n    let mut col_idxs_sorted = vec![];\n    let mut row_idxs_sorted\
    \ = vec![];\n    let mut col_idxs_sorted = vec![];\n    let mut row_idxs_sorted\
    \ = vec![];\n    let mut col_idxs_sorted = vec![];\n    let mut row_idxs_sorted\
    \ = vec![];\n    let mut col_idxs_sorted = vec![];\n    let mut row_idxs_sorted\
    \ = vec![];\n    let mut col_idxs_sorted = vec![];\n    let mut row_idxs_sorted\
    \ = vec![];\n    let mut col_idxs_sorted = vec![];\n    let mut row_idxs_sorted\
    \ = vec![];\n    let mut col_idxs_sorted = vec![];\n    let mut row_idxs_sorted\
    \ = vec![];\n    let mut col_idxs_sorted = vec![];\n    let mut row_idxs_sorted\
    \ = vec![];\n    let mut col_idxs_sorted = vec![];\n    let mut row_idxs_sorted\
    \ = vec![];\n    let mut col_idxs_sorted = vec![];\n    let mut row_idxs_sorted\
    \ = vec![];\n    let mut col_idxs_sorted = vec![];\n    let mut row_idxs_sorted\
    \ = vec![];\n    let mut col_idxs_sorted = vec![];\n    let mut row_idxs_sorted\
    \ = vec![];\n    let mut col_idxs_sorted = vec![];\n    let mut row_idxs_sorted\
    \ = vec![];\n    let mut col_idxs_sorted = vec![];\n    let mut row_idxs_sorted\
    \ = vec![];\n    let mut col_idxs_sorted = vec![];\n    let mut row_idxs_sorted\
    \ = vec![];\n    let mut col_idxs_sorted = vec![];\n    let mut row_idxs_sorted\
    \ = vec![];\n    let mut col_idxs_sorted = vec![];\n    let mut row_idxs_sorted\
    \ = vec![];\n    let mu\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_vzsk0ul.rs:61:11\n   |\n\
    61 |     let mu\n   |           ^ help: add `;` here\n62 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_vzsk0ul.rs:16:47\n \
    \  |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n\
    \   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749648
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut row_idx = 1;\n    let mut col_idx = 1;\n    let\
    \ mut row_len = lst.len();\n    let mut col_len = lst[0].len();\n    while row_idx\
    \ < row_len {\n        let mut row_result = vec![];\n        while col_idx < col_len\
    \ {\n            if lst[row_idx][col_idx] == x {\n                row_result.push((row_idx,\
    \ col_idx));\n                col_idx++;\n            } else {\n             \
    \   break;\n            }\n        }\n        result.push(row_result);\n     \
    \   row_idx++;\n        col_idx = 1;\n    }\n    result.sort_by_key(|&(_, y)|\
    \ y.reverse());\n    result.sort_by_key(|&(_, y)| y.reverse());\n    result\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `+`\n  --> /tmp/tmpoz9vbbq6.rs:27:25\n\
    \   |\n27 |                 col_idx++;\n   |                         ^ expected\
    \ expression\n\nerror: expected expression, found `+`\n  --> /tmp/tmpoz9vbbq6.rs:33:17\n\
    \   |\n33 |         row_idx++;\n   |                 ^ expected expression\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpoz9vbbq6.rs:36:26\n   |\n36 |  \
    \   result.sort_by_key(|&(_, y)| y.reverse());\n   |                         \
    \ ^^^^^-\n   |                          |    |\n   |                         \
    \ |    expected due to this\n   |                          expected struct `Vec`,\
    \ found tuple\n   |\n   = note: expected struct `Vec<(usize, usize)>`\n      \
    \         found tuple `(_, _)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoz9vbbq6.rs:37:26\n\
    \   |\n37 |     result.sort_by_key(|&(_, y)| y.reverse());\n   |             \
    \             ^^^^^-\n   |                          |    |\n   |             \
    \             |    expected due to this\n   |                          expected\
    \ struct `Vec`, found tuple\n   |\n   = note: expected struct `Vec<(usize, usize)>`\n\
    \               found tuple `(_, _)`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpoz9vbbq6.rs:38:5\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize)\
    \ -> Vec<(isize, isize)> {\n   |                                             \
    \  ------------------- expected `Vec<(isize, isize)>` because of return type\n\
    ...\n38 |     result\n   |     ^^^^^^ expected tuple, found struct `Vec`\n   |\n\
    \   = note: expected struct `Vec<(isize, isize)>`\n              found struct\
    \ `Vec<Vec<(usize, usize)>>`\n\nerror: aborting due to 5 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749648
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows = lst.len();\n    let mut cols = lst[0].len();\n    let mut coords = vec![];\n\
    \    let mut row_coords = vec![];\n    let mut col_coords = vec![];\n    let mut\
    \ row_sort = vec![];\n    let mut col_sort = vec![];\n    let mut row_sort_idx\
    \ = vec![];\n    let mut col_sort_idx = vec![];\n    let mut row_sort_idx2 = vec![];\n\
    \    let mut col_sort_idx2 = vec![];\n    let mut row_sort_idx3 = vec![];\n  \
    \  let mut col_sort_idx3 = vec![];\n    let mut row_sort_idx4 = vec![];\n    let\
    \ mut col_sort_idx4 = vec![];\n    let mut row_sort_idx5 = vec![];\n    let mut\
    \ col_sort_idx5 = vec![];\n    let mut row_sort_idx6 = vec![];\n    let mut col_sort_idx6\
    \ = vec![];\n    let mut row_sort_idx7 = vec![];\n    let mut col_sort_idx7 =\
    \ vec![];\n    let mut row_sort_idx8 = vec![];\n    let mut col_sort_idx8 = vec![];\n\
    \    let mut row_sort_idx9 = vec![];\n    let mut col_sort_idx9 = vec![];\n  \
    \  let mut row_sort_idx10 = vec![];\n    let mut col_sort_idx10 = vec![];\n  \
    \  let mut row_sort_idx11 = vec![];\n    let mut col_sort_idx11 = vec![];\n  \
    \  let mut row_sort_idx12 = vec![];\n    let mut col_sort_idx12 = vec![];\n  \
    \  let mut row_sort_idx13 = vec![];\n    let mut col_sort_idx13 = vec![];\n  \
    \  let mut row_sort_idx14 = vec![];\n    let mut col_sort_idx14 = vec![];\n  \
    \  let mut row_sort_idx15 = vec![];\n    let mut col_sort_idx15 = vec![];\n  \
    \  let mut row_sort_idx16 = vec![];\n    let mut col_sort_idx16 = vec![];\n  \
    \  let mut row_sort_idx17 = vec![];\n    let mut col_sort_idx17 = vec![];\n  \
    \  let mut row_sort_idx18 = vec![];\n    let mut col_sort_idx18 = vec![];\n  \
    \  let mut row_sort_idx19 = vec![];\n    let mut col_sort_idx19 = vec![];\n  \
    \  let mut row_sort_idx20 = vec![];\n    let mut \n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp8uz9w704.rs:64:1\n\
    \   |\n64 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659749648
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n\
    \    let mut row_idx = 0;\n    let mut col_idx = 0;\n    while row_idx < rows\
    \ {\n        let mut row_result = vec![];\n        while col_idx < cols {\n  \
    \          if row_idx == row_idx {\n                row_result.push((row_idx,\
    \ col_idx));\n            }\n            if row_idx < rows && col_idx < cols {\n\
    \                if lst[row_idx][col_idx] == x {\n                    row_result.push((row_idx,\
    \ col_idx));\n                }\n            }\n            col_idx++;\n     \
    \   }\n        result.push(row_result);\n        row_idx++;\n        col_idx =\
    \ 0;\n    }\n    result.sort_by_key(|&(_, y)| y.cmp(&x));\n    result.sort_by_key(|&(_,\
    \ y)| y.cmp(&x));\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `+`\n  --> /tmp/tmpkkxlbzqc.rs:33:21\n\
    \   |\n33 |             col_idx++;\n   |                     ^ expected expression\n\
    \nerror: expected expression, found `+`\n  --> /tmp/tmpkkxlbzqc.rs:36:17\n   |\n\
    36 |         row_idx++;\n   |                 ^ expected expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkkxlbzqc.rs:39:26\n   |\n39 |     result.sort_by_key(|&(_,\
    \ y)| y.cmp(&x));\n   |                          ^^^^^-\n   |                \
    \          |    |\n   |                          |    expected due to this\n \
    \  |                          expected struct `Vec`, found tuple\n   |\n   = note:\
    \ expected struct `Vec<(usize, usize)>`\n               found tuple `(_, _)`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpkkxlbzqc.rs:40:26\n   |\n40 |\
    \     result.sort_by_key(|&(_, y)| y.cmp(&x));\n   |                         \
    \ ^^^^^-\n   |                          |    |\n   |                         \
    \ |    expected due to this\n   |                          expected struct `Vec`,\
    \ found tuple\n   |\n   = note: expected struct `Vec<(usize, usize)>`\n      \
    \         found tuple `(_, _)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkkxlbzqc.rs:41:5\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n41 |     result\n   |   \
    \  ^^^^^^ expected tuple, found struct `Vec`\n   |\n   = note: expected struct\
    \ `Vec<(isize, isize)>`\n              found struct `Vec<Vec<(usize, usize)>>`\n\
    \nerror: aborting due to 5 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749648
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows = lst.len();\n    let mut cols = lst[0].len();\n    let mut coords = vec![];\n\
    \    let mut row_coords = vec![];\n    let mut col_coords = vec![];\n    let mut\
    \ row_sort = vec![];\n    let mut col_sort = vec![];\n    let mut i = 0;\n   \
    \ let mut j = 0;\n    while i < rows {\n        let mut row_sort = vec![];\n \
    \       let mut col_sort = vec![];\n        let mut row_coords = vec![];\n   \
    \     let mut col_coords = vec![];\n        let mut i = 0;\n        let mut j\
    \ = 0;\n        while i < rows {\n            if i == x {\n                row_sort.push(i);\n\
    \                col_sort.push(j);\n                row_coords.push((i, j));\n\
    \                col_coords.push((i, j));\n            }\n            i += 1;\n\
    \        }\n        row_sort.sort();\n        col_sort.sort();\n        row_coords.sort();\n\
    \        col_coords.sort();\n        coords.push(row_coords);\n        coords.push(col_coords);\n\
    \        i += 1;\n        j += 1;\n    }\n    coords\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2viyb78f.rs:34:21\n   |\n\
    34 |             if i == x {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n34 |             if i == x.try_into().unwrap()\
    \ {\n   |                     ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2viyb78f.rs:51:5\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>,\
    \ x: isize) -> Vec<(isize, isize)> {\n   |                                   \
    \            ------------------- expected `Vec<(isize, isize)>` because of return\
    \ type\n...\n51 |     coords\n   |     ^^^^^^ expected tuple, found struct `Vec`\n\
    \   |\n   = note: expected struct `Vec<(isize, isize)>`\n              found struct\
    \ `Vec<Vec<(usize, {integer})>>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749648
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows = lst.len();\n    let mut cols = lst[0].len();\n    let mut coords = vec![];\n\
    \    let mut row = 0;\n    let mut col = 0;\n    while row < rows {\n        while\
    \ col < cols {\n            if lst[row][col] == x {\n                coords.push((row,\
    \ col));\n                break;\n            }\n            col += 1;\n     \
    \   }\n        row += 1;\n        col = 0;\n    }\n    coords.sort_by_key(|&(_,\
    \ y)| y.reverse());\n    coords.sort_by_key(|&(_, y)| y.reverse());\n    coords\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmpy9pre_yf.rs:33:36\n   |\n33 |     coords.sort_by_key(|&(_,\
    \ y)| y.reverse());\n   |                                    ^^^^^^^ method not\
    \ found in `usize`\n\nerror[E0599]: no method named `reverse` found for type `usize`\
    \ in the current scope\n  --> /tmp/tmpy9pre_yf.rs:34:36\n   |\n34 |     coords.sort_by_key(|&(_,\
    \ y)| y.reverse());\n   |                                    ^^^^^^^ method not\
    \ found in `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy9pre_yf.rs:35:5\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n35 |     coords\n   |   \
    \  ^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n              found struct `Vec<(usize, usize)>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749648
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n\
    \    let mut row_idx = 0;\n    let mut col_idx = 0;\n    while row_idx < rows\
    \ {\n        while col_idx < cols {\n            if lst[row_idx][col_idx] == x\
    \ {\n                result.push((row_idx, col_idx));\n                break;\n\
    \            }\n            col_idx += 1;\n        }\n        col_idx = 0;\n \
    \       row_idx += 1;\n    }\n    result.sort_by_key(|&(x, y)| x.0);\n    result.sort_by_key(|&(x,\
    \ y)| y.0);\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0610]: `usize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmpokev0spl.rs:33:36\n   |\n33 |     result.sort_by_key(|&(x, y)|\
    \ x.0);\n   |                                    ^\n\nerror[E0610]: `usize` is\
    \ a primitive type and therefore doesn't have fields\n  --> /tmp/tmpokev0spl.rs:34:36\n\
    \   |\n34 |     result.sort_by_key(|&(x, y)| y.0);\n   |                     \
    \               ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpokev0spl.rs:35:5\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n35 |     result\n   |   \
    \  ^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n              found struct `Vec<(usize, usize)>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0610.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows: Vec<(isize, isize)> = vec![];\n    let mut row_idx: Vec<isize> = vec![];\n\
    \    let mut row_idx2: Vec<isize> = vec![];\n    let mut row_idx3: Vec<isize>\
    \ = vec![];\n    let mut row_idx4: Vec<isize> = vec![];\n    let mut row_idx5:\
    \ Vec<isize> = vec![];\n    let mut row_idx6: Vec<isize> = vec![];\n    let mut\
    \ row_idx7: Vec<isize> = vec![];\n    let mut row_idx8: Vec<isize> = vec![];\n\
    \    let mut row_idx9: Vec<isize> = vec![];\n    let mut row_idx10: Vec<isize>\
    \ = vec![];\n    let mut row_idx11: Vec<isize> = vec![];\n    let mut row_idx12:\
    \ Vec<isize> = vec![];\n    let mut row_idx13: Vec<isize> = vec![];\n    let mut\
    \ row_idx14: Vec<isize> = vec![];\n    let mut row_idx15: Vec<isize> = vec![];\n\
    \    let mut row_idx16: Vec<isize> = vec![];\n    let mut row_idx17: Vec<isize>\
    \ = vec![];\n    let mut row_idx18: Vec<isize> = vec![];\n    let mut row_idx19:\
    \ Vec<isize> = vec![];\n    let mut row_idx20: Vec<isize> = vec![];\n    let mut\
    \ row_idx21: Vec<isize> = vec![];\n    let mut row_idx22: Vec<isize> = vec![];\n\
    \    let mut row_idx23: Vec<isize> = vec![];\n    let mut row_idx24: Vec<isize>\
    \ = vec![];\n    let mut row_idx25: Vec<isize> = vec![];\n    let mut row_idx26:\
    \ Vec<isize> = vec![];\n    let mut row_idx27: Vec<isize> = vec![];\n    let mut\
    \ row_idx28: Vec<isize> = vec![];\n    let mut row_idx29: Vec<isize> = vec![];\n\
    \    let mut row_idx30: \n}\n\nfn main() {\n    let candidate = get_row;\n   \
    \ assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1,\
    \ 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected type, found `}`\n  --> /tmp/tmp5pr78efa.rs:48:1\n   |\n\
    47 |     let mut row_idx30: \n   |         ------------- while parsing the type\
    \ for `mut row_idx30`\n48 | }\n   | ^ expected type\n\nerror: aborting due to\
    \ previous error\n\n"
  stdout: ''
  timestamp: 1659749648
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx: Vec<isize> = vec![];\n\
    \    let mut row_idx_idx: Vec<isize> = vec![];\n    let mut row_idx_idx_idx: Vec<isize>\
    \ = vec![];\n    let mut row_idx_idx_idx_idx: Vec<isize> = vec![];\n    let mut\
    \ row_idx_idx_idx_idx_idx: Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx: Vec<isize>\
    \ = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx: Vec<isize> = vec![];\n\
    \    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx: Vec<isize> = vec![];\n \
    \   let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx: Vec<isize> = vec![];\n\
    \    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx: Vec<isize> = vec![];\n\
    \    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx: Vec<isize> =\
    \ vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxh2zn75s.rs:37:21\n   |\n\
    37 |     let mut row_idx_\n   |                     ^ help: add `;` here\n38 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxh2zn75s.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749648
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    for row in lst {\n        let mut row_result = vec![];\n\
    \        for cell in row {\n            if cell == x {\n                row_result.push((cell,\
    \ cell));\n            }\n        }\n        result.push(row_result);\n    }\n\
    \    result.sort_by_key(|x| x.0);\n    result.sort_by_key(|x| x.1, |a, b| b.cmp(a));\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `0` on type `&Vec<(isize, isize)>`\n  --> /tmp/tmp8obg29m4.rs:27:30\n\
    \   |\n27 |     result.sort_by_key(|x| x.0);\n   |                           \
    \   ^ unknown field\n\nerror[E0061]: this function takes 1 argument but 2 arguments\
    \ were supplied\n   --> /tmp/tmp8obg29m4.rs:28:12\n    |\n28  |     result.sort_by_key(|x|\
    \ x.1, |a, b| b.cmp(a));\n    |            ^^^^^^^^^^^ -------  ---------------\
    \ supplied 2 arguments\n    |            |\n    |            expected 1 argument\n\
    \    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8obg29m4.rs:29:5\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x:\
    \ isize) -> Vec<(isize, isize)> {\n   |                                      \
    \         ------------------- expected `Vec<(isize, isize)>` because of return\
    \ type\n...\n29 |     result\n   |     ^^^^^^ expected tuple, found struct `Vec`\n\
    \   |\n   = note: expected struct `Vec<(isize, isize)>`\n              found struct\
    \ `Vec<Vec<(isize, isize)>>`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0061, E0308, E0609.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659749648
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    let mut row_len = 0;\n    let mut col_len = 0;\n    let mut row_start\
    \ = 0;\n    let mut col_start = 0;\n    let mut row_end = 0;\n    let mut col_end\
    \ = 0;\n    let mut row_start2 = 0;\n    let mut col_start2 = 0;\n    let mut\
    \ row_end2 = 0;\n    let mut col_end2 = 0;\n    let mut row_start3 = 0;\n    let\
    \ mut col_start3 = 0;\n    let mut row_end3 = 0;\n    let mut col_end3 = 0;\n\
    \    let mut row_start4 = 0;\n    let mut col_start4 = 0;\n    let mut row_end4\
    \ = 0;\n    let mut col_end4 = 0;\n    let mut row_start5 = 0;\n    let mut col_start5\
    \ = 0;\n    let mut row_end5 = 0;\n    let mut col_end5 = 0;\n    let mut row_start6\
    \ = 0;\n    let mut col_start6 = 0;\n    let mut row_end6 = 0;\n    let mut col_end6\
    \ = 0;\n    let mut row_start7 = 0;\n    let mut col_start7 = 0;\n    let mut\
    \ row_end7 = 0;\n    let mut col_end7 = 0;\n    let mut row_start8 = 0;\n    let\
    \ mut col_start8 = 0;\n    let mut row_end8 = 0;\n    let mut col_end8 = 0;\n\
    \    let mut row_start9 = 0;\n    let mut col_start9 = 0;\n    let mut row_end9\
    \ = 0;\n    let mut col_end9 = 0;\n    let mut row_start10 = 0;\n    let mut col_start10\
    \ = 0;\n    let mut row_end10 = 0;\n    let mut col_end10 = 0;\n    let mut row_start11\
    \ = 0;\n    let mut col_start11 = 0;\n    let mut row_end11 = 0;\n    let mut\
    \ col_end11 = 0;\n    let mut row_start12 = 0;\n    let mut col_start12 = 0;\n\
    \    let mut row_end12 = 0;\n    let mut col_end12 = 0;\n    let mut row_start13\
    \ = 0;\n    let mut col_start13 = 0;\n    let mut row_end13 = 0;\n    let mut\
    \ col_end13 = 0;\n    let mut row_start14 = 0;\n    let mut col_start14 = 0;\n\
    \    let mut row_end14 = 0;\n    let mut col_end14 = 0;\n    let mut row_start15\
    \ = 0;\n    let mut col_start15 = 0;\n    let mut row_end15 = 0;\n    let mut\
    \ col_end15 = 0;\n    let mut row_start16 = 0;\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgk2gxbys.rs:16:47\n   |\n\
    16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \    -------                                    ^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749648
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n\
    \    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_idx2 = vec![];\n\
    \    let mut col_idx2 = vec![];\n    let mut row_sorted2 = vec![];\n    let mut\
    \ col_sorted2 = vec![];\n    let mut row_idx3 = vec![];\n    let mut col_idx3\
    \ = vec![];\n    let mut row_sorted3 = vec![];\n    let mut col_sorted3 = vec![];\n\
    \    let mut row_idx4 = vec![];\n    let mut col_idx4 = vec![];\n    let mut row_sorted4\
    \ = vec![];\n    let mut col_sorted4 = vec![];\n    let mut row_idx5 = vec![];\n\
    \    let mut col_idx5 = vec![];\n    let mut row_sorted5 = vec![];\n    let mut\
    \ col_sorted5 = vec![];\n    let mut row_idx6 = vec![];\n    let mut col_idx6\
    \ = vec![];\n    let mut row_sorted6 = vec![];\n    let mut col_sorted6 = vec![];\n\
    \    let mut row_idx7 = vec![];\n    let mut col_idx7 = vec![];\n    let mut row_sorted7\
    \ = vec![];\n    let mut col_sorted7 = vec![];\n    let mut row_idx8 = vec![];\n\
    \    let mut col_idx8 = vec![];\n    let mut row_sorted8 = vec![];\n    let mut\
    \ col_sorted8 = vec![];\n    let mut row_idx9 = vec![];\n    let mut col_idx9\
    \ = vec![];\n    let mut row_sorted9 = vec![];\n    let mut col_sorted9 = vec![];\n\
    \    let mut row_idx10 = vec![];\n    let mut col_idx10 = vec![];\n    let mut\
    \ row_sorted10 = vec![];\n    let mut col_sorted10 = vec![];\n    let mut row_idx11\
    \ = vec![];\n    let mut col_idx11 = vec![];\n    let mut row_sorted11 = vec![];\n\
    \    let mut col_sorted11 = vec![];\n    let mut row_idx12 = vec![];\n    let\
    \ mut col_idx12 = vec![];\n    let mut row_sorted12 = vec![];\n    let mut col_sorted12\
    \ = vec![];\n    let mut row_idx13 = vec\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpulywony8.rs:68:28\n   |\n\
    68 |     let mut row_idx13 = vec\n   |                            ^ help: add\
    \ `;` here\n69 | }\n   | - unexpected token\n\nerror[E0423]: expected value, found\
    \ macro `vec`\n  --> /tmp/tmpulywony8.rs:68:25\n   |\n68 |     let mut row_idx13\
    \ = vec\n   |                         ^^^ not a value\n   |\nhelp: use `!` to\
    \ invoke the macro\n   |\n68 |     let mut row_idx13 = vec!\n   |            \
    \                +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpulywony8.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0423.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749648
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut row_len\
    \ = 0;\n    let mut col_len = 0;\n    for row in lst {\n        row_len += row.len();\n\
    \        col_len += row.iter().map(|x| x.len()).sum();\n    }\n    let mut col_len:\
    \ isize = col_len;\n    let mut row_len: isize = row_len;\n    let mut row_idx:\
    \ isize = 0;\n    let mut col_len: isize = col_len;\n    let mut row_idx: isize\
    \ = 0;\n    for row in lst {\n        let mut col_len: isize = row.iter().map(|x|\
    \ x.len()).sum();\n        let mut row_len: isize = row.len();\n        let mut\
    \ row_idx: isize = 0;\n        for col in row {\n            if row_idx == x {\n\
    \                row.push(row_idx, col_len);\n                row_idx += 1;\n\
    \            }\n            col_len -= 1;\n        }\n        row_idx += 1;\n\
    \        col_len += 1;\n    }\n    row.sort_by_key(|&(_, y)| y.cmp(&y));\n   \
    \ row.sort_by_key(|&(_, y)| y.cmp(&y));\n    row\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for reference `&isize` in the\
    \ current scope\n  --> /tmp/tmprr1xljn2.rs:23:41\n   |\n23 |         col_len +=\
    \ row.iter().map(|x| x.len()).sum();\n   |                                   \
    \      ^^^ method not found in `&isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmprr1xljn2.rs:26:30\n   |\n26 |     let mut row_len: isize = row_len;\n\
    \   |                      -----   ^^^^^^^ expected `isize`, found `usize`\n \
    \  |                      |\n   |                      expected due to this\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n26 |     let mut row_len: isize = row_len.try_into().unwrap();\n\
    \   |                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]:\
    \ no method named `len` found for reference `&isize` in the current scope\n  -->\
    \ /tmp/tmprr1xljn2.rs:31:55\n   |\n31 |         let mut col_len: isize = row.iter().map(|x|\
    \ x.len()).sum();\n   |                                                      \
    \ ^^^ method not found in `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprr1xljn2.rs:32:34\n\
    \   |\n32 |         let mut row_len: isize = row.len();\n   |                \
    \          -----   ^^^^^^^^^ expected `isize`, found `usize`\n   |           \
    \               |\n   |                          expected due to this\n   |\n\
    help: you can convert a `usize` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n32 |         let mut row_len: isize = row.len().try_into().unwrap();\n\
    \   |                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]:\
    \ this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmprr1xljn2.rs:36:21\n\
    \     |\n36   |                 row.push(row_idx, col_len);\n     |          \
    \           ^^^^ -------  ------- supplied 2 arguments\n     |               \
    \      |\n     |                     expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0061, E0308, E0599.\nFor more information about\
    \ an"
  stdout: ''
  timestamp: 1659749648
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n\
    \    let mut row_idx = 0;\n    let mut col_idx = 0;\n    while row_idx < rows\
    \ {\n        let mut row_sorted = vec![];\n        while col_idx < cols {\n  \
    \          if row_idx == row_idx {\n                row_sorted.push((row_idx,\
    \ col_idx));\n            }\n            if row_idx < row_idx {\n            \
    \    col_idx++;\n            }\n            if row_idx > row_idx {\n         \
    \       row_idx++;\n                col_idx = 0;\n            }\n        }\n \
    \       row_sorted.sort_by_key(|&(_, y)| y.cmp(&x));\n        result.push(row_sorted);\n\
    \    }\n    result.sort_by_key(|&(_, y)| y.cmp(&x));\n    result\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `+`\n  --> /tmp/tmpu3r89h0e.rs:29:25\n\
    \   |\n29 |                 col_idx++;\n   |                         ^ expected\
    \ expression\n\nerror: expected expression, found `+`\n  --> /tmp/tmpu3r89h0e.rs:32:25\n\
    \   |\n32 |                 row_idx++;\n   |                         ^ expected\
    \ expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu3r89h0e.rs:36:48\n\
    \   |\n36 |         row_sorted.sort_by_key(|&(_, y)| y.cmp(&x));\n   |       \
    \                                         ^^ expected `usize`, found `isize`\n\
    \   |\n   = note: expected reference `&usize`\n              found reference `&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpu3r89h0e.rs:39:26\n   |\n39 |\
    \     result.sort_by_key(|&(_, y)| y.cmp(&x));\n   |                         \
    \ ^^^^^-\n   |                          |    |\n   |                         \
    \ |    expected due to this\n   |                          expected struct `Vec`,\
    \ found tuple\n   |\n   = note: expected struct `Vec<(usize, usize)>`\n      \
    \         found tuple `(_, _)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu3r89h0e.rs:40:5\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n40 |     result\n   |   \
    \  ^^^^^^ expected tuple, found struct `Vec`\n   |\n   = note: expected struct\
    \ `Vec<(isize, isize)>`\n              found struct `Vec<Vec<(usize, usize)>>`\n\
    \nerror: aborting due to 5 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749648
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ coords = vec![];\n    let mut rows = vec![];\n    let mut cols = vec![];\n \
    \   for row in lst {\n        let mut row_coords = vec![];\n        let mut row_cols\
    \ = vec![];\n        for col in row {\n            if col == x {\n           \
    \     row_coords.push((row, col));\n                row_cols.push((col, col));\n\
    \            }\n        }\n        rows.push(row_coords);\n        cols.push(row_cols);\n\
    \    }\n    coords.sort_by(|a, b| a.0.cmp(&b.0));\n    rows.sort_by(|a, b| b.0.cmp(&a.0));\n\
    \    cols.sort_by(|a, b| b.0.cmp(&a.0));\n    coords\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `&T`\n  --> /tmp/tmpl8zdmghy.rs:32:21\n\
    \   |\n32 |     coords.sort_by(|a, b| a.0.cmp(&b.0));\n   |                  \
    \   ^ consider giving this closure parameter the explicit type `&T`, where the\
    \ type parameter `T` is specified\n   |\n   = note: type must be known at this\
    \ point\n\nerror[E0609]: no field `0` on type `&_`\n  --> /tmp/tmpl8zdmghy.rs:32:29\n\
    \   |\n32 |     coords.sort_by(|a, b| a.0.cmp(&b.0));\n   |                  \
    \           ^\n\nerror[E0609]: no field `0` on type `&Vec<(Vec<isize>, isize)>`\n\
    \  --> /tmp/tmpl8zdmghy.rs:33:27\n   |\n33 |     rows.sort_by(|a, b| b.0.cmp(&a.0));\n\
    \   |                           ^ unknown field\n\nerror[E0609]: no field `0`\
    \ on type `&Vec<(Vec<isize>, isize)>`\n  --> /tmp/tmpl8zdmghy.rs:33:36\n   |\n\
    33 |     rows.sort_by(|a, b| b.0.cmp(&a.0));\n   |                           \
    \         ^ unknown field\n\nerror[E0609]: no field `0` on type `&Vec<(isize,\
    \ isize)>`\n  --> /tmp/tmpl8zdmghy.rs:34:27\n   |\n34 |     cols.sort_by(|a, b|\
    \ b.0.cmp(&a.0));\n   |                           ^ unknown field\n\nerror[E0609]:\
    \ no field `0` on type `&Vec<(isize, isize)>`\n  --> /tmp/tmpl8zdmghy.rs:34:36\n\
    \   |\n34 |     cols.sort_by(|a, b| b.0.cmp(&a.0));\n   |                    \
    \                ^ unknown field\n\nerror: aborting due to 6 previous errors\n\
    \nSome errors have detailed explanations: E0282, E0609.\nFor more information\
    \ about an error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659749648
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut row_idx_max\
    \ = 0;\n    let mut row_idx_min = 0;\n    let mut row_idx_max_idx = 0;\n    let\
    \ mut row_idx_min_idx = 0;\n    let mut col_max = 0;\n    let mut col_min = 0;\n\
    \    let mut col_max_idx = 0;\n    let mut col_min_idx = 0;\n    let mut col_max_idx2\
    \ = 0;\n    let mut col_min_idx2 = 0;\n    let mut col_max_idx3 = 0;\n    let\
    \ mut col_min_idx3 = 0;\n    let mut col_max_idx4 = 0;\n    let mut col_min_idx4\
    \ = 0;\n    let mut col_max_idx5 = 0;\n    let mut col_min_idx5 = 0;\n    let\
    \ mut col_max_idx6 = 0;\n    let mut col_min_idx6 = 0;\n    let mut col_max_idx7\
    \ = 0;\n    let mut col_min_idx7 = 0;\n    let mut col_max_idx8 = 0;\n    let\
    \ mut col_min_idx8 = 0;\n    let mut col_max_idx9 = 0;\n    let mut col_min_idx9\
    \ = 0;\n    let mut col_max_idx10 = 0;\n    let mut col_min_idx10 = 0;\n    let\
    \ mut col_max_idx11 = 0;\n    let mut col_min_idx11 = 0;\n    let mut col_max_idx12\
    \ = 0;\n    let mut col_min_idx12 = 0;\n    let mut col_max_idx13 = 0;\n    let\
    \ mut col_min_idx13 = 0;\n    let mut col_max_idx14 = 0;\n    let mut col_min_idx14\
    \ = 0;\n    let mut col_max_idx15 = 0;\n    let mut col_min_idx15 = 0;\n    let\
    \ mut col_max_idx16 = 0;\n    let mut col_min_idx16 = 0;\n    let mut col_max_idx17\
    \ = 0;\n    let mut col_min_idx17 = 0;\n    let mut col_max_idx18 = 0;\n    let\
    \ mut col_min_idx18 = 0;\n    let mut col_max_idx19 = 0;\n    let mut col_min_idx19\
    \ = 0;\n    let mut col_max_idx20 = 0;\n    let mut col_min_idx20 = 0;\n    let\
    \ mut col_max_idx21 = 0;\n    let mut col_min_idx21 = 0;\n    let mut col_max_idx22\
    \ = 0;\n    let mut col_min_idx22 = 0;\n    let mut col_max_idx23 = 0;\n    let\
    \ mut col_min_idx23 = 0;\n    let mut col_max_idx24 = 0;\n    let mut col_min_idx24\
    \ = 0;\n    let mut col_max_idx25 = 0;\n    let mut col_min_idx25 = 0;\n\n}\n\n\
    fn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpar3_awuh.rs:16:47\n   |\n\
    16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \    -------                                    ^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749648
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows = lst.len();\n    let mut cols = lst[0].len();\n    let mut coords = vec![];\n\
    \    let mut row_coords = vec![];\n    let mut col_coords = vec![];\n    let mut\
    \ row_coord = vec![];\n    let mut col_coord = vec![];\n    let mut i = 0;\n \
    \   let mut j = 0;\n    while i < rows {\n        while j < cols {\n         \
    \   if lst[i][j] == x {\n                row_coord.push((i, j));\n           \
    \     col_coord.push((j, i));\n                coords.push(row_coord);\n     \
    \           coords.push(col_coord);\n                i += 1;\n               \
    \ j += 1;\n                break;\n            }\n            i += 1;\n      \
    \  }\n    }\n    coords.sort_by(|a, b| a.0.cmp(&b.0));\n    coords.sort_by(|a,\
    \ b| b.0.cmp(&a.0));\n    coords.reverse();\n    coords.sort_by(|a, b| b.1.cmp(&a.1));\n\
    \    coords.reverse();\n    coords\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `0` on type `&Vec<(usize, usize)>`\n  --> /tmp/tmpvum9ytlc.rs:40:29\n\
    \   |\n40 |     coords.sort_by(|a, b| a.0.cmp(&b.0));\n   |                  \
    \           ^ unknown field\n\nerror[E0609]: no field `0` on type `&Vec<(usize,\
    \ usize)>`\n  --> /tmp/tmpvum9ytlc.rs:40:38\n   |\n40 |     coords.sort_by(|a,\
    \ b| a.0.cmp(&b.0));\n   |                                      ^ unknown field\n\
    \nerror[E0609]: no field `0` on type `&Vec<(usize, usize)>`\n  --> /tmp/tmpvum9ytlc.rs:41:29\n\
    \   |\n41 |     coords.sort_by(|a, b| b.0.cmp(&a.0));\n   |                  \
    \           ^ unknown field\n\nerror[E0609]: no field `0` on type `&Vec<(usize,\
    \ usize)>`\n  --> /tmp/tmpvum9ytlc.rs:41:38\n   |\n41 |     coords.sort_by(|a,\
    \ b| b.0.cmp(&a.0));\n   |                                      ^ unknown field\n\
    \nerror[E0609]: no field `1` on type `&Vec<(usize, usize)>`\n  --> /tmp/tmpvum9ytlc.rs:43:29\n\
    \   |\n43 |     coords.sort_by(|a, b| b.1.cmp(&a.1));\n   |                  \
    \           ^ unknown field\n\nerror[E0609]: no field `1` on type `&Vec<(usize,\
    \ usize)>`\n  --> /tmp/tmpvum9ytlc.rs:43:38\n   |\n43 |     coords.sort_by(|a,\
    \ b| b.1.cmp(&a.1));\n   |                                      ^ unknown field\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpvum9ytlc.rs:45:5\n   |\n16 | fn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |     \
    \                                          ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n45 |     coords\n   |     ^^^^^^ expected\
    \ tuple, found struct `Vec`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \              found struct `Vec<Vec<(usize, usize)>>`\n\nerror: aborting due\
    \ to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0609.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749648
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ coords = vec![];\n    let mut rows = vec![];\n    for row in lst {\n       \
    \ let mut cols = vec![];\n        for col in row {\n            if col == x {\n\
    \                coords.push((row, col));\n            }\n            cols.push(col);\n\
    \        }\n        rows.push(cols);\n    }\n    coords.sort_by(|a, b| a.1.cmp(&b.1));\n\
    \    coords.sort_by(|a, b| b.1.cmp(&a.1));\n    coords.reverse();\n    coords.sort_by(|a,\
    \ b| b.0.cmp(&a.0));\n    coords.reverse();\n    coords\n}\n\nfn main() {\n  \
    \  let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4g6_oz0w.rs:34:5\n   |\n\
    16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \                                               ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n34 |     coords\n   |     ^^^^^^ expected\
    \ `isize`, found struct `Vec`\n   |\n   = note: expected struct `Vec<(isize, _)>`\n\
    \              found struct `Vec<(Vec<isize>, _)>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749648
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n\
    \    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sort\
    \ = vec![];\n    let mut col_sort = vec![];\n    let mut row_sort_idx = vec![];\n\
    \    let mut col_sort_idx = vec![];\n    let mut row_sort_reverse = vec![];\n\
    \    let mut col_sort_reverse = vec![];\n    let mut row_sort_reverse_idx = vec![];\n\
    \    let mut col_sort_reverse_idx = vec![];\n    let mut row_sort_reverse_idx\
    \ = vec![];\n    let mut col_sort_reverse_idx = vec![];\n    let mut row_sort_reverse_idx\
    \ = vec![];\n    let mut col_sort_reverse_idx = vec![];\n    let mut row_sort_reverse_idx\
    \ = vec![];\n    let mut col_sort_reverse_idx = vec![];\n    let mut row_sort_reverse_idx\
    \ = vec![];\n    let mut col_sort_reverse_idx = vec![];\n    let mut row_sort_reverse_idx\
    \ = vec![];\n    let mut col_sort_reverse_idx = vec![];\n    let mut row_sort_reverse_idx\
    \ = vec![];\n    let mut col_sort_reverse_idx = vec![];\n    let mut row_sort_reverse_idx\
    \ = vec![];\n    let mut col_sort_reverse_idx = vec![];\n    let mut row_sort_reverse_idx\
    \ = vec![];\n    let mut col_sort_reverse_idx = vec![];\n    let mut row_sort_reverse_idx\
    \ = vec![];\n    let mut col_sort_reverse_idx = vec![];\n    let mut row_sort_reverse_idx\
    \ = vec![];\n    let mut col_sort_reverse_idx = vec![];\n    let mut row_sort_reverse_idx\
    \ = vec![];\n    let mut col_sort_reverse_idx = vec![];\n    let mut row_sort_reverse_idx\
    \ = vec![];\n    let mut col_sort_reverse_idx = vec![];\n    let mut row_sort_reverse_idx\
    \ = vec![];\n    let mut col_sort_reverse_idx = vec![];\n    let mut row_sort_reverse_idx\
    \ = vec![];\n    let mut col_sort_reverse_idx = vec![];\n    let mut row_sort_reverse_idx\
    \ = vec![];\n    let mut col_sort_reverse_idx = vec![];\n    let mut row_sort_reverse_idx\
    \ = vec![];\n    let mut col_sort_reverse_idx = vec![];\n    let mut row_sort_reverse_idx\
    \ = vec![];\n    let mut col_sort_reverse_idx = vec![];\n    let mut row_sort_reverse_idx\
    \ = vec![];\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqqg5fhpc.rs:16:47\n   |\n\
    16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \    -------                                    ^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749648
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    for row in lst {\n        let mut row_result = vec![];\n\
    \        for col in row.iter().rev() {\n            if col == x {\n          \
    \      row_result.push((col, row.len()));\n            }\n        }\n        result.push(row_result);\n\
    \    }\n    result.sort_by(|a, b| a.iter().rev().cmp(b.iter().rev()));\n    result.sort_by(|a,\
    \ b| b.iter().rev().cmp(a.iter().rev()));\n    result\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp82hzksb_.rs:21:20\n\
    \   |\n21 |             if col == x {\n   |                    ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp82hzksb_.rs:29:5\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n29 |     result\n   |   \
    \  ^^^^^^ expected tuple, found struct `Vec`\n   |\n   = note: expected struct\
    \ `Vec<(isize, isize)>`\n              found struct `Vec<Vec<(&isize, usize)>>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749648
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows = lst.len();\n    let mut cols = lst[0].len();\n    let mut coords = vec![];\n\
    \    let mut row_coords = vec![];\n    let mut col_coords = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sort\
    \ = vec![];\n    let mut col_sort = vec![];\n    let mut row_sort_idx = vec![];\n\
    \    let mut col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n    let\
    \ mut col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n    let mut\
    \ col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n    let mut col_sort_idx\
    \ = vec![];\n    let mut row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n\
    \    let mut row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n    let\
    \ mut row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n    let mut\
    \ row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n    let mut row_sort_idx\
    \ = vec![];\n    let mut col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n\
    \    let mut col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n    let\
    \ mut col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n    let mut\
    \ col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n    let mut col_sort_idx\
    \ = vec![];\n    let mut row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n\
    \    let mut row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n    let\
    \ mut row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n    let mut\
    \ row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n    let mut row_sort_idx\
    \ = vec![];\n    let mut col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n\
    \    let mut col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n    let\
    \ mut col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n    let mut\
    \ col_sort_idx = vec![];\n    let mut row_sort_\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpucvttksj.rs:68:22\n   |\n\
    68 |     let mut row_sort_\n   |                      ^ help: add `;` here\n69\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpucvttksj.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx: Vec<isize> = vec![];\n\
    \    let mut row_idx_idx: Vec<isize> = vec![];\n    let mut row_idx_idx_idx: Vec<isize>\
    \ = vec![];\n    let mut row_idx_idx_idx_idx: Vec<isize> = vec![];\n    let mut\
    \ row_idx_idx_idx_idx_idx: Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx: Vec<isize>\
    \ = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx: Vec<isize> = vec![];\n\
    \    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx: Vec<isize> = vec![];\n \
    \   let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx: Vec<isize> = vec![];\n\
    \    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx: Vec<isize> = vec![];\n\
    \    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx: Vec<isize> =\
    \ vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let \n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp6bliisib.rs:38:1\n  \
    \ |\n38 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659749648
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ lst = lst.clone();\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n\
    \    let mut result = vec![];\n    while rows > 0 {\n        let mut cols = lst[0].len();\n\
    \        while cols > 0 {\n            let mut row = vec![];\n            for\
    \ _ in 0..cols {\n                row.push((0, 0));\n            }\n         \
    \   for (i, row) in lst.iter().enumerate() {\n                if row[0] == i {\n\
    \                    for (j, col) in row.iter().enumerate() {\n              \
    \          if col == x {\n                            result.push((i, j));\n \
    \                       }\n                    }\n                }\n        \
    \    }\n            cols = cols - 1;\n        }\n        rows = rows - 1;\n  \
    \  }\n    result.sort_by_key(|&(x, y)| x.0);\n    result.sort_by_key(|&(x, y)|\
    \ y.0);\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsbwoa4eu.rs:29:30\n   |\n\
    29 |                 if row[0] == i {\n   |                              ^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n29 |                 if\
    \ row[0] == i.try_into().unwrap() {\n   |                              ~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpsbwoa4eu.rs:31:32\n\
    \   |\n31 |                         if col == x {\n   |                      \
    \          ^^ no implementation for `&isize == isize`\n   |\n   = help: the trait\
    \ `PartialEq<isize>` is not implemented for `&isize`\n\nerror[E0610]: `usize`\
    \ is a primitive type and therefore doesn't have fields\n  --> /tmp/tmpsbwoa4eu.rs:41:36\n\
    \   |\n41 |     result.sort_by_key(|&(x, y)| x.0);\n   |                     \
    \               ^\n\nerror[E0610]: `usize` is a primitive type and therefore doesn't\
    \ have fields\n  --> /tmp/tmpsbwoa4eu.rs:42:36\n   |\n42 |     result.sort_by_key(|&(x,\
    \ y)| y.0);\n   |                                    ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpsbwoa4eu.rs:43:5\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>,\
    \ x: isize) -> Vec<(isize, isize)> {\n   |                                   \
    \            ------------------- expected `Vec<(isize, isize)>` because of return\
    \ type\n...\n43 |     result\n   |     ^^^^^^ expected `isize`, found `usize`\n\
    \   |\n   = note: expected struct `Vec<(isize, isize)>`\n              found struct\
    \ `Vec<(usize, usize)>`\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0610.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749648
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    while row_idx < lst.len() {\n        let mut row_len = lst[row_idx].len();\n\
    \        if row_len > col_idx {\n            rows.push((row_idx, col_idx));\n\
    \            row_idx += 1;\n            col_idx = 0;\n        }\n        col_idx\
    \ += 1;\n    }\n    rows\n        .iter()\n        .sort_by_key(|(_, y)| y.cmp(&x))\n\
    \        .map(|(_, y)| (y, row_idx))\n        .collect()\n}\n\nfn main() {\n \
    \   let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxxdstfa5.rs:23:24\n   |\n\
    23 |             rows.push((row_idx, col_idx));\n   |                        ^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n23 |           \
    \  rows.push((row_idx.try_into().unwrap(), col_idx));\n   |                  \
    \      ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxxdstfa5.rs:23:33\n\
    \   |\n23 |             rows.push((row_idx, col_idx));\n   |                 \
    \                ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n23 |             rows.push((row_idx, col_idx.try_into().unwrap()));\n \
    \  |                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]:\
    \ no method named `sort_by_key` found for struct `std::slice::Iter` in the current\
    \ scope\n  --> /tmp/tmpxxdstfa5.rs:31:10\n   |\n31 |         .sort_by_key(|(_,\
    \ y)| y.cmp(&x))\n   |          ^^^^^^^^^^^ method not found in `std::slice::Iter<'_,\
    \ (isize, isize)>`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749648
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut row_idx_max\
    \ = 0;\n    let mut row_idx_min = std::i32::MAX;\n    for row in lst {\n     \
    \   let row_len = row.len();\n        if row_len > row_idx_max {\n           \
    \ row_idx_max = row_len;\n        }\n        if row_len < row_idx_min {\n    \
    \        row_idx_min = row_len;\n        }\n    }\n    for row in lst {\n    \
    \    let row_len = row.len();\n        if row_len == row_idx_max {\n         \
    \   break;\n        }\n        let mut row_idx = 0;\n        let mut row_idx_max\
    \ = 0;\n        let mut row_idx_min = std::i32::MAX;\n        for row in lst {\n\
    \            let row_len = row.len();\n            if row_len > row_idx_max {\n\
    \                row_idx_max = row_len;\n            }\n            if row_len\
    \ < row_idx_min {\n                row_idx_min = row_len;\n            }\n   \
    \         if row_len == row_idx_max {\n                break;\n            }\n\
    \        }\n        if row_idx_min == row_idx_max {\n            break;\n    \
    \    }\n        let mut row_idx = 0;\n        let mut row_idx_max = 0;\n     \
    \   let mut row_idx_min = std::i32::MAX;\n        for row in lst {\n         \
    \   let row_len = row.len();\n            if row_len > row_idx_max {\n       \
    \         row_idx_max = row_len;\n            }\n            if row_len < row_idx_min\
    \ {\n                row_idx_min = row_len;\n            }\n            if row_len\
    \ == row_idx_max {\n                break;\n            }\n        }\n       \
    \ if row_idx_min == row_idx_max {\n            break;\n        }\n        if row_idx_min\
    \ > row_idx_max {\n            break;\n        }\n        let mut row_idx = 0;\n\
    \        let mut row_idx_max = 0;\n        let mut row_idx_min = std::i32::MAX;\n\
    \        for row in lst {\n            let row_len = row.len();\n            if\
    \ row_len > row_idx_max {\n                row_idx_max = row_len;\n          \
    \  }\n            if row_len < row_idx_min {\n                row_idx_min = row_len;\n\
    \            }\n            if row_len == row_idx_max {\n                break;\n\
    \            }\n        }\n        if row_idx_min == row_idx_max {\n         \
    \   break;\n        }\n        if row_idx_min > row_idx_max {\n            break;\n\
    \        }\n        let mut row_idx = 0;\n        let mut row_idx_max = 0;\n \
    \       let mut row_idx_min = std::i32::MAX;\n        for row in lst {\n     \
    \       let row_len = row.len();\n            if row_len > row_idx_max {\n   \
    \             row_idx_\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp40h1olsy.rs:112:3\n\
    \    |\n16  | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    |                                                                   -\
    \ unclosed delimiter\n...\n30  |     for row in lst {\n    |                 \
    \   - unclosed delimiter\n...\n98  |         for row in lst {\n    |         \
    \               - unclosed delimiter\n99  |             let row_len = row.len();\n\
    100 |             if row_len > row_idx_max {\n    |                          \
    \            - this delimiter might not be properly closed...\n101 |         \
    \        row_idx_\n102 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n112 | }\n    |   ^\n\nerror[E0425]: cannot find value `row_idx_`\
    \ in this scope\n   --> /tmp/tmp40h1olsy.rs:101:17\n    |\n101 |             \
    \    row_idx_\n    |                 ^^^^^^^^ help: a local variable with a similar\
    \ name exists: `row_idx`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp40h1olsy.rs:26:22\n\
    \   |\n26 |         if row_len < row_idx_min {\n   |                      ^^^^^^^^^^^\
    \ expected `usize`, found `i32`\n   |\nhelp: you can convert an `i32` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n26 |         if row_len\
    \ < row_idx_min.try_into().unwrap() {\n   |                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp40h1olsy.rs:27:27\n   |\n27 |\
    \             row_idx_min = row_len;\n   |                           ^^^^^^^ expected\
    \ `i32`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp40h1olsy.rs:43:26\n\
    \   |\n43 |             if row_len < row_idx_min {\n   |                     \
    \     ^^^^^^^^^^^ expected `usize`, found `i32`\n   |\nhelp: you can convert an\
    \ `i32` to a `usize` and panic if the converted value doesn't fit\n   |\n43 |\
    \             if row_len < row_idx_min.try_into().unwrap() {\n   |           \
    \               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp40h1olsy.rs:44:31\n   |\n44 |                 row_idx_min = row_len;\n\
    \   |        "
  stdout: ''
  timestamp: 1659749648
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut row_len\
    \ = 0;\n    let mut col_len = 0;\n    let mut col_pos = 0;\n    let mut col_pos_idx\
    \ = 0;\n    let mut col_pos_len = 0;\n    let mut col_pos_idx2 = 0;\n    let mut\
    \ col_pos_len2 = 0;\n    let mut col_pos_idx3 = 0;\n    let mut col_pos_len3 =\
    \ 0;\n    let mut col_pos_idx4 = 0;\n    let mut col_pos_len4 = 0;\n    let mut\
    \ col_pos_idx5 = 0;\n    let mut col_pos_len5 = 0;\n    let mut col_pos_idx6 =\
    \ 0;\n    let mut col_pos_len6 = 0;\n    let mut col_pos_idx7 = 0;\n    let mut\
    \ col_pos_len7 = 0;\n    let mut col_pos_idx8 = 0;\n    let mut col_pos_len8 =\
    \ 0;\n    let mut col_pos_idx9 = 0;\n    let mut col_pos_len9 = 0;\n    let mut\
    \ col_pos_idx10 = 0;\n    let mut col_pos_len10 = 0;\n    let mut col_pos_idx11\
    \ = 0;\n    let mut col_pos_len11 = 0;\n    let mut col_pos_idx12 = 0;\n    let\
    \ mut col_pos_len12 = 0;\n    let mut col_pos_idx13 = 0;\n    let mut col_pos_len13\
    \ = 0;\n    let mut col_pos_idx14 = 0;\n    let mut col_pos_len14 = 0;\n    let\
    \ mut col_pos_idx15 = 0;\n    let mut col_pos_len15 = 0;\n    let mut col_pos_idx16\
    \ = 0;\n    let mut col_pos_len16 = 0;\n    let mut col_pos_idx17 = 0;\n    let\
    \ mut col_pos_len17 = 0;\n    let mut col_pos_idx18 = 0;\n    let mut col_pos_len18\
    \ = 0;\n    let mut col_pos_idx19 = 0;\n    let mut col_pos_len19 = 0;\n    let\
    \ mut col_pos_idx20 = 0;\n    let mut col_pos_len20 = 0;\n    let mut col_pos_idx21\
    \ = 0;\n    let mut col_pos_len21 = 0;\n    let mut col_pos_idx22 = 0;\n    let\
    \ mut col_pos_len22 = 0;\n    let mut col_pos_idx23 = 0;\n    let mut col_pos_len23\
    \ = 0;\n    let mut col_pos_idx24 = 0;\n    let mut col_pos_len24 = 0;\n    let\
    \ mut col_pos_idx25 = 0;\n    let mut col_pos_len25 = 0;\n    let mut col_pos_idx26\
    \ = 0;\n    let mut col_pos_len26 = 0;\n    let mut col_pos_idx27 = 0;\n\n}\n\n\
    fn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3nuppifl.rs:16:47\n   |\n\
    16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \    -------                                    ^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749648
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut row_idx_max\
    \ = 0;\n    let mut col_max = 0;\n    let mut col_min = 0;\n    for row in lst\
    \ {\n        let mut col_max = 0;\n        let mut col_min = 0;\n        for col\
    \ in row {\n            if col > col_max {\n                col_max = col;\n \
    \           }\n            if col < col_min {\n                col_min = col;\n\
    \            }\n        }\n        if col_max > col_min {\n            row_idx_max\
    \ = row_idx;\n            row_idx += 1;\n        }\n        if row_idx > row_idx_max\
    \ {\n            row_idx_max = row_idx;\n            row_idx += 1;\n        }\n\
    \    }\n    let mut col_max = 0;\n    let mut col_min = 0;\n    for row in lst\
    \ {\n        let mut col_max = 0;\n        let mut col_min = 0;\n        for col\
    \ in row {\n            if col > col_max {\n                col_max = col;\n \
    \           }\n            if col < col_min {\n                col_min = col;\n\
    \            }\n        }\n        if col_max > col_min {\n            row_idx_max\
    \ = row_idx;\n            row_idx += 1;\n        }\n        if row_idx > row_idx_max\
    \ {\n            row_idx_max = row_idx;\n            row_idx += 1;\n        }\n\
    \    }\n    let mut row_max = 0;\n    let mut row_min = 0;\n    for row in lst\
    \ {\n        let mut row_max = 0;\n        let mut row_min = 0;\n        for col\
    \ in row {\n            if col > row_max {\n                row_max = col;\n \
    \           }\n            if col < row_min {\n                row_min = col;\n\
    \            }\n        }\n        if row_max > row_min {\n            row_idx_max\
    \ = row_idx;\n            row_idx += 1;\n        }\n        if row_idx > row_idx_max\
    \ {\n            row_idx_max = row_idx;\n            row_idx += 1;\n        }\n\
    \    }\n    let mut col_max = 0;\n    let mut col_min = 0;\n    for row in lst\
    \ {\n        let mut col_max = 0;\n        let mut col_min = 0;\n        for col\
    \ in row {\n            if col > col_max {\n                col_max = col;\n \
    \           }\n            if col < col_min {\n                col_min = col;\n\
    \            }\n        }\n        if col_max > col_min {\n            row_idx_max\
    \ = row_idx;\n            row_idx += 1;\n        }\n        if row_idx > row_idx_max\
    \ {\n            row_idx_max = row_idx;\n            row_\n}\n\nfn main() {\n\
    \    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp3cf7hv7y.rs:116:3\n\
    \    |\n16  | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    |                                                                   -\
    \ unclosed delimiter\n...\n88  |     for row in lst {\n    |                 \
    \   - unclosed delimiter\n...\n103 |         if row_idx > row_idx_max {\n    |\
    \                                  - this delimiter might not be properly closed...\n\
    ...\n106 | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n116 | }\n    |   ^\n\nerror[E0425]: cannot find value `row_` in this scope\n\
    \   --> /tmp/tmp3cf7hv7y.rs:105:13\n    |\n105 |             row_\n    |     \
    \        ^^^^ help: a local variable with a similar name exists: `row`\n\nerror[E0308]:\
    \ mismatched types\n   --> /tmp/tmp3cf7hv7y.rs:88:5\n    |\n16  |   fn get_row(lst:\
    \ Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    |                 \
    \                                ------------------- expected `Vec<(isize, isize)>`\
    \ because of return type\n...\n88  | /     for row in lst {\n89  | |         let\
    \ mut col_max = 0;\n90  | |         let mut col_min = 0;\n91  | |         for\
    \ col in row {\n...   |\n115 | |     assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n116 | | }\n    | |__^ expected struct `Vec`,\
    \ found `()`\n    |\n    = note: expected struct `Vec<(isize, isize)>`\n     \
    \       found unit type `()`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749648
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    for row in lst {\n        let mut row_result = vec![];\n\
    \        for col in row.iter().rev() {\n            if col == x {\n          \
    \      row_result.push((row, col));\n            }\n        }\n        result.push(row_result.iter().rev().cloned());\n\
    \    }\n    result.sort_by(|a, b| a.0.cmp(&b.0));\n    result.sort_by(|a, b| b.1.cmp(&a.1));\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp5uhsvmv5.rs:21:20\n\
    \   |\n21 |             if col == x {\n   |                    ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n\nerror[E0609]: no field `0` on type `&Cloned<Rev<std::slice::Iter<'_,\
    \ (Vec<isize>, &isize)>>>`\n  --> /tmp/tmp5uhsvmv5.rs:27:29\n   |\n27 |     result.sort_by(|a,\
    \ b| a.0.cmp(&b.0));\n   |                             ^ unknown field\n\nerror[E0609]:\
    \ no field `0` on type `&Cloned<Rev<std::slice::Iter<'_, (Vec<isize>, &isize)>>>`\n\
    \  --> /tmp/tmp5uhsvmv5.rs:27:38\n   |\n27 |     result.sort_by(|a, b| a.0.cmp(&b.0));\n\
    \   |                                      ^ unknown field\n\nerror[E0609]: no\
    \ field `1` on type `&Cloned<Rev<std::slice::Iter<'_, (Vec<isize>, &isize)>>>`\n\
    \  --> /tmp/tmp5uhsvmv5.rs:28:29\n   |\n28 |     result.sort_by(|a, b| b.1.cmp(&a.1));\n\
    \   |                             ^ unknown field\n\nerror[E0609]: no field `1`\
    \ on type `&Cloned<Rev<std::slice::Iter<'_, (Vec<isize>, &isize)>>>`\n  --> /tmp/tmp5uhsvmv5.rs:28:38\n\
    \   |\n28 |     result.sort_by(|a, b| b.1.cmp(&a.1));\n   |                  \
    \                    ^ unknown field\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp5uhsvmv5.rs:29:5\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize)\
    \ -> Vec<(isize, isize)> {\n   |                                             \
    \  ------------------- expected `Vec<(isize, isize)>` because of return type\n\
    ...\n29 |     result\n   |     ^^^^^^ expected tuple, found struct `Cloned`\n\
    \   |\n   = note: expected struct `Vec<(isize, isize)>`\n              found struct\
    \ `Vec<Cloned<Rev<std::slice::Iter<'_, (Vec<isize>, &isize)>>>>`\n\nerror: aborting\
    \ due to 6 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0609.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows = lst.len();\n    let mut cols = lst[0].len();\n    let mut coords = vec![];\n\
    \    let mut row_coords = vec![];\n    let mut col_coords = vec![];\n    let mut\
    \ row_sort = vec![];\n    let mut col_sort = vec![];\n    let mut i = 0;\n   \
    \ while i < rows {\n        let mut j = 0;\n        while j < cols {\n       \
    \     if lst[i][j] == x {\n                coords.push((i, j));\n            \
    \    row_sort.push(i);\n                col_sort.push(j);\n                i +=\
    \ 1;\n                j += 1;\n            } else {\n                j += 1;\n\
    \            }\n        }\n    }\n    row_coords.sort_by(|a, b| row_sort.iter().zip(a.iter()).map(|&(aa,\
    \ bb)| aa).cmp(&bb));\n    col_coords.sort_by(|a, b| col_sort.iter().zip(a.iter()).map(|&(aa,\
    \ bb)| aa).cmp(&bb));\n    coords.sort_by(|a, b| row_coords.iter().zip(a.iter()).map(|&(aa,\
    \ bb)| aa).cmp(&bb));\n    coords.sort_by(|a, b| col_coords.iter().zip(a.iter()).map(|&(aa,\
    \ bb)| aa).cmp(&bb));\n    coords\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `bb` in this scope\n  --> /tmp/tmppt_q0lqp.rs:39:86\n\
    \   |\n39 |     row_coords.sort_by(|a, b| row_sort.iter().zip(a.iter()).map(|&(aa,\
    \ bb)| aa).cmp(&bb));\n   |                                                  \
    \                                    ^^ help: a local variable with a similar\
    \ name exists: `b`\n\nerror[E0425]: cannot find value `bb` in this scope\n  -->\
    \ /tmp/tmppt_q0lqp.rs:40:86\n   |\n40 |     col_coords.sort_by(|a, b| col_sort.iter().zip(a.iter()).map(|&(aa,\
    \ bb)| aa).cmp(&bb));\n   |                                                  \
    \                                    ^^ help: a local variable with a similar\
    \ name exists: `b`\n\nerror[E0425]: cannot find value `bb` in this scope\n  -->\
    \ /tmp/tmppt_q0lqp.rs:41:84\n   |\n41 |     coords.sort_by(|a, b| row_coords.iter().zip(a.iter()).map(|&(aa,\
    \ bb)| aa).cmp(&bb));\n   |                                                  \
    \                                  ^^ help: a local variable with a similar name\
    \ exists: `b`\n\nerror[E0425]: cannot find value `bb` in this scope\n  --> /tmp/tmppt_q0lqp.rs:42:84\n\
    \   |\n42 |     coords.sort_by(|a, b| col_coords.iter().zip(a.iter()).map(|&(aa,\
    \ bb)| aa).cmp(&bb));\n   |                                                  \
    \                                  ^^ help: a local variable with a similar name\
    \ exists: `b`\n\nerror[E0282]: type annotations needed for `&T`\n  --> /tmp/tmppt_q0lqp.rs:39:25\n\
    \   |\n39 |     row_coords.sort_by(|a, b| row_sort.iter().zip(a.iter()).map(|&(aa,\
    \ bb)| aa).cmp(&bb));\n   |                         ^ consider giving this closure\
    \ parameter the explicit type `&T`, where the type parameter `T` is specified\n\
    \   |\n   = note: type must be known at this point\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmppt_q0lqp.rs:39:66\n   |\n39 |     row_coords.sort_by(|a,\
    \ b| row_sort.iter().zip(a.iter()).map(|&(aa, bb)| aa).cmp(&bb));\n   |      \
    \                                                            ^^^^^^^^-\n   | \
    \                                                                 |       |\n\
    \   |                              "
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ lst = lst.clone();\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n\
    \    let mut coords = vec![];\n    let mut row_coords = vec![];\n    let mut col_coords\
    \ = vec![];\n    let mut row_sort = vec![];\n    let mut col_sort = vec![];\n\
    \    let mut i = 0;\n    while i < rows {\n        row_sort.push(row_coords.len());\n\
    \        col_sort.push(col_coords.len());\n        row_coords.clear();\n     \
    \   col_coords.clear();\n        coords.clear();\n        row_coords.push(i);\n\
    \        col_coords.push(i);\n        coords.push((row_coords.len(), col_coords.len()));\n\
    \        i += 1;\n    }\n    while i < rows {\n        let mut j = 0;\n      \
    \  while j < cols {\n            if lst[i][j] == x {\n                row_sort.push(row_coords.len());\n\
    \                col_sort.push(col_coords.len());\n                row_coords.clear();\n\
    \                col_coords.clear();\n                coords.clear();\n      \
    \          row_coords.push(i);\n                col_coords.push(j);\n        \
    \        coords.push((row_coords.len(), col_coords.len()));\n                i\
    \ += 1;\n                j += 1;\n            }\n            j += 1;\n       \
    \ }\n    }\n    for i in row_sort {\n        row_coords.swap(i);\n    }\n    for\
    \ i in col_sort {\n        col_coords.swap(i);\n    }\n    for i in row_coords.iter()\
    \ {\n        for j in col_coords.iter() {\n            coords.push((i, j));\n\
    \        }\n    }\n    coords\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 2 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpfcg9rv95.rs:56:20\n    |\n56  |         row_coords.swap(i);\n\
    \    |                    ^^^^ - supplied 1 argument\n    |                  \
    \  |\n    |                    expected 2 arguments\n    |\nnote: associated function\
    \ defined here\n\nerror[E0061]: this function takes 2 arguments but 1 argument\
    \ was supplied\n   --> /tmp/tmpfcg9rv95.rs:59:20\n    |\n59  |         col_coords.swap(i);\n\
    \    |                    ^^^^ - supplied 1 argument\n    |                  \
    \  |\n    |                    expected 2 arguments\n    |\nnote: associated function\
    \ defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfcg9rv95.rs:63:26\n\
    \   |\n63 |             coords.push((i, j));\n   |                          ^\
    \ expected `usize`, found `&usize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n63 |             coords.push((*i, j));\n   |                          +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpfcg9rv95.rs:63:29\n   |\n63 |\
    \             coords.push((i, j));\n   |                             ^ expected\
    \ `usize`, found `&usize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    63 |             coords.push((i, *j));\n   |                             +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpfcg9rv95.rs:66:5\n   |\n16 | fn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |     \
    \                                          ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n66 |     coords\n   |     ^^^^^^ expected\
    \ `isize`, found `usize`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \              found struct `Vec<(usize, usize)>`\n\nerror: aborting due to 5\
    \ previous errors\n\nSome errors have detailed explanations: E0061, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659749648
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows: Vec<(isize, isize)> = vec![];\n    let mut row_idx: usize = 0;\n    let\
    \ mut col_idx: usize = 0;\n    let mut row_size: usize = 0;\n    let mut col_count:\
    \ usize = 0;\n    for row in lst {\n        row_idx += 1;\n        row_size +=\
    \ row.len();\n        if row_idx == x {\n            let mut cols: Vec<(isize,\
    \ isize)> = vec![];\n            for col in row {\n                col_idx +=\
    \ 1;\n                col_count += 1;\n                cols.push((col_idx, col));\n\
    \            }\n            rows.push((row_idx, cols));\n        }\n    }\n  \
    \  rows\n        .into_iter()\n        .sort_by(|a, b| a.0.cmp(&b.0))\n      \
    \  .map(|a| a.1)\n        .collect()\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnzfst5zw.rs:25:23\n   |\n\
    25 |         if row_idx == x {\n   |                       ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n25 |         if row_idx == x.try_into().unwrap()\
    \ {\n   |                       ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnzfst5zw.rs:30:28\n   |\n30 |                 cols.push((col_idx,\
    \ col));\n   |                            ^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n30 |                 cols.push((col_idx.try_into().unwrap(),\
    \ col));\n   |                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnzfst5zw.rs:32:24\n   |\n32 |             rows.push((row_idx,\
    \ cols));\n   |                        ^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n32 |             rows.push((row_idx.try_into().unwrap(),\
    \ cols));\n   |                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnzfst5zw.rs:32:33\n   |\n32 |             rows.push((row_idx,\
    \ cols));\n   |                                 ^^^^ expected `isize`, found struct\
    \ `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<(isize,\
    \ isize)>`\n\nerror[E0599]: no method named `sort_by` found for struct `std::vec::IntoIter`\
    \ in the current scope\n  --> /tmp/tmpnzfst5zw.rs:37:10\n   |\n37 |         .sort_by(|a,\
    \ b| a.0.cmp(&b.0))\n   |          ^^^^^^^ method not found in `std::vec::IntoIter<(isize,\
    \ isize)>`\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749648
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx: Vec<isize> = vec![];\n\
    \    let mut row_idx2: Vec<isize> = vec![];\n    let mut row_idx3: Vec<isize>\
    \ = vec![];\n    let mut row_idx4: Vec<isize> = vec![];\n    let mut row_idx5:\
    \ Vec<isize> = vec![];\n    let mut row_idx6: Vec<isize> = vec![];\n    let mut\
    \ row_idx7: Vec<isize> = vec![];\n    let mut row_idx8: Vec<isize> = vec![];\n\
    \    let mut row_idx9: Vec<isize> = vec![];\n    let mut row_idx10: Vec<isize>\
    \ = vec![];\n    let mut row_idx11: Vec<isize> = vec![];\n    let mut row_idx12:\
    \ Vec<isize> = vec![];\n    let mut row_idx13: Vec<isize> = vec![];\n    let mut\
    \ row_idx14: Vec<isize> = vec![];\n    let mut row_idx15: Vec<isize> = vec![];\n\
    \    let mut row_idx16: Vec<isize> = vec![];\n    let mut row_idx17: Vec<isize>\
    \ = vec![];\n    let mut row_idx18: Vec<isize> = vec![];\n    let mut row_idx19:\
    \ Vec<isize> = vec![];\n    let mut row_idx20: Vec<isize> = vec![];\n    let mut\
    \ row_idx21: Vec<isize> = vec![];\n    let mut row_idx22: Vec<isize> = vec![];\n\
    \    let mut row_idx23: Vec<isize> = vec![];\n    let mut row_idx24: Vec<isize>\
    \ = vec![];\n    let mut row_idx25: Vec<isize> = vec![];\n    let mut row_idx26:\
    \ Vec<isize> = vec![];\n    let mut row_idx27: Vec<isize> = vec![];\n    let mut\
    \ row_idx28: Vec<isize> = vec![];\n    let mut row_idx29: Vec<isize> = vec![];\n\
    \    let mut row_idx30: \n}\n\nfn main() {\n    let candidate = get_row;\n   \
    \ assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1,\
    \ 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected type, found `}`\n  --> /tmp/tmpn5ksppg3.rs:48:1\n   |\n\
    47 |     let mut row_idx30: \n   |         ------------- while parsing the type\
    \ for `mut row_idx30`\n48 | }\n   | ^ expected type\n\nerror: aborting due to\
    \ previous error\n\n"
  stdout: ''
  timestamp: 1659749648
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut\
    \ col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n  \
    \  let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut\
    \ col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n  \
    \  let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut\
    \ col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n  \
    \  let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut\
    \ col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n  \
    \  let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let \n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpzfv6u_ru.rs:72:1\n  \
    \ |\n72 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx: Vec<isize> = vec![];\n\
    \    let mut row_idx_idx: Vec<isize> = vec![];\n    let mut row_idx_idx_idx: Vec<isize>\
    \ = vec![];\n    let mut row_idx_idx_idx_idx: Vec<isize> = vec![];\n    let mut\
    \ row_idx_idx_idx_idx_idx: Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx: Vec<isize>\
    \ = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx: Vec<isize> = vec![];\n\
    \    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx: Vec<isize> = vec![];\n \
    \   let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx: Vec<isize> = vec![];\n\
    \    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx: Vec<isize> = vec![];\n\
    \    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx: Vec<isize> =\
    \ vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxh2zn75s.rs:37:21\n   |\n\
    37 |     let mut row_idx_\n   |                     ^ help: add `;` here\n38 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxh2zn75s.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749648
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows: Vec<(isize, isize)> = vec![];\n    let mut row_idx: usize = 0;\n    let\
    \ mut col_idx: usize = 0;\n    let mut row_size: usize = 0;\n    let mut col_count:\
    \ usize = 0;\n    for row in lst {\n        row_idx += 1;\n        row_size +=\
    \ row.len();\n        if row_idx == x {\n            let mut cols: Vec<(isize,\
    \ isize)> = vec![];\n            for col in row {\n                col_idx +=\
    \ 1;\n                col_count += 1;\n                cols.push((col_idx, col));\n\
    \            }\n            rows.push((row_idx, cols));\n        }\n    }\n  \
    \  rows.sort_by_key(|(_, cols)| cols.iter().rev().map(|(_, col)| col).collect::<Vec<_>>());\n\
    \    rows.sort_by_key(|(_, cols)| cols.iter().rev().map(|(_, col)| col).collect::<Vec<_>>()).reverse();\n\
    \    rows\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpad9_xbie.rs:25:23\n   |\n\
    25 |         if row_idx == x {\n   |                       ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n25 |         if row_idx == x.try_into().unwrap()\
    \ {\n   |                       ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpad9_xbie.rs:30:28\n   |\n30 |                 cols.push((col_idx,\
    \ col));\n   |                            ^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n30 |                 cols.push((col_idx.try_into().unwrap(),\
    \ col));\n   |                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpad9_xbie.rs:32:24\n   |\n32 |             rows.push((row_idx,\
    \ cols));\n   |                        ^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n32 |             rows.push((row_idx.try_into().unwrap(),\
    \ cols));\n   |                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpad9_xbie.rs:32:33\n   |\n32 |             rows.push((row_idx,\
    \ cols));\n   |                                 ^^^^ expected `isize`, found struct\
    \ `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<(isize,\
    \ isize)>`\n\nerror[E0599]: no method named `iter` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmpad9_xbie.rs:35:39\n   |\n35 |     rows.sort_by_key(|(_,\
    \ cols)| cols.iter().rev().map(|(_, col)| col).collect::<Vec<_>>());\n   |   \
    \                                    ^^^^ method not found in `&isize`\n\nerror[E0599]:\
    \ no method named `iter` found for reference `&isize` in the current scope\n \
    \ --> /tmp/tmpad9_xbie.rs:36:39\n   |\n36 |     rows.sort_by_key(|(_, cols)| cols.iter().rev().map(|(_,\
    \ col)| col).collect::<Vec<_>>()).reverse();\n   |                           \
    \            ^^^^ method"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted = \n}\n\n\
    fn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp9ts34w6m.rs:69:1\n\
    \   |\n69 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659749648
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut row_idx_max\
    \ = 0;\n    let mut row_idx_min = 0;\n    let mut col_max = 0;\n    let mut col_min\
    \ = 0;\n    let mut col_max2 = 0;\n    let mut col_min2 = 0;\n    let mut col_max3\
    \ = 0;\n    let mut col_min3 = 0;\n    let mut col_max4 = 0;\n    let mut col_min4\
    \ = 0;\n    let mut col_max5 = 0;\n    let mut col_min5 = 0;\n    let mut col_max6\
    \ = 0;\n    let mut col_min6 = 0;\n    let mut col_max7 = 0;\n    let mut col_min7\
    \ = 0;\n    let mut col_max8 = 0;\n    let mut col_min8 = 0;\n    let mut col_max9\
    \ = 0;\n    let mut col_min9 = 0;\n    let mut col_max10 = 0;\n    let mut col_min10\
    \ = 0;\n    let mut col_max11 = 0;\n    let mut col_min11 = 0;\n    let mut col_max12\
    \ = 0;\n    let mut col_min12 = 0;\n    let mut col_max13 = 0;\n    let mut col_min13\
    \ = 0;\n    let mut col_max14 = 0;\n    let mut col_min14 = 0;\n    let mut col_max15\
    \ = 0;\n    let mut col_min15 = 0;\n    let mut col_max16 = 0;\n    let mut col_min16\
    \ = 0;\n    let mut col_max17 = 0;\n    let mut col_min17 = 0;\n    let mut col_max18\
    \ = 0;\n    let mut col_min18 = 0;\n    let mut col_max19 = 0;\n    let mut col_min19\
    \ = 0;\n    let mut col_max20 = 0;\n    let mut col_min20 = 0;\n    let mut col_max21\
    \ = 0;\n    let mut col_min21 = 0;\n    let mut col_max22 = 0;\n    let mut col_min22\
    \ = 0;\n    let mut col_max23 = 0;\n    let mut col_min23 = 0;\n    let mut col_max24\
    \ = 0;\n    let mut col_min24 = 0;\n    let mut col_max25 = 0;\n    let mut col_min25\
    \ = 0;\n    let mut col_max26 = 0;\n    let mut col_min26 = 0;\n    let mut col_max27\
    \ = 0;\n    let mut col_min27 = 0;\n    let mut col_max28 = 0;\n    let mut col_min28\
    \ = 0;\n    let mut col_max29 = 0;\n    let mut col_min29 = 0;\n    let mut col_max30\
    \ = 0;\n    let mut col_min30 = 0;\n    let mu\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpsa7tzda6.rs:81:11\n   |\n\
    81 |     let mu\n   |           ^ help: add `;` here\n82 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsa7tzda6.rs:16:47\n \
    \  |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n\
    \   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idxs = vec![];\n    let mut col_idxs = vec![];\n    let mut row_sorted =\
    \ vec![];\n    let mut col_sorted = vec![];\n    let mut row_idxs = vec![];\n\
    \    let mut col_idxs = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut row_idxs = vec![];\n    let mut col_idxs =\
    \ vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_idxs = vec![];\n    let mut col_idxs = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_idxs = vec![];\n\
    \    let mut col_idxs = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut row_idxs = vec![];\n    let mut col_idxs =\
    \ vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_idxs = vec![];\n    let mut col_idxs = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_idxs = vec![];\n\
    \    let mut col_idxs = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut row_idxs = vec![];\n    let mut col_idxs =\
    \ vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_idxs = vec![];\n    let mut col_idxs = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_idxs = vec![];\n\
    \    let mut col_idxs = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut row_idxs = vec![];\n    let mut col_idxs =\
    \ vec![];\n    let mut row_sorted = \n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpx7eumwzh.rs:69:1\n\
    \   |\n69 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659749648
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n\
    \    let mut row_idx = 0;\n    let mut col_idx = 0;\n    while row_idx < rows\
    \ {\n        if col_idx < cols {\n            if lst[row_idx][col_idx] == x {\n\
    \                result.push((row_idx, col_idx));\n            }\n           \
    \ col_idx += 1;\n        } else {\n            row_idx += 1;\n            col_idx\
    \ = 0;\n        }\n    }\n    result.sort_by_key(|&(x, y)| x.0);\n    result.sort_by_key(|&(x,\
    \ y)| y.0);\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0610]: `usize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmpj1ofdfjz.rs:33:36\n   |\n33 |     result.sort_by_key(|&(x, y)|\
    \ x.0);\n   |                                    ^\n\nerror[E0610]: `usize` is\
    \ a primitive type and therefore doesn't have fields\n  --> /tmp/tmpj1ofdfjz.rs:34:36\n\
    \   |\n34 |     result.sort_by_key(|&(x, y)| y.0);\n   |                     \
    \               ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj1ofdfjz.rs:35:5\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n35 |     result\n   |   \
    \  ^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n              found struct `Vec<(usize, usize)>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0610.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut row_idx = 1;\n    let mut col_idx = 1;\n    let\
    \ mut row_size = lst.len();\n    let mut col_size = lst[0].len();\n    while row_idx\
    \ < row_size {\n        let mut row_start = row_idx;\n        let mut row_end\
    \ = row_idx;\n        let mut col_start = col_idx;\n        let mut col_end =\
    \ col_idx;\n        while col_start < col_end {\n            if row_start == row_end\
    \ {\n                row_end = row_start + 1;\n                col_start = col_start\
    \ + 1;\n                col_end = col_start + 1;\n            } else {\n     \
    \           row_end = row_end;\n                col_end = col_end;\n         \
    \   }\n        }\n        let row = row_start .. row_end;\n        let col = col_start\
    \ .. col_end;\n        let row_idx = row.iter().enumerate().map(|(i, _)| i).max().unwrap()\
    \ + 1;\n        let col_idx = col.iter().enumerate().map(|(i, _)| i).max().unwrap()\
    \ + 1;\n        result.push((row_idx, col_idx));\n    }\n    result.sort_by_key(|&(_,\
    \ y)| y.cmp(&x));\n    result.sort_by_key(|&(_, y)| y.cmp(&x));\n    result\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `std::ops::Range`\
    \ in the current scope\n  --> /tmp/tmpubtzuv4q.rs:39:27\n   |\n39 |         let\
    \ row_idx = row.iter().enumerate().map(|(i, _)| i).max().unwrap() + 1;\n   | \
    \                          ^^^^ method not found in `std::ops::Range<usize>`\n\
    \nerror[E0599]: no method named `iter` found for struct `std::ops::Range` in the\
    \ current scope\n  --> /tmp/tmpubtzuv4q.rs:40:27\n   |\n40 |         let col_idx\
    \ = col.iter().enumerate().map(|(i, _)| i).max().unwrap() + 1;\n   |         \
    \                  ^^^^ method not found in `std::ops::Range<{integer}>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows = lst.len();\n    let mut cols = lst[0].len();\n    let mut coords = vec![];\n\
    \    let mut row_coords = vec![];\n    let mut col_coords = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted_idx\
    \ = vec![];\n    let mut col_sorted_idx = vec![];\n    let mut row_sorted_idx_idx\
    \ = vec![];\n    let mut col_sorted_idx_idx = vec![];\n    let mut row_sorted_idx_idx_idx\
    \ = vec![];\n    let mut col_sorted_idx_idx_idx = vec![];\n    let mut row_sorted_idx_idx_idx_idx\
    \ = vec![];\n    let mut col_sorted_idx_idx_idx_idx = vec![];\n    let mut row_sorted_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut col_sorted_idx_idx_idx_idx_idx = vec![];\n    let mut\
    \ row_sorted_idx_idx_idx_idx_idx_idx = vec![];\n    let mut col_sorted_idx_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut row_sorted_idx_idx_idx_idx_idx_idx_idx = vec![];\n  \
    \  let mut col_sorted_idx_idx_idx_idx_idx_idx_idx = vec![];\n    let mut row_sorted_idx_idx_idx_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut col_sorted_idx_idx_idx_idx_idx_idx_idx_idx = vec![];\n\
    \    let mut row_sorted_idx_idx_idx_idx_idx_idx_idx_idx_idx = vec![];\n    let\
    \ mut col_sorted_idx_idx_idx_idx_idx_idx_idx_idx_idx = vec![];\n    let mut row_sorted_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut col_sorted_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx =\
    \ vec![];\n    let mut row_sorted_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut col_sorted_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut row_sorted_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut col_sorted_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut row_sorted_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut col_sorted_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut row_sorted_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut \n}\n\nfn main() {\n    let candidate = get_row;\n  \
    \  assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1,\
    \ 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpq_pehv2u.rs:52:1\n\
    \   |\n52 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659749648
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows = lst.len();\n    let mut cols = lst[0].len();\n    let mut coords = vec![];\n\
    \    let mut row_coords = vec![];\n    let mut col_coords = vec![];\n    let mut\
    \ row_sort = vec![];\n    let mut col_sort = vec![];\n    let mut row_sort_idx\
    \ = vec![];\n    let mut col_sort_idx = vec![];\n    let mut row_sort_idx2 = vec![];\n\
    \    let mut col_sort_idx2 = vec![];\n    let mut row_sort_idx3 = vec![];\n  \
    \  let mut col_sort_idx3 = vec![];\n    let mut row_sort_idx4 = vec![];\n    let\
    \ mut col_sort_idx4 = vec![];\n    let mut row_sort_idx5 = vec![];\n    let mut\
    \ col_sort_idx5 = vec![];\n    let mut row_sort_idx6 = vec![];\n    let mut col_sort_idx6\
    \ = vec![];\n    let mut row_sort_idx7 = vec![];\n    let mut col_sort_idx7 =\
    \ vec![];\n    let mut row_sort_idx8 = vec![];\n    let mut col_sort_idx8 = vec![];\n\
    \    let mut row_sort_idx9 = vec![];\n    let mut col_sort_idx9 = vec![];\n  \
    \  let mut row_sort_idx10 = vec![];\n    let mut col_sort_idx10 = vec![];\n  \
    \  let mut row_sort_idx11 = vec![];\n    let mut col_sort_idx11 = vec![];\n  \
    \  let mut row_sort_idx12 = vec![];\n    let mut col_sort_idx12 = vec![];\n  \
    \  let mut row_sort_idx13 = vec![];\n    let mut col_sort_idx13 = vec![];\n  \
    \  let mut row_sort_idx14 = vec![];\n    let mut col_sort_idx14 = vec![];\n  \
    \  let mut row_sort_idx15 = vec![];\n    let mut col_sort_idx15 = vec![];\n  \
    \  let mut row_sort_idx16 = vec![];\n    let mut col_sort_idx16 = vec![];\n  \
    \  let mut row_sort_idx17 = vec![];\n    let mut col_sort_idx17 = vec![];\n  \
    \  let mut row_sort_idx18 = vec![];\n    let mut col_sort_idx18 = vec![];\n  \
    \  let mut row_sort_idx19 = vec![];\n    let mut col_sort_idx19 = vec![];\n  \
    \  let mut row_sort_idx20 = vec![];\n    let mut \n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp8uz9w704.rs:64:1\n\
    \   |\n64 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659749648
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n\
    \    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_idx2 = vec![];\n\
    \    let mut col_idx2 = vec![];\n    let mut row_sorted2 = vec![];\n    let mut\
    \ col_sorted2 = vec![];\n    let mut row_idx3 = vec![];\n    let mut col_idx3\
    \ = vec![];\n    let mut row_sorted3 = vec![];\n    let mut col_sorted3 = vec![];\n\
    \    let mut row_idx4 = vec![];\n    let mut col_idx4 = vec![];\n    let mut row_sorted4\
    \ = vec![];\n    let mut col_sorted4 = vec![];\n    let mut row_idx5 = vec![];\n\
    \    let mut col_idx5 = vec![];\n    let mut row_sorted5 = vec![];\n    let mut\
    \ col_sorted5 = vec![];\n    let mut row_idx6 = vec![];\n    let mut col_idx6\
    \ = vec![];\n    let mut row_sorted6 = vec![];\n    let mut col_sorted6 = vec![];\n\
    \    let mut row_idx7 = vec![];\n    let mut col_idx7 = vec![];\n    let mut row_sorted7\
    \ = vec![];\n    let mut col_sorted7 = vec![];\n    let mut row_idx8 = vec![];\n\
    \    let mut col_idx8 = vec![];\n    let mut row_sorted8 = vec![];\n    let mut\
    \ col_sorted8 = vec![];\n    let mut row_idx9 = vec![];\n    let mut col_idx9\
    \ = vec![];\n    let mut row_sorted9 = vec![];\n    let mut col_sorted9 = vec![];\n\
    \    let mut row_idx10 = vec![];\n    let mut col_idx10 = vec![];\n    let mut\
    \ row_sorted10 = vec![];\n    let mut col_sorted10 = vec![];\n    let mut row_idx11\
    \ = vec![];\n    let mut col_idx11 = vec![];\n    let mut row_sorted11 = vec![];\n\
    \    let mut col_sorted11 = vec![];\n    let mut row_idx12 = vec![];\n    let\
    \ mut col_idx12 = vec![];\n    let mut row_sorted12 = vec![];\n    let mut col_sorted12\
    \ = vec![];\n    let mut row_idx13 = vec\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpulywony8.rs:68:28\n   |\n\
    68 |     let mut row_idx13 = vec\n   |                            ^ help: add\
    \ `;` here\n69 | }\n   | - unexpected token\n\nerror[E0423]: expected value, found\
    \ macro `vec`\n  --> /tmp/tmpulywony8.rs:68:25\n   |\n68 |     let mut row_idx13\
    \ = vec\n   |                         ^^^ not a value\n   |\nhelp: use `!` to\
    \ invoke the macro\n   |\n68 |     let mut row_idx13 = vec!\n   |            \
    \                +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpulywony8.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0423.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749648
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n\
    \    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted_idx = vec![];\n\
    \    let mut col_sorted_idx = vec![];\n    let mut row_sorted_idx2 = vec![];\n\
    \    let mut col_sorted_idx2 = vec![];\n    let mut row_sorted_idx3 = vec![];\n\
    \    let mut col_sorted_idx3 = vec![];\n    let mut row_sorted_idx4 = vec![];\n\
    \    let mut col_sorted_idx4 = vec![];\n    let mut row_sorted_idx5 = vec![];\n\
    \    let mut col_sorted_idx5 = vec![];\n    let mut row_sorted_idx6 = vec![];\n\
    \    let mut col_sorted_idx6 = vec![];\n    let mut row_sorted_idx7 = vec![];\n\
    \    let mut col_sorted_idx7 = vec![];\n    let mut row_sorted_idx8 = vec![];\n\
    \    let mut col_sorted_idx8 = vec![];\n    let mut row_sorted_idx9 = vec![];\n\
    \    let mut col_sorted_idx9 = vec![];\n    let mut row_sorted_idx10 = vec![];\n\
    \    let mut col_sorted_idx10 = vec![];\n    let mut row_sorted_idx11 = vec![];\n\
    \    let mut col_sorted_idx11 = vec![];\n    let mut row_sorted_idx12 = vec![];\n\
    \    let mut col_sorted_idx12 = vec![];\n    let mut row_sorted_idx13 = vec![];\n\
    \    let mut col_sorted_idx13 = vec![];\n    let mut row_sorted_idx14 = vec![];\n\
    \    let mut col_sorted_idx14 = vec![];\n    let mut row_sorted_idx15 = vec![];\n\
    \    let mut col_sorted_idx15 = vec![];\n    let mut row_sorted_idx16 = vec![];\n\
    \    let mut col_sorted_idx16 = vec![];\n    let mut row_sorted_idx17 = vec![];\n\
    \    let mut col_sorted_idx17 = vec![];\n    let mut row_sorted_idx18 = vec![];\n\
    \    let mut col_sorted_idx18 = vec![];\n    let mut row_sorted_idx19 = vec![];\n\
    \    let mut col_sorted_idx19 = vec![];\n    let mut row_sorted_idx20 = vec![];\n\
    \    let mut col_sorted_idx\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpkea8k9ev.rs:63:27\n   |\n\
    63 |     let mut col_sorted_idx\n   |                           ^ help: add `;`\
    \ here\n64 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpkea8k9ev.rs:16:47\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize)\
    \ -> Vec<(isize, isize)> {\n   |    -------                                  \
    \  ^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<(isize, isize)>`\n           found unit type `()`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut row_idx_max\
    \ = 0;\n    let mut row_idx_min = 0;\n    let mut col_idx = 0;\n    let mut col_idx_max\
    \ = 0;\n    let mut col_idx_min = 0;\n    for row in lst {\n        row_idx_max\
    \ = row.iter().max().unwrap();\n        row_idx_min = row.iter().min().unwrap();\n\
    \        col_idx_max = row.iter().rev().max().unwrap();\n        col_idx_min =\
    \ row.iter().rev().min().unwrap();\n        if row_idx_min <= x && x <= row_idx_max\
    \ {\n            if col_idx_min <= x && x <= col_idx_max {\n                row.push((row_idx,\
    \ col_idx));\n            }\n        }\n        row_idx += 1;\n        col_idx\
    \ += 1;\n    }\n    row.sort_by_key(|&(x, y)| x.0);\n    row.sort_by_key(|&(x,\
    \ y)| y.0);\n    row\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp83hiq6mb.rs:25:23\n   |\n\
    25 |         row_idx_max = row.iter().max().unwrap();\n   |                  \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n25 |         row_idx_max = *row.iter().max().unwrap();\n\
    \   |                       +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp83hiq6mb.rs:26:23\n\
    \   |\n26 |         row_idx_min = row.iter().min().unwrap();\n   |           \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found `&isize`\n   |\n\
    help: consider dereferencing the borrow\n   |\n26 |         row_idx_min = *row.iter().min().unwrap();\n\
    \   |                       +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp83hiq6mb.rs:27:23\n\
    \   |\n27 |         col_idx_max = row.iter().rev().max().unwrap();\n   |     \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n27 |         col_idx_max\
    \ = *row.iter().rev().max().unwrap();\n   |                       +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp83hiq6mb.rs:28:23\n   |\n28 |         col_idx_min\
    \ = row.iter().rev().min().unwrap();\n   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n28 |         col_idx_min = *row.iter().rev().min().unwrap();\n   |    \
    \                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp83hiq6mb.rs:31:26\n\
    \   |\n31 |                 row.push((row_idx, col_idx));\n   |              \
    \            ^^^^^^^^^^^^^^^^^^ expected `isize`, found tuple\n   |\n   = note:\
    \ expected type `isize`\n             found tuple `({integer}, {integer})`\n\n\
    error[E0610]: `isize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmp83hiq6mb.rs:37:33\n   |\n37 |     row.sort_by_key(|&(x, y)| x.0);\n\
    \   |                                 ^\n\nerror[E0610]: `isize` is a primitive\
    \ type and therefore doesn't have fields\n  --> /tmp/tmp83hiq6mb.rs:38:33\n  \
    \ |\n38 |     row.sort_by_key(|&(x, y)| y.0);\n   | "
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut row_len\
    \ = 0;\n    let mut col_len = 0;\n    let mut col_len_idx = 0;\n    let mut col_len_idx_max\
    \ = 0;\n    let mut col_len_idx_min = 0;\n    let mut row_len_idx = 0;\n    let\
    \ mut row_len_idx_max = 0;\n    let mut row_len_idx_min = 0;\n    let mut row_idx\
    \ = 0;\n    let mut row_idx_max = 0;\n    let mut row_idx_min = 0;\n    let mut\
    \ col_idx = 0;\n    let mut col_idx_max = 0;\n    let mut col_idx_min = 0;\n \
    \   let mut col_len = 0;\n    let mut col_len_idx = 0;\n    let mut col_len_idx_max\
    \ = 0;\n    let mut col_len_idx_min = 0;\n    let mut row_len = 0;\n    let mut\
    \ row_len_idx = 0;\n    let mut row_len_idx_max = 0;\n    let mut row_len_idx_min\
    \ = 0;\n    let mut row_idx = 0;\n    let mut row_idx_max = 0;\n    let mut row_idx_min\
    \ = 0;\n    let mut col_idx = 0;\n    let mut col_idx_max = 0;\n    let mut col_idx_min\
    \ = 0;\n    let mut col_len = 0;\n    let mut col_len_idx = 0;\n    let mut col_len_idx_max\
    \ = 0;\n    let mut col_len_idx_min = 0;\n    let mut row_len = 0;\n    let mut\
    \ row_len_idx = 0;\n    let mut row_len_idx_max = 0;\n    let mut row_len_idx_min\
    \ = 0;\n    let mut row_idx = 0;\n    let mut row_idx_max = 0;\n    let mut row_idx_min\
    \ = 0;\n    let mut col_idx = 0;\n    let mut col_idx_max = 0;\n    let mut col_idx_min\
    \ = 0;\n    let mut col_len = 0;\n    let mut col_len_idx = 0;\n    let mut col_len_idx_max\
    \ = 0;\n    let mut col_len_idx_min = 0;\n    let mut row_len = 0;\n    let mut\
    \ row_len_idx = 0;\n    let mut row_len_idx_max = 0;\n    let mut row_len_idx_min\
    \ = 0;\n    let mut row_idx = 0;\n    let mut row_idx_max = 0;\n    let mut row_idx_min\
    \ = 0;\n    let mut col_idx = 0;\n    let mut col_idx_max = 0;\n    let mut col_idx_min\
    \ = 0;\n    let mut col_len = 0;\n    let mut col_len_idx = 0;\n    let mut col_len_idx_max\
    \ = 0;\n    let mut col_len_idx_min = 0;\n    let mut row_len = 0;\n\n}\n\nfn\
    \ main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppw59x6wv.rs:16:47\n   |\n\
    16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \    -------                                    ^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749648
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows = lst.len();\n    let mut cols = lst[0].len();\n    let mut coords = vec![];\n\
    \    for row in 0..rows {\n        for col in 0..cols {\n            if row ==\
    \ x {\n                coords.push((row, col));\n            }\n        }\n  \
    \  }\n    coords.sort_by(|a, b| a.1.cmp(&b.1));\n    coords.sort_by(|a, b| b.1.cmp(&a.1));\n\
    \    coords.reverse();\n    coords\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpunjk1rvp.rs:22:23\n   |\n\
    22 |             if row == x {\n   |                       ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n22 |             if row == x.try_into().unwrap()\
    \ {\n   |                       ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpunjk1rvp.rs:30:5\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>,\
    \ x: isize) -> Vec<(isize, isize)> {\n   |                                   \
    \            ------------------- expected `Vec<(isize, isize)>` because of return\
    \ type\n...\n30 |     coords\n   |     ^^^^^^ expected `isize`, found `usize`\n\
    \   |\n   = note: expected struct `Vec<(isize, isize)>`\n              found struct\
    \ `Vec<(usize, usize)>`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows = lst.len();\n    let mut cols = lst[0].len();\n    let mut coords = vec![];\n\
    \    let mut row_coords = vec![];\n    let mut col_coords = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_coord\
    \ = vec![];\n    let mut col_coord = vec![];\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    while i < rows {\n        let mut row_sorted = vec![];\n       \
    \ let mut col_sorted = vec![];\n        let mut row_coord = vec![];\n        let\
    \ mut col_coord = vec![];\n        let mut j = 0;\n        while j < cols {\n\
    \            if lst[i][j] == x {\n                row_sorted.push(i);\n      \
    \          col_sorted.push(j);\n                row_coord.push(i);\n         \
    \       col_coord.push(j);\n            }\n            j += 1\n        }\n   \
    \     coords.push(row_coord);\n        coords.push(col_coord);\n        row_sorted.sort();\n\
    \        col_sorted.sort();\n        row_coord.sort();\n        col_coord.sort();\n\
    \        row_sorted.reverse();\n        col_sorted.reverse();\n        row_coord.reverse();\n\
    \        col_coord.reverse();\n        row_sorted.push(row_coord);\n        col_sorted.push(col_coord);\n\
    \        i += 1;\n    }\n    coords\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5col2c6l.rs:53:25\n   |\n\
    53 |         row_sorted.push(row_coord);\n   |                         ^^^^^^^^^\
    \ expected `usize`, found struct `Vec`\n   |\n   = note: expected type `usize`\n\
    \            found struct `Vec<usize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp5col2c6l.rs:54:25\n   |\n54 |         col_sorted.push(col_coord);\n\
    \   |                         ^^^^^^^^^ expected `usize`, found struct `Vec`\n\
    \   |\n   = note: expected type `usize`\n            found struct `Vec<usize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp5col2c6l.rs:57:5\n   |\n16 | fn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |     \
    \                                          ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n57 |     coords\n   |     ^^^^^^ expected\
    \ tuple, found struct `Vec`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \              found struct `Vec<Vec<usize>>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut row_idx_max\
    \ = 0;\n    let mut row_idx_min = 0;\n    let mut col_max = 0;\n    let mut col_min\
    \ = 0;\n    for row_idx in 0..lst.len() {\n        let mut col = 0;\n        let\
    \ mut col_max = 0;\n        let mut col_min = 0;\n        for col in 0..lst[row_idx].len()\
    \ {\n            if lst[row_idx][col] == x {\n                row.push((row_idx,\
    \ col));\n                if col > col_max {\n                    col_max = col;\n\
    \                }\n                if col < col_min {\n                    col_min\
    \ = col;\n                }\n            }\n        }\n        if col_max > col_max\
    \ {\n            row_idx_max = row_idx;\n        }\n        if col_min < col_min\
    \ {\n            row_idx_min = row_idx;\n        }\n    }\n    row.sort_by_key(|&(x,\
    \ y)| x.0);\n    row.sort_by_key(|&(x, y)| y.0);\n    row.sort_by_key(|&(x, y)|\
    \ x.1.cmp(&y.1));\n    row.sort_by_key(|&(x, y)| y.1.cmp(&x.1));\n    row\n}\n\
    \nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7iv557wf.rs:29:27\n   |\n\
    29 |                 row.push((row_idx, col));\n   |                         \
    \  ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n29 |     \
    \            row.push((row_idx.try_into().unwrap(), col));\n   |             \
    \              ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp7iv557wf.rs:29:36\n   |\n29 |                 row.push((row_idx,\
    \ col));\n   |                                    ^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n29 |                 row.push((row_idx, col.try_into().unwrap()));\n\
    \   |                                    ~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0610]:\
    \ `isize` is a primitive type and therefore doesn't have fields\n  --> /tmp/tmp7iv557wf.rs:45:33\n\
    \   |\n45 |     row.sort_by_key(|&(x, y)| x.0);\n   |                        \
    \         ^\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't\
    \ have fields\n  --> /tmp/tmp7iv557wf.rs:46:33\n   |\n46 |     row.sort_by_key(|&(x,\
    \ y)| y.0);\n   |                                 ^\n\nerror[E0610]: `isize` is\
    \ a primitive type and therefore doesn't have fields\n  --> /tmp/tmp7iv557wf.rs:47:33\n\
    \   |\n47 |     row.sort_by_key(|&(x, y)| x.1.cmp(&y.1));\n   |              \
    \                   ^\n\nerror[E0610]: `isize` is a primitive type and therefore\
    \ doesn't have fields\n  --> /tmp/tmp7iv557wf.rs:47:42\n   |\n47 |     row.sort_by_key(|&(x,\
    \ y)| x.1.cmp(&y.1));\n   |                                          ^\n\nerror[E0610]:\
    \ `isize` is a primitive type and therefore doesn't have fields\n  --> /tmp/tmp7iv557wf.rs:48:33\n\
    \   |\n48 |     row.sort_by_key(|&(x, y)| y.1.cmp(&x.1));\n   |              \
    \                   ^\n\nerror[E0610]: `isize` is a primitive type and therefore\
    \ doesn't have fields\n  --> /tmp/tmp7iv557wf.rs:48:42\n   |\n48 |     row.sort_by_key(|&(x,\
    \ y)| y.1.cmp(&x.1));\n   |                                 "
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    for row in lst {\n        let mut row_result = vec![];\n\
    \        for col in row.iter().rev() {\n            if col == x {\n          \
    \      row_result.push((col, row.len()));\n            }\n        }\n        result.push(row_result);\n\
    \    }\n    result.sort_by(|a, b| a.0.cmp(&b.0));\n    result.sort_by(|a, b| b.1.cmp(&a.1));\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpknafju7y.rs:21:20\n\
    \   |\n21 |             if col == x {\n   |                    ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n\nerror[E0609]: no field `0` on type `&Vec<(&isize,\
    \ usize)>`\n  --> /tmp/tmpknafju7y.rs:27:29\n   |\n27 |     result.sort_by(|a,\
    \ b| a.0.cmp(&b.0));\n   |                             ^ unknown field\n\nerror[E0609]:\
    \ no field `0` on type `&Vec<(&isize, usize)>`\n  --> /tmp/tmpknafju7y.rs:27:38\n\
    \   |\n27 |     result.sort_by(|a, b| a.0.cmp(&b.0));\n   |                  \
    \                    ^ unknown field\n\nerror[E0609]: no field `1` on type `&Vec<(&isize,\
    \ usize)>`\n  --> /tmp/tmpknafju7y.rs:28:29\n   |\n28 |     result.sort_by(|a,\
    \ b| b.1.cmp(&a.1));\n   |                             ^ unknown field\n\nerror[E0609]:\
    \ no field `1` on type `&Vec<(&isize, usize)>`\n  --> /tmp/tmpknafju7y.rs:28:38\n\
    \   |\n28 |     result.sort_by(|a, b| b.1.cmp(&a.1));\n   |                  \
    \                    ^ unknown field\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpknafju7y.rs:29:5\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize)\
    \ -> Vec<(isize, isize)> {\n   |                                             \
    \  ------------------- expected `Vec<(isize, isize)>` because of return type\n\
    ...\n29 |     result\n   |     ^^^^^^ expected tuple, found struct `Vec`\n   |\n\
    \   = note: expected struct `Vec<(isize, isize)>`\n              found struct\
    \ `Vec<Vec<(&isize, usize)>>`\n\nerror: aborting due to 6 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308, E0609.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows = lst.len();\n    let mut cols = lst[0].len();\n    let mut coords = vec![];\n\
    \    let mut row_coords = vec![];\n    let mut col_coords = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sor\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpa1objz2n.rs:68:20\n   |\n\
    68 |     let mut row_sor\n   |                    ^ help: add `;` here\n69 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa1objz2n.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n\
    \    let mut row_idx = 0;\n    let mut col_idx = 0;\n    while row_idx < rows\
    \ {\n        let mut row_result = vec![];\n        while col_idx < cols {\n  \
    \          if row_idx == row_idx {\n                if col_idx < cols {\n    \
    \                row_result.push((row_idx, col_idx));\n                    col_idx\
    \ += 1;\n                }\n                else {\n                    break;\n\
    \                }\n            }\n            row_idx += 1;\n        }\n    \
    \    result.push(row_result);\n    }\n    result.sort_by_key(|&(_, y)| y.cmp(&x));\n\
    \    result.sort_by_key(|&(_, y)| {\n        let mut result = vec![];\n      \
    \  for &(_, col) in &result {\n            result.push((col, y.cmp(&col)));\n\
    \        }\n        result\n    });\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg2pgcb3q.rs:38:26\n   |\n\
    38 |     result.sort_by_key(|&(_, y)| y.cmp(&x));\n   |                      \
    \    ^^^^^-\n   |                          |    |\n   |                      \
    \    |    expected due to this\n   |                          expected struct\
    \ `Vec`, found tuple\n   |\n   = note: expected struct `Vec<(usize, usize)>`\n\
    \               found tuple `(_, _)`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpg2pgcb3q.rs:39:26\n   |\n39 |     result.sort_by_key(|&(_, y)| {\n \
    \  |                          ^^^^^-\n   |                          |    |\n \
    \  |                          |    expected due to this\n   |                \
    \          expected struct `Vec`, found tuple\n   |\n   = note: expected struct\
    \ `Vec<(usize, usize)>`\n               found tuple `(_, _)`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpg2pgcb3q.rs:46:5\n   |\n16 | fn get_row(lst:\
    \ Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |                  \
    \                             ------------------- expected `Vec<(isize, isize)>`\
    \ because of return type\n...\n46 |     result\n   |     ^^^^^^ expected tuple,\
    \ found struct `Vec`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \              found struct `Vec<Vec<(usize, usize)>>`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx: Vec<isize> = vec![];\n\
    \    let mut row_idx2: Vec<isize> = vec![];\n    let mut row_idx3: Vec<isize>\
    \ = vec![];\n    let mut row_idx4: Vec<isize> = vec![];\n    let mut row_idx5:\
    \ Vec<isize> = vec![];\n    let mut row_idx6: Vec<isize> = vec![];\n    let mut\
    \ row_idx7: Vec<isize> = vec![];\n    let mut row_idx8: Vec<isize> = vec![];\n\
    \    let mut row_idx9: Vec<isize> = vec![];\n    let mut row_idx10: Vec<isize>\
    \ = vec![];\n    let mut row_idx11: Vec<isize> = vec![];\n    let mut row_idx12:\
    \ Vec<isize> = vec![];\n    let mut row_idx13: Vec<isize> = vec![];\n    let mut\
    \ row_idx14: Vec<isize> = vec![];\n    let mut row_idx15: Vec<isize> = vec![];\n\
    \    let mut row_idx16: Vec<isize> = vec![];\n    let mut row_idx17: Vec<isize>\
    \ = vec![];\n    let mut row_idx18: Vec<isize> = vec![];\n    let mut row_idx19:\
    \ Vec<isize> = vec![];\n    let mut row_idx20: Vec<isize> = vec![];\n    let mut\
    \ row_idx21: Vec<isize> = vec![];\n    let mut row_idx22: Vec<isize> = vec![];\n\
    \    let mut row_idx23: Vec<isize> = vec![];\n    let mut row_idx24: Vec<isize>\
    \ = vec![];\n    let mut row_idx25: Vec<isize> = vec![];\n    let mut row_idx26:\
    \ Vec<isize> = vec![];\n    let mut row_idx27: Vec<isize> = vec![];\n    let mut\
    \ row_idx28: Vec<isize> = vec![];\n    let mut row_idx29: Vec<isize> = vec![];\n\
    \    let mut row_idx30: \n}\n\nfn main() {\n    let candidate = get_row;\n   \
    \ assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1,\
    \ 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected type, found `}`\n  --> /tmp/tmpn5ksppg3.rs:48:1\n   |\n\
    47 |     let mut row_idx30: \n   |         ------------- while parsing the type\
    \ for `mut row_idx30`\n48 | }\n   | ^ expected type\n\nerror: aborting due to\
    \ previous error\n\n"
  stdout: ''
  timestamp: 1659749648
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n\
    \    let mut row_idx = 0;\n    let mut col_idx = 0;\n    let mut row_max = rows;\n\
    \    let mut col_max = cols;\n    let mut row_min = rows;\n    let mut col_min\
    \ = cols;\n    while row_idx < rows && col_idx < cols {\n        if row_idx <\
    \ row_max && col_idx < col_max {\n            if lst[row_idx][col_idx] == x {\n\
    \                result.push((row_idx, col_idx));\n                row_idx +=\
    \ 1;\n                col_idx += 1;\n            } else {\n                row_idx\
    \ += 1;\n                col_idx += 1;\n            }\n        } else if row_idx\
    \ < row_max {\n            row_max -= 1;\n            row_min -= 1;\n        \
    \    row_idx += 1;\n            col_idx += 1;\n        } else if col_idx < col_max\
    \ {\n            col_max -= 1;\n            col_min -= 1;\n            col_idx\
    \ += 1;\n        } else {\n            break;\n        }\n    }\n    result.sort_by_key(|&(_,\
    \ y)| y.cmp(&x));\n    result.sort_by_key(|&(_, y)| y.cmp(&y));\n    result\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw5g0cnmx.rs:49:40\n   |\n\
    49 |     result.sort_by_key(|&(_, y)| y.cmp(&x));\n   |                      \
    \                  ^^ expected `usize`, found `isize`\n   |\n   = note: expected\
    \ reference `&usize`\n              found reference `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpw5g0cnmx.rs:51:5\n   |\n16 | fn get_row(lst:\
    \ Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |                  \
    \                             ------------------- expected `Vec<(isize, isize)>`\
    \ because of return type\n...\n51 |     result\n   |     ^^^^^^ expected `isize`,\
    \ found `usize`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n    \
    \          found struct `Vec<(usize, usize)>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut col_max\
    \ = vec![];\n    let mut col_min = vec![];\n    for row in lst {\n        col_max\
    \ = vec![];\n        col_min = vec![];\n        for col in row {\n           \
    \ if col > x {\n                col_max.push(col);\n            } else {\n   \
    \             col_min.push(col);\n            }\n        }\n        if col_max.len()\
    \ > col_min.len() {\n            row.swap(row_idx, col_min.len());\n         \
    \   row_idx += 1;\n        }\n    }\n    for col in col_max {\n        row.push((row_idx,\
    \ col));\n    }\n    for col in col_min {\n        row.push((row_idx, col));\n\
    \    }\n    row\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcrkc5v1a.rs:37:19\n   |\n\
    37 |         row.push((row_idx, col));\n   |                   ^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n37 |         row.push((row_idx.try_into().unwrap(),\
    \ col));\n   |                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcrkc5v1a.rs:40:19\n   |\n40 |         row.push((row_idx,\
    \ col));\n   |                   ^^^^^^^ expected `isize`, found `usize`\n   |\n\
    help: you can convert a `usize` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n40 |         row.push((row_idx.try_into().unwrap(), col));\n\
    \   |                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx: Vec<isize> = vec![];\n\
    \    let mut row_idx2: Vec<isize> = vec![];\n    let mut row_idx3: Vec<isize>\
    \ = vec![];\n    let mut row_idx4: Vec<isize> = vec![];\n    let mut row_idx5:\
    \ Vec<isize> = vec![];\n    let mut row_idx6: Vec<isize> = vec![];\n    let mut\
    \ row_idx7: Vec<isize> = vec![];\n    let mut row_idx8: Vec<isize> = vec![];\n\
    \    let mut row_idx9: Vec<isize> = vec![];\n    let mut row_idx10: Vec<isize>\
    \ = vec![];\n    let mut row_idx11: Vec<isize> = vec![];\n    let mut row_idx12:\
    \ Vec<isize> = vec![];\n    let mut row_idx13: Vec<isize> = vec![];\n    let mut\
    \ row_idx14: Vec<isize> = vec![];\n    let mut row_idx15: Vec<isize> = vec![];\n\
    \    let mut row_idx16: Vec<isize> = vec![];\n    let mut row_idx17: Vec<isize>\
    \ = vec![];\n    let mut row_idx18: Vec<isize> = vec![];\n    let mut row_idx19:\
    \ Vec<isize> = vec![];\n    let mut row_idx20: Vec<isize> = vec![];\n    let mut\
    \ row_idx21: Vec<isize> = vec![];\n    let mut row_idx22: Vec<isize> = vec![];\n\
    \    let mut row_idx23: Vec<isize> = vec![];\n    let mut row_idx24: Vec<isize>\
    \ = vec![];\n    let mut row_idx25: Vec<isize> = vec![];\n    let mut row_idx26:\
    \ Vec<isize> = vec![];\n    let mut row_idx27: Vec<isize> = vec![];\n    let mut\
    \ row_idx28: Vec<isize> = vec![];\n    let mut row_idx29: Vec<isize> = vec![];\n\
    \    let mut row_idx30: \n}\n\nfn main() {\n    let candidate = get_row;\n   \
    \ assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1,\
    \ 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected type, found `}`\n  --> /tmp/tmpn5ksppg3.rs:48:1\n   |\n\
    47 |     let mut row_idx30: \n   |         ------------- while parsing the type\
    \ for `mut row_idx30`\n48 | }\n   | ^ expected type\n\nerror: aborting due to\
    \ previous error\n\n"
  stdout: ''
  timestamp: 1659749648
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    let mut row_len = 0;\n    let mut col_len = 0;\n    let mut row_start\
    \ = 0;\n    let mut col_start = 0;\n    let mut row_end = 0;\n    let mut col_end\
    \ = 0;\n    let mut row_start2 = 0;\n    let mut col_start2 = 0;\n    let mut\
    \ row_end2 = 0;\n    let mut col_end2 = 0;\n    let mut row_start3 = 0;\n    let\
    \ mut col_start3 = 0;\n    let mut row_end3 = 0;\n    let mut col_end3 = 0;\n\
    \    let mut row_start4 = 0;\n    let mut col_start4 = 0;\n    let mut row_end4\
    \ = 0;\n    let mut col_end4 = 0;\n    let mut row_start5 = 0;\n    let mut col_start5\
    \ = 0;\n    let mut row_end5 = 0;\n    let mut col_end5 = 0;\n    let mut row_start6\
    \ = 0;\n    let mut col_start6 = 0;\n    let mut row_end6 = 0;\n    let mut col_end6\
    \ = 0;\n    let mut row_start7 = 0;\n    let mut col_start7 = 0;\n    let mut\
    \ row_end7 = 0;\n    let mut col_end7 = 0;\n    let mut row_start8 = 0;\n    let\
    \ mut col_start8 = 0;\n    let mut row_end8 = 0;\n    let mut col_end8 = 0;\n\
    \    let mut row_start9 = 0;\n    let mut col_start9 = 0;\n    let mut row_end9\
    \ = 0;\n    let mut col_end9 = 0;\n    let mut row_start10 = 0;\n    let mut col_start10\
    \ = 0;\n    let mut row_end10 = 0;\n    let mut col_end10 = 0;\n    let mut row_start11\
    \ = 0;\n    let mut col_start11 = 0;\n    let mut row_end11 = 0;\n    let mut\
    \ col_end11 = 0;\n    let mut row_start12 = 0;\n    let mut col_start12 = 0;\n\
    \    let mut row_end12 = 0;\n    let mut col_end12 = 0;\n    let mut row_start13\
    \ = 0;\n    let mut col_start13 = 0;\n    let mut row_end13 = 0;\n    let mut\
    \ col_end13 = 0;\n    let mut row_start14 = 0;\n    let mut col_start14 = 0;\n\
    \    let mut row_end14 = 0;\n    let mut col_end14 = 0;\n    let mut row_start15\
    \ = 0;\n    let mut col_start15 = 0;\n    let mut row_end15 = 0;\n    let mut\
    \ col_end15 = 0;\n    let mut row_start16 = 0;\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpixaq88qt.rs:16:47\n   |\n\
    16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \    -------                                    ^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut row_cols:\
    \ Vec<isize> = vec![];\n    let mut row_cols_idx = 0;\n    for row in lst {\n\
    \        let mut row_cols_idx = 0;\n        for col in row {\n            if col\
    \ == x {\n                row_cols.push((row_idx, row_cols_idx));\n          \
    \  }\n            row_cols_idx += 1;\n        }\n        row_idx += 1;\n    }\n\
    \    row_cols.sort_by_key(|&(_, idx)| {\n        idx as isize\n    });\n    row_cols.sort_by_key(|&(_,\
    \ idx)| {\n        idx as isize\n    }).reverse();\n    for (_, col) in row_cols\
    \ {\n        row.push((col, col));\n    }\n    row\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphd2l0npj.rs:25:31\n   |\n\
    25 |                 row_cols.push((row_idx, row_cols_idx));\n   |           \
    \                    ^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found tuple\n \
    \  |\n   = note: expected type `isize`\n             found tuple `({integer},\
    \ {integer})`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphd2l0npj.rs:31:28\n\
    \   |\n31 |     row_cols.sort_by_key(|&(_, idx)| {\n   |                     \
    \       ^^^^^^^-\n   |                            |      |\n   |             \
    \               |      expected due to this\n   |                            expected\
    \ `isize`, found tuple\n   |\n   = note: expected type `isize`\n             found\
    \ tuple `(_, _)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphd2l0npj.rs:34:28\n\
    \   |\n34 |     row_cols.sort_by_key(|&(_, idx)| {\n   |                     \
    \       ^^^^^^^-\n   |                            |      |\n   |             \
    \               |      expected due to this\n   |                            expected\
    \ `isize`, found tuple\n   |\n   = note: expected type `isize`\n             found\
    \ tuple `(_, _)`\n\nerror[E0599]: no method named `reverse` found for unit type\
    \ `()` in the current scope\n  --> /tmp/tmphd2l0npj.rs:36:8\n   |\n36 |     }).reverse();\n\
    \   |        ^^^^^^^ method not found in `()`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmphd2l0npj.rs:37:9\n   |\n37 |     for (_, col) in row_cols {\n \
    \  |         ^^^^^^^^    -------- this expression has type `isize`\n   |     \
    \    |\n   |         expected `isize`, found tuple\n   |\n   = note: expected\
    \ type `isize`\n             found tuple `(_, _)`\n\nerror: aborting due to 5\
    \ previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut row_idx2\
    \ = 0;\n    let mut row_idx3 = 0;\n    let mut row_idx4 = 0;\n    let mut row_idx5\
    \ = 0;\n    let mut row_idx6 = 0;\n    let mut row_idx7 = 0;\n    let mut row_idx8\
    \ = 0;\n    let mut row_idx9 = 0;\n    let mut row_idx10 = 0;\n    let mut row_idx11\
    \ = 0;\n    let mut row_idx12 = 0;\n    let mut row_idx13 = 0;\n    let mut row_idx14\
    \ = 0;\n    let mut row_idx15 = 0;\n    let mut row_idx16 = 0;\n    let mut row_idx17\
    \ = 0;\n    let mut row_idx18 = 0;\n    let mut row_idx19 = 0;\n    let mut row_idx20\
    \ = 0;\n    let mut row_idx21 = 0;\n    let mut row_idx22 = 0;\n    let mut row_idx23\
    \ = 0;\n    let mut row_idx24 = 0;\n    let mut row_idx25 = 0;\n    let mut row_idx26\
    \ = 0;\n    let mut row_idx27 = 0;\n    let mut row_idx28 = 0;\n    let mut row_idx29\
    \ = 0;\n    let mut row_idx30 = 0;\n    let mut row_idx31 = 0;\n    let mut row_idx32\
    \ = 0;\n    let mut row_idx33 = 0;\n    let mut row_idx34 = 0;\n    let mut row_idx35\
    \ = 0;\n    let mut row_idx36 = 0;\n    let mut row_idx37 = 0;\n    let mut row_idx38\
    \ = 0;\n    let mut row_idx39 = 0;\n    let mut row_idx40 = 0;\n    let mut row_idx41\
    \ = 0;\n    let mut row_idx42 = 0;\n    let mut row_idx43 = 0;\n    let mut row_idx44\
    \ = 0;\n    let mut row_idx45 = 0;\n    let mut row_idx46 = 0;\n    let mut row_idx47\
    \ = 0;\n    let mut row_idx48 = 0;\n    let mut row_idx49 = 0;\n    let mut row_idx50\
    \ = 0;\n    let mut row_idx51 = 0;\n    let mut row_idx52 = 0;\n    let mut row_idx53\
    \ = 0;\n    let mut row_idx54 = 0;\n    let mut row_idx55 = 0;\n    let mut row_idx56\
    \ = 0;\n    let mut row_idx57 = 0;\n    let mut row_idx58 = 0;\n    let mut row_idx59\
    \ = 0;\n    let mut row_idx60 = 0;\n    let mut row_idx61 = 0;\n    let mut row_idx62\
    \ = 0;\n    let mut row_\n}\n\nfn main() {\n    let candidate = get_row;\n   \
    \ assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1,\
    \ 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmppjyfu577.rs:80:17\n   |\n\
    80 |     let mut row_\n   |                 ^ help: add `;` here\n81 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppjyfu577.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    let mut row_len = lst.len();\n    let mut col_len = lst[0].len();\n\
    \    while row_idx < row_len {\n        let mut row_end = row_idx;\n        while\
    \ row_end < row_len && lst[row_end][col_idx] < x {\n            row_end += 1;\n\
    \        }\n        let mut col_end = col_idx;\n        while col_end < col_len\
    \ && lst[row_idx][col_end] < x {\n            col_end += 1;\n        }\n     \
    \   if col_end == col_len {\n            row.push((row_idx, col_idx));\n     \
    \       row_idx += 1;\n            col_idx = 0;\n            col_len = lst[row_idx].len();\n\
    \        } else {\n            row.push((row_idx, col_end));\n            row_idx\
    \ += 1;\n            col_idx = col_end - 1;\n            col_len = lst[row_idx].len();\n\
    \        }\n    }\n    row.sort_by_key(|&(x, y)| x.0);\n    row.sort_by_key(|&(x,\
    \ y)| -x.1);\n    row\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw5acx53o.rs:32:23\n   |\n\
    32 |             row.push((row_idx, col_idx));\n   |                       ^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n32 |           \
    \  row.push((row_idx.try_into().unwrap(), col_idx));\n   |                   \
    \    ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw5acx53o.rs:32:32\n\
    \   |\n32 |             row.push((row_idx, col_idx));\n   |                  \
    \              ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    32 |             row.push((row_idx, col_idx.try_into().unwrap()));\n   |     \
    \                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpw5acx53o.rs:37:23\n   |\n37 |             row.push((row_idx,\
    \ col_end));\n   |                       ^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n37 |             row.push((row_idx.try_into().unwrap(),\
    \ col_end));\n   |                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpw5acx53o.rs:37:32\n   |\n37 |             row.push((row_idx,\
    \ col_end));\n   |                                ^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n37 |             row.push((row_idx, col_end.try_into().unwrap()));\n\
    \   |                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0610]:\
    \ `isize` is a primitive type and therefore doesn't have fields\n  --> /tmp/tmpw5acx53o.rs:43:33\n\
    \   |\n43 |     row.sort_by_key(|&(x, y)| x.0);\n   |                        \
    \         ^\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't\
    \ have fields\n  --> /tmp/tmpw5acx53o.rs:44:34\n   |\n44 |     row.sort_by_key(|&(x,\
    \ y)| -x.1);\n   |                                  ^"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx: Vec<isize> = vec![];\n\
    \    let mut row_idx_idx: Vec<isize> = vec![];\n    let mut row_idx_idx_idx: Vec<isize>\
    \ = vec![];\n    let mut row_idx_idx_idx_idx: Vec<isize> = vec![];\n    let mut\
    \ row_idx_idx_idx_idx_idx: Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx: Vec<isize>\
    \ = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx: Vec<isize> = vec![];\n\
    \    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx: Vec<isize> = vec![];\n \
    \   let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx: Vec<isize> = vec![];\n\
    \    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx: Vec<isize> = vec![];\n\
    \    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx: Vec<isize> =\
    \ vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n\n}\n\nfn main() {\n    let candidate = get_row;\n   \
    \ assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1,\
    \ 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2k9z5q35.rs:16:47\n   |\n\
    16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \    -------                                    ^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut\
    \ col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n  \
    \  let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut\
    \ col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n  \
    \  let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut\
    \ col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n  \
    \  let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut\
    \ col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n  \
    \  let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let \n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpzfv6u_ru.rs:72:1\n  \
    \ |\n72 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut row_idx_max\
    \ = 0;\n    let mut col_max = 0;\n    for row in lst {\n        let mut col_max\
    \ = 0;\n        for col in row {\n            if col > col_max {\n           \
    \     col_max = col;\n            }\n        }\n        if row_idx > row_idx_max\
    \ {\n            row_idx_max = row_idx;\n        }\n        if col_max > col_max\
    \ {\n            col_max = col_max;\n        }\n        row.sort_by_key(|&x| x.0);\n\
    \        row.sort_by_key(|&x| x.1);\n        if row_idx != row_idx_max {\n   \
    \         row.swap(0, row_idx);\n        }\n        if col_max != col_max {\n\
    \            row.swap(0, col_max);\n        }\n        row_idx += 1;\n    }\n\
    \    row\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0610]: `isize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmpl63eaf5c.rs:34:32\n   |\n34 |         row.sort_by_key(|&x| x.0);\n\
    \   |                                ^\n\nerror[E0610]: `isize` is a primitive\
    \ type and therefore doesn't have fields\n  --> /tmp/tmpl63eaf5c.rs:35:32\n  \
    \ |\n35 |         row.sort_by_key(|&x| x.1);\n   |                           \
    \     ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl63eaf5c.rs:40:25\n \
    \  |\n40 |             row.swap(0, col_max);\n   |                         ^^^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n40 |           \
    \  row.swap(0, col_max.try_into().unwrap());\n   |                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0610.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    let mut row_len = lst.len();\n    let mut col_len = lst[0].len();\n\
    \    while row_idx < row_len {\n        let mut row = vec![];\n        while col_idx\
    \ < col_len {\n            if lst[row_idx][col_idx] == x {\n                row.push((row_idx,\
    \ col_idx));\n            }\n            col_idx += 1;\n        }\n        rows.push(row);\n\
    \        row_idx += 1;\n        col_len = lst[row_idx].len();\n    }\n    rows\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp31psd29j.rs:30:19\n   |\n\
    30 |         rows.push(row);\n   |                   ^^^ expected tuple, found\
    \ struct `Vec`\n   |\n   = note: expected tuple `(isize, isize)`\n           \
    \  found struct `Vec<(usize, usize)>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    let mut row_len = 0;\n    let mut col_len = 0;\n    let mut row_idx2\
    \ = 0;\n    let mut col_idx2 = 0;\n    let mut row_len2 = 0;\n    let mut col_len2\
    \ = 0;\n    while row_idx < lst.len() {\n        row_len += lst[row_idx].len();\n\
    \        if row_len > x {\n            break;\n        }\n        row_idx2 +=\
    \ 1;\n    }\n    while col_idx < lst.len() {\n        col_len += lst[col_idx].len();\n\
    \        if col_len > x {\n            break;\n        }\n        col_idx2 +=\
    \ 1;\n    }\n    while row_idx2 < lst.len() {\n        row_len2 += lst[row_idx2].len();\n\
    \        if row_len2 > x {\n            break;\n        }\n        row_idx +=\
    \ 1;\n        row_idx2 += 1;\n    }\n    while col_idx2 < lst.len() {\n      \
    \  col_len2 += lst[col_idx2].len();\n        if col_len2 > x {\n            break;\n\
    \        }\n        col_idx += 1;\n        col_idx2 += 1;\n    }\n    while row_idx\
    \ < lst.len() {\n        let mut row = vec![];\n        let mut row_idx3 = 0;\n\
    \        let mut col_idx3 = 0;\n        let mut row_len3 = 0;\n        let mut\
    \ col_len3 = 0;\n        while row_idx3 < lst[row_idx].len() {\n            row_len3\
    \ += lst[row_idx][row_idx3];\n            if row_len3 > x {\n                break;\n\
    \            }\n            row_idx3 += 1;\n        }\n        while col_idx3\
    \ < lst[col_idx].len() {\n            col_len3 += lst[col_idx][col_idx3];\n  \
    \          if col_len3 > x {\n                break;\n            }\n        \
    \    col_idx3 += 1;\n        }\n        row.push((row_idx, col_idx));\n      \
    \  row.push((row_idx2, col_idx2));\n        row.push((row_idx3, col_idx3));\n\
    \        row.push((row_idx, col_idx));\n        row.push((row_idx2, col_idx2));\n\
    \        row.push((row_idx3, col_idx3));\n        row.push((row_idx, col_idx));\n\
    \        row.push((row_idx2, col_idx2));\n        row.push((row_idx3, col_idx3));\n\
    \        row.push((row_idx, col_idx));\n        row.push((row_idx2, col_idx2));\n\
    \        row.push((row_idx\n}\n\nfn main() {\n    let candidate = get_row;\n \
    \   assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp9n3o9mca.rs:98:3\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                                                   -\
    \ unclosed delimiter\n...\n56 |     while row_idx < lst.len() {\n   |        \
    \                       - this delimiter might not be properly closed...\n...\n\
    88 | }\n   | - ...as it matches this but it has different indentation\n...\n98\
    \ | }\n   |   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp9n3o9mca.rs:87:18\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                                                   -\
    \ closing delimiter possibly meant for this\n...\n87 |         row.push((row_idx\n\
    \   |                  ^ unclosed delimiter\n88 | }\n   | ^ mismatched closing\
    \ delimiter\n\nwarning: unnecessary parentheses around method argument\n  -->\
    \ /tmp/tmp9n3o9mca.rs:87:18\n   |\n87 |           row.push((row_idx\n   |  __________________^\n\
    88 | | }\n   | |_^ help: remove these parentheses\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9n3o9mca.rs:28:22\n\
    \   |\n28 |         if row_len > x {\n   |                      ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n28 |         if row_len > x.try_into().unwrap()\
    \ {\n   |                      ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9n3o9mca.rs:35:22\n   |\n35 |         if col_len > x {\n\
    \   |                      ^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n35 |         if col_len > x.try_into().unwrap() {\n   |         \
    \             ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9n3o9mca.rs:42:23\n\
    \   |\n42 |         if row_len2 > x {\n   |                       ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and pani"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx: Vec<isize> = vec![];\n\
    \    let mut row_idx2: Vec<isize> = vec![];\n    let mut row_idx3: Vec<isize>\
    \ = vec![];\n    let mut row_idx4: Vec<isize> = vec![];\n    let mut row_idx5:\
    \ Vec<isize> = vec![];\n    let mut row_idx6: Vec<isize> = vec![];\n    let mut\
    \ row_idx7: Vec<isize> = vec![];\n    let mut row_idx8: Vec<isize> = vec![];\n\
    \    let mut row_idx9: Vec<isize> = vec![];\n    let mut row_idx10: Vec<isize>\
    \ = vec![];\n    let mut row_idx11: Vec<isize> = vec![];\n    let mut row_idx12:\
    \ Vec<isize> = vec![];\n    let mut row_idx13: Vec<isize> = vec![];\n    let mut\
    \ row_idx14: Vec<isize> = vec![];\n    let mut row_idx15: Vec<isize> = vec![];\n\
    \    let mut row_idx16: Vec<isize> = vec![];\n    let mut row_idx17: Vec<isize>\
    \ = vec![];\n    let mut row_idx18: Vec<isize> = vec![];\n    let mut row_idx19:\
    \ Vec<isize> = vec![];\n    let mut row_idx20: Vec<isize> = vec![];\n    let mut\
    \ row_idx21: Vec<isize> = vec![];\n    let mut row_idx22: Vec<isize> = vec![];\n\
    \    let mut row_idx23: Vec<isize> = vec![];\n    let mut row_idx24: Vec<isize>\
    \ = vec![];\n    let mut row_idx25: Vec<isize> = vec![];\n    let mut row_idx26:\
    \ Vec<isize> = vec![];\n    let mut row_idx27: Vec<isize> = vec![];\n    let mut\
    \ row_idx28: Vec<isize> = vec![];\n    let mut row_idx29: Vec<isize> = vec![];\n\
    \    let mut row_idx30: \n}\n\nfn main() {\n    let candidate = get_row;\n   \
    \ assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1,\
    \ 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected type, found `}`\n  --> /tmp/tmpn5ksppg3.rs:48:1\n   |\n\
    47 |     let mut row_idx30: \n   |         ------------- while parsing the type\
    \ for `mut row_idx30`\n48 | }\n   | ^ expected type\n\nerror: aborting due to\
    \ previous error\n\n"
  stdout: ''
  timestamp: 1659749648
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows = lst.len();\n    let mut cols = lst[0].len();\n    let mut coords = vec![];\n\
    \    let mut row_coords = vec![];\n    let mut col_coords = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted_idx\
    \ = vec![];\n    let mut col_sorted_idx = vec![];\n    let mut row_sorted_idx_idx\
    \ = vec![];\n    let mut col_sorted_idx_idx = vec![];\n    let mut row_sorted_idx_idx_idx\
    \ = vec![];\n    let mut col_sorted_idx_idx_idx = vec![];\n    let mut row_sorted_idx_idx_idx_idx\
    \ = vec![];\n    let mut col_sorted_idx_idx_idx_idx = vec![];\n    let mut row_sorted_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut col_sorted_idx_idx_idx_idx_idx = vec![];\n    let mut\
    \ row_sorted_idx_idx_idx_idx_idx_idx = vec![];\n    let mut col_sorted_idx_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut row_sorted_idx_idx_idx_idx_idx_idx_idx = vec![];\n  \
    \  let mut col_sorted_idx_idx_idx_idx_idx_idx_idx = vec![];\n    let mut row_sorted_idx_idx_idx_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut col_sorted_idx_idx_idx_idx_idx_idx_idx_idx = vec![];\n\
    \    let mut row_sorted_idx_idx_idx_idx_idx_idx_idx_idx_idx = vec![];\n    let\
    \ mut col_sorted_idx_idx_idx_idx_idx_idx_idx_idx_idx = vec![];\n    let mut row_sorted_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut col_sorted_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx =\
    \ vec![];\n    let mut row_sorted_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx = vec![];\n\
    \    let mut col_sorted_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx = vec![];\n\
    \    let mut row_sorted_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx = vec![];\n\
    \    let mut col_sorted_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx = vec![];\n\
    \    let mut row_sorted_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx = vec![];\n\
    \    let mut col_sorted_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx = vec![];\n\
    \    let mut row_sorted_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx = vec![];\n\
    \    let mut col_sorted_idx_idx_idx_idx_idx_idx_idx_idx_idx_\n}\n\nfn main() {\n\
    \    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmplsalybux.rs:51:60\n   |\n\
    51 |     let mut col_sorted_idx_idx_idx_idx_idx_idx_idx_idx_idx_\n   |       \
    \                                                     ^ help: add `;` here\n52\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplsalybux.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut row_len\
    \ = 0;\n    let mut col_len = 0;\n    let mut col_pos = 0;\n    let mut col_pos_idx\
    \ = 0;\n    let mut col_pos_len = 0;\n    let mut row_len_idx = 0;\n    let mut\
    \ row_len_idx_idx = 0;\n    let mut col_pos_len_idx = 0;\n    let mut col_pos_len_idx_idx\
    \ = 0;\n    let mut row_idx = 0;\n    let mut row_idx_idx = 0;\n    let mut col_pos_idx\
    \ = 0;\n    let mut col_pos_idx_idx = 0;\n    let mut col_pos_len_idx = 0;\n \
    \   let mut col_pos_len_idx_idx = 0;\n    let mut row_len_idx = 0;\n    let mut\
    \ row_len_idx_idx = 0;\n    let mut col_pos_len_idx = 0;\n    let mut col_pos_len_idx_idx\
    \ = 0;\n    let mut row_idx = 0;\n    let mut row_idx_idx = 0;\n    let mut col_pos_idx\
    \ = 0;\n    let mut col_pos_idx_idx = 0;\n    let mut col_pos_len_idx = 0;\n \
    \   let mut col_pos_len_idx_idx = 0;\n    let mut row_len_idx = 0;\n    let mut\
    \ row_len_idx_idx = 0;\n    let mut col_pos_len_idx = 0;\n    let mut col_pos_len_idx_idx\
    \ = 0;\n    let mut row_idx = 0;\n    let mut row_idx_idx = 0;\n    let mut col_pos_idx\
    \ = 0;\n    let mut col_pos_idx_idx = 0;\n    let mut col_pos_len_idx = 0;\n \
    \   let mut col_pos_len_idx_idx = 0;\n    let mut row_len_idx = 0;\n    let mut\
    \ row_len_idx_idx = 0;\n    let mut col_pos_len_idx = 0;\n    let mut col_pos_len_idx_idx\
    \ = 0;\n    let mut row_idx = 0;\n    let mut row_idx_idx = 0;\n    let mut col_pos_idx\
    \ = 0;\n    let mut col_pos_idx_idx = 0;\n    let mut col_pos_len_idx = 0;\n \
    \   let mut col_pos_len_idx_idx = 0;\n    let mut row_len_idx = 0;\n    let mut\
    \ row_len_idx_idx = 0;\n    let mut col_pos_len_idx = 0;\n    let mut col_pos_len_idx_idx\
    \ = 0;\n    let mut row_idx = 0;\n    let mut row_idx_idx = 0;\n    let mut col_pos_idx\
    \ = 0;\n    let mut col_pos_idx_idx = 0;\n    let mut col_pos_len_idx = 0;\n \
    \   let mut col_pos_len_idx_idx = 0;\n    let mut row_len_idx = 0;\n    let mut\
    \ row_len_idx_idx = 0;\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpctz0y1x_.rs:16:47\n   |\n\
    16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \    -------                                    ^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows = lst.len();\n    let mut cols = lst[0].len();\n    let mut coords = vec![];\n\
    \    let mut row_coords = vec![];\n    let mut col_coords = vec![];\n    let mut\
    \ row_sort = vec![];\n    let mut col_sort = vec![];\n    let mut row_sort_idx\
    \ = vec![];\n    let mut col_sort_idx = vec![];\n    let mut row_sort_idx2 = vec![];\n\
    \    let mut col_sort_idx2 = vec![];\n    let mut row_sort_idx3 = vec![];\n  \
    \  let mut col_sort_idx3 = vec![];\n    let mut row_sort_idx4 = vec![];\n    let\
    \ mut col_sort_idx4 = vec![];\n    let mut row_sort_idx5 = vec![];\n    let mut\
    \ col_sort_idx5 = vec![];\n    let mut row_sort_idx6 = vec![];\n    let mut col_sort_idx6\
    \ = vec![];\n    let mut row_sort_idx7 = vec![];\n    let mut col_sort_idx7 =\
    \ vec![];\n    let mut row_sort_idx8 = vec![];\n    let mut col_sort_idx8 = vec![];\n\
    \    let mut row_sort_idx9 = vec![];\n    let mut col_sort_idx9 = vec![];\n  \
    \  let mut row_sort_idx10 = vec![];\n    let mut col_sort_idx10 = vec![];\n  \
    \  let mut row_sort_idx11 = vec![];\n    let mut col_sort_idx11 = vec![];\n  \
    \  let mut row_sort_idx12 = vec![];\n    let mut col_sort_idx12 = vec![];\n  \
    \  let mut row_sort_idx13 = vec![];\n    let mut col_sort_idx13 = vec![];\n  \
    \  let mut row_sort_idx14 = vec![];\n    let mut col_sort_idx14 = vec![];\n  \
    \  let mut row_sort_idx15 = vec![];\n    let mut col_sort_idx15 = vec![];\n  \
    \  let mut row_sort_idx16 = vec![];\n    let mut col_sort_idx16 = vec![];\n  \
    \  let mut row_sort_idx17 = vec![];\n    let mut col_sort_idx17 = vec![];\n  \
    \  let mut row_sort_idx18 = vec![];\n    let mut col_sort_idx18 = vec![];\n  \
    \  let mut row_sort_idx19 = vec![];\n    let mut col_sort_idx19 = vec![];\n  \
    \  let mut row_sort_idx20 = vec![];\n    let mut \n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp8uz9w704.rs:64:1\n\
    \   |\n64 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659749648
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows = lst.len();\n    let mut cols = lst[0].len();\n    let mut result = vec![];\n\
    \    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n\
    \    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut\
    \ col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n  \
    \  let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut\
    \ col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n  \
    \  let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut\
    \ col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n  \
    \  let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mu\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwsp2bs41.rs:71:11\n   |\n\
    71 |     let mu\n   |           ^ help: add `;` here\n72 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwsp2bs41.rs:16:47\n \
    \  |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n\
    \   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749648
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n\
    \    let mut row_idx = 0;\n    let mut col_idx = 0;\n    while row_idx < rows\
    \ {\n        let mut row_sorted = vec![];\n        let mut col_sorted = vec![];\n\
    \        let mut row_max = -1;\n        let mut col_max = -1;\n        for row\
    \ in lst {\n            let row_len = row.len();\n            if row_len > row_max\
    \ {\n                row_max = row_len;\n            }\n            for col in\
    \ row {\n                if col > col_max {\n                    col_max = col;\n\
    \                }\n            }\n        }\n        for col in lst {\n     \
    \       let col_len = col.len();\n            if col_len > col_max {\n       \
    \         col_max = col_len;\n            }\n        }\n        for col in lst\
    \ {\n            let row_len = row.len();\n            if row_len > row_max {\n\
    \                row_max = row_len;\n            }\n            for row in lst\
    \ {\n                let row_idx = row_idx * row_max + col;\n                let\
    \ col_idx = col_idx * col_max + row;\n                row_sorted.push((row_idx,\
    \ col));\n                col_sorted.push((row_idx, col_idx));\n            }\n\
    \        }\n        row_idx += 1;\n        col_idx += 1;\n        result.push(row_sorted);\n\
    \        result.push(col_sorted);\n    }\n    result.sort_by_key(|&(_, y)| y.0);\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `row` in this scope\n  --> /tmp/tmp8vg0jf3_.rs:45:27\n\
    \   |\n45 |             let row_len = row.len();\n   |                       \
    \    ^^^ help: a local variable with a similar name exists: `rows`\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp8vg0jf3_.rs:25:27\n\
    \   |\n25 |         let mut row_max = -1;\n   |                           ^^ the\
    \ trait `Neg` is not implemented for `usize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8vg0jf3_.rs:40:26\n   |\n40 |             if col_len > col_max\
    \ {\n   |                          ^^^^^^^ expected `usize`, found `isize`\n \
    \  |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n40 |             if col_len > col_max.try_into().unwrap()\
    \ {\n   |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8vg0jf3_.rs:41:27\n   |\n41 |              \
    \   col_max = col_len;\n   |                           ^^^^^^^ expected `isize`,\
    \ found `usize`\n\nerror[E0277]: cannot add `Vec<isize>` to `usize`\n  --> /tmp/tmp8vg0jf3_.rs:50:49\n\
    \   |\n50 |                 let row_idx = row_idx * row_max + col;\n   |     \
    \                                            ^ no implementation for `usize +\
    \ Vec<isize>`\n   |\n   = help: the trait `Add<Vec<isize>>` is not implemented\
    \ for `usize`\n\nerror[E0277]: cannot add `Vec<isize>` to `isize`\n  --> /tmp/tmp8vg0jf3_.rs:51:49\n\
    \   |\n51 |                 let col_idx = col_idx * col_max + row;\n   |     \
    \                                            ^ no implementation for `isize +\
    \ Vec<isize>`\n   |\n   = help: the trait `Add<Vec<isize>>` is not implemented\
    \ for `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8vg0jf3_.rs:61:26\n\
    \   |\n61 |     result.sort_by_key(|&(_, y)| y.0);\n   |                     \
    \     ^^^^^-\n   |                          |    |\n   |                     \
    \     |    expected due to this\n   |                          expected struct\
    \ `Vec`, found tuple\n   |\n   = note: expected struct `Vec<(_, Vec<isize>)>`\n\
    \               found tuple `("
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ coords = vec![];\n    let mut rows = vec![];\n    let mut cols = vec![];\n \
    \   let mut row_coords = vec![];\n    let mut col_coords = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sort\
    \ = vec![];\n    let mut col_sort = vec![];\n    let mut row_sort_idx = vec![];\n\
    \    let mut col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n    let\
    \ mut col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n    let mut\
    \ col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n    let mut col_sort_idx\
    \ = vec![];\n    let mut row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n\
    \    let mut row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n    let\
    \ mut row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n    let mut\
    \ row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n    let mut row_sort_idx\
    \ = vec![];\n    let mut col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n\
    \    let mut col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n    let\
    \ mut col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n    let mut\
    \ col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n    let mut col_sort_idx\
    \ = vec![];\n    let mut row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n\
    \    let mut row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n    let\
    \ mut row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n    let mut\
    \ row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n    let mut row_sort_idx\
    \ = vec![];\n    let mut col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n\
    \    let mut col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n    let\
    \ mut col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n    let mut\
    \ col_sort_idx = vec![];\n    let mut row_sort_idx = vec\n}\n\nfn main() {\n \
    \   let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp0odr2m3s.rs:68:31\n   |\n\
    68 |     let mut row_sort_idx = vec\n   |                               ^ help:\
    \ add `;` here\n69 | }\n   | - unexpected token\n\nerror[E0423]: expected value,\
    \ found macro `vec`\n  --> /tmp/tmp0odr2m3s.rs:68:28\n   |\n68 |     let mut row_sort_idx\
    \ = vec\n   |                            ^^^ not a value\n   |\nhelp: use `!`\
    \ to invoke the macro\n   |\n68 |     let mut row_sort_idx = vec!\n   |      \
    \                         +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0odr2m3s.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0423.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ coords = vec![];\n    let mut rows = vec![];\n    let mut cols = vec![];\n \
    \   for row in lst {\n        let mut cols = vec![];\n        for col in row {\n\
    \            if col == x {\n                coords.push((row, col));\n       \
    \     }\n            cols.push(col);\n        }\n        rows.push(row);\n   \
    \     cols.push(cols);\n    }\n    coords.sort_by(|a, b| a.1.cmp(&b.1));\n   \
    \ rows.sort_by(|a, b| a.0.cmp(&b.0));\n    cols.sort_by(|a, b| b.0.cmp(&a.0));\n\
    \    coords\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoixvczhl.rs:29:19\n   |\n\
    29 |         cols.push(cols);\n   |                   ^^^^ expected `isize`, found\
    \ struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct\
    \ `Vec<isize>`\n\nerror[E0609]: no field `0` on type `&Vec<isize>`\n  --> /tmp/tmpoixvczhl.rs:32:27\n\
    \   |\n32 |     rows.sort_by(|a, b| a.0.cmp(&b.0));\n   |                    \
    \       ^ unknown field\n\nerror[E0609]: no field `0` on type `&Vec<isize>`\n\
    \  --> /tmp/tmpoixvczhl.rs:32:36\n   |\n32 |     rows.sort_by(|a, b| a.0.cmp(&b.0));\n\
    \   |                                    ^ unknown field\n\nerror[E0609]: no field\
    \ `0` on type `&_`\n  --> /tmp/tmpoixvczhl.rs:33:27\n   |\n33 |     cols.sort_by(|a,\
    \ b| b.0.cmp(&a.0));\n   |                           ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpoixvczhl.rs:34:5\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>,\
    \ x: isize) -> Vec<(isize, isize)> {\n   |                                   \
    \            ------------------- expected `Vec<(isize, isize)>` because of return\
    \ type\n...\n34 |     coords\n   |     ^^^^^^ expected `isize`, found struct `Vec`\n\
    \   |\n   = note: expected struct `Vec<(isize, _)>`\n              found struct\
    \ `Vec<(Vec<isize>, _)>`\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0609.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows = lst.len();\n    let mut cols = lst[0].len();\n    let mut coords = vec![];\n\
    \    let mut row_coords = vec![];\n    let mut col_coords = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut i = 0;\n\
    \    let mut j = 0;\n    while i < rows {\n        let mut row_sorted = vec![];\n\
    \        let mut col_sorted = vec![];\n        let mut j = 0;\n        while j\
    \ < cols {\n            if lst[i][j] == x {\n                row_sorted.push((i,\
    \ j));\n                col_sorted.push((j, i));\n                i += 1;\n  \
    \              j += 1;\n            } else {\n                j += 1;\n      \
    \      }\n        }\n        row_coords.push_all(row_sorted);\n        col_coords.push_all(col_sorted);\n\
    \        i += 1;\n    }\n    row_coords.sort_by(|a, b| a.1.cmp(&b.1));\n    col_coords.sort_by(|a,\
    \ b| b.1.cmp(&a.1));\n    coords.push_all(row_coords);\n    coords.push_all(col_coords);\n\
    \    coords\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `push_all` found for struct `Vec<_>` in the\
    \ current scope\n  --> /tmp/tmpidnt6fej.rs:40:20\n   |\n40 |         row_coords.push_all(row_sorted);\n\
    \   |                    ^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]:\
    \ no method named `push_all` found for struct `Vec<_>` in the current scope\n\
    \  --> /tmp/tmpidnt6fej.rs:41:20\n   |\n41 |         col_coords.push_all(col_sorted);\n\
    \   |                    ^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0609]:\
    \ no field `1` on type `&_`\n  --> /tmp/tmpidnt6fej.rs:44:33\n   |\n44 |     row_coords.sort_by(|a,\
    \ b| a.1.cmp(&b.1));\n   |                                 ^\n\nerror[E0609]:\
    \ no field `1` on type `&_`\n  --> /tmp/tmpidnt6fej.rs:45:33\n   |\n45 |     col_coords.sort_by(|a,\
    \ b| b.1.cmp(&a.1));\n   |                                 ^\n\nerror[E0599]:\
    \ no method named `push_all` found for struct `Vec<_>` in the current scope\n\
    \  --> /tmp/tmpidnt6fej.rs:46:12\n   |\n46 |     coords.push_all(row_coords);\n\
    \   |            ^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method\
    \ named `push_all` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpidnt6fej.rs:47:12\n\
    \   |\n47 |     coords.push_all(col_coords);\n   |            ^^^^^^^^ method\
    \ not found in `Vec<_>`\n\nerror: aborting due to 6 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0609.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut row_len\
    \ = 0;\n    let mut col_len = 0;\n    let mut col_len_idx = 0;\n    let mut row_len_idx\
    \ = 0;\n    let mut col_len_idx_max = 0;\n    let mut row_len_idx_max = 0;\n \
    \   let mut col_len_idx_min = 0;\n    let mut row_len_idx_min = 0;\n    let mut\
    \ col_len_idx_min_max = 0;\n    let mut row_len_idx_min_max = 0;\n    let mut\
    \ col_len_idx_min_max_idx = 0;\n    let mut row_len_idx_min_max_idx = 0;\n   \
    \ let mut col_len_idx_min_max_idx_max = 0;\n    let mut row_len_idx_min_max_idx_max\
    \ = 0;\n    let mut col_len_idx_min_max_idx_min = 0;\n    let mut row_len_idx_min_max_idx_min\
    \ = 0;\n    let mut col_len_idx_min_max_idx_min_max = 0;\n    let mut row_len_idx_min_max_idx_min_max\
    \ = 0;\n    let mut col_len_idx_min_max_idx_min_max_idx = 0;\n    let mut row_len_idx_min_max_idx_min_max_idx\
    \ = 0;\n    let mut col_len_idx_min_max_idx_min_max_idx_max = 0;\n    let mut\
    \ row_len_idx_min_max_idx_min_max_idx_max = 0;\n    let mut col_len_idx_min_max_idx_min_max_idx_min\
    \ = 0;\n    let mut row_len_idx_min_max_idx_min_max_idx_min = 0;\n    let mut\
    \ col_len_idx_min_max_idx_min_max_idx_min_max = 0;\n    let mut row_len_idx_min_max_idx_min_max_idx_min_max\
    \ = 0;\n    let mut col_len_idx_min_max_idx_min_max_idx_min_max_idx = 0;\n   \
    \ let mut row_len_idx_min_max_idx_min_max_idx_min_max_idx = 0;\n    let mut col_len_idx_min_max_idx_min_max_idx_min_max_idx_max\
    \ = 0;\n    let mut row_len_idx_min_max_idx_min_max_idx_min_max_idx_max = 0;\n\
    \    let mut col_len_idx_min_max_idx_min_max_idx_min_max_idx_min = 0;\n    let\
    \ mut row_len_idx_min_max_idx_min_max_idx_min_max_idx_min = 0;\n    let mut col_len_idx_min_max_idx_min_max_idx_min_max_idx_min_max\
    \ = 0;\n    let mut row_len_idx_min_max_idx_min_max_idx_min_max_idx_min_max =\
    \ 0;\n    let mut col_len_idx_min_max_idx_min_max_idx_min_max_idx_min_max_idx\
    \ = 0;\n    let mut row_len_idx_min_max_idx_min_max_idx_min_max_idx_min_max_idx\
    \ = 0;\n    let mu\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpep1j30y8.rs:55:11\n   |\n\
    55 |     let mu\n   |           ^ help: add `;` here\n56 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpep1j30y8.rs:16:47\n \
    \  |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n\
    \   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut row_idx2\
    \ = 0;\n    let mut row_idx3 = 0;\n    let mut row_idx4 = 0;\n    let mut row_idx5\
    \ = 0;\n    let mut row_idx6 = 0;\n    let mut row_idx7 = 0;\n    let mut row_idx8\
    \ = 0;\n    let mut row_idx9 = 0;\n    let mut row_idx10 = 0;\n    let mut row_idx11\
    \ = 0;\n    let mut row_idx12 = 0;\n    let mut row_idx13 = 0;\n    let mut row_idx14\
    \ = 0;\n    let mut row_idx15 = 0;\n    let mut row_idx16 = 0;\n    let mut row_idx17\
    \ = 0;\n    let mut row_idx18 = 0;\n    let mut row_idx19 = 0;\n    let mut row_idx20\
    \ = 0;\n    let mut row_idx21 = 0;\n    let mut row_idx22 = 0;\n    let mut row_idx23\
    \ = 0;\n    let mut row_idx24 = 0;\n    let mut row_idx25 = 0;\n    let mut row_idx26\
    \ = 0;\n    let mut row_idx27 = 0;\n    let mut row_idx28 = 0;\n    let mut row_idx29\
    \ = 0;\n    let mut row_idx30 = 0;\n    let mut row_idx31 = 0;\n    let mut row_idx32\
    \ = 0;\n    let mut row_idx33 = 0;\n    let mut row_idx34 = 0;\n    let mut row_idx35\
    \ = 0;\n    let mut row_idx36 = 0;\n    let mut row_idx37 = 0;\n    let mut row_idx38\
    \ = 0;\n    let mut row_idx39 = 0;\n    let mut row_idx40 = 0;\n    let mut row_idx41\
    \ = 0;\n    let mut row_idx42 = 0;\n    let mut row_idx43 = 0;\n    let mut row_idx44\
    \ = 0;\n    let mut row_idx45 = 0;\n    let mut row_idx46 = 0;\n    let mut row_idx47\
    \ = 0;\n    let mut row_idx48 = 0;\n    let mut row_idx49 = 0;\n    let mut row_idx50\
    \ = 0;\n    let mut row_idx51 = 0;\n    let mut row_idx52 = 0;\n    let mut row_idx53\
    \ = 0;\n    let mut row_idx54 = 0;\n    let mut row_idx55 = 0;\n    let mut row_idx56\
    \ = 0;\n    let mut row_idx57 = 0;\n    let mut row_idx58 = 0;\n    let mut row_idx59\
    \ = 0;\n    let mut row_idx60 = 0;\n    let mut row_idx61 = 0;\n    let mut row_idx62\
    \ = 0;\n    let mut row_\n}\n\nfn main() {\n    let candidate = get_row;\n   \
    \ assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1,\
    \ 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmppjyfu577.rs:80:17\n   |\n\
    80 |     let mut row_\n   |                 ^ help: add `;` here\n81 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppjyfu577.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows = lst.len();\n    let mut cols = lst[0].len();\n    let mut result = vec![];\n\
    \    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n\
    \    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut\
    \ col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n  \
    \  let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut\
    \ col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n  \
    \  let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut\
    \ col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n  \
    \  let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mu\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwsp2bs41.rs:71:11\n   |\n\
    71 |     let mu\n   |           ^ help: add `;` here\n72 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwsp2bs41.rs:16:47\n \
    \  |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n\
    \   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749648
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows = lst.len();\n    let mut cols = lst[0].len();\n    let mut coords = vec![];\n\
    \    let mut row = 0;\n    let mut col = 0;\n    let mut i = 0;\n    while i <\
    \ rows {\n        if row == x {\n            i += 1;\n            continue;\n\
    \        }\n        let mut found = false;\n        for j in 0..cols {\n     \
    \       if col == x {\n                found = true;\n                break;\n\
    \            }\n            if lst[i][j] == x {\n                coords.push((i,\
    \ j));\n                col += 1;\n                found = true;\n           \
    \     break;\n            }\n        }\n        if !found {\n            row +=\
    \ 1;\n            col = 0;\n        }\n        i += 1;\n    }\n    coords.sort_by_key(|&(_,\
    \ y)| y);\n    coords.sort_by_key(|&(_, y)| -y);\n    coords\n}\n\nfn main() {\n\
    \    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmpxn8uhwqh.rs:48:34\n\
    \   |\n48 |     coords.sort_by_key(|&(_, y)| -y);\n   |                      \
    \            ^^ cannot apply unary operator `-`\n   |\n   = note: unsigned values\
    \ cannot be negated\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxn8uhwqh.rs:49:5\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n49 |     coords\n   |   \
    \  ^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n              found struct `Vec<(usize, usize)>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0600.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    let mut row_len = 0;\n    let mut col_len = 0;\n    let mut row_start\
    \ = 0;\n    let mut col_start = 0;\n    let mut row_end = 0;\n    let mut col_end\
    \ = 0;\n    for row in lst {\n        row_len += row.len();\n        row_end =\
    \ row_start + row.len();\n        row_start = row_end;\n        col_idx = 0;\n\
    \        for col in row {\n            col_len += 1;\n            col_end = col_start\
    \ + 1;\n            col_start = col_end;\n            if col == x {\n        \
    \        let row = row_idx as isize;\n                let col = col_idx as isize;\n\
    \                rows.push(vec![(row, col)]);\n                row_idx += 1;\n\
    \                col_idx += 1;\n            }\n        }\n    }\n    rows\n}\n\
    \nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe544zmus.rs:38:27\n   |\n\
    38 |                 rows.push(vec![(row, col)]);\n   |                      \
    \     ^^^^^^^^^^^^^^^^ expected tuple, found struct `Vec`\n   |\n   = note: expected\
    \ tuple `(isize, isize)`\n             found struct `Vec<(isize, isize)>`\n  \
    \ = note: this error originates in the macro `vec` (in Nightly builds, run with\
    \ -Z macro-backtrace for more info)\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n\
    \    let mut row_idx = 0;\n    let mut col_idx = 0;\n    while col_idx < cols\
    \ {\n        if row_idx == rows {\n            break;\n        }\n        let\
    \ mut row_start = row_idx;\n        let mut row_end = row_idx;\n        let mut\
    \ col_start = col_idx;\n        let mut col_end = col_idx;\n        if row_idx\
    \ < rows {\n            row_end = rows - 1;\n        }\n        if col_idx < cols\
    \ {\n            col_end = cols - 1;\n        }\n        if row_start > row_end\
    \ {\n            break;\n        }\n        if col_start > col_end {\n       \
    \     break;\n        }\n        if row_start == row_end && col_start == col_end\
    \ {\n            if lst[row_start][col_idx] == x {\n                result.push((row_start,\
    \ col_idx));\n            }\n        }\n        if row_start < row_end && col_start\
    \ < col_end {\n            if lst[row_start][col_idx] > lst[row_end][col_idx]\
    \ {\n                row_start = row_end;\n            }\n            if lst[row_start][col_idx]\
    \ < lst[row_end][col_idx] {\n                col_start = col_end;\n          \
    \  }\n        }\n        row_idx += 1;\n        col_idx += 1;\n    }\n    result.sort_by_key(|&(x,\
    \ y)| x.0);\n    result.sort_by_key(|&(x, y)| y.0);\n    result\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0610]: `usize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmpkincvt_b.rs:58:36\n   |\n58 |     result.sort_by_key(|&(x, y)|\
    \ x.0);\n   |                                    ^\n\nerror[E0610]: `usize` is\
    \ a primitive type and therefore doesn't have fields\n  --> /tmp/tmpkincvt_b.rs:59:36\n\
    \   |\n59 |     result.sort_by_key(|&(x, y)| y.0);\n   |                     \
    \               ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkincvt_b.rs:60:5\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n60 |     result\n   |   \
    \  ^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n              found struct `Vec<(usize, usize)>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0610.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    for row in lst {\n        let mut row_result = vec![];\n\
    \        for col in row.iter().rev() {\n            if col == x {\n          \
    \      row_result.push((row, col));\n            }\n        }\n        result.push(row_result);\n\
    \    }\n    result.sort_by(|a, b| a.iter().cmp(&b.iter()).reverse());\n    result.sort_by(|a,\
    \ b| b.iter().cmp(&a.iter()).reverse());\n    result\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpaai6hyfj.rs:21:20\n\
    \   |\n21 |             if col == x {\n   |                    ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n\nerror[E0277]: `&std::slice::Iter<'_, (Vec<isize>,\
    \ &isize)>` is not an iterator\n  --> /tmp/tmpaai6hyfj.rs:27:40\n   |\n27 |  \
    \   result.sort_by(|a, b| a.iter().cmp(&b.iter()).reverse());\n   |          \
    \                              ^^^^^^^^^ `&std::slice::Iter<'_, (Vec<isize>, &isize)>`\
    \ is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `&std::slice::Iter<'_, (Vec<isize>, &isize)>`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `&std::slice::Iter<'_,\
    \ (Vec<isize>, &isize)>`\nhelp: consider removing the leading `&`-reference\n\
    \   |\n27 -     result.sort_by(|a, b| a.iter().cmp(&b.iter()).reverse());\n27\
    \ +     result.sort_by(|a, b| a.iter().cmp(b.iter()).reverse());\n   | \nhelp:\
    \ consider changing this borrow's mutability\n   |\n27 |     result.sort_by(|a,\
    \ b| a.iter().cmp(&mut b.iter()).reverse());\n   |                           \
    \             ~~~~\n\nerror[E0277]: `&std::slice::Iter<'_, (Vec<isize>, &isize)>`\
    \ is not an iterator\n  --> /tmp/tmpaai6hyfj.rs:28:40\n   |\n28 |     result.sort_by(|a,\
    \ b| b.iter().cmp(&a.iter()).reverse());\n   |                               \
    \         ^^^^^^^^^ `&std::slice::Iter<'_, (Vec<isize>, &isize)>` is not an iterator\n\
    \   |\n   = help: the trait `Iterator` is not implemented for `&std::slice::Iter<'_,\
    \ (Vec<isize>, &isize)>`\n   = note: required because of the requirements on the\
    \ impl of `IntoIterator` for `&std::slice::Iter<'_, (Vec<isize>, &isize)>`\nhelp:\
    \ consider removing the leading `&`-reference\n   |\n28 -     result.sort_by(|a,\
    \ b| b.iter().cmp(&a.iter()).reverse());\n28 +     result.sort_by(|a, b| b.iter().cmp(a.iter()).reverse());\n\
    \   | \nhelp: consider changing this borrow's mutability\n   |\n28 |     result.sort_by(|a,\
    \ b| b.iter().cmp(&mut a.iter()).reverse());\n   |                     "
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n\
    \    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n\
    \    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut\
    \ col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n  \
    \  let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut\
    \ col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n  \
    \  let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut\
    \ col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n  \
    \  let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mu\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpjwimt5si.rs:71:11\n   |\n\
    71 |     let mu\n   |           ^ help: add `;` here\n72 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjwimt5si.rs:16:47\n \
    \  |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n\
    \   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ lst = lst.clone();\n    let mut row = 0;\n    let mut col = 0;\n    while row\
    \ < lst.len() {\n        if lst[row][col] == x {\n            return vec![(row,\
    \ col)]\n        }\n        row += 1;\n        col += 1;\n    }\n    vec![]\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphge5cel_.rs:22:26\n   |\n\
    22 |             return vec![(row, col)]\n   |                          ^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n22 |             return\
    \ vec![(row.try_into().unwrap(), col)]\n   |                          ~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmphge5cel_.rs:22:31\n   |\n22 |\
    \             return vec![(row, col)]\n   |                               ^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n22 |           \
    \  return vec![(row, col.try_into().unwrap())]\n   |                         \
    \      ~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows: Vec<(isize, isize)> = vec![];\n    let mut row_idx: Vec<isize> = vec![];\n\
    \    let mut row_idx_idx: Vec<isize> = vec![];\n    let mut row_idx_idx_idx: Vec<isize>\
    \ = vec![];\n    let mut row_idx_idx_idx_idx: Vec<isize> = vec![];\n    let mut\
    \ row_idx_idx_idx_idx_idx: Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx: Vec<isize>\
    \ = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx: Vec<isize> = vec![];\n\
    \    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx: Vec<isize> = vec![];\n \
    \   let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx: Vec<isize> = vec![];\n\
    \    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx: Vec<isize> = vec![];\n\
    \    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx: Vec<isize> =\
    \ vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp23pxtg6y.rs:37:21\n   |\n\
    37 |     let mut row_idx_\n   |                     ^ help: add `;` here\n38 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp23pxtg6y.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx2 = vec![];\n    let mut col_idx2 = vec![];\n    let mut row_sorted2\
    \ = vec![];\n    let mut col_sorted2 = vec![];\n    let mut row_idx3 = vec![];\n\
    \    let mut col_idx3 = vec![];\n    let mut row_sorted3 = vec![];\n    let mut\
    \ col_sorted3 = vec![];\n    let mut row_idx4 = vec![];\n    let mut col_idx4\
    \ = vec![];\n    let mut row_sorted4 = vec![];\n    let mut col_sorted4 = vec![];\n\
    \    let mut row_idx5 = vec![];\n    let mut col_idx5 = vec![];\n    let mut row_sorted5\
    \ = vec![];\n    let mut col_sorted5 = vec![];\n    let mut row_idx6 = vec![];\n\
    \    let mut col_idx6 = vec![];\n    let mut row_sorted6 = vec![];\n    let mut\
    \ col_sorted6 = vec![];\n    let mut row_idx7 = vec![];\n    let mut col_idx7\
    \ = vec![];\n    let mut row_sorted7 = vec![];\n    let mut col_sorted7 = vec![];\n\
    \    let mut row_idx8 = vec![];\n    let mut col_idx8 = vec![];\n    let mut row_sorted8\
    \ = vec![];\n    let mut col_sorted8 = vec![];\n    let mut row_idx9 = vec![];\n\
    \    let mut col_idx9 = vec![];\n    let mut row_sorted9 = vec![];\n    let mut\
    \ col_sorted9 = vec![];\n    let mut row_idx10 = vec![];\n    let mut col_idx10\
    \ = vec![];\n    let mut row_sorted10 = vec![];\n    let mut col_sorted10 = vec![];\n\
    \    let mut row_idx11 = vec![];\n    let mut col_idx11 = vec![];\n    let mut\
    \ row_sorted11 = vec![];\n    let mut col_sorted11 = vec![];\n    let mut row_idx12\
    \ = vec![];\n    let mut col_idx12 = vec![];\n    let mut row_sorted12 = vec![];\n\
    \    let mut col_sorted12 = vec![];\n    let mut row_idx13 = vec![];\n    let\
    \ mut col_idx13 = vec![];\n    let mut row_\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwg44o9b1.rs:68:17\n   |\n\
    68 |     let mut row_\n   |                 ^ help: add `;` here\n69 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwg44o9b1.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res = vec![];\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n\
    \    let mut row_idx = 0;\n    let mut col_idx = 0;\n    while row_idx < rows\
    \ {\n        let mut row_res = vec![];\n        while col_idx < cols {\n     \
    \       if row_idx == rows {\n                break;\n            }\n        \
    \    if col_idx == cols {\n                row_res.push((row_idx, col_idx));\n\
    \                break;\n            }\n            if lst[row_idx][col_idx] ==\
    \ x {\n                row_res.push((row_idx, col_idx));\n                break;\n\
    \            }\n            col_idx++;\n        }\n        res.push(row_res);\n\
    \        row_idx++;\n        col_idx = 0;\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `+`\n  --> /tmp/tmps3mmjl_w.rs:36:21\n\
    \   |\n36 |             col_idx++;\n   |                     ^ expected expression\n\
    \nerror: expected expression, found `+`\n  --> /tmp/tmps3mmjl_w.rs:39:17\n   |\n\
    39 |         row_idx++;\n   |                 ^ expected expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmps3mmjl_w.rs:42:5\n   |\n16 | fn get_row(lst:\
    \ Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |                  \
    \                             ------------------- expected `Vec<(isize, isize)>`\
    \ because of return type\n...\n42 |     res\n   |     ^^^ expected tuple, found\
    \ struct `Vec`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n     \
    \         found struct `Vec<Vec<(usize, usize)>>`\n\nerror: aborting due to 3\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n\
    \    let mut row_idx = 1;\n    let mut col_idx = 1;\n    while row_idx < rows\
    \ {\n        let mut row_sorted = vec![];\n        let mut col_sorted = vec![];\n\
    \        let mut row_idx = 1;\n        let mut col_idx = 1;\n        while row_idx\
    \ < rows {\n            if row_idx != row_idx {\n                row_sorted.push((row_idx,\
    \ col_idx));\n            }\n            row_idx += 1;\n        }\n        while\
    \ col_idx < cols {\n            if col_idx != col_idx {\n                col_sorted.push((row_idx,\
    \ col_idx));\n            }\n            col_idx += 1;\n        }\n        result.push(row_sorted.reverse());\n\
    \        result.push(col_sorted.reverse());\n    }\n    result.sort_by_key(|&(x,\
    \ y)| x.0);\n    result.sort_by_key(|&(x, y)| y.0);\n    result\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcz2s01yb.rs:42:26\n   |\n\
    42 |     result.sort_by_key(|&(x, y)| x.0);\n   |                          ^^^^^-\n\
    \   |                          |    |\n   |                          |    expected\
    \ due to this\n   |                          expected `()`, found tuple\n   |\n\
    \   = note: expected unit type `()`\n                  found tuple `(_, _)`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpcz2s01yb.rs:43:26\n   |\n43 |  \
    \   result.sort_by_key(|&(x, y)| y.0);\n   |                          ^^^^^-\n\
    \   |                          |    |\n   |                          |    expected\
    \ due to this\n   |                          expected `()`, found tuple\n   |\n\
    \   = note: expected unit type `()`\n                  found tuple `(_, _)`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpcz2s01yb.rs:44:5\n   |\n16 | fn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |     \
    \                                          ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n44 |     result\n   |     ^^^^^^ expected\
    \ tuple, found `()`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \              found struct `Vec<()>`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows: Vec<(isize, isize)> = vec![];\n    for row in lst {\n        let mut row_sorted\
    \ = vec![];\n        for elem in row.iter().cloned() {\n            if elem ==\
    \ x {\n                row_sorted.push((row, elem));\n            }\n        }\n\
    \        rows.push(row_sorted.reverse());\n    }\n    rows.sort_by(|a, b| a.0.cmp(&b.0));\n\
    \    rows.sort_by(|a, b| b.1.cmp(&a.1));\n    rows\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbhsd782r.rs:25:19\n   |\n\
    25 |         rows.push(row_sorted.reverse());\n   |                   ^^^^^^^^^^^^^^^^^^^^\
    \ expected tuple, found `()`\n   |\n   = note:  expected tuple `(isize, isize)`\n\
    \           found unit type `()`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut col_max\
    \ = 0;\n    let mut col_min = 0;\n    let mut row_max = lst.len();\n    let mut\
    \ row_min = row_max - 1;\n    while row_idx < row_max {\n        let mut col_max\
    \ = 0;\n        let mut col_min = 0;\n        let mut row_max = lst.len();\n \
    \       let mut row_min = row_max - 1;\n        while col_max < col_min {\n  \
    \          let mut col_max = col_max;\n            let mut col_min = col_max;\n\
    \            let mut row_max = lst.len();\n            let mut row_min = row_max\
    \ - 1;\n            while row_max > row_min {\n                let mut row_max\
    \ = row_max;\n                let mut row_min = row_max - 1;\n               \
    \ while col_max < col_min {\n                    let mut col_max = col_max;\n\
    \                    let mut col_min = col_max;\n                    let mut row_max\
    \ = lst.len();\n                    let mut row_min = row_max - 1;\n         \
    \           while row_max > row_min {\n                        if row_idx == row_min\
    \ {\n                            row_idx -= 1;\n                            break;\n\
    \                        }\n                        if row_idx == row_max {\n\
    \                            row_idx -= 1;\n                            break;\n\
    \                        }\n                        if col_max == col_min {\n\
    \                            col_max -= 1;\n                            col_max\
    \ -= 1;\n                            break;\n                        }\n     \
    \                   if col_max == col_max {\n                            col_max\
    \ -= 1;\n                            col_max -= 1;\n                         \
    \   break;\n                        }\n                        if col_max == col_max\
    \ {\n                            col_max -= 1;\n                            col_max\
    \ -= 1;\n                            break;\n                        }\n     \
    \                   if col_max == col_max {\n                            col_max\
    \ -= 1;\n                            col_max -= 1;\n                         \
    \   break;\n                        }\n                        if col_max == col_max\
    \ {\n                            col_max -= 1;\n                            col_max\
    \ -= 1;\n                            break;\n                        }\n     \
    \                   if col_max == col_max {\n                            col_max\
    \ -= 1;\n                            col_max -= 1;\n                         \
    \   break;\n                        }\n                        if col_max == col_max\
    \ {\n                            col_max -= 1;\n                            col_max\
    \ -= 1;\n                            break;\n                        }\n     \
    \                   if col_max == col_max {\n                            col_max\
    \ -= 1;\n                            col_max -= 1;\n                         \
    \   break;\n                        }\n                        if col_max == col_max\
    \ {\n                            col_max -= 1;\n                            col_max\
    \ -= 1;\n                            break;\n                        }\n     \
    \                   if col_max == col_max {\n                            col_max\
    \ -= 1;\n                            col_max -= 1;\n\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp7yb8flmc.rs:109:3\n\
    \    |\n16  | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    |                                                                   -\
    \ unclosed delimiter\n...\n23  |     while row_idx < row_max {\n    |        \
    \                     - unclosed delimiter\n...\n28  |         while col_max <\
    \ col_min {\n    |                                 - unclosed delimiter\n...\n\
    33  |             while row_max > row_min {\n    |                           \
    \          - unclosed delimiter\n...\n36  |                 while col_max < col_min\
    \ {\n    |                                         - unclosed delimiter\n...\n\
    41  |                     while row_max > row_min {\n    |                   \
    \                          - unclosed delimiter\n...\n95  |                  \
    \       if col_max == col_max {\n    |                                       \
    \        - this delimiter might not be properly closed...\n...\n99  | }\n    |\
    \ - ...as it matches this but it has different indentation\n...\n109 | }\n   \
    \ |   ^\n\nerror[E0308]: mismatched types\n   --> /tmp/tmp7yb8flmc.rs:23:5\n \
    \   |\n16  |   fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    |                                                 -------------------\
    \ expected `Vec<(isize, isize)>` because of return type\n...\n23  | /     while\
    \ row_idx < row_max {\n24  | |         let mut col_max = 0;\n25  | |         let\
    \ mut col_min = 0;\n26  | |         let mut row_max = lst.len();\n...   |\n108\
    \ | |     assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2, 3]], 3), vec![(2,\
    \ 2)]);\n109 | | }\n    | |__^ expected struct `Vec`, found `()`\n    |\n    =\
    \ note: expected struct `Vec<(isize, isize)>`\n            found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idxs = vec![];\n    let mut col_idxs = vec![];\n    let mut row_idxs_sorted\
    \ = vec![];\n    let mut col_idxs_sorted = vec![];\n    let mut row_idxs_size\
    \ = vec![];\n    let mut col_idxs_size = vec![];\n    let mut row_idxs_size =\
    \ vec![];\n    let mut col_idxs_size = vec![];\n    let mut row_idxs_size = vec![];\n\
    \    let mut col_idxs_size = vec![];\n    let mut row_idxs_size = vec![];\n  \
    \  let mut col_idxs_size = vec![];\n    let mut row_idxs_size = vec![];\n    let\
    \ mut col_idxs_size = vec![];\n    let mut row_idxs_size = vec![];\n    let mut\
    \ col_idxs_size = vec![];\n    let mut row_idxs_size = vec![];\n    let mut col_idxs_size\
    \ = vec![];\n    let mut row_idxs_size = vec![];\n    let mut col_idxs_size =\
    \ vec![];\n    let mut row_idxs_size = vec![];\n    let mut col_idxs_size = vec![];\n\
    \    let mut row_idxs_size = vec![];\n    let mut col_idxs_size = vec![];\n  \
    \  let mut row_idxs_size = vec![];\n    let mut col_idxs_size = vec![];\n    let\
    \ mut row_idxs_size = vec![];\n    let mut col_idxs_size = vec![];\n    let mut\
    \ row_idxs_size = vec![];\n    let mut col_idxs_size = vec![];\n    let mut row_idxs_size\
    \ = vec![];\n    let mut col_idxs_size = vec![];\n    let mut row_idxs_size =\
    \ vec![];\n    let mut col_idxs_size = vec![];\n    let mut row_idxs_size = vec![];\n\
    \    let mut col_idxs_size = vec![];\n    let mut row_idxs_size = vec![];\n  \
    \  let mut col_idxs_size = vec![];\n    let mut row_idxs_size = vec![];\n    let\
    \ mut col_idxs_size = vec![];\n    let mut row_idxs_size = vec![];\n    let mut\
    \ col_idxs_size = vec![];\n    let mut row_\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpyaumyyfu.rs:64:17\n   |\n\
    64 |     let mut row_\n   |                 ^ help: add `;` here\n65 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyaumyyfu.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut row_idx_max\
    \ = 0;\n    let mut row_idx_min = std::cmp::min::<isize>(lst.len(), x);\n    let\
    \ mut col_max = 0;\n    let mut col_min = 0;\n    let mut col_max_idx = 0;\n \
    \   let mut col_min_idx = 0;\n    let mut col_max_idx2 = 0;\n    let mut col_min_idx2\
    \ = 0;\n    let mut col_max_idx3 = 0;\n    let mut col_min_idx3 = 0;\n    let\
    \ mut col_max_idx4 = 0;\n    let mut col_min_idx4 = 0;\n    let mut col_max_idx5\
    \ = 0;\n    let mut col_min_idx5 = 0;\n    let mut col_max_idx6 = 0;\n    let\
    \ mut col_min_idx6 = 0;\n    let mut col_max_idx7 = 0;\n    let mut col_min_idx7\
    \ = 0;\n    let mut col_max_idx8 = 0;\n    let mut col_min_idx8 = 0;\n    let\
    \ mut col_max_idx9 = 0;\n    let mut col_min_idx9 = 0;\n    let mut col_max_idx10\
    \ = 0;\n    let mut col_min_idx10 = 0;\n    let mut col_max_idx11 = 0;\n    let\
    \ mut col_min_idx11 = 0;\n    let mut col_max_idx12 = 0;\n    let mut col_min_idx12\
    \ = 0;\n    let mut col_max_idx13 = 0;\n    let mut col_min_idx13 = 0;\n    let\
    \ mut col_max_idx14 = 0;\n    let mut col_min_idx14 = 0;\n    let mut col_max_idx15\
    \ = 0;\n    let mut col_min_idx15 = 0;\n    let mut col_max_idx16 = 0;\n    let\
    \ mut col_min_idx16 = 0;\n    let mut col_max_idx17 = 0;\n    let mut col_min_idx17\
    \ = 0;\n    let mut col_max_idx18 = 0;\n    let mut col_min_idx18 = 0;\n    let\
    \ mut col_max_idx19 = 0;\n    let mut col_min_idx19 = 0;\n    let mut col_max_idx20\
    \ = 0;\n    let mut col_min_idx20 = 0;\n    let mut col_max_idx21 = 0;\n    let\
    \ mut col_min_idx21 = 0;\n    let mut col_max_idx22 = 0;\n    let mut col_min_idx22\
    \ = 0;\n    let mut col_max_idx23 = 0;\n    let mut col_min_idx23 = 0;\n    let\
    \ mut col_max_idx24 = 0;\n    let mut col_min_idx24 = 0;\n    let mut col_max_idx25\
    \ = 0;\n    let mut col_min_idx25 = 0;\n    let mut col_max_\n}\n\nfn main() {\n\
    \    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpadss3jru.rs:73:21\n   |\n\
    73 |     let mut col_max_\n   |                     ^ help: add `;` here\n74 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpadss3jru.rs:20:50\n\
    \   |\n20 |     let mut row_idx_min = std::cmp::min::<isize>(lst.len(), x);\n\
    \   |                                                  ^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n20 |     let mut row_idx_min = std::cmp::min::<isize>(lst.len().try_into().unwrap(),\
    \ x);\n   |                                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpadss3jru.rs:16:47\n   |\n16 |\
    \ fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |  \
    \  -------                                    ^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx: usize = 0;\n    let\
    \ mut row_len: usize = 0;\n    let mut col_len: usize = 0;\n    for row in lst\
    \ {\n        row_len += row.len();\n        col_len = row.len();\n        if row_idx\
    \ < row_len && row_idx < col_len {\n            if row[row_idx] == x {\n     \
    \           row.swap(row_idx, row_len-1);\n                row.swap(row_len-1,\
    \ row_len-2);\n                row.swap(row_len-2, row_len-1);\n             \
    \   row.swap(row_len-1, row_len);\n                row.swap(row_len-1, row_len-1);\n\
    \                row.swap(row_len-1, row_len-1);\n                row.swap(row_len-1,\
    \ row_len-1);\n                row.swap(row_len-1, row_len-1);\n             \
    \   row.swap(row_len-1, row_len-1);\n                row.swap(row_len-1, row_len-1);\n\
    \                row.swap(row_len-1, row_len-1);\n                row.swap(row_len-1,\
    \ row_len-1);\n                row.swap(row_len-1, row_len-1);\n             \
    \   row.swap(row_len-1, row_len-1);\n                row.swap(row_len-1, row_len-1);\n\
    \                row.swap(row_len-1, row_len-1);\n                row.swap(row_len-1,\
    \ row_len-1);\n                row.swap(row_len-1, row_len-1);\n             \
    \   row.swap(row_len-1, row_len-1);\n                row.swap(row_len-1, row_len-1);\n\
    \                row.swap(row_len-1, row_len-1);\n                row.swap(row_len-1,\
    \ row_len-1);\n                row.swap(row_len-1, row_len-1);\n             \
    \   row.swap(row_len-1, row_len-1);\n                row.swap(row_len-1, row_len-1);\n\
    \                row.swap(row_len-1, row_len-1);\n                row.swap(row_len-1,\
    \ row_len-1);\n                row.swap(row_len-1, row_len-1);\n             \
    \   row.swap(row_len-1, row_len-1);\n                row.swap(row_len-1, row_len-1);\n\
    \                row.swap(row_len-1, row_len-1);\n                row.swap(row_len-1,\
    \ row_len-1);\n                row.swap(row_len-1, row_len-1);\n             \
    \   row.swap(row_len-1, row_len-1);\n                row.swap(row_len-1, row_len-1);\n\
    \                row.swap(row_len-1, row_len-1);\n                row.swap(row_len-1,\
    \ row_len-1);\n                row.swap(row_len-1, row_len-1);\n             \
    \   row.swap(row_len\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpbszo0wsa.rs:75:3\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                                                   -\
    \ unclosed delimiter\n...\n21 |     for row in lst {\n   |                   \
    \ - unclosed delimiter\n...\n24 |         if row_idx < row_len && row_idx < col_len\
    \ {\n   |                                                   - unclosed delimiter\n\
    25 |             if row[row_idx] == x {\n   |                                \
    \  - this delimiter might not be properly closed...\n...\n65 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n75 | }\n   |   ^\n\n\
    error: mismatched closing delimiter: `}`\n  --> /tmp/tmpbszo0wsa.rs:64:25\n  \
    \ |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n\
    \   |                                                                   - closing\
    \ delimiter possibly meant for this\n...\n64 |                 row.swap(row_len\n\
    \   |                         ^ unclosed delimiter\n65 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror[E0061]: this function takes 2 arguments but 1 argument\
    \ was supplied\n   --> /tmp/tmpbszo0wsa.rs:64:21\n    |\n64  |               \
    \  row.swap(row_len\n    |                     ^^^^ ------- supplied 1 argument\n\
    \    |                     |\n    |                     expected 2 arguments\n\
    \    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbszo0wsa.rs:21:5\n   |\n16 |   fn get_row(lst: Vec<Vec<isize>>,\
    \ x: isize) -> Vec<(isize, isize)> {\n   |                                   \
    \              ------------------- expected `Vec<(isize, isize)>` because of return\
    \ type\n...\n21 | /     for row in lst {\n22 | |         row_len += row.len();\n\
    23 | |         col_len = row.len();\n24 | |         if row_idx < row_len && row_idx\
    \ < col_len {\n...  |\n74 | |     assert_eq!(candidate(vec![vec![], vec![1], vec![1,\
    \ 2, 3]], 3), vec![(2, 2)]);\n75 | | }\n   | |__^ expected struct `Vec`, found\
    \ `()`\n   |\n   = note: expected struct `Vec<(isize, isize"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n\
    \    let mut row_idx = 0;\n    let mut col_idx = 0;\n    while row_idx < rows\
    \ {\n        let mut row_result = vec![];\n        while col_idx < cols {\n  \
    \          if row_idx == row_idx {\n                if col_idx < cols {\n    \
    \                row_result.push((row_idx, col_idx));\n                }\n   \
    \             col_idx++;\n            } else {\n                if row_idx < rows\
    \ {\n                    row_result.push((row_idx, col_idx));\n              \
    \  }\n                row_idx++;\n            }\n        }\n        result.push(row_result);\n\
    \    }\n    result.sort_by_key(|&(_, y)| y.cmp(&x));\n    result.sort_by_key(|&(_,\
    \ y)| y.cmp(&-x));\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `+`\n  --> /tmp/tmp4vmdd9so.rs:29:25\n\
    \   |\n29 |                 col_idx++;\n   |                         ^ expected\
    \ expression\n\nerror: expected expression, found `+`\n  --> /tmp/tmp4vmdd9so.rs:34:25\n\
    \   |\n34 |                 row_idx++;\n   |                         ^ expected\
    \ expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4vmdd9so.rs:39:26\n\
    \   |\n39 |     result.sort_by_key(|&(_, y)| y.cmp(&x));\n   |               \
    \           ^^^^^-\n   |                          |    |\n   |               \
    \           |    expected due to this\n   |                          expected\
    \ struct `Vec`, found tuple\n   |\n   = note: expected struct `Vec<(usize, usize)>`\n\
    \               found tuple `(_, _)`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp4vmdd9so.rs:40:26\n   |\n40 |     result.sort_by_key(|&(_, y)| y.cmp(&-x));\n\
    \   |                          ^^^^^-\n   |                          |    |\n\
    \   |                          |    expected due to this\n   |               \
    \           expected struct `Vec`, found tuple\n   |\n   = note: expected struct\
    \ `Vec<(usize, usize)>`\n               found tuple `(_, _)`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4vmdd9so.rs:41:5\n   |\n16 | fn get_row(lst:\
    \ Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |                  \
    \                             ------------------- expected `Vec<(isize, isize)>`\
    \ because of return type\n...\n41 |     result\n   |     ^^^^^^ expected tuple,\
    \ found struct `Vec`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \              found struct `Vec<Vec<(usize, usize)>>`\n\nerror: aborting due\
    \ to 5 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ coords = vec![];\n    for row in lst {\n        let mut coord = vec![];\n  \
    \      for col in row.iter().rev() {\n            if col == x {\n            \
    \    coord.push((row.len(), col.len()));\n            }\n        }\n        coords.push_back(coord);\n\
    \    }\n    coords.sort_by_key(|x| x.0);\n    coords.sort_by_key(|x| x.1, |a,\
    \ b| b.1.cmp(&a.1));\n    coords\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp70ziugye.rs:21:20\n\
    \   |\n21 |             if col == x {\n   |                    ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n\nerror[E0599]: no method named `len` found for reference\
    \ `&isize` in the current scope\n  --> /tmp/tmp70ziugye.rs:22:44\n   |\n22 | \
    \                coord.push((row.len(), col.len()));\n   |                   \
    \                         ^^^ method not found in `&isize`\n\nerror[E0599]: no\
    \ method named `push_back` found for struct `Vec<_>` in the current scope\n  -->\
    \ /tmp/tmp70ziugye.rs:25:16\n   |\n25 |         coords.push_back(coord);\n   |\
    \                ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0609]: no field\
    \ `0` on type `&_`\n  --> /tmp/tmp70ziugye.rs:27:30\n   |\n27 |     coords.sort_by_key(|x|\
    \ x.0);\n   |                              ^\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0599, E0609.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n\
    \    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorting = false;\n\
    \    let mut col_sorting = false;\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    let mut row_idx2 = 0;\n    let mut col_idx2 = 0;\n    let mut row_idx3\
    \ = 0;\n    let mut col_idx3 = 0;\n    let mut row_idx4 = 0;\n    let mut col_idx4\
    \ = 0;\n    let mut row_idx5 = 0;\n    let mut col_idx5 = 0;\n    let mut row_idx6\
    \ = 0;\n    let mut col_idx6 = 0;\n    let mut row_idx7 = 0;\n    let mut col_idx7\
    \ = 0;\n    let mut row_idx8 = 0;\n    let mut col_idx8 = 0;\n    let mut row_idx9\
    \ = 0;\n    let mut col_idx9 = 0;\n    let mut row_idx10 = 0;\n    let mut col_idx10\
    \ = 0;\n    let mut row_idx11 = 0;\n    let mut col_idx11 = 0;\n    let mut row_idx12\
    \ = 0;\n    let mut col_idx12 = 0;\n    let mut row_idx13 = 0;\n    let mut col_idx13\
    \ = 0;\n    let mut row_idx14 = 0;\n    let mut col_idx14 = 0;\n    let mut row_idx15\
    \ = 0;\n    let mut col_idx15 = 0;\n    let mut row_idx16 = 0;\n    let mut col_idx16\
    \ = 0;\n    let mut row_idx17 = 0;\n    let mut col_idx17 = 0;\n    let mut row_idx18\
    \ = 0;\n    let mut col_idx18 = 0;\n    let mut row_idx19 = 0;\n    let mut col_idx19\
    \ = 0;\n    let mut row_idx20 = 0;\n    let mut col_idx20 = 0;\n    let mut row_idx21\
    \ = 0;\n    let mut col_idx21 = 0;\n    let mut row_idx22 = 0;\n    let mut col_idx22\
    \ = 0;\n    let mut row_idx23 = 0;\n    let mut col_idx23 = 0;\n    let mut row_idx24\
    \ = 0;\n    let mut col_idx24 = 0;\n    let mut row_idx25 = 0;\n    let mut col_idx25\
    \ = 0;\n    let mut row_idx26 = 0;\n    let mut col_idx26 = 0;\n    let mut row_idx27\
    \ = 0;\n    let mut col_idx27 = 0;\n    let mut row_idx28 = 0;\n    let \n}\n\n\
    fn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpjmsf7zhv.rs:82:1\n  \
    \ |\n82 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    let mut row_idx2 = 0;\n    let mut col_idx2 = 0;\n    let mut row_idx3\
    \ = 0;\n    let mut col_idx3 = 0;\n    for row in lst {\n        if row_idx ==\
    \ x {\n            break;\n        }\n        for col in row {\n            if\
    \ col_idx == x {\n                break;\n            }\n            if row_idx2\
    \ == x {\n                break;\n            }\n            if col_idx2 == x\
    \ {\n                break;\n            }\n            if row_idx3 == x {\n \
    \               break;\n            }\n            if col_idx3 == x {\n      \
    \          break;\n            }\n            row.push(col);\n            row_idx\
    \ += 1;\n            col_idx += 1;\n            row_idx2 += 1;\n            col_idx2\
    \ += 1;\n            row_idx3 += 1;\n            col_idx3 += 1;\n        }\n \
    \   }\n    row.sort_by_key(|&x| x.0);\n    row.sort_by_key(|&x| x.1);\n    row.sort_by_key(|&x|\
    \ x.0);\n    row.sort_by_key(|&x| x.1);\n    row\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `row` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpy7rlj3ew.rs:44:13\n   |\n24 |     for row in lst {\n\
    \   |         --- help: consider changing this to be mutable: `mut row`\n...\n\
    44 |             row.push(col);\n   |             ^^^ cannot borrow as mutable\n\
    \nerror[E0382]: borrow of moved value: `row`\n   --> /tmp/tmpy7rlj3ew.rs:44:13\n\
    \    |\n24  |     for row in lst {\n    |         --- move occurs because `row`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n28  |\
    \         for col in row {\n    |                    ---\n    |              \
    \      |\n    |                    `row` moved due to this implicit call to `.into_iter()`\n\
    \    |                    help: consider borrowing to avoid moving into the for\
    \ loop: `&row`\n...\n44  |             row.push(col);\n    |             ^^^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `row`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0382, E0596.\nFor more information\
    \ about an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ coords = vec![];\n    let mut rows = vec![];\n    for row in lst {\n       \
    \ let mut cols = vec![];\n        for col in row {\n            if col == x {\n\
    \                cols.push((row, col));\n            }\n        }\n        rows.push((row,\
    \ cols));\n    }\n    for row in rows {\n        let mut cols = vec![];\n    \
    \    for col in row.1 {\n            cols.push((row.0, col));\n        }\n   \
    \     coords.push((row, cols));\n    }\n    coords.sort_by(|a, b| a.1.iter().cmp(&b.1.iter()));\n\
    \    coords.sort_by(|a, b| b.0.iter().cmp(&a.0.iter()));\n    coords\n}\n\nfn\
    \ main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&std::slice::Iter<'_, (Vec<isize>, (Vec<isize>, isize))>`\
    \ is not an iterator\n  --> /tmp/tmpet7g6c15.rs:35:42\n   |\n35 |     coords.sort_by(|a,\
    \ b| a.1.iter().cmp(&b.1.iter()));\n   |                                     \
    \     ^^^^^^^^^^^ `&std::slice::Iter<'_, (Vec<isize>, (Vec<isize>, isize))>` is\
    \ not an iterator\n   |\n   = help: the trait `Iterator` is not implemented for\
    \ `&std::slice::Iter<'_, (Vec<isize>, (Vec<isize>, isize))>`\n   = note: required\
    \ because of the requirements on the impl of `IntoIterator` for `&std::slice::Iter<'_,\
    \ (Vec<isize>, (Vec<isize>, isize))>`\nhelp: consider removing the leading `&`-reference\n\
    \   |\n35 -     coords.sort_by(|a, b| a.1.iter().cmp(&b.1.iter()));\n35 +    \
    \ coords.sort_by(|a, b| a.1.iter().cmp(b.1.iter()));\n   | \nhelp: consider changing\
    \ this borrow's mutability\n   |\n35 |     coords.sort_by(|a, b| a.1.iter().cmp(&mut\
    \ b.1.iter()));\n   |                                          ~~~~\n\nerror[E0599]:\
    \ no method named `iter` found for tuple `(Vec<isize>, Vec<(Vec<isize>, isize)>)`\
    \ in the current scope\n  --> /tmp/tmpet7g6c15.rs:36:31\n   |\n36 |     coords.sort_by(|a,\
    \ b| b.0.iter().cmp(&a.0.iter()));\n   |                               ^^^^ method\
    \ not found in `(Vec<isize>, Vec<(Vec<isize>, isize)>)`\n\nerror[E0599]: no method\
    \ named `iter` found for tuple `(Vec<isize>, Vec<(Vec<isize>, isize)>)` in the\
    \ current scope\n  --> /tmp/tmpet7g6c15.rs:36:47\n   |\n36 |     coords.sort_by(|a,\
    \ b| b.0.iter().cmp(&a.0.iter()));\n   |                                     \
    \          ^^^^ method not found in `(Vec<isize>, Vec<(Vec<isize>, isize)>)`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpet7g6c15.rs:37:5\n   |\n16 | fn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |     \
    \                                          ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n37 |     coords\n   |     ^^^^^^ expected\
    \ `isize`, found tuple\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \              found struct `Vec<((Vec<isize>, Vec<(Vec<isize>, isize)>), Vec<("
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx2 = vec![];\n    let mut col_idx2 = vec![];\n    let mut row_sorted2\
    \ = vec![];\n    let mut col_sorted2 = vec![];\n    let mut row_idx3 = vec![];\n\
    \    let mut col_idx3 = vec![];\n    let mut row_sorted3 = vec![];\n    let mut\
    \ col_sorted3 = vec![];\n    let mut row_idx4 = vec![];\n    let mut col_idx4\
    \ = vec![];\n    let mut row_sorted4 = vec![];\n    let mut col_sorted4 = vec![];\n\
    \    let mut row_idx5 = vec![];\n    let mut col_idx5 = vec![];\n    let mut row_sorted5\
    \ = vec![];\n    let mut col_sorted5 = vec![];\n    let mut row_idx6 = vec![];\n\
    \    let mut col_idx6 = vec![];\n    let mut row_sorted6 = vec![];\n    let mut\
    \ col_sorted6 = vec![];\n    let mut row_idx7 = vec![];\n    let mut col_idx7\
    \ = vec![];\n    let mut row_sorted7 = vec![];\n    let mut col_sorted7 = vec![];\n\
    \    let mut row_idx8 = vec![];\n    let mut col_idx8 = vec![];\n    let mut row_sorted8\
    \ = vec![];\n    let mut col_sorted8 = vec![];\n    let mut row_idx9 = vec![];\n\
    \    let mut col_idx9 = vec![];\n    let mut row_sorted9 = vec![];\n    let mut\
    \ col_sorted9 = vec![];\n    let mut row_idx10 = vec![];\n    let mut col_idx10\
    \ = vec![];\n    let mut row_sorted10 = vec![];\n    let mut col_sorted10 = vec![];\n\
    \    let mut row_idx11 = vec![];\n    let mut col_idx11 = vec![];\n    let mut\
    \ row_sorted11 = vec![];\n    let mut col_sorted11 = vec![];\n    let mut row_idx12\
    \ = vec![];\n    let mut col_idx12 = vec![];\n    let mut row_sorted12 = vec![];\n\
    \    let mut col_sorted12 = vec![];\n    let mut row_idx13 = vec![];\n    let\
    \ mut col_idx13 = vec![];\n    let mut row_\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwg44o9b1.rs:68:17\n   |\n\
    68 |     let mut row_\n   |                 ^ help: add `;` here\n69 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwg44o9b1.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ coords = vec![];\n    let mut rows = vec![];\n    let mut cols = vec![];\n \
    \   for row in lst {\n        let mut cols = vec![];\n        for col in row {\n\
    \            if col == x {\n                coords.push((row, col));\n       \
    \     }\n            cols.push(col);\n        }\n        rows.push(row);\n   \
    \     cols.push(cols);\n    }\n    coords.sort_by(|a, b| a.0.cmp(&b.0));\n   \
    \ rows.sort_by(|a, b| a.0.cmp(&b.0));\n    cols.sort_by(|a, b| b.0.cmp(&a.0));\n\
    \    coords\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp139g2403.rs:29:19\n   |\n\
    29 |         cols.push(cols);\n   |                   ^^^^ expected `isize`, found\
    \ struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct\
    \ `Vec<isize>`\n\nerror[E0609]: no field `0` on type `&Vec<isize>`\n  --> /tmp/tmp139g2403.rs:32:27\n\
    \   |\n32 |     rows.sort_by(|a, b| a.0.cmp(&b.0));\n   |                    \
    \       ^ unknown field\n\nerror[E0609]: no field `0` on type `&Vec<isize>`\n\
    \  --> /tmp/tmp139g2403.rs:32:36\n   |\n32 |     rows.sort_by(|a, b| a.0.cmp(&b.0));\n\
    \   |                                    ^ unknown field\n\nerror[E0609]: no field\
    \ `0` on type `&_`\n  --> /tmp/tmp139g2403.rs:33:27\n   |\n33 |     cols.sort_by(|a,\
    \ b| b.0.cmp(&a.0));\n   |                           ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp139g2403.rs:34:5\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>,\
    \ x: isize) -> Vec<(isize, isize)> {\n   |                                   \
    \            ------------------- expected `Vec<(isize, isize)>` because of return\
    \ type\n...\n34 |     coords\n   |     ^^^^^^ expected `isize`, found struct `Vec`\n\
    \   |\n   = note: expected struct `Vec<(isize, _)>`\n              found struct\
    \ `Vec<(Vec<isize>, _)>`\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0609.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows: Vec<(isize, isize)> = vec![];\n    let mut row_idx: Vec<isize> = vec![];\n\
    \    let mut row_idx2: Vec<isize> = vec![];\n    let mut row_idx3: Vec<isize>\
    \ = vec![];\n    let mut row_idx4: Vec<isize> = vec![];\n    let mut row_idx5:\
    \ Vec<isize> = vec![];\n    let mut row_idx6: Vec<isize> = vec![];\n    let mut\
    \ row_idx7: Vec<isize> = vec![];\n    let mut row_idx8: Vec<isize> = vec![];\n\
    \    let mut row_idx9: Vec<isize> = vec![];\n    let mut row_idx10: Vec<isize>\
    \ = vec![];\n    let mut row_idx11: Vec<isize> = vec![];\n    let mut row_idx12:\
    \ Vec<isize> = vec![];\n    let mut row_idx13: Vec<isize> = vec![];\n    let mut\
    \ row_idx14: Vec<isize> = vec![];\n    let mut row_idx15: Vec<isize> = vec![];\n\
    \    let mut row_idx16: Vec<isize> = vec![];\n    let mut row_idx17: Vec<isize>\
    \ = vec![];\n    let mut row_idx18: Vec<isize> = vec![];\n    let mut row_idx19:\
    \ Vec<isize> = vec![];\n    let mut row_idx20: Vec<isize> = vec![];\n    let mut\
    \ row_idx21: Vec<isize> = vec![];\n    let mut row_idx22: Vec<isize> = vec![];\n\
    \    let mut row_idx23: Vec<isize> = vec![];\n    let mut row_idx24: Vec<isize>\
    \ = vec![];\n    let mut row_idx25: Vec<isize> = vec![];\n    let mut row_idx26:\
    \ Vec<isize> = vec![];\n    let mut row_idx27: Vec<isize> = vec![];\n    let mut\
    \ row_idx28: Vec<isize> = vec![];\n    let mut row_idx29: Vec<isize> = vec![];\n\
    \    let mut row_idx30: \n}\n\nfn main() {\n    let candidate = get_row;\n   \
    \ assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1,\
    \ 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected type, found `}`\n  --> /tmp/tmp5pr78efa.rs:48:1\n   |\n\
    47 |     let mut row_idx30: \n   |         ------------- while parsing the type\
    \ for `mut row_idx30`\n48 | }\n   | ^ expected type\n\nerror: aborting due to\
    \ previous error\n\n"
  stdout: ''
  timestamp: 1659749648
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n\
    \    let mut row_idx = 0;\n    let mut col_idx = 0;\n    while row_idx < rows\
    \ {\n        let mut row_result = vec![];\n        while col_idx < cols {\n  \
    \          if row_idx == rows {\n                row_result.push((row_idx, col_idx));\n\
    \                break;\n            }\n            if col_idx == cols {\n   \
    \             row_result.push((row_idx, col_idx));\n                break;\n \
    \           }\n            if lst[row_idx][col_idx] == x {\n                row_result.push((row_idx,\
    \ col_idx));\n                break;\n            }\n            col_idx++;\n\
    \        }\n        result.push(row_result);\n        col_idx = 0;\n        row_idx++;\n\
    \    }\n    result.sort_by_key(|&(x, y)| x.0);\n    result.sort_by_key(|&(x, y)|\
    \ y.0);\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `+`\n  --> /tmp/tmprnyu8n72.rs:37:21\n\
    \   |\n37 |             col_idx++;\n   |                     ^ expected expression\n\
    \nerror: expected expression, found `+`\n  --> /tmp/tmprnyu8n72.rs:41:17\n   |\n\
    41 |         row_idx++;\n   |                 ^ expected expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprnyu8n72.rs:43:26\n   |\n43 |     result.sort_by_key(|&(x,\
    \ y)| x.0);\n   |                          ^^^^^-\n   |                      \
    \    |    |\n   |                          |    expected due to this\n   |   \
    \                       expected struct `Vec`, found tuple\n   |\n   = note: expected\
    \ struct `Vec<(usize, usize)>`\n               found tuple `(_, _)`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprnyu8n72.rs:44:26\n   |\n44 |     result.sort_by_key(|&(x,\
    \ y)| y.0);\n   |                          ^^^^^-\n   |                      \
    \    |    |\n   |                          |    expected due to this\n   |   \
    \                       expected struct `Vec`, found tuple\n   |\n   = note: expected\
    \ struct `Vec<(usize, usize)>`\n               found tuple `(_, _)`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprnyu8n72.rs:45:5\n   |\n16 | fn get_row(lst:\
    \ Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |                  \
    \                             ------------------- expected `Vec<(isize, isize)>`\
    \ because of return type\n...\n45 |     result\n   |     ^^^^^^ expected tuple,\
    \ found struct `Vec`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \              found struct `Vec<Vec<(usize, usize)>>`\n\nerror: aborting due\
    \ to 5 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n\
    \    let mut row_idx = 0;\n    let mut col_idx = 0;\n    while col_idx < cols\
    \ {\n        if row_idx < rows {\n            if lst[row_idx][col_idx] == x {\n\
    \                result.push((row_idx, col_idx));\n                row_idx +=\
    \ 1;\n                col_idx += 1;\n            } else {\n                row_idx\
    \ += 1;\n                col_idx += 1;\n            }\n        } else {\n    \
    \        col_idx += 1;\n        }\n    }\n    result.sort_by(|a, b| a.1.cmp(&b.1));\n\
    \    result.sort_by(|a, b| b.1.cmp(&a.1));\n    result\n}\n\nfn main() {\n   \
    \ let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2ealz414.rs:38:5\n   |\n\
    16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \                                               ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n38 |     result\n   |     ^^^^^^ expected\
    \ `isize`, found `usize`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \              found struct `Vec<(usize, usize)>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n\
    \    let mut row_idx = 0;\n    let mut col_idx = 0;\n    let mut row_max = rows;\n\
    \    let mut col_max = cols;\n    let mut row_min = rows;\n    let mut col_min\
    \ = cols;\n    while row_idx < rows && col_idx < cols {\n        if row_idx <\
    \ row_max && col_idx < col_max {\n            if lst[row_idx][col_idx] == x {\n\
    \                result.push((row_idx, col_idx));\n                row_idx +=\
    \ 1;\n                col_idx += 1;\n            } else {\n                row_idx\
    \ += 1;\n                col_idx += 1;\n            }\n        } else if row_idx\
    \ < row_max {\n            row_idx += 1;\n            row_max = rows;\n      \
    \      row_min = rows;\n            col_max = cols;\n            col_min = cols;\n\
    \            col_idx = 0;\n        } else if col_idx < col_max {\n           \
    \ col_idx += 1;\n            row_max = rows;\n            row_min = rows;\n  \
    \          col_max = cols;\n            col_min = cols;\n            row_idx =\
    \ 0;\n        } else {\n            break;\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4ah7czpg.rs:54:5\n   |\n\
    16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \                                               ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n54 |     result\n   |     ^^^^^^ expected\
    \ `isize`, found `usize`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \              found struct `Vec<(usize, usize)>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows: Vec<(isize, isize)> = vec![];\n    let mut row_idx: usize = 0;\n    let\
    \ mut col_idx: usize = 0;\n    let mut row_size: usize = 0;\n    for row in lst\
    \ {\n        row_size = row.len();\n        if row_idx >= row_size {\n       \
    \     break;\n        }\n        let mut cols: Vec<isize> = vec![];\n        for\
    \ col in row {\n            if col_idx >= row_size {\n                break;\n\
    \            }\n            cols.push(col);\n            col_idx++;\n        }\n\
    \        rows.push((row_idx, cols));\n        row_idx++;\n    }\n    let mut sorted_rows:\
    \ Vec<(isize, isize)> = vec![];\n    let mut sorted_row_idx: usize = 0;\n    let\
    \ mut sorted_col_idx: usize = 0;\n    let mut sorted_row_size: usize = 0;\n  \
    \  for row in rows {\n        sorted_row_size = row.1;\n        if sorted_row_idx\
    \ >= sorted_row_size {\n            break;\n        }\n        let mut sorted_cols:\
    \ Vec<isize> = vec![];\n        for col in row.1 {\n            if sorted_col_idx\
    \ >= sorted_row_size {\n                break;\n            }\n            sorted_cols.push(col);\n\
    \            sorted_col_idx++;\n        }\n        sorted_rows.push((sorted_row_idx,\
    \ sorted_cols));\n        sorted_row_idx++;\n    }\n    let mut sorted_cols: Vec<isize>\
    \ = vec![];\n    for col in sorted_rows {\n        sorted_cols = col;\n    }\n\
    \    let mut sorted_col_idx = 0;\n    let mut sorted_row_idx = 0;\n    let mut\
    \ sorted_row_size: usize = 0;\n    for col in sorted_cols {\n        sorted_row_size\
    \ = sorted_rows[sorted_row_idx].1;\n        if sorted_col_idx >= sorted_row_size\
    \ {\n            break;\n        }\n        let mut rows: Vec<(isize, isize)>\
    \ = vec![];\n        for row in sorted_rows {\n            if row.1 == col {\n\
    \                rows.push(row);\n            }\n        }\n        sorted_row_idx++;\n\
    \    }\n    let mut sorted_rows: Vec<(isize, isize)> = vec![];\n    for row in\
    \ rows {\n        sorted_rows = row;\n    }\n    let mut sorted_row_idx = 0;\n\
    \    let mut sorted_col_idx = 0;\n    let mut sorted_row_size: usize = 0;\n  \
    \  for row in sorted_rows {\n        sorted_row_size = row.1;\n        if sorted_row_idx\
    \ >= sorted_row_size {\n            break;\n        }\n        let mut cols: Vec<isize>\
    \ = vec![];\n        for col in \n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpwn4pdnpk.rs:101:3\n\
    \    |\n16  | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    |                                                                   -\
    \ unclosed delimiter\n...\n84  |     for row in sorted_rows {\n    |         \
    \                   - this delimiter might not be properly closed...\n...\n91\
    \  | }\n    | - ...as it matches this but it has different indentation\n...\n\
    101 | }\n    |   ^\n\nerror: expected expression, found `+`\n  --> /tmp/tmpwn4pdnpk.rs:32:21\n\
    \   |\n32 |             col_idx++;\n   |                     ^ expected expression\n\
    \nerror: expected expression, found `+`\n  --> /tmp/tmpwn4pdnpk.rs:35:17\n   |\n\
    35 |         row_idx++;\n   |                 ^ expected expression\n\nerror:\
    \ expected expression, found `+`\n  --> /tmp/tmpwn4pdnpk.rs:52:28\n   |\n52 |\
    \             sorted_col_idx++;\n   |                            ^ expected expression\n\
    \nerror: expected expression, found `+`\n  --> /tmp/tmpwn4pdnpk.rs:55:24\n   |\n\
    55 |         sorted_row_idx++;\n   |                        ^ expected expression\n\
    \nerror: expected expression, found `+`\n  --> /tmp/tmpwn4pdnpk.rs:75:24\n   |\n\
    75 |         sorted_row_idx++;\n   |                        ^ expected expression\n\
    \nerror: expected expression, found `}`\n  --> /tmp/tmpwn4pdnpk.rs:91:1\n   |\n\
    91 | }\n   | ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwn4pdnpk.rs:34:20\n\
    \   |\n34 |         rows.push((row_idx, cols));\n   |                    ^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n34 |         rows.push((row_idx.try_into().unwrap(),\
    \ cols));\n   |                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwn4pdnpk.rs:34:29\n   |\n34 |         rows.push((row_idx,\
    \ cols));\n   |                             ^^^^ expected `isize`, found struct\
    \ `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tm"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows: Vec<(isize, isize)> = vec![];\n    let mut row_idx: usize = 0;\n    let\
    \ mut col_idx: usize = 0;\n    let mut row_idxs: Vec<usize> = vec![];\n    let\
    \ mut col_idxs: Vec<usize> = vec![];\n    let mut row_idxs_sorted: Vec<usize>\
    \ = vec![];\n    let mut col_idxs_sorted: Vec<usize> = vec![];\n    let mut row_idxs_sorted_reverse:\
    \ Vec<usize> = vec![];\n    let mut col_idxs_sorted_reverse: Vec<usize> = vec![];\n\
    \    let mut row_idxs_sorted_reverse_sorted: Vec<usize> = vec![];\n    let mut\
    \ col_idxs_sorted_reverse_sorted: Vec<usize> = vec![];\n    let mut row_idxs_sorted_reverse_sorted_reverse:\
    \ Vec<usize> = vec![];\n    let mut col_idxs_sorted_reverse_sorted_reverse: Vec<usize>\
    \ = vec![];\n    let mut row_idxs_sorted_reverse_sorted_reverse_sorted: Vec<usize>\
    \ = vec![];\n    let mut col_idxs_sorted_reverse_sorted_reverse_sorted: Vec<usize>\
    \ = vec![];\n    for row in lst {\n        if row_idx == row.len() {\n       \
    \     row_idxs.push(row_idx);\n            row_idxs_sorted.push(row_idx);\n  \
    \          row_idxs_sorted_reverse.push(row_idx);\n            row_idxs_sorted_reverse_sorted.push(row_idx);\n\
    \            row_idxs_sorted_reverse_sorted_reverse.push(row_idx);\n         \
    \   row_idxs_sorted_reverse_sorted_reverse_sorted.push(row_idx);\n           \
    \ col_idxs.push(col_idx);\n            col_idxs_sorted.push(col_idx);\n      \
    \      col_idxs_sorted_reverse.push(col_idx);\n            col_idxs_sorted_reverse_sorted.push(col_idx);\n\
    \            col_idxs_sorted_reverse_sorted_reverse.push(col_idx);\n         \
    \   row_idx = 0;\n            col_idx = 0;\n        } else {\n            if row_idx\
    \ == 0 {\n                row_idxs.push(row_idx);\n                row_idxs_sorted.push(row_idx);\n\
    \                row_idxs_sorted_reverse.push(row_idx);\n                row_idxs_sorted_reverse_sorted.push(row_idx);\n\
    \                row_idxs_sorted_reverse_sorted_reverse.push(row_idx);\n     \
    \           col_idxs.push(col_idx);\n                col_idxs_sorted.push(col_idx);\n\
    \                col_idxs_sorted_reverse.push(col\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpvevmn7mv.rs:67:3\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                                                   -\
    \ unclosed delimiter\n...\n32 |     for row in lst {\n   |                   \
    \ - unclosed delimiter\n...\n47 |         } else {\n   |                - unclosed\
    \ delimiter\n48 |             if row_idx == 0 {\n   |                        \
    \     - this delimiter might not be properly closed...\n...\n57 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n67 | }\n   |   ^\n\n\
    error: mismatched closing delimiter: `}`\n  --> /tmp/tmpvevmn7mv.rs:56:45\n  \
    \ |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n\
    \   |                                                                   - closing\
    \ delimiter possibly meant for this\n...\n56 |                 col_idxs_sorted_reverse.push(col\n\
    \   |                                             ^ unclosed delimiter\n57 | }\n\
    \   | ^ mismatched closing delimiter\n\nerror[E0425]: cannot find value `col`\
    \ in this scope\n  --> /tmp/tmpvevmn7mv.rs:56:46\n   |\n56 |                 col_idxs_sorted_reverse.push(col\n\
    \   |                                              ^^^ not found in this scope\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpvevmn7mv.rs:32:5\n   |\n16 | \
    \  fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   | \
    \                                                ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n32 | /     for row in lst\
    \ {\n33 | |         if row_idx == row.len() {\n34 | |             row_idxs.push(row_idx);\n\
    35 | |             row_idxs_sorted.push(row_idx);\n...  |\n66 | |     assert_eq!(candidate(vec![vec![],\
    \ vec![1], vec![1, 2, 3]], 3), vec![(2, 2)]);\n67 | | }\n   | |__^ expected struct\
    \ `Vec`, found `()`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \           found unit type `()`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more informatio"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    let mut row_len = 0;\n    let mut col_len = 0;\n    while row_idx\
    \ < lst.len() {\n        let row_len = lst[row_idx].len();\n        if row_len\
    \ > col_idx {\n            row_len = col_idx;\n        }\n        if row_len >\
    \ x {\n            break;\n        }\n        let mut row_coord = vec![];\n  \
    \      for _ in 0..row_len {\n            row_coord.push((row_idx, col_idx));\n\
    \            col_idx = (col_idx + 1) % row_len;\n        }\n        rows.push(row_coord);\n\
    \        row_idx++;\n    }\n    rows\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `+`\n  --> /tmp/tmp5h1n1xjm.rs:36:17\n\
    \   |\n36 |         row_idx++;\n   |                 ^ expected expression\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp5h1n1xjm.rs:27:22\n   |\n27 |  \
    \       if row_len > x {\n   |                      ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n27 |         if row_len > x.try_into().unwrap()\
    \ {\n   |                      ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5h1n1xjm.rs:35:19\n   |\n35 |         rows.push(row_coord);\n\
    \   |                   ^^^^^^^^^ expected tuple, found struct `Vec`\n   |\n \
    \  = note: expected tuple `(isize, isize)`\n             found struct `Vec<(usize,\
    \ usize)>`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ lst = lst.clone();\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n\
    \    let mut result = vec![];\n    while rows > 0 {\n        let mut row = vec![];\n\
    \        while cols > 0 {\n            let mut col = vec![];\n            while\
    \ col < cols {\n                let mut found = false;\n                for i\
    \ in 0..rows {\n                    if lst[i][col] == x {\n                  \
    \      row.push((i, col));\n                        found = true;\n          \
    \              break;\n                    }\n                }\n            \
    \    if !found {\n                    col.push((col, cols));\n               \
    \     col--;\n                }\n            }\n            if row.len() > 0 {\n\
    \                result.push(row);\n                row.clear();\n           \
    \     col--;\n            } else {\n                col--;\n            }\n  \
    \      }\n        rows--;\n    }\n    result.sort_by_key(|x| x.0);\n    result.sort_by_key(|x|\
    \ x.1, |a, b| b.1.cmp(&a.1));\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmps2ox7p75.rs:36:26\n\
    \   |\n36 |                     col--;\n   |                          ^ expected\
    \ expression\n\nerror: expected expression, found `;`\n  --> /tmp/tmps2ox7p75.rs:42:22\n\
    \   |\n42 |                 col--;\n   |                      ^ expected expression\n\
    \nerror: expected expression, found `;`\n  --> /tmp/tmps2ox7p75.rs:44:22\n   |\n\
    44 |                 col--;\n   |                      ^ expected expression\n\
    \nerror: expected expression, found `;`\n  --> /tmp/tmps2ox7p75.rs:47:15\n   |\n\
    47 |         rows--;\n   |               ^ expected expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmps2ox7p75.rs:25:25\n   |\n25 |             while\
    \ col < cols {\n   |                         ^^^^ expected struct `Vec`, found\
    \ `usize`\n   |\n   = note: expected struct `Vec<_>`\n                found type\
    \ `usize`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `Vec<_>`\n\
    \  --> /tmp/tmps2ox7p75.rs:28:24\n   |\n28 |                     if lst[i][col]\
    \ == x {\n   |                        ^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `Vec<_>`\n   = note: required because of the requirements on\
    \ the impl of `Index<Vec<_>>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmps2ox7p75.rs:35:30\n   |\n35 |                     col.push((col,\
    \ cols));\n   |                              ^^^^^^^^^^^ cyclic type of infinite\
    \ size\n\nerror[E0609]: no field `0` on type `&Vec<(usize, Vec<_>)>`\n  --> /tmp/tmps2ox7p75.rs:49:30\n\
    \   |\n49 |     result.sort_by_key(|x| x.0);\n   |                           \
    \   ^ unknown field\n\nerror[E0061]: this function takes 1 argument but 2 arguments\
    \ were supplied\n   --> /tmp/tmps2ox7p75.rs:50:12\n    |\n50  |     result.sort_by_key(|x|\
    \ x.1, |a, b| b.1.cmp(&a.1));\n    |            ^^^^^^^^^^^ -------  --------------------\
    \ supplied 2 arguments\n    |            |\n    |            expected 1 argument\n\
    \    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut\
    \ col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n  \
    \  let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut\
    \ col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n  \
    \  let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut\
    \ col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n  \
    \  let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut\
    \ col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n  \
    \  let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let \n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpzfv6u_ru.rs:72:1\n  \
    \ |\n72 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx: Vec<isize> = vec![];\n\
    \    let mut row_idx_idx: Vec<isize> = vec![];\n    let mut row_idx_idx_idx: Vec<isize>\
    \ = vec![];\n    let mut row_idx_idx_idx_idx: Vec<isize> = vec![];\n    let mut\
    \ row_idx_idx_idx_idx_idx: Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx: Vec<isize>\
    \ = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx: Vec<isize> = vec![];\n\
    \    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx: Vec<isize> = vec![];\n \
    \   let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx: Vec<isize> = vec![];\n\
    \    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx: Vec<isize> = vec![];\n\
    \    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx: Vec<isize> =\
    \ vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxm9yskxk.rs:37:17\n   |\n\
    37 |     let mut row_\n   |                 ^ help: add `;` here\n38 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxm9yskxk.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    for row in lst {\n        let mut row_result = vec![];\n\
    \        for col in row.iter().rev() {\n            if col == x {\n          \
    \      row_result.push((row, col));\n            }\n        }\n        result.push(row_result.iter().cloned().collect::<Vec<_>>());\n\
    \    }\n    result.sort_by(|a, b| a.0.cmp(&b.0));\n    result.sort_by(|a, b| b.1.cmp(&a.1));\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpouebcwge.rs:21:20\n\
    \   |\n21 |             if col == x {\n   |                    ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n\nerror[E0609]: no field `0` on type `&Vec<(Vec<isize>,\
    \ &isize)>`\n  --> /tmp/tmpouebcwge.rs:27:29\n   |\n27 |     result.sort_by(|a,\
    \ b| a.0.cmp(&b.0));\n   |                             ^ unknown field\n\nerror[E0609]:\
    \ no field `0` on type `&Vec<(Vec<isize>, &isize)>`\n  --> /tmp/tmpouebcwge.rs:27:38\n\
    \   |\n27 |     result.sort_by(|a, b| a.0.cmp(&b.0));\n   |                  \
    \                    ^ unknown field\n\nerror[E0609]: no field `1` on type `&Vec<(Vec<isize>,\
    \ &isize)>`\n  --> /tmp/tmpouebcwge.rs:28:29\n   |\n28 |     result.sort_by(|a,\
    \ b| b.1.cmp(&a.1));\n   |                             ^ unknown field\n\nerror[E0609]:\
    \ no field `1` on type `&Vec<(Vec<isize>, &isize)>`\n  --> /tmp/tmpouebcwge.rs:28:38\n\
    \   |\n28 |     result.sort_by(|a, b| b.1.cmp(&a.1));\n   |                  \
    \                    ^ unknown field\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpouebcwge.rs:29:5\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize)\
    \ -> Vec<(isize, isize)> {\n   |                                             \
    \  ------------------- expected `Vec<(isize, isize)>` because of return type\n\
    ...\n29 |     result\n   |     ^^^^^^ expected tuple, found struct `Vec`\n   |\n\
    \   = note: expected struct `Vec<(isize, isize)>`\n              found struct\
    \ `Vec<Vec<(Vec<isize>, &isize)>>`\n\nerror: aborting due to 6 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0609.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut col_num\
    \ = 0;\n    let mut col_num_idx = 0;\n    let mut row_idxs = vec![];\n    let\
    \ mut row_idxs_idx = 0;\n    let mut col_nums = vec![];\n    let mut col_nums_idx\
    \ = 0;\n    let mut row_idxs_idx = 0;\n    let mut col_nums_idx = 0;\n    let\
    \ mut row_idxs_idx = 0;\n    let mut col_nums_idx = 0;\n    let mut row_idxs_idx\
    \ = 0;\n    let mut col_nums_idx = 0;\n    let mut row_idxs_idx = 0;\n    let\
    \ mut col_nums_idx = 0;\n    let mut row_idxs_idx = 0;\n    let mut col_nums_idx\
    \ = 0;\n    let mut row_idxs_idx = 0;\n    let mut col_nums_idx = 0;\n    let\
    \ mut row_idxs_idx = 0;\n    let mut col_nums_idx = 0;\n    let mut row_idxs_idx\
    \ = 0;\n    let mut col_nums_idx = 0;\n    let mut row_idxs_idx = 0;\n    let\
    \ mut col_nums_idx = 0;\n    let mut row_idxs_idx = 0;\n    let mut col_nums_idx\
    \ = 0;\n    let mut row_idxs_idx = 0;\n    let mut col_nums_idx = 0;\n    let\
    \ mut row_idxs_idx = 0;\n    let mut col_nums_idx = 0;\n    let mut row_idxs_idx\
    \ = 0;\n    let mut col_nums_idx = 0;\n    let mut row_idxs_idx = 0;\n    let\
    \ mut col_nums_idx = 0;\n    let mut row_idxs_idx = 0;\n    let mut col_nums_idx\
    \ = 0;\n    let mut row_idxs_idx = 0;\n    let mut col_nums_idx = 0;\n    let\
    \ mut row_idxs_idx = 0;\n    let mut col_nums_idx = 0;\n    let mut row_idxs_idx\
    \ = 0;\n    let mut col_nums_idx = 0;\n    let mut row_idxs_idx = 0;\n    let\
    \ mut col_nums_idx = 0;\n    let mut row_idxs_idx = 0;\n    let mut col_nums_idx\
    \ = 0;\n    let mut row_idxs_idx = 0;\n    let mut col_nums_idx = 0;\n    let\
    \ mut row_idxs_idx = 0;\n    let mut col_nums_idx = 0;\n    let mut row_idxs_idx\
    \ = 0;\n    let mut col_nums_idx = 0;\n    let mut row_idxs_idx = 0;\n    let\
    \ mut col_nums_idx = 0;\n    let mut \n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpwcoh20m6.rs:74:1\n\
    \   |\n74 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ lst = lst.clone();\n    lst.sort_by(|a, b| a.iter().cmp(&b.iter()).reverse());\n\
    \    let mut lst = lst.clone();\n    lst.sort_by(|a, b| b.iter().cmp(&a.iter()).reverse());\n\
    \    let mut lst = lst.clone();\n    lst.sort_by(|a, b| a.iter().cmp(&b.iter()).reverse());\n\
    \    let mut lst = lst.clone();\n    lst.sort_by(|a, b| b.iter().cmp(&a.iter()).reverse());\n\
    \    let mut lst = lst.clone();\n    lst.sort_by(|a, b| a.iter().cmp(&b.iter()).reverse());\n\
    \    let mut lst = lst.clone();\n    lst.sort_by(|a, b| b.iter().cmp(&a.iter()).reverse());\n\
    \    let mut lst = lst.clone();\n    lst.sort_by(|a, b| a.iter().cmp(&b.iter()).reverse());\n\
    \    let mut lst = lst.clone();\n    lst.sort_by(|a, b| b.iter().cmp(&a.iter()).reverse());\n\
    \    let mut lst = lst.clone();\n    lst.sort_by(|a, b| a.iter().cmp(&b.iter()).reverse());\n\
    \    let mut lst = lst.clone();\n    lst.sort_by(|a, b| b.iter().cmp(&a.iter()).reverse());\n\
    \    let mut lst = lst.clone();\n    lst.sort_by(|a, b| a.iter().cmp(&b.iter()).reverse());\n\
    \    let mut lst = lst.clone();\n    lst.sort_by(|a, b| b.iter().cmp(&a.iter()).reverse());\n\
    \    let mut lst = lst.clone();\n    lst.sort_by(|a, b| a.iter().cmp(&b.iter()).reverse());\n\
    \    let mut lst = lst.clone();\n    lst.sort_by(|a, b| b.iter().cmp(&a.iter()).reverse());\n\
    \    let mut lst = lst.clone();\n    lst.sort_by(|a, b| a.iter().cmp(&b.iter()).reverse());\n\
    \    let mut lst = lst.clone();\n    lst.sort_by(|a, b| b.iter().cmp(&a.iter()).reverse());\n\
    \    let mut lst = lst.clone();\n    lst.sort_by(|a, b| a.iter().cmp(&b.iter()).reverse());\n\
    \    let mut lst = lst.clone();\n    lst.sort_by(|a, b| b.iter().cmp(&a.iter()).reverse());\n\
    \    let mut lst = lst.clone();\n    lst.sort_by(|a, b| a.iter().cmp(&b.iter()).reverse());\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&std::slice::Iter<'_, isize>` is not an iterator\n  -->\
    \ /tmp/tmp2exb_2mo.rs:18:37\n   |\n18 |     lst.sort_by(|a, b| a.iter().cmp(&b.iter()).reverse());\n\
    \   |                                     ^^^^^^^^^ `&std::slice::Iter<'_, isize>`\
    \ is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `&std::slice::Iter<'_, isize>`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `&std::slice::Iter<'_, isize>`\nhelp: consider\
    \ removing the leading `&`-reference\n   |\n18 -     lst.sort_by(|a, b| a.iter().cmp(&b.iter()).reverse());\n\
    18 +     lst.sort_by(|a, b| a.iter().cmp(b.iter()).reverse());\n   | \nhelp: consider\
    \ changing this borrow's mutability\n   |\n18 |     lst.sort_by(|a, b| a.iter().cmp(&mut\
    \ b.iter()).reverse());\n   |                                     ~~~~\n\nerror[E0277]:\
    \ `&std::slice::Iter<'_, isize>` is not an iterator\n  --> /tmp/tmp2exb_2mo.rs:20:37\n\
    \   |\n20 |     lst.sort_by(|a, b| b.iter().cmp(&a.iter()).reverse());\n   | \
    \                                    ^^^^^^^^^ `&std::slice::Iter<'_, isize>`\
    \ is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `&std::slice::Iter<'_, isize>`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `&std::slice::Iter<'_, isize>`\nhelp: consider\
    \ removing the leading `&`-reference\n   |\n20 -     lst.sort_by(|a, b| b.iter().cmp(&a.iter()).reverse());\n\
    20 +     lst.sort_by(|a, b| b.iter().cmp(a.iter()).reverse());\n   | \nhelp: consider\
    \ changing this borrow's mutability\n   |\n20 |     lst.sort_by(|a, b| b.iter().cmp(&mut\
    \ a.iter()).reverse());\n   |                                     ~~~~\n\nerror[E0277]:\
    \ `&std::slice::Iter<'_, isize>` is not an iterator\n  --> /tmp/tmp2exb_2mo.rs:22:37\n\
    \   |\n22 |     lst.sort_by(|a, b| a.iter().cmp(&b.iter()).reverse());\n   | \
    \                                    ^^^^^^^^^ `&std::slice::Iter<'_, isize>`\
    \ is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `&std::slice::Iter<'_, isize>`\n   = note: required because of the re"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows = lst.len();\n    let mut cols = lst[0].len();\n    let mut result = vec![];\n\
    \    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n\
    \    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut\
    \ col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n  \
    \  let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut\
    \ col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n  \
    \  let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut\
    \ col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n  \
    \  let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mu\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwsp2bs41.rs:71:11\n   |\n\
    71 |     let mu\n   |           ^ help: add `;` here\n72 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwsp2bs41.rs:16:47\n \
    \  |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n\
    \   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749648
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_idx\
    \ = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut\
    \ col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n  \
    \  let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut\
    \ col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n  \
    \  let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut\
    \ col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n  \
    \  let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut\
    \ col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n  \
    \  let mut row_sorted = vec![];\n\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzst0gf9u.rs:16:47\n   |\n\
    16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \    -------                                    ^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    let mut row_len = 0;\n    let mut col_len = 0;\n    for row in lst\
    \ {\n        row_len += row.len();\n        row_idx += 1;\n        if row_idx\
    \ > x {\n            break;\n        }\n        for col in row {\n           \
    \ col_len += 1;\n            col_idx += 1;\n            if col_idx > x {\n   \
    \             break;\n            }\n            rows.push((row_idx, col_idx));\n\
    \        }\n    }\n    rows\n        .into_iter()\n        .sort_by(|a, b| a.1.cmp(&b.1))\n\
    \        .sort_by(|a, b| b.0.cmp(&a.0))\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `std::vec::IntoIter`\
    \ in the current scope\n  --> /tmp/tmp1xqqel36.rs:39:10\n   |\n39 |         .sort_by(|a,\
    \ b| a.1.cmp(&b.1))\n   |          ^^^^^^^ method not found in `std::vec::IntoIter<(isize,\
    \ isize)>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows = lst.len();\n    let mut cols = lst[0].len();\n    let mut coords = vec![];\n\
    \    let mut row_coords = vec![];\n    let mut col_coords = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sor\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpa1objz2n.rs:68:20\n   |\n\
    68 |     let mut row_sor\n   |                    ^ help: add `;` here\n69 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa1objz2n.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows = lst.len();\n    let mut cols = lst[0].len();\n    let mut coords = vec![];\n\
    \    let mut row_coords = vec![];\n    let mut col_coords = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorting\
    \ = false;\n    let mut col_sorting = false;\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    while i < rows {\n        row_sorting = false;\n        col_sorting\
    \ = false;\n        while j < cols {\n            if lst[i][j] == x {\n      \
    \          row_sorting = true;\n                row_coords.push((i, j));\n   \
    \             col_coords.push((i, j));\n                coords.push((i, j));\n\
    \                i += 1;\n                j += 1;\n                continue;\n\
    \            }\n            if lst[i][j] > x {\n                col_sorting =\
    \ true;\n                col_coords.push((i, j));\n                coords.push((i,\
    \ j));\n                i += 1;\n                j += 1;\n                continue;\n\
    \            }\n            i += 1;\n            j += 1;\n        }\n        if\
    \ row_sorting {\n            row_sorted.push(row_coords);\n            row_coords\
    \ = vec![];\n        }\n        if col_sorting {\n            col_sorted.push(col_coords);\n\
    \            col_coords = vec![];\n        }\n    }\n    if row_sorted.len() >\
    \ 0 {\n        row_sorted.sort_by_key(|x| x.0);\n    }\n    if col_sorted.len()\
    \ > 0 {\n        col_sorted.sort_by_key(|x| x.0);\n    }\n    vec![row_sorted.len(),\
    \ col_sorted.len()]\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `0` on type `&Vec<(usize, usize)>`\n  --> /tmp/tmpij0u81bj.rs:62:38\n\
    \   |\n62 |         row_sorted.sort_by_key(|x| x.0);\n   |                   \
    \                   ^ unknown field\n\nerror[E0609]: no field `0` on type `&Vec<(usize,\
    \ usize)>`\n  --> /tmp/tmpij0u81bj.rs:65:38\n   |\n65 |         col_sorted.sort_by_key(|x|\
    \ x.0);\n   |                                      ^ unknown field\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpij0u81bj.rs:67:10\n   |\n67 |     vec![row_sorted.len(),\
    \ col_sorted.len()]\n   |          ^^^^^^^^^^^^^^^^ expected tuple, found `usize`\n\
    \   |\n   = note: expected tuple `(isize, isize)`\n               found type `usize`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0609.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    let mut row_len = lst.len();\n    let mut col_len = lst[0].len();\n\
    \    let mut row_idx = 0;\n    let mut col_idx = 0;\n    let mut row_len = lst.len();\n\
    \    let mut col_len = lst[0].len();\n    while row_idx < row_len {\n        let\
    \ mut row_idx = 0;\n        while col_idx < col_len {\n            if lst[row_idx][col_idx]\
    \ == x {\n                rows.push((row_idx, col_idx));\n                row_idx\
    \ += 1;\n                col_idx += 1;\n            } else {\n               \
    \ col_idx += 1;\n            }\n        }\n        row_idx += 1;\n        col_idx\
    \ = 0;\n    }\n    rows\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp40plfwfa.rs:30:28\n   |\n\
    30 |                 rows.push((row_idx, col_idx));\n   |                    \
    \        ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    30 |                 rows.push((row_idx.try_into().unwrap(), col_idx));\n   |\
    \                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp40plfwfa.rs:30:37\n   |\n30 |                 rows.push((row_idx,\
    \ col_idx));\n   |                                     ^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n30 |                 rows.push((row_idx,\
    \ col_idx.try_into().unwrap()));\n   |                                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut row_len\
    \ = 0;\n    let mut col_len = 0;\n    for row in lst {\n        row_len += row.len();\n\
    \        col_len += row.iter().map(|x| x).sum();\n    }\n    for row in lst {\n\
    \        if row_len == x {\n            row_idx += 1;\n            row_len -=\
    \ 1;\n        }\n    }\n    for col in lst.iter().map(|x| x.iter().map(|x| x)).flatten()\
    \ {\n        if col_len == x {\n            col_len -= 1;\n        }\n    }\n\
    \    for col in lst.iter().map(|x| x.iter().map(|x| x)).flatten() {\n        if\
    \ col_len == x {\n            col_len -= 1;\n        }\n    }\n    for col in\
    \ lst.iter().map(|x| x.iter().map(|x| x)).flatten() {\n        if col_len == x\
    \ {\n            col_len -= 1;\n        }\n    }\n    for col in lst.iter().map(|x|\
    \ x.iter().map(|x| x)).flatten() {\n        if col_len == x {\n            col_len\
    \ -= 1;\n        }\n    }\n    for col in lst.iter().map(|x| x.iter().map(|x|\
    \ x)).flatten() {\n        if col_len == x {\n            col_len -= 1;\n    \
    \    }\n    }\n    for col in lst.iter().map(|x| x.iter().map(|x| x)).flatten()\
    \ {\n        if col_len == x {\n            col_len -= 1;\n        }\n    }\n\
    \    for col in lst.iter().map(|x| x.iter().map(|x| x)).flatten() {\n        if\
    \ col_len == x {\n            col_len -= 1;\n        }\n    }\n    for col in\
    \ lst.iter().map(|x| x.iter().map(|x| x)).flatten() {\n        if col_len == x\
    \ {\n            col_len -= 1;\n        }\n    }\n    for col in lst.iter().map(|x|\
    \ x.iter().map(|x| x)).flatten() {\n        if col_len == x {\n            col_len\
    \ -= 1;\n        }\n    }\n    for col in lst.iter().map(|x| x.iter().map(|x|\
    \ x)).flatten() {\n        if col_len == x {\n            col_len -= 1;\n    \
    \    }\n    }\n    for col in lst.iter().map(|x| x.iter().map(|x| x)).flatten()\
    \ {\n        if col_\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpjcz0ikvd.rs:93:3\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                                                   -\
    \ unclosed delimiter\n...\n81 |     for col in lst.iter().map(|x| x.iter().map(|x|\
    \ x)).flatten() {\n   |                                                      \
    \            - this delimiter might not be properly closed...\n82 |         if\
    \ col_\n83 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n93 | }\n   |   ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmpjcz0ikvd.rs:83:1\n\
    \   |\n82 |         if col_\n   |         -- this `if` expression has a condition,\
    \ but no block\n83 | }\n   | ^ expected `{`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpjcz0ikvd.rs:26:23\n   |\n26 |         if row_len == x {\n   | \
    \                      ^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n26 |         if row_len == x.try_into().unwrap() {\n   |              \
    \         ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjcz0ikvd.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows = lst.len();\n    let mut cols = lst[0].len();\n    let mut coords = vec![];\n\
    \    let mut row_coords = vec![];\n    let mut col_coords = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sort\
    \ = vec![];\n    let mut col_sort = vec![];\n    let mut row_sort_idx = vec![];\n\
    \    let mut col_sort_idx = vec![];\n    let mut row_sort_idx2 = vec![];\n   \
    \ let mut col_sort_idx2 = vec![];\n    let mut row_sort_idx3 = vec![];\n    let\
    \ mut col_sort_idx3 = vec![];\n    let mut row_sort_idx4 = vec![];\n    let mut\
    \ col_sort_idx4 = vec![];\n    let mut row_sort_idx5 = vec![];\n    let mut col_sort_idx5\
    \ = vec![];\n    let mut row_sort_idx6 = vec![];\n    let mut col_sort_idx6 =\
    \ vec![];\n    let mut row_sort_idx7 = vec![];\n    let mut col_sort_idx7 = vec![];\n\
    \    let mut row_sort_idx8 = vec![];\n    let mut col_sort_idx8 = vec![];\n  \
    \  let mut row_sort_idx9 = vec![];\n    let mut col_sort_idx9 = vec![];\n    let\
    \ mut row_sort_idx10 = vec![];\n    let mut col_sort_idx10 = vec![];\n    let\
    \ mut row_sort_idx11 = vec![];\n    let mut col_sort_idx11 = vec![];\n    let\
    \ mut row_sort_idx12 = vec![];\n    let mut col_sort_idx12 = vec![];\n    let\
    \ mut row_sort_idx13 = vec![];\n    let mut col_sort_idx13 = vec![];\n    let\
    \ mut row_sort_idx14 = vec![];\n    let mut col_sort_idx14 = vec![];\n    let\
    \ mut row_sort_idx15 = vec![];\n    let mut col_sort_idx15 = vec![];\n    let\
    \ mut row_sort_idx16 = vec![];\n    let mut col_sort_idx16 = vec![];\n    let\
    \ mut row_sort_idx17 = vec![];\n    let mut col_sort_idx17 = vec![];\n    let\
    \ mut row_sort_idx18 = vec![];\n    let mut col_sort_idx18 = vec![];\n    let\
    \ mut row_sort_idx19 = vec![];\n    let mut col_sort_idx19\n}\n\nfn main() {\n\
    \    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp18f5dy2q.rs:63:27\n   |\n\
    63 |     let mut col_sort_idx19\n   |                           ^ help: add `;`\
    \ here\n64 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp18f5dy2q.rs:16:47\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize)\
    \ -> Vec<(isize, isize)> {\n   |    -------                                  \
    \  ^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<(isize, isize)>`\n           found unit type `()`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    let mut row_idxs: Vec<isize> = vec![];\n    let mut col_idxs: Vec<isize>\
    \ = vec![];\n    let mut row_idxs_sorted: Vec<isize> = vec![];\n    let mut col_idxs_sorted:\
    \ Vec<isize> = vec![];\n    let mut row_idxs_sorted_idx: Vec<isize> = vec![];\n\
    \    let mut col_idxs_sorted_idx: Vec<isize> = vec![];\n    let mut row_idxs_sorted_idxs:\
    \ Vec<isize> = vec![];\n    let mut col_idxs_sorted_idxs: Vec<isize> = vec![];\n\
    \    let mut row_idxs_sorted_idxs_idx: Vec<isize> = vec![];\n    let mut col_idxs_sorted_idxs_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idxs_sorted_idxs_idxs: Vec<isize> = vec![];\n\
    \    let mut col_idxs_sorted_idxs_idxs: Vec<isize> = vec![];\n    let mut row_idxs_sorted_idxs_idxs_idx:\
    \ Vec<isize> = vec![];\n    let mut col_idxs_sorted_idxs_idxs_idx: Vec<isize>\
    \ = vec![];\n    let mut row_idxs_sorted_idxs_idxs_idxs: Vec<isize> = vec![];\n\
    \    let mut col_idxs_sorted_idxs_idxs_idxs: Vec<isize> = vec![];\n    let mut\
    \ row_idxs_sorted_idxs_idxs_idxs_idx: Vec<isize> = vec![];\n    let mut col_idxs_sorted_idxs_idxs_idxs_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idxs_sorted_idxs_idxs_idxs_idxs: Vec<isize>\
    \ = vec![];\n    let mut col_idxs_sorted_idxs_idxs_idxs_idxs: Vec<isize> = vec![];\n\
    \    let mut row_idxs_sorted_idxs_idxs_idxs_idxs_idx: Vec<isize> = vec![];\n \
    \   let mut col_idxs_sorted_idxs_idxs_idxs_idxs_idx: Vec<isize> = vec![];\n  \
    \  let mut row_idxs_sorted_\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpm0_fzkyi.rs:42:29\n   |\n\
    42 |     let mut row_idxs_sorted_\n   |                             ^ help: add\
    \ `;` here\n43 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpm0_fzkyi.rs:16:47\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>,\
    \ x: isize) -> Vec<(isize, isize)> {\n   |    -------                        \
    \            ^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<(isize, isize)>`\n           found unit\
    \ type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut row_idx2\
    \ = 0;\n    let mut row_idx3 = 0;\n    let mut row_idx4 = 0;\n    let mut row_idx5\
    \ = 0;\n    let mut row_idx6 = 0;\n    let mut row_idx7 = 0;\n    let mut row_idx8\
    \ = 0;\n    let mut row_idx9 = 0;\n    let mut row_idx10 = 0;\n    let mut row_idx11\
    \ = 0;\n    let mut row_idx12 = 0;\n    let mut row_idx13 = 0;\n    let mut row_idx14\
    \ = 0;\n    let mut row_idx15 = 0;\n    let mut row_idx16 = 0;\n    let mut row_idx17\
    \ = 0;\n    let mut row_idx18 = 0;\n    let mut row_idx19 = 0;\n    let mut row_idx20\
    \ = 0;\n    let mut row_idx21 = 0;\n    let mut row_idx22 = 0;\n    let mut row_idx23\
    \ = 0;\n    let mut row_idx24 = 0;\n    let mut row_idx25 = 0;\n    let mut row_idx26\
    \ = 0;\n    let mut row_idx27 = 0;\n    let mut row_idx28 = 0;\n    let mut row_idx29\
    \ = 0;\n    let mut row_idx30 = 0;\n    let mut row_idx31 = 0;\n    let mut row_idx32\
    \ = 0;\n    let mut row_idx33 = 0;\n    let mut row_idx34 = 0;\n    let mut row_idx35\
    \ = 0;\n    let mut row_idx36 = 0;\n    let mut row_idx37 = 0;\n    let mut row_idx38\
    \ = 0;\n    let mut row_idx39 = 0;\n    let mut row_idx40 = 0;\n    let mut row_idx41\
    \ = 0;\n    let mut row_idx42 = 0;\n    let mut row_idx43 = 0;\n    let mut row_idx44\
    \ = 0;\n    let mut row_idx45 = 0;\n    let mut row_idx46 = 0;\n    let mut row_idx47\
    \ = 0;\n    let mut row_idx48 = 0;\n    let mut row_idx49 = 0;\n    let mut row_idx50\
    \ = 0;\n    let mut row_idx51 = 0;\n    let mut row_idx52 = 0;\n    let mut row_idx53\
    \ = 0;\n    let mut row_idx54 = 0;\n    let mut row_idx55 = 0;\n    let mut row_idx56\
    \ = 0;\n    let mut row_idx57 = 0;\n    let mut row_idx58 = 0;\n    let mut row_idx59\
    \ = 0;\n    let mut row_idx60 = 0;\n    let mut row_idx61 = 0;\n    let mut row_idx62\
    \ = 0;\n    let mut row_\n}\n\nfn main() {\n    let candidate = get_row;\n   \
    \ assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1,\
    \ 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmppjyfu577.rs:80:17\n   |\n\
    80 |     let mut row_\n   |                 ^ help: add `;` here\n81 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppjyfu577.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut row_idx_max\
    \ = 0;\n    let mut row_idx_min = 0;\n    let mut col_max = 0;\n    let mut col_min\
    \ = 0;\n    let mut col_max2 = 0;\n    let mut col_min2 = 0;\n    let mut col_max3\
    \ = 0;\n    let mut col_min3 = 0;\n    let mut col_max4 = 0;\n    let mut col_min4\
    \ = 0;\n    let mut col_max5 = 0;\n    let mut col_min5 = 0;\n    let mut col_max6\
    \ = 0;\n    let mut col_min6 = 0;\n    let mut col_max7 = 0;\n    let mut col_min7\
    \ = 0;\n    let mut col_max8 = 0;\n    let mut col_min8 = 0;\n    let mut col_max9\
    \ = 0;\n    let mut col_min9 = 0;\n    let mut col_max10 = 0;\n    let mut col_min10\
    \ = 0;\n    let mut col_max11 = 0;\n    let mut col_min11 = 0;\n    let mut col_max12\
    \ = 0;\n    let mut col_min12 = 0;\n    let mut col_max13 = 0;\n    let mut col_min13\
    \ = 0;\n    let mut col_max14 = 0;\n    let mut col_min14 = 0;\n    let mut col_max15\
    \ = 0;\n    let mut col_min15 = 0;\n    let mut col_max16 = 0;\n    let mut col_min16\
    \ = 0;\n    let mut col_max17 = 0;\n    let mut col_min17 = 0;\n    let mut col_max18\
    \ = 0;\n    let mut col_min18 = 0;\n    let mut col_max19 = 0;\n    let mut col_min19\
    \ = 0;\n    let mut col_max20 = 0;\n    let mut col_min20 = 0;\n    let mut col_max21\
    \ = 0;\n    let mut col_min21 = 0;\n    let mut col_max22 = 0;\n    let mut col_min22\
    \ = 0;\n    let mut col_max23 = 0;\n    let mut col_min23 = 0;\n    let mut col_max24\
    \ = 0;\n    let mut col_min24 = 0;\n    let mut col_max25 = 0;\n    let mut col_min25\
    \ = 0;\n    let mut col_max26 = 0;\n    let mut col_min26 = 0;\n    let mut col_max27\
    \ = 0;\n    let mut col_min27 = 0;\n    let mut col_max28 = 0;\n    let mut col_min28\
    \ = 0;\n    let mut col_max29 = 0;\n    let mut col_min29 = 0;\n    let mut col_max30\
    \ = 0;\n    let mut col_min30 = 0;\n    let mu\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpsa7tzda6.rs:81:11\n   |\n\
    81 |     let mu\n   |           ^ help: add `;` here\n82 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsa7tzda6.rs:16:47\n \
    \  |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n\
    \   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n\
    \    let mut row_idx = 0;\n    let mut col_idx = 0;\n    while row_idx < rows\
    \ {\n        let mut row_start = row_idx;\n        let mut row_end = row_idx;\n\
    \        let mut col_start = col_idx;\n        let mut col_end = col_idx;\n  \
    \      let mut row_end = row_idx;\n        let mut col_end = col_idx;\n      \
    \  while row_end < rows && col_end < cols {\n            if row_end == row_idx\
    \ {\n                row_end += 1;\n                col_end += 1;\n          \
    \      continue;\n            }\n            if col_end == col_idx {\n       \
    \         col_end += 1;\n                continue;\n            }\n          \
    \  if row_end == row_idx {\n                row_end += 1;\n                continue;\n\
    \            }\n            if col_end == col_idx {\n                col_end +=\
    \ 1;\n                continue;\n            }\n            if row_end == row_idx\
    \ {\n                row_end += 1;\n                col_end += 1;\n          \
    \      continue;\n            }\n            if col_end == col_idx {\n       \
    \         col_end += 1;\n                continue;\n            }\n          \
    \  if row_end == row_idx {\n                row_end += 1;\n                col_end\
    \ += 1;\n                continue;\n            }\n            if col_end == col_idx\
    \ {\n                col_end += 1;\n                continue;\n            }\n\
    \            if row_end == row_idx {\n                row_end += 1;\n        \
    \        continue;\n            }\n            if col_end == col_idx {\n     \
    \           col_end += 1;\n                continue;\n            }\n        \
    \    if row_end == row_idx {\n                row_end += 1;\n                col_end\
    \ += 1;\n                continue;\n            }\n            if col_end == col_idx\
    \ {\n                col_end += 1;\n                continue;\n            }\n\
    \            if row_end == row_idx {\n                row_end += 1;\n        \
    \        continue;\n            }\n            if col_end == col_idx {\n     \
    \           col_end += 1;\n                continue;\n            }\n        \
    \    if row_end == row_idx {\n                row_end += 1;\n                col_end\
    \ += 1;\n                continue;\n            }\n            if col_end == col_idx\
    \ {\n                col_end += 1;\n                continue;\n            }\n\
    \            if row_end == row_idx {\n                row_end += 1;\n        \
    \        continue;\n            }\n            if col_end == col_idx {\n     \
    \           col_end += 1;\n                continue;\n            }\n        \
    \    if row_end == row_idx {\n                row_end += 1;\n                col_end\
    \ += 1;\n                continue;\n            }\n            if col_\n}\n\n\
    fn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp2j6s_hqr.rs:123:3\n\
    \    |\n16  | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    |                                                                   -\
    \ unclosed delimiter\n...\n22  |     while row_idx < rows {\n    |           \
    \               - unclosed delimiter\n...\n29  |         while row_end < rows\
    \ && col_end < cols {\n    |                                                -\
    \ this delimiter might not be properly closed...\n...\n113 | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n123 | }\n    |   ^\n\n\
    error: expected `{`, found `}`\n   --> /tmp/tmp2j6s_hqr.rs:113:1\n    |\n112 |\
    \             if col_\n    |             -- this `if` expression has a condition,\
    \ but no block\n113 | }\n    | ^ expected `{`\n\nerror[E0308]: mismatched types\n\
    \   --> /tmp/tmp2j6s_hqr.rs:22:5\n    |\n16  |   fn get_row(lst: Vec<Vec<isize>>,\
    \ x: isize) -> Vec<(isize, isize)> {\n    |                                  \
    \               ------------------- expected `Vec<(isize, isize)>` because of\
    \ return type\n...\n22  | /     while row_idx < rows {\n23  | |         let mut\
    \ row_start = row_idx;\n24  | |         let mut row_end = row_idx;\n25  | |  \
    \       let mut col_start = col_idx;\n...   |\n122 | |     assert_eq!(candidate(vec![vec![],\
    \ vec![1], vec![1, 2, 3]], 3), vec![(2, 2)]);\n123 | | }\n    | |__^ expected\
    \ struct `Vec`, found `()`\n    |\n    = note: expected struct `Vec<(isize, isize)>`\n\
    \            found unit type `()`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n\
    \    let mut row_idx = 0;\n    let mut col_idx = 0;\n    while row_idx < rows\
    \ && col_idx < cols {\n        if row_idx < rows && col_idx < cols {\n       \
    \     if lst[row_idx][col_idx] == x {\n                result.push((row_idx, col_idx));\n\
    \            }\n        }\n        row_idx += 1;\n        col_idx += 1;\n    }\n\
    \    result.sort_by(|a, b| a.1.cmp(&b.1));\n    result.sort_by(|a, b| b.1.cmp(&a.1));\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp73auge26.rs:33:5\n   |\n\
    16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \                                               ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n33 |     result\n   |     ^^^^^^ expected\
    \ `isize`, found `usize`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \              found struct `Vec<(usize, usize)>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749650
- exit_code: 101
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows = lst.len();\n    let mut cols = lst[0].len();\n    let mut result = vec![];\n\
    \    let mut row_idx = 0;\n    let mut col_idx = 0;\n    while col_idx < cols\
    \ {\n        if row_idx == rows {\n            break;\n        }\n        let\
    \ mut row_start = row_idx;\n        let mut row_end = row_idx;\n        let mut\
    \ col_start = col_idx;\n        let mut col_end = col_idx;\n        while row_end\
    \ < rows && col_end < cols {\n            if row_end == rows {\n             \
    \   row_end = 0;\n            }\n            if col_end == cols {\n          \
    \      col_end = 0;\n            }\n            if row_start == row_end && col_start\
    \ == col_end {\n                break;\n            }\n            if lst[row_end][col_end]\
    \ < x {\n                row_end += 1;\n            } else {\n               \
    \ col_end += 1;\n            }\n        }\n        if row_start == row_end {\n\
    \            break;\n        }\n        let row = row_start as isize;\n      \
    \  let col = col_start as isize;\n        result.push((row, col));\n        row_idx\
    \ += 1;\n        col_idx += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]`', /tmp/tmp4fhidx1w.rs:60:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    for row in lst {\n        let mut row_result = vec![];\n\
    \        for col in row.iter().rev() {\n            if col == x {\n          \
    \      row_result.push((row, col));\n            }\n        }\n        result.push(row_result);\n\
    \    }\n    result.sort_by(|a, b| a.0.cmp(&b.0));\n    result.sort_by(|a, b| b.1.cmp(&a.1));\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp7d381xs7.rs:21:20\n\
    \   |\n21 |             if col == x {\n   |                    ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n\nerror[E0609]: no field `0` on type `&Vec<(Vec<isize>,\
    \ &isize)>`\n  --> /tmp/tmp7d381xs7.rs:27:29\n   |\n27 |     result.sort_by(|a,\
    \ b| a.0.cmp(&b.0));\n   |                             ^ unknown field\n\nerror[E0609]:\
    \ no field `0` on type `&Vec<(Vec<isize>, &isize)>`\n  --> /tmp/tmp7d381xs7.rs:27:38\n\
    \   |\n27 |     result.sort_by(|a, b| a.0.cmp(&b.0));\n   |                  \
    \                    ^ unknown field\n\nerror[E0609]: no field `1` on type `&Vec<(Vec<isize>,\
    \ &isize)>`\n  --> /tmp/tmp7d381xs7.rs:28:29\n   |\n28 |     result.sort_by(|a,\
    \ b| b.1.cmp(&a.1));\n   |                             ^ unknown field\n\nerror[E0609]:\
    \ no field `1` on type `&Vec<(Vec<isize>, &isize)>`\n  --> /tmp/tmp7d381xs7.rs:28:38\n\
    \   |\n28 |     result.sort_by(|a, b| b.1.cmp(&a.1));\n   |                  \
    \                    ^ unknown field\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp7d381xs7.rs:29:5\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize)\
    \ -> Vec<(isize, isize)> {\n   |                                             \
    \  ------------------- expected `Vec<(isize, isize)>` because of return type\n\
    ...\n29 |     result\n   |     ^^^^^^ expected tuple, found struct `Vec`\n   |\n\
    \   = note: expected struct `Vec<(isize, isize)>`\n              found struct\
    \ `Vec<Vec<(Vec<isize>, &isize)>>`\n\nerror: aborting due to 6 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0609.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    let mut row_len = lst.len();\n    let mut col_len = lst[0].len();\n\
    \    while row_idx < row_len && col_idx < col_len {\n        if lst[row_idx][col_idx]\
    \ == x {\n            row.push((row_idx, col_idx));\n            row_idx += 1;\n\
    \            col_idx += 1;\n        } else {\n            row_idx += 1;\n    \
    \    }\n    }\n    row.sort_by(|a, b| a.1.cmp(&b.1));\n    row.sort_by(|a, b|\
    \ b.1.cmp(&a.1));\n    row\n}\n\nfn main() {\n    let candidate = get_row;\n \
    \   assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv3ra_0s9.rs:24:23\n   |\n\
    24 |             row.push((row_idx, col_idx));\n   |                       ^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n24 |           \
    \  row.push((row_idx.try_into().unwrap(), col_idx));\n   |                   \
    \    ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv3ra_0s9.rs:24:32\n\
    \   |\n24 |             row.push((row_idx, col_idx));\n   |                  \
    \              ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    24 |             row.push((row_idx, col_idx.try_into().unwrap()));\n   |     \
    \                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    let mut row_idxs: Vec<isize> = vec![];\n    let mut col_idxs: Vec<isize>\
    \ = vec![];\n    let mut row_idxs_sorted: Vec<isize> = vec![];\n    let mut col_idxs_sorted:\
    \ Vec<isize> = vec![];\n    let mut row_idxs_sorted_reverse: Vec<isize> = vec![];\n\
    \    let mut col_idxs_sorted_reverse: Vec<isize> = vec![];\n    let mut row_idxs_reverse:\
    \ Vec<isize> = vec![];\n    let mut col_idxs_reverse: Vec<isize> = vec![];\n \
    \   let mut row_idxs_reversed: Vec<isize> = vec![];\n    let mut col_idxs_reversed:\
    \ Vec<isize> = vec![];\n    let mut row_idxs_reversed_sorted: Vec<isize> = vec![];\n\
    \    let mut col_idxs_reversed_sorted: Vec<isize> = vec![];\n    let mut row_idxs_reversed_sorted_reverse:\
    \ Vec<isize> = vec![];\n    let mut col_idxs_reversed_sorted_reverse: Vec<isize>\
    \ = vec![];\n    let mut row_idxs_reversed_reverse: Vec<isize> = vec![];\n   \
    \ let mut col_idxs_reversed_reverse: Vec<isize> = vec![];\n    let mut row_idxs_reversed_reversed:\
    \ Vec<isize> = vec![];\n    let mut col_idxs_reversed_reversed: Vec<isize> = vec![];\n\
    \    for row in lst {\n        let mut row_idxs_sorted_reversed = vec![];\n  \
    \      let mut col_idxs_sorted_reversed = vec![];\n        let mut row_idxs_reversed_reversed\
    \ = vec![];\n        let mut col_idxs_reversed_reversed = vec![];\n        let\
    \ mut row_idxs_reversed_reversed_sorted = vec![];\n        let mut col_idxs_reversed_reversed_sorted\
    \ = vec![];\n        let mut row_idxs_reversed_reversed_sorted_reverse = vec![];\n\
    \        let mut col_idxs_reversed_reversed_sorted_reverse = vec![];\n       \
    \ let mut row_idxs_reversed_reversed_reverse = vec![];\n}\n\nfn main() {\n   \
    \ let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpcr_x7bxy.rs:58:3\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                                                   -\
    \ unclosed delimiter\n...\n38 |     for row in lst {\n   |                   \
    \ - this delimiter might not be properly closed...\n...\n48 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n58 | }\n   |   ^\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpcr_x7bxy.rs:16:47\n   |\n16 | fn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |    -------\
    \                                    ^^^^^^^^^^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n\
    \    let mut row_idx = 0;\n    let mut col_idx = 0;\n    let mut row_max = rows;\n\
    \    let mut col_max = cols;\n    while row_idx < rows && col_idx < cols {\n \
    \       if row_idx < rows && col_idx < cols {\n            if lst[row_idx][col_idx]\
    \ == x {\n                result.push((row_idx, col_idx));\n                row_idx\
    \ += 1;\n                col_idx += 1;\n            }\n            row_max = std::cmp::max(row_max,\
    \ row_idx);\n            col_max = std::cmp::max(col_max, col_idx);\n        }\n\
    \    }\n    result.sort_by_key(|&(x, y)| {\n        std::cmp::cmp(&y, &x)\n  \
    \  });\n    result.sort_by_key(|&(x, y)| {\n        std::cmp::cmp(&y, &x)\n  \
    \  });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `cmp` in module `std::cmp`\n  --> /tmp/tmpwca6k_i7.rs:36:19\n\
    \   |\n36 |         std::cmp::cmp(&y, &x)\n   |                   ^^^ not found\
    \ in `std::cmp`\n\nerror[E0425]: cannot find function `cmp` in module `std::cmp`\n\
    \  --> /tmp/tmpwca6k_i7.rs:39:19\n   |\n39 |         std::cmp::cmp(&y, &x)\n \
    \  |                   ^^^ not found in `std::cmp`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwca6k_i7.rs:41:5\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>,\
    \ x: isize) -> Vec<(isize, isize)> {\n   |                                   \
    \            ------------------- expected `Vec<(isize, isize)>` because of return\
    \ type\n...\n41 |     result\n   |     ^^^^^^ expected `isize`, found `usize`\n\
    \   |\n   = note: expected struct `Vec<(isize, isize)>`\n              found struct\
    \ `Vec<(usize, usize)>`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n\
    \    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sort\
    \ = vec![];\n    let mut col_sort = vec![];\n    let mut row_sort_idx = vec![];\n\
    \    let mut col_sort_idx = vec![];\n    let mut row_sort_idx2 = vec![];\n   \
    \ let mut col_sort_idx2 = vec![];\n    let mut row_sort_idx3 = vec![];\n    let\
    \ mut col_sort_idx3 = vec![];\n    let mut row_sort_idx4 = vec![];\n    let mut\
    \ col_sort_idx4 = vec![];\n    let mut row_sort_idx5 = vec![];\n    let mut col_sort_idx5\
    \ = vec![];\n    let mut row_sort_idx6 = vec![];\n    let mut col_sort_idx6 =\
    \ vec![];\n    let mut row_sort_idx7 = vec![];\n    let mut col_sort_idx7 = vec![];\n\
    \    let mut row_sort_idx8 = vec![];\n    let mut col_sort_idx8 = vec![];\n  \
    \  let mut row_sort_idx9 = vec![];\n    let mut col_sort_idx9 = vec![];\n    let\
    \ mut row_sort_idx10 = vec![];\n    let mut col_sort_idx10 = vec![];\n    let\
    \ mut row_sort_idx11 = vec![];\n    let mut col_sort_idx11 = vec![];\n    let\
    \ mut row_sort_idx12 = vec![];\n    let mut col_sort_idx12 = vec![];\n    let\
    \ mut row_sort_idx13 = vec![];\n    let mut col_sort_idx13 = vec![];\n    let\
    \ mut row_sort_idx14 = vec![];\n    let mut col_sort_idx14 = vec![];\n    let\
    \ mut row_sort_idx15 = vec![];\n    let mut col_sort_idx15 = vec![];\n    let\
    \ mut row_sort_idx16 = vec![];\n    let mut col_sort_idx16 = vec![];\n    let\
    \ mut row_sort_idx17 = vec![];\n    let mut col_sort_idx17 = vec![];\n    let\
    \ mut row_sort_idx18 = vec![];\n    let mut col_sort_idx18 = vec![];\n    let\
    \ mut row_sort_idx19 = vec![];\n    let mut col_sort_idx19 = vec![];\n    let\
    \ mut row_sort_idx20 = vec![];\n    let mut col_sort_idx\n}\n\nfn main() {\n \
    \   let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmprs0cbi3d.rs:63:25\n   |\n\
    63 |     let mut col_sort_idx\n   |                         ^ help: add `;` here\n\
    64 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprs0cbi3d.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n\
    \    let mut row_idx = 0;\n    let mut col_idx = 0;\n    let mut row_max = rows;\n\
    \    let mut col_max = cols;\n    while row_idx < rows && col_idx < cols {\n \
    \       if row_idx < rows && col_idx < cols {\n            if lst[row_idx][col_idx]\
    \ == x {\n                result.push((row_idx, col_idx));\n                row_idx\
    \ += 1;\n                col_idx += 1;\n            }\n        }\n        if row_idx\
    \ < rows {\n            row_max -= 1;\n            col_idx += 1;\n        }\n\
    \        if col_idx < cols {\n            row_idx += 1;\n            col_max -=\
    \ 1;\n        }\n    }\n    result.sort_by(|a, b| a.1.cmp(&b.1));\n    result.sort_by(|a,\
    \ b| b.1.cmp(&a.1));\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6793fxgm.rs:43:5\n   |\n\
    16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \                                               ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n43 |     result\n   |     ^^^^^^ expected\
    \ `isize`, found `usize`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \              found struct `Vec<(usize, usize)>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut row_idx2\
    \ = 0;\n    let mut row_idx3 = 0;\n    let mut row_idx4 = 0;\n    let mut row_idx5\
    \ = 0;\n    let mut row_idx6 = 0;\n    let mut row_idx7 = 0;\n    let mut row_idx8\
    \ = 0;\n    let mut row_idx9 = 0;\n    let mut row_idx10 = 0;\n    let mut row_idx11\
    \ = 0;\n    let mut row_idx12 = 0;\n    let mut row_idx13 = 0;\n    let mut row_idx14\
    \ = 0;\n    let mut row_idx15 = 0;\n    let mut row_idx16 = 0;\n    let mut row_idx17\
    \ = 0;\n    let mut row_idx18 = 0;\n    let mut row_idx19 = 0;\n    let mut row_idx20\
    \ = 0;\n    let mut row_idx21 = 0;\n    let mut row_idx22 = 0;\n    let mut row_idx23\
    \ = 0;\n    let mut row_idx24 = 0;\n    let mut row_idx25 = 0;\n    let mut row_idx26\
    \ = 0;\n    let mut row_idx27 = 0;\n    let mut row_idx28 = 0;\n    let mut row_idx29\
    \ = 0;\n    let mut row_idx30 = 0;\n    let mut row_idx31 = 0;\n    let mut row_idx32\
    \ = 0;\n    let mut row_idx33 = 0;\n    let mut row_idx34 = 0;\n    let mut row_idx35\
    \ = 0;\n    let mut row_idx36 = 0;\n    let mut row_idx37 = 0;\n    let mut row_idx38\
    \ = 0;\n    let mut row_idx39 = 0;\n    let mut row_idx40 = 0;\n    let mut row_idx41\
    \ = 0;\n    let mut row_idx42 = 0;\n    let mut row_idx43 = 0;\n    let mut row_idx44\
    \ = 0;\n    let mut row_idx45 = 0;\n    let mut row_idx46 = 0;\n    let mut row_idx47\
    \ = 0;\n    let mut row_idx48 = 0;\n    let mut row_idx49 = 0;\n    let mut row_idx50\
    \ = 0;\n    let mut row_idx51 = 0;\n    let mut row_idx52 = 0;\n    let mut row_idx53\
    \ = 0;\n    let mut row_idx54 = 0;\n    let mut row_idx55 = 0;\n    let mut row_idx56\
    \ = 0;\n    let mut row_idx57 = 0;\n    let mut row_idx58 = 0;\n    let mut row_idx59\
    \ = 0;\n    let mut row_idx60 = 0;\n    let mut row_idx61 = 0;\n    let mut row_idx62\
    \ = 0;\n    let mut row_\n}\n\nfn main() {\n    let candidate = get_row;\n   \
    \ assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1,\
    \ 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmppjyfu577.rs:80:17\n   |\n\
    80 |     let mut row_\n   |                 ^ help: add `;` here\n81 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppjyfu577.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    for row in lst {\n        let mut row_result = vec![];\n\
    \        for col in row.iter().rev() {\n            if col == x {\n          \
    \      row_result.push((row.len(), col.len()));\n            }\n        }\n  \
    \      result.push(row_result);\n    }\n    result.sort_by(|a, b| a.iter().cmp(&b.iter()).reverse());\n\
    \    result.sort_by(|a, b| b.iter().cmp(&a.iter()).reverse());\n    result\n}\n\
    \nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpnraa2057.rs:21:20\n\
    \   |\n21 |             if col == x {\n   |                    ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n\nerror[E0599]: no method named `len` found for reference\
    \ `&isize` in the current scope\n  --> /tmp/tmpnraa2057.rs:22:49\n   |\n22 | \
    \                row_result.push((row.len(), col.len()));\n   |              \
    \                                   ^^^ method not found in `&isize`\n\nerror[E0277]:\
    \ `&std::slice::Iter<'_, _>` is not an iterator\n  --> /tmp/tmpnraa2057.rs:27:40\n\
    \   |\n27 |     result.sort_by(|a, b| a.iter().cmp(&b.iter()).reverse());\n  \
    \ |                                        -^^^^^^^^\n   |                   \
    \                     |\n   |                                        `&std::slice::Iter<'_,\
    \ _>` is not an iterator\n   |                                        help: consider\
    \ removing the leading `&`-reference\n   |\n   = help: the trait `Iterator` is\
    \ not implemented for `&std::slice::Iter<'_, _>`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `&std::slice::Iter<'_,\
    \ _>`\n\nerror[E0277]: `&std::slice::Iter<'_, _>` is not an iterator\n  --> /tmp/tmpnraa2057.rs:28:40\n\
    \   |\n28 |     result.sort_by(|a, b| b.iter().cmp(&a.iter()).reverse());\n  \
    \ |                                        -^^^^^^^^\n   |                   \
    \                     |\n   |                                        `&std::slice::Iter<'_,\
    \ _>` is not an iterator\n   |                                        help: consider\
    \ removing the leading `&`-reference\n   |\n   = help: the trait `Iterator` is\
    \ not implemented for `&std::slice::Iter<'_, _>`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `&std::slice::Iter<'_,\
    \ _>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnraa2057.rs:29:5\n   |\n\
    16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \                                               ------------------- expected `Ve"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    for row in lst {\n        let mut row_result = vec![];\n\
    \        for col in row.iter().rev() {\n            if col == x {\n          \
    \      row_result.push((row, col));\n            }\n        }\n        result.push(row_result);\n\
    \    }\n    result.sort_by_key(|row| row.iter().rev());\n    result.sort_by_key(|row|\
    \ row.iter().rev());\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmph4wwqnx1.rs:21:20\n\
    \   |\n21 |             if col == x {\n   |                    ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n\nerror[E0277]: the trait bound `Rev<std::slice::Iter<'_,\
    \ (Vec<isize>, &isize)>>: Ord` is not satisfied\n  --> /tmp/tmph4wwqnx1.rs:27:12\n\
    \   |\n27 |     result.sort_by_key(|row| row.iter().rev());\n   |            ^^^^^^^^^^^\
    \ the trait `Ord` is not implemented for `Rev<std::slice::Iter<'_, (Vec<isize>,\
    \ &isize)>>`\n\nerror[E0277]: the trait bound `Rev<std::slice::Iter<'_, (Vec<isize>,\
    \ &isize)>>: Ord` is not satisfied\n  --> /tmp/tmph4wwqnx1.rs:28:12\n   |\n28\
    \ |     result.sort_by_key(|row| row.iter().rev());\n   |            ^^^^^^^^^^^\
    \ the trait `Ord` is not implemented for `Rev<std::slice::Iter<'_, (Vec<isize>,\
    \ &isize)>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph4wwqnx1.rs:29:5\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n29 |     result\n   |   \
    \  ^^^^^^ expected tuple, found struct `Vec`\n   |\n   = note: expected struct\
    \ `Vec<(isize, isize)>`\n              found struct `Vec<Vec<(Vec<isize>, &isize)>>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows = lst.len();\n    let mut cols = lst[0].len();\n    let mut coords = vec![];\n\
    \    let mut row_coords = vec![];\n    let mut col_coords = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sort\
    \ = vec![];\n    let mut col_sort = vec![];\n    let mut row_sort_idx = vec![];\n\
    \    let mut col_sort_idx = vec![];\n    let mut row_sort_idx2 = vec![];\n   \
    \ let mut col_sort_idx2 = vec![];\n    let mut row_sort_idx3 = vec![];\n    let\
    \ mut col_sort_idx3 = vec![];\n    let mut row_sort_idx4 = vec![];\n    let mut\
    \ col_sort_idx4 = vec![];\n    let mut row_sort_idx5 = vec![];\n    let mut col_sort_idx5\
    \ = vec![];\n    let mut row_sort_idx6 = vec![];\n    let mut col_sort_idx6 =\
    \ vec![];\n    let mut row_sort_idx7 = vec![];\n    let mut col_sort_idx7 = vec![];\n\
    \    let mut row_sort_idx8 = vec![];\n    let mut col_sort_idx8 = vec![];\n  \
    \  let mut row_sort_idx9 = vec![];\n    let mut col_sort_idx9 = vec![];\n    let\
    \ mut row_sort_idx10 = vec![];\n    let mut col_sort_idx10 = vec![];\n    let\
    \ mut row_sort_idx11 = vec![];\n    let mut col_sort_idx11 = vec![];\n    let\
    \ mut row_sort_idx12 = vec![];\n    let mut col_sort_idx12 = vec![];\n    let\
    \ mut row_sort_idx13 = vec![];\n    let mut col_sort_idx13 = vec![];\n    let\
    \ mut row_sort_idx14 = vec![];\n    let mut col_sort_idx14 = vec![];\n    let\
    \ mut row_sort_idx15 = vec![];\n    let mut col_sort_idx15 = vec![];\n    let\
    \ mut row_sort_idx16 = vec![];\n    let mut col_sort_idx16 = vec![];\n    let\
    \ mut row_sort_idx17 = vec![];\n    let mut col_sort_idx17 = vec![];\n    let\
    \ mut row_sort_idx18 = vec![];\n    let mut col_sort_idx18 = vec![];\n    let\
    \ mut row_sort_idx19 = vec![];\n    let mut col_sort_idx19\n}\n\nfn main() {\n\
    \    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp18f5dy2q.rs:63:27\n   |\n\
    63 |     let mut col_sort_idx19\n   |                           ^ help: add `;`\
    \ here\n64 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp18f5dy2q.rs:16:47\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize)\
    \ -> Vec<(isize, isize)> {\n   |    -------                                  \
    \  ^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<(isize, isize)>`\n           found unit type `()`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx2 = vec![];\n    let mut col_idx2 = vec![];\n    let mut row_sorted2\
    \ = vec![];\n    let mut col_sorted2 = vec![];\n    let mut row_idx3 = vec![];\n\
    \    let mut col_idx3 = vec![];\n    let mut row_sorted3 = vec![];\n    let mut\
    \ col_sorted3 = vec![];\n    let mut row_idx4 = vec![];\n    let mut col_idx4\
    \ = vec![];\n    let mut row_sorted4 = vec![];\n    let mut col_sorted4 = vec![];\n\
    \    let mut row_idx5 = vec![];\n    let mut col_idx5 = vec![];\n    let mut row_sorted5\
    \ = vec![];\n    let mut col_sorted5 = vec![];\n    let mut row_idx6 = vec![];\n\
    \    let mut col_idx6 = vec![];\n    let mut row_sorted6 = vec![];\n    let mut\
    \ col_sorted6 = vec![];\n    let mut row_idx7 = vec![];\n    let mut col_idx7\
    \ = vec![];\n    let mut row_sorted7 = vec![];\n    let mut col_sorted7 = vec![];\n\
    \    let mut row_idx8 = vec![];\n    let mut col_idx8 = vec![];\n    let mut row_sorted8\
    \ = vec![];\n    let mut col_sorted8 = vec![];\n    let mut row_idx9 = vec![];\n\
    \    let mut col_idx9 = vec![];\n    let mut row_sorted9 = vec![];\n    let mut\
    \ col_sorted9 = vec![];\n    let mut row_idx10 = vec![];\n    let mut col_idx10\
    \ = vec![];\n    let mut row_sorted10 = vec![];\n    let mut col_sorted10 = vec![];\n\
    \    let mut row_idx11 = vec![];\n    let mut col_idx11 = vec![];\n    let mut\
    \ row_sorted11 = vec![];\n    let mut col_sorted11 = vec![];\n    let mut row_idx12\
    \ = vec![];\n    let mut col_idx12 = vec![];\n    let mut row_sorted12 = vec![];\n\
    \    let mut col_sorted12 = vec![];\n    let mut row_idx13 = vec![];\n    let\
    \ mut col_idx13 = vec![];\n    let mut row_\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmplj814n86.rs:68:17\n   |\n\
    68 |     let mut row_\n   |                 ^ help: add `;` here\n69 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplj814n86.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ coords = vec![];\n    let mut rows = vec![];\n    let mut cols = vec![];\n \
    \   let mut row_coords = vec![];\n    let mut col_coords = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted = vec\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpo812tp_t.rs:68:29\n   |\n\
    68 |     let mut row_sorted = vec\n   |                             ^ help: add\
    \ `;` here\n69 | }\n   | - unexpected token\n\nerror[E0423]: expected value, found\
    \ macro `vec`\n  --> /tmp/tmpo812tp_t.rs:68:26\n   |\n68 |     let mut row_sorted\
    \ = vec\n   |                          ^^^ not a value\n   |\nhelp: use `!` to\
    \ invoke the macro\n   |\n68 |     let mut row_sorted = vec!\n   |           \
    \                  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo812tp_t.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0423.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows = lst.len();\n    let mut cols = lst[0].len();\n    let mut coords = vec![];\n\
    \    let mut row_coords = vec![];\n    let mut col_coords = vec![];\n    let mut\
    \ row_coord = vec![];\n    let mut col_coord = vec![];\n    let mut i = 0;\n \
    \   let mut j = 0;\n    while i < rows {\n        row_coord = vec![];\n      \
    \  col_coord = vec![];\n        row_coord.push(i);\n        col_coord.push(j);\n\
    \        i += 1;\n        j += 1;\n        while j < cols {\n            if lst[i][j]\
    \ == x {\n                coords.push((row_coord.clone(), col_coord.clone()));\n\
    \                row_coord.push(j);\n                col_coord.push(i);\n    \
    \            i += 1;\n                j += 1;\n            } else {\n        \
    \        j += 1;\n            }\n        }\n    }\n    coords.sort_by_key(|&(_,\
    \ y)| y.0);\n    coords.sort_by_key(|&(_, y)| y.1);\n    coords\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `0` on type `Vec<usize>`\n  --> /tmp/tmpjygy7vac.rs:45:36\n\
    \   |\n45 |     coords.sort_by_key(|&(_, y)| y.0);\n   |                     \
    \               ^ unknown field\n\nerror[E0609]: no field `1` on type `Vec<usize>`\n\
    \  --> /tmp/tmpjygy7vac.rs:46:36\n   |\n46 |     coords.sort_by_key(|&(_, y)|\
    \ y.1);\n   |                                    ^ unknown field\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjygy7vac.rs:47:5\n   |\n16 | fn get_row(lst:\
    \ Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |                  \
    \                             ------------------- expected `Vec<(isize, isize)>`\
    \ because of return type\n...\n47 |     coords\n   |     ^^^^^^ expected `isize`,\
    \ found struct `Vec`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \              found struct `Vec<(Vec<usize>, Vec<usize>)>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0609.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows = lst.len();\n    let mut cols = lst[0].len();\n    let mut coords = vec![];\n\
    \    let mut row_coords = vec![];\n    let mut col_coords = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sort_idx\
    \ = 0;\n    let mut col_sort_idx = 0;\n    let mut row_sort_idx2 = 0;\n    let\
    \ mut col_sort_idx2 = 0;\n    let mut row_sort_idx3 = 0;\n    let mut col_sort_idx3\
    \ = 0;\n    let mut row_sort_idx4 = 0;\n    let mut col_sort_idx4 = 0;\n    let\
    \ mut row_sort_idx5 = 0;\n    let mut col_sort_idx5 = 0;\n    let mut row_sort_idx6\
    \ = 0;\n    let mut col_sort_idx6 = 0;\n    let mut row_sort_idx7 = 0;\n    let\
    \ mut col_sort_idx7 = 0;\n    let mut row_sort_idx8 = 0;\n    let mut col_sort_idx8\
    \ = 0;\n    let mut row_sort_idx9 = 0;\n    let mut col_sort_idx9 = 0;\n    let\
    \ mut row_sort_idx10 = 0;\n    let mut col_sort_idx10 = 0;\n    let mut row_sort_idx11\
    \ = 0;\n    let mut col_sort_idx11 = 0;\n    let mut row_sort_idx12 = 0;\n   \
    \ let mut col_sort_idx12 = 0;\n    let mut row_sort_idx13 = 0;\n    let mut col_sort_idx13\
    \ = 0;\n    let mut row_sort_idx14 = 0;\n    let mut col_sort_idx14 = 0;\n   \
    \ let mut row_sort_idx15 = 0;\n    let mut col_sort_idx15 = 0;\n    let mut row_sort_idx16\
    \ = 0;\n    let mut col_sort_idx16 = 0;\n    let mut row_sort_idx17 = 0;\n   \
    \ let mut col_sort_idx17 = 0;\n    let mut row_sort_idx18 = 0;\n    let mut col_sort_idx18\
    \ = 0;\n    let mut row_sort_idx19 = 0;\n    let mut col_sort_idx19 = 0;\n   \
    \ let mut row_sort_idx20 = 0;\n    let mut col_sort_idx20 = 0;\n    let mut row_sort_idx21\
    \ = 0;\n    let mut col_sort_idx21 = 0;\n    let mut row_sort_idx22 = 0;\n   \
    \ let mut col_sort_idx22 = 0;\n    let mut row_sort_idx23 = 0;\n    let mut col_sort_idx23\
    \ = 0;\n    let mut row_sort_idx24 = 0;\n    let mut col_sort_idx24 = 0;\n   \
    \ let mut row_sort_idx25 = 0;\n    let mut col_sort_idx25 = 0;\n    let mut row_sort_\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8reh6ncl.rs:74:22\n   |\n\
    74 |     let mut row_sort_\n   |                      ^ help: add `;` here\n75\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8reh6ncl.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut row_idx_max\
    \ = 0;\n    let mut col_max = 0;\n    let mut col_min = 0;\n    let mut col_sum\
    \ = 0;\n    let mut col_sum2 = 0;\n    let mut col_sum3 = 0;\n    let mut col_sum4\
    \ = 0;\n    let mut col_sum5 = 0;\n    let mut col_sum6 = 0;\n    let mut col_sum7\
    \ = 0;\n    let mut col_sum8 = 0;\n    let mut col_sum9 = 0;\n    let mut col_sum10\
    \ = 0;\n    let mut col_sum11 = 0;\n    let mut col_sum12 = 0;\n    let mut col_sum13\
    \ = 0;\n    let mut col_sum14 = 0;\n    let mut col_sum15 = 0;\n    let mut col_sum16\
    \ = 0;\n    let mut col_sum17 = 0;\n    let mut col_sum18 = 0;\n    let mut col_sum19\
    \ = 0;\n    let mut col_sum20 = 0;\n    let mut col_sum21 = 0;\n    let mut col_sum22\
    \ = 0;\n    let mut col_sum23 = 0;\n    let mut col_sum24 = 0;\n    let mut col_sum25\
    \ = 0;\n    let mut col_sum26 = 0;\n    let mut col_sum27 = 0;\n    let mut col_sum28\
    \ = 0;\n    let mut col_sum29 = 0;\n    let mut col_sum30 = 0;\n    let mut col_sum31\
    \ = 0;\n    let mut col_sum32 = 0;\n    let mut col_sum33 = 0;\n    let mut col_sum34\
    \ = 0;\n    let mut col_sum35 = 0;\n    let mut col_sum36 = 0;\n    let mut col_sum37\
    \ = 0;\n    let mut col_sum38 = 0;\n    let mut col_sum39 = 0;\n    let mut col_sum40\
    \ = 0;\n    let mut col_sum41 = 0;\n    let mut col_sum42 = 0;\n    let mut col_sum43\
    \ = 0;\n    let mut col_sum44 = 0;\n    let mut col_sum45 = 0;\n    let mut col_sum46\
    \ = 0;\n    let mut col_sum47 = 0;\n    let mut col_sum48 = 0;\n    let mut col_sum49\
    \ = 0;\n    let mut col_sum50 = 0;\n    let mut col_sum51 = 0;\n    let mut col_sum52\
    \ = 0;\n    let mut col_sum53 = 0;\n    let mut col_sum54 = 0;\n    let mut col_sum55\
    \ = 0;\n    let mut col_sum56 = 0;\n    let mut col_sum57 = 0;\n    let mut col_sum58\
    \ = 0;\n    let mut col_sum59 = 0;\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3pipl040.rs:16:47\n   |\n\
    16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \    -------                                    ^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut col_num\
    \ = 0;\n    let mut col_max = 0;\n    let mut row_max = 0;\n    let mut col_min\
    \ = 0;\n    let mut row_min = 0;\n    for row in lst {\n        col_num = row.len();\n\
    \        col_max = col_num;\n        row_max = row.len();\n        col_min = col_num;\n\
    \        row_min = row.len();\n        for row in row {\n            if row ==\
    \ x {\n                row.push((row_idx, col_num));\n                break;\n\
    \            }\n            if row > x {\n                col_max = col_num;\n\
    \                row_max = row.len();\n            }\n            if row < x {\n\
    \                col_min = col_num;\n                row_min = row.len();\n  \
    \          }\n            col_num += 1;\n        }\n        if col_num > col_max\
    \ {\n            col_max = col_num;\n        }\n        if row_num > row_max {\n\
    \            row_max = row_num;\n        }\n        if col_num < col_min {\n \
    \           col_min = col_num;\n        }\n        if row_num < row_min {\n  \
    \          row_min = row_num;\n        }\n    }\n    row.sort_by_key(|&(_, y)|\
    \ y);\n    row.sort_by_key(|&(_, y)| y, |&(_, y)| -y);\n    row\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `row_num` in this scope\n  --> /tmp/tmpar0u5jpu.rs:48:12\n\
    \   |\n48 |         if row_num > row_max {\n   |            ^^^^^^^ help: a local\
    \ variable with a similar name exists: `col_num`\n\nerror[E0425]: cannot find\
    \ value `row_num` in this scope\n  --> /tmp/tmpar0u5jpu.rs:49:23\n   |\n49 | \
    \            row_max = row_num;\n   |                       ^^^^^^^ help: a local\
    \ variable with a similar name exists: `col_num`\n\nerror[E0425]: cannot find\
    \ value `row_num` in this scope\n  --> /tmp/tmpar0u5jpu.rs:54:12\n   |\n54 | \
    \        if row_num < row_min {\n   |            ^^^^^^^ help: a local variable\
    \ with a similar name exists: `col_num`\n\nerror[E0425]: cannot find value `row_num`\
    \ in this scope\n  --> /tmp/tmpar0u5jpu.rs:55:23\n   |\n55 |             row_min\
    \ = row_num;\n   |                       ^^^^^^^ help: a local variable with a\
    \ similar name exists: `col_num`\n\nerror[E0599]: no method named `push` found\
    \ for type `isize` in the current scope\n  --> /tmp/tmpar0u5jpu.rs:32:21\n   |\n\
    32 |                 row.push((row_idx, col_num));\n   |                     ^^^^\
    \ method not found in `isize`\n\nerror[E0599]: no method named `len` found for\
    \ type `isize` in the current scope\n  --> /tmp/tmpar0u5jpu.rs:37:31\n   |\n37\
    \ |                 row_max = row.len();\n   |                               ^^^\
    \ method not found in `isize`\n\nerror[E0599]: no method named `len` found for\
    \ type `isize` in the current scope\n  --> /tmp/tmpar0u5jpu.rs:41:31\n   |\n41\
    \ |                 row_min = row.len();\n   |                               ^^^\
    \ method not found in `isize`\n\nerror[E0061]: this function takes 1 argument\
    \ but 2 arguments were supplied\n   --> /tmp/tmpar0u5jpu.rs:59:9\n    |\n59  |\
    \     row.sort_by_key(|&(_, y)| y, |&(_, y)| -y);\n    |         ^^^^^^^^^^^ -----------\
    \  ------------ supplied 2 arguments\n    |         |\n    |         expected\
    \ 1 argument\n    |\nnote: associated function defined here\n\nerror: aborting\
    \ due to 8 previous errors\n\nSome errors have detailed explanations: E0061, E0425,\
    \ E0599.\nFor more information about an error, try `rus"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows = lst.len();\n    let mut cols = lst[0].len();\n    let mut coords = vec![];\n\
    \    let mut row_coords = vec![];\n    let mut col_coords = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sort_idx\
    \ = vec![];\n    let mut col_sort_idx = vec![];\n    let mut row_sort_idx_idx\
    \ = vec![];\n    let mut col_sort_idx_idx = vec![];\n    let mut row_sort_idx_idx_idx\
    \ = vec![];\n    let mut col_sort_idx_idx_idx = vec![];\n    let mut row_sort_idx_idx_idx_idx\
    \ = vec![];\n    let mut col_sort_idx_idx_idx_idx = vec![];\n    let mut row_sort_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut col_sort_idx_idx_idx_idx_idx = vec![];\n    let mut row_sort_idx_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut col_sort_idx_idx_idx_idx_idx_idx = vec![];\n    let mut\
    \ row_sort_idx_idx_idx_idx_idx_idx_idx = vec![];\n    let mut col_sort_idx_idx_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut row_sort_idx_idx_idx_idx_idx_idx_idx_idx = vec![];\n\
    \    let mut col_sort_idx_idx_idx_idx_idx_idx_idx_idx = vec![];\n    let mut row_sort_idx_idx_idx_idx_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut col_sort_idx_idx_idx_idx_idx_idx_idx_idx_idx = vec![];\n\
    \    let mut row_sort_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx = vec![];\n    let\
    \ mut col_sort_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx = vec![];\n    let mut\
    \ row_sort_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx = vec![];\n    let mut col_sort_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut row_sort_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut col_sort_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut row_sort_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut col_sort_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut row_sort_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut col_sort_idx_idx_idx_idx_idx_idx_idx_idx_\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp2dys8fvn.rs:51:54\n   |\n\
    51 |     let mut col_sort_idx_idx_idx_idx_idx_idx_idx_idx_\n   |             \
    \                                         ^ help: add `;` here\n52 | }\n   | -\
    \ unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2dys8fvn.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    let mut row_len = lst.len();\n    let mut col_len = lst[0].len();\n\
    \    while row_idx < row_len {\n        let mut row_col: (isize, isize) = (row_idx,\
    \ col_idx);\n        while col_idx < col_len {\n            if lst[row_idx][col_idx]\
    \ == x {\n                row_col.0 = row_idx;\n                row_col.1 = col_idx;\n\
    \                break;\n            }\n            col_idx += 1;\n        }\n\
    \        row.push(row_col);\n        col_idx = 0;\n        row_idx += 1;\n   \
    \ }\n    row.sort_by_key(|&(_, y)| y);\n    row.sort_by_key(|&(_, y)| y, |&(_,\
    \ y)| -y);\n    row\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpehc7gpc1.rs:23:44\n   |\n\
    23 |         let mut row_col: (isize, isize) = (row_idx, col_idx);\n   |     \
    \                                       ^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |         let mut row_col: (isize, isize) = (row_idx.try_into().unwrap(),\
    \ col_idx);\n   |                                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpehc7gpc1.rs:24:25\n   |\n24 |\
    \         while col_idx < col_len {\n   |                         ^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n24 |         while col_idx\
    \ < col_len.try_into().unwrap() {\n   |                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpehc7gpc1.rs:25:16\n\
    \   |\n25 |             if lst[row_idx][col_idx] == x {\n   |                ^^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpehc7gpc1.rs:26:29\n   |\n26 |\
    \                 row_col.0 = row_idx;\n   |                             ^^^^^^^\
    \ expected `isize`, found `usize`\n\nerror[E0061]: this function takes 1 argument\
    \ but 2 arguments were supplied\n   --> /tmp/tmpehc7gpc1.rs:37:9\n    |\n37  |\
    \     row.sort_by_key(|&(_, y)| y, |&(_, y)| -y);\n    |         ^^^^^^^^^^^ -----------\
    \  ------------ supplied 2 arguments\n    |         |\n    |         expected\
    \ 1 argument\n    |\nnote: associated function defined here\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0061, E0277,\
    \ E0308.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ coords = vec![];\n    let mut row = 0;\n    let mut col = 0;\n    while row\
    \ < lst.len() {\n        if row == x {\n            coords.push(vec![(row, col)]);\n\
    \            row++;\n            col = 0;\n        } else {\n            row +=\
    \ 1;\n            col += 1\n        }\n    }\n    coords.sort_by_key(|&(_, y)|\
    \ y.reverse());\n    coords.sort_by_key(|&(_, y)| y.reverse());\n    coords\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `+`\n  --> /tmp/tmpvozkj1k4.rs:23:17\n\
    \   |\n23 |             row++;\n   |                 ^ expected expression\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpvozkj1k4.rs:21:19\n   |\n21 |  \
    \       if row == x {\n   |                   ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n21 |         if row == x.try_into().unwrap() {\n  \
    \ |                   ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpvozkj1k4.rs:30:26\n   |\n30 |     coords.sort_by_key(|&(_, y)|\
    \ y.reverse());\n   |                          ^^^^^-\n   |                  \
    \        |    |\n   |                          |    expected due to this\n   |\
    \                          expected struct `Vec`, found tuple\n   |\n   = note:\
    \ expected struct `Vec<(usize, {integer})>`\n               found tuple `(_, _)`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpvozkj1k4.rs:31:26\n   |\n31 |\
    \     coords.sort_by_key(|&(_, y)| y.reverse());\n   |                       \
    \   ^^^^^-\n   |                          |    |\n   |                       \
    \   |    expected due to this\n   |                          expected struct `Vec`,\
    \ found tuple\n   |\n   = note: expected struct `Vec<(usize, {integer})>`\n  \
    \             found tuple `(_, _)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvozkj1k4.rs:32:5\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n32 |     coords\n   |   \
    \  ^^^^^^ expected tuple, found struct `Vec`\n   |\n   = note: expected struct\
    \ `Vec<(isize, isize)>`\n              found struct `Vec<Vec<(usize, {integer})>>`\n\
    \nerror: aborting due to 5 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx: Vec<isize> = vec![];\n\
    \    let mut row_idx2: Vec<isize> = vec![];\n    let mut row_idx3: Vec<isize>\
    \ = vec![];\n    let mut row_idx4: Vec<isize> = vec![];\n    let mut row_idx5:\
    \ Vec<isize> = vec![];\n    let mut row_idx6: Vec<isize> = vec![];\n    let mut\
    \ row_idx7: Vec<isize> = vec![];\n    let mut row_idx8: Vec<isize> = vec![];\n\
    \    let mut row_idx9: Vec<isize> = vec![];\n    let mut row_idx10: Vec<isize>\
    \ = vec![];\n    let mut row_idx11: Vec<isize> = vec![];\n    let mut row_idx12:\
    \ Vec<isize> = vec![];\n    let mut row_idx13: Vec<isize> = vec![];\n    let mut\
    \ row_idx14: Vec<isize> = vec![];\n    let mut row_idx15: Vec<isize> = vec![];\n\
    \    let mut row_idx16: Vec<isize> = vec![];\n    let mut row_idx17: Vec<isize>\
    \ = vec![];\n    let mut row_idx18: Vec<isize> = vec![];\n    let mut row_idx19:\
    \ Vec<isize> = vec![];\n    let mut row_idx20: Vec<isize> = vec![];\n    let mut\
    \ row_idx21: Vec<isize> = vec![];\n    let mut row_idx22: Vec<isize> = vec![];\n\
    \    let mut row_idx23: Vec<isize> = vec![];\n    let mut row_idx24: Vec<isize>\
    \ = vec![];\n    let mut row_idx25: Vec<isize> = vec![];\n    let mut row_idx26:\
    \ Vec<isize> = vec![];\n    let mut row_idx27: Vec<isize> = vec![];\n    let mut\
    \ row_idx28: Vec<isize> = vec![];\n    let mut row_idx29: Vec<isize> = vec![];\n\
    \    let mut row_idx30: \n}\n\nfn main() {\n    let candidate = get_row;\n   \
    \ assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1,\
    \ 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected type, found `}`\n  --> /tmp/tmpn5ksppg3.rs:48:1\n   |\n\
    47 |     let mut row_idx30: \n   |         ------------- while parsing the type\
    \ for `mut row_idx30`\n48 | }\n   | ^ expected type\n\nerror: aborting due to\
    \ previous error\n\n"
  stdout: ''
  timestamp: 1659749648
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut row_idx_max\
    \ = 0;\n    let mut row_idx_min = 0;\n    let mut col_max = 0;\n    let mut col_min\
    \ = 0;\n    let mut col_max_idx = 0;\n    let mut col_min_idx = 0;\n    let mut\
    \ col_max_idx2 = 0;\n    let mut col_min_idx2 = 0;\n    let mut col_max_idx3 =\
    \ 0;\n    let mut col_min_idx3 = 0;\n    let mut col_max_idx4 = 0;\n    let mut\
    \ col_min_idx4 = 0;\n    let mut col_max_idx5 = 0;\n    let mut col_min_idx5 =\
    \ 0;\n    let mut col_max_idx6 = 0;\n    let mut col_min_idx6 = 0;\n    let mut\
    \ col_max_idx7 = 0;\n    let mut col_min_idx7 = 0;\n    let mut col_max_idx8 =\
    \ 0;\n    let mut col_min_idx8 = 0;\n    let mut col_max_idx9 = 0;\n    let mut\
    \ col_min_idx9 = 0;\n    let mut col_max_idx10 = 0;\n    let mut col_min_idx10\
    \ = 0;\n    let mut col_max_idx11 = 0;\n    let mut col_min_idx11 = 0;\n    let\
    \ mut col_max_idx12 = 0;\n    let mut col_min_idx12 = 0;\n    let mut col_max_idx13\
    \ = 0;\n    let mut col_min_idx13 = 0;\n    let mut col_max_idx14 = 0;\n    let\
    \ mut col_min_idx14 = 0;\n    let mut col_max_idx15 = 0;\n    let mut col_min_idx15\
    \ = 0;\n    let mut col_max_idx16 = 0;\n    let mut col_min_idx16 = 0;\n    let\
    \ mut col_max_idx17 = 0;\n    let mut col_min_idx17 = 0;\n    let mut col_max_idx18\
    \ = 0;\n    let mut col_min_idx18 = 0;\n    let mut col_max_idx19 = 0;\n    let\
    \ mut col_min_idx19 = 0;\n    let mut col_max_idx20 = 0;\n    let mut col_min_idx20\
    \ = 0;\n    let mut col_max_idx21 = 0;\n    let mut col_min_idx21 = 0;\n    let\
    \ mut col_max_idx22 = 0;\n    let mut col_min_idx22 = 0;\n    let mut col_max_idx23\
    \ = 0;\n    let mut col_min_idx23 = 0;\n    let mut col_max_idx24 = 0;\n    let\
    \ mut col_min_idx24 = 0;\n    let mut col_max_idx25 = 0;\n    let mut col_min_idx25\
    \ = 0;\n    let mut col_max_idx26 = 0;\n    let mut col_min_idx26 = 0;\n\n}\n\n\
    fn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj87et7nn.rs:16:47\n   |\n\
    16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \    -------                                    ^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ lst = lst.clone();\n    let mut res = vec![];\n    let mut row = 0;\n    let\
    \ mut col = 0;\n    while row < lst.len() {\n        let mut found = false;\n\
    \        for y in 0..lst[row].len() {\n            if lst[row][y] == x {\n   \
    \             found = true;\n                break;\n            }\n        }\n\
    \        if found {\n            res.push((row, col));\n            row += 1;\n\
    \            col = 0;\n        } else {\n            col += 1;\n        }\n  \
    \  }\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmjch_tmo.rs:37:5\n   |\n\
    16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \                                               ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n37 |     res\n   |     ^^^ expected `isize`,\
    \ found `usize`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n    \
    \          found struct `Vec<(usize, {integer})>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n\
    \    let mut row_idx = vec![0; rows];\n    let mut col_idx = vec![0; cols];\n\
    \    let mut row_sorted = vec![0; rows];\n    let mut col_sorted = vec![0; cols];\n\
    \    let mut row_idx2 = vec![0; rows];\n    let mut col_idx2 = vec![0; cols];\n\
    \    let mut row_sorted2 = vec![0; rows];\n    let mut col_sorted2 = vec![0; cols];\n\
    \    let mut row_idx3 = vec![0; rows];\n    let mut col_idx3 = vec![0; cols];\n\
    \    let mut row_sorted3 = vec![0; rows];\n    let mut col_sorted3 = vec![0; cols];\n\
    \    let mut row_idx4 = vec![0; rows];\n    let mut col_idx4 = vec![0; cols];\n\
    \    let mut row_sorted4 = vec![0; rows];\n    let mut col_sorted4 = vec![0; cols];\n\
    \    let mut row_idx5 = vec![0; rows];\n    let mut col_idx5 = vec![0; cols];\n\
    \    let mut row_sorted5 = vec![0; rows];\n    let mut col_sorted5 = vec![0; cols];\n\
    \    let mut row_idx6 = vec![0; rows];\n    let mut col_idx6 = vec![0; cols];\n\
    \    let mut row_sorted6 = vec![0; rows];\n    let mut col_sorted6 = vec![0; cols];\n\
    \    let mut row_idx7 = vec![0; rows];\n    let mut col_idx7 = vec![0; cols];\n\
    \    let mut row_sorted7 = vec![0; rows];\n    let mut col_sorted7 = vec![0; cols];\n\
    \    let mut row_idx8 = vec![0; rows];\n    let mut col_idx8 = vec![0; cols];\n\
    \    let mut row_sorted8 = vec![0; rows];\n    let mut col_sorted8 = vec![0; cols];\n\
    \    let mut row_idx9 = vec![0; rows];\n    let mut col_idx9 = vec![0; cols];\n\
    \    let mut row_sorted9 = vec![0; rows];\n    let mut col_sorted9 = vec![0; cols];\n\
    \    let mut row_idx10 = vec![0; rows];\n    let mut col_idx10 = vec![0; cols];\n\
    \    let mut row_sorted10 = vec![0; rows];\n    let mut col_sorted10 = vec![0;\
    \ cols];\n    let mut row_idx11 = vec![\n}\n\nfn main() {\n    let candidate =\
    \ get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmp1djz1w4g.rs:61:1\n   |\n61 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmp1djz1w4g.rs:60:29\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize)\
    \ -> Vec<(isize, isize)> {\n   |                                             \
    \                      - closing delimiter possibly meant for this\n...\n60 |\
    \     let mut row_idx11 = vec![\n   |                             ^ unclosed delimiter\n\
    61 | }\n   | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous\
    \ errors\n\n"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n\
    \    let mut row_idx = 0;\n    let mut col_idx = 0;\n    let mut row_max = rows;\n\
    \    let mut col_max = cols;\n    while row_idx < rows && col_idx < cols {\n \
    \       if row_idx < rows && col_idx < cols && lst[row_idx][col_idx] == x {\n\
    \            result.push((row_idx, col_idx));\n            row_idx++;\n      \
    \      col_idx++;\n        } else if row_idx < rows && col_idx >= cols {\n   \
    \         row_idx++;\n            row_max--;\n            col_idx = 0;\n     \
    \       col_max = cols;\n        } else if row_idx >= rows && col_idx < cols {\n\
    \            col_idx++;\n            col_max--;\n            row_idx = 0;\n  \
    \          row_max = rows;\n        }\n    }\n    result.sort_by_key(|&(x, y)|\
    \ x.0);\n    result.sort_by_key(|&(x, y)| y.0);\n    result\n}\n\nfn main() {\n\
    \    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `+`\n  --> /tmp/tmpoxgqrc1o.rs:27:21\n\
    \   |\n27 |             row_idx++;\n   |                     ^ expected expression\n\
    \nerror: expected expression, found `+`\n  --> /tmp/tmpoxgqrc1o.rs:30:21\n   |\n\
    30 |             row_idx++;\n   |                     ^ expected expression\n\n\
    error: expected expression, found `+`\n  --> /tmp/tmpoxgqrc1o.rs:35:21\n   |\n\
    35 |             col_idx++;\n   |                     ^ expected expression\n\n\
    error[E0610]: `usize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmpoxgqrc1o.rs:41:36\n   |\n41 |     result.sort_by_key(|&(x, y)|\
    \ x.0);\n   |                                    ^\n\nerror[E0610]: `usize` is\
    \ a primitive type and therefore doesn't have fields\n  --> /tmp/tmpoxgqrc1o.rs:42:36\n\
    \   |\n42 |     result.sort_by_key(|&(x, y)| y.0);\n   |                     \
    \               ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoxgqrc1o.rs:43:5\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n43 |     result\n   |   \
    \  ^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n              found struct `Vec<(usize, usize)>`\n\nerror: aborting\
    \ due to 6 previous errors\n\nSome errors have detailed explanations: E0308, E0610.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx: Vec<isize> = vec![];\n\
    \    let mut row_idx_idx: Vec<isize> = vec![];\n    let mut row_idx_idx_idx: Vec<isize>\
    \ = vec![];\n    let mut row_idx_idx_idx_idx: Vec<isize> = vec![];\n    let mut\
    \ row_idx_idx_idx_idx_idx: Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx: Vec<isize>\
    \ = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx: Vec<isize> = vec![];\n\
    \    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx: Vec<isize> = vec![];\n \
    \   let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx: Vec<isize> = vec![];\n\
    \    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx: Vec<isize> = vec![];\n\
    \    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx: Vec<isize> =\
    \ vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n    let mut row_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx:\
    \ Vec<isize> = vec![];\n\n}\n\nfn main() {\n    let candidate = get_row;\n   \
    \ assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1,\
    \ 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2k9z5q35.rs:16:47\n   |\n\
    16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \    -------                                    ^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    while row_idx < lst.len() {\n        let mut row_idx = 0;\n      \
    \  while col_idx < lst[row_idx].len() {\n            if lst[row_idx][col_idx]\
    \ == x {\n                let row = row_idx;\n                let col = col_idx;\n\
    \                rows.push(vec![(row, col)]);\n                row_idx += 1;\n\
    \                col_idx += 1;\n            } else {\n                col_idx\
    \ += 1;\n            }\n        }\n        row_idx += 1;\n    }\n    rows\n}\n\
    \nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl7r6n7oj.rs:26:27\n   |\n\
    26 |                 rows.push(vec![(row, col)]);\n   |                      \
    \     ^^^^^^^^^^^^^^^^ expected tuple, found struct `Vec`\n   |\n   = note: expected\
    \ tuple `(isize, isize)`\n             found struct `Vec<(usize, usize)>`\n  \
    \ = note: this error originates in the macro `vec` (in Nightly builds, run with\
    \ -Z macro-backtrace for more info)\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    for row in lst {\n        if row_idx == x {\n            rows.push((row_idx,\
    \ col_idx));\n        }\n        for col in row {\n            col_idx = (col_idx\
    \ + 1) % row.len();\n            row_idx = (row_idx + 1) % lst.len();\n      \
    \  }\n    }\n    rows.sort_by_key(|&(x, y)| x.0);\n    rows.sort_by_key(|&(x,\
    \ y)| y.0);\n    rows\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4svw4s8s.rs:25:39\n   |\n\
    25 |             col_idx = (col_idx + 1) % row.len();\n   |                  \
    \                     ^^^^^^^^^ expected `isize`, found `usize`\n\nerror[E0277]:\
    \ cannot mod `isize` by `usize`\n  --> /tmp/tmp4svw4s8s.rs:25:37\n   |\n25 | \
    \            col_idx = (col_idx + 1) % row.len();\n   |                      \
    \               ^ no implementation for `isize % usize`\n   |\n   = help: the\
    \ trait `Rem<usize>` is not implemented for `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4svw4s8s.rs:26:39\n   |\n26 |             row_idx = (row_idx\
    \ + 1) % lst.len();\n   |                                       ^^^^^^^^^ expected\
    \ `isize`, found `usize`\n\nerror[E0277]: cannot mod `isize` by `usize`\n  -->\
    \ /tmp/tmp4svw4s8s.rs:26:37\n   |\n26 |             row_idx = (row_idx + 1) %\
    \ lst.len();\n   |                                     ^ no implementation for\
    \ `isize % usize`\n   |\n   = help: the trait `Rem<usize>` is not implemented\
    \ for `isize`\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't\
    \ have fields\n  --> /tmp/tmp4svw4s8s.rs:29:34\n   |\n29 |     rows.sort_by_key(|&(x,\
    \ y)| x.0);\n   |                                  ^\n\nerror[E0610]: `isize`\
    \ is a primitive type and therefore doesn't have fields\n  --> /tmp/tmp4svw4s8s.rs:30:34\n\
    \   |\n30 |     rows.sort_by_key(|&(x, y)| y.0);\n   |                       \
    \           ^\n\nerror: aborting due to 6 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308, E0610.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows = lst.len();\n    let mut cols = lst[0].len();\n    let mut coords = vec![];\n\
    \    let mut row_coords = vec![];\n    let mut col_coords = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sort_idx\
    \ = 0;\n    let mut col_sort_idx = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    while i < rows {\n        row_coords.clear();\n        col_coords.clear();\n\
    \        row_sorted.clear();\n        col_sorted.clear();\n        row_sort_idx\
    \ = 0;\n        col_sort_idx = 0;\n        while j < cols {\n            if lst[i][j]\
    \ == x {\n                row_coords.push((i, j));\n                col_coords.push((j,\
    \ j));\n                row_sorted.push((i, j));\n                col_sorted.push((j,\
    \ j));\n                row_sort_idx += 1;\n                col_sort_idx += 1;\n\
    \            }\n            j += 1\n        }\n        i += 1;\n        j = 0;\n\
    \        while row_sort_idx > 0 {\n            row_coords.swap(row_coords.len()\
    \ - row_sort_idx, row_coords.len() - 1);\n            row_sorted.swap(row_sorted.len()\
    \ - row_sort_idx, row_sorted.len() - 1);\n            row_sort_idx -= 1;\n   \
    \     }\n        j = 0;\n        while col_sort_idx > 0 {\n            col_coords.swap(col_coords.len()\
    \ - col_sort_idx, col_coords.len() - 1);\n            col_sorted.swap(col_sorted.len()\
    \ - col_sort_idx, col_sorted.len() - 1);\n            col_sort_idx -= 1;\n   \
    \     }\n        coords.push(row_coords);\n        coords.push(col_coords);\n\
    \    }\n    coords\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp94e0pjra.rs:62:5\n   |\n\
    16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \                                               ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n62 |     coords\n   |     ^^^^^^ expected\
    \ tuple, found struct `Vec`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \              found struct `Vec<Vec<(usize, usize)>>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows: Vec<(isize, isize)> = vec![];\n    let mut row_idx: usize = 0;\n    let\
    \ mut col_idx: usize = 0;\n    for row in lst {\n        if row_idx == x {\n \
    \           rows.push((row_idx, col_idx));\n            row_idx = 0;\n       \
    \     col_idx = 0;\n        }\n        for col in row {\n            col_idx +=\
    \ 1;\n        }\n        row_idx += 1;\n    }\n    rows.sort_by(|a, b| a.1.cmp(&b.1));\n\
    \    rows.sort_by(|a, b| b.1.cmp(&a.1));\n    rows\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiu9gmgdb.rs:21:23\n   |\n\
    21 |         if row_idx == x {\n   |                       ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n21 |         if row_idx == x.try_into().unwrap()\
    \ {\n   |                       ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpiu9gmgdb.rs:22:24\n   |\n22 |             rows.push((row_idx,\
    \ col_idx));\n   |                        ^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n22 |             rows.push((row_idx.try_into().unwrap(),\
    \ col_idx));\n   |                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpiu9gmgdb.rs:22:33\n   |\n22 |             rows.push((row_idx,\
    \ col_idx));\n   |                                 ^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n22 |             rows.push((row_idx, col_idx.try_into().unwrap()));\n\
    \   |                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n\
    \    let mut row_idx = 0;\n    let mut col_idx = 0;\n    while row_idx < rows\
    \ {\n        let mut row_sorted = vec![];\n        let mut col_sorted = vec![];\n\
    \        let mut row_idx = row_idx;\n        let mut col_idx = col_idx;\n    \
    \    while col_idx < cols {\n            if row_idx < rows && col_idx < cols {\n\
    \                if lst[row_idx][col_idx] == x {\n                    row_sorted.push((row_idx,\
    \ col_idx));\n                    col_sorted.push((row_idx, col_idx));\n     \
    \           }\n                col_idx += 1;\n            } else {\n         \
    \       break;\n            }\n        }\n        result.push(row_sorted);\n \
    \       col_idx = col_idx;\n        row_idx += 1;\n    }\n    result.sort_by_key(|x|\
    \ x.0);\n    result.sort_by_key(|x| x.1, |a, b| b.1.cmp(&a.1));\n    result\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `0` on type `&Vec<(usize, usize)>`\n  --> /tmp/tmpdvhqjwks.rs:42:30\n\
    \   |\n42 |     result.sort_by_key(|x| x.0);\n   |                           \
    \   ^ unknown field\n\nerror[E0061]: this function takes 1 argument but 2 arguments\
    \ were supplied\n   --> /tmp/tmpdvhqjwks.rs:43:12\n    |\n43  |     result.sort_by_key(|x|\
    \ x.1, |a, b| b.1.cmp(&a.1));\n    |            ^^^^^^^^^^^ -------  --------------------\
    \ supplied 2 arguments\n    |            |\n    |            expected 1 argument\n\
    \    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpdvhqjwks.rs:44:5\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x:\
    \ isize) -> Vec<(isize, isize)> {\n   |                                      \
    \         ------------------- expected `Vec<(isize, isize)>` because of return\
    \ type\n...\n44 |     result\n   |     ^^^^^^ expected tuple, found struct `Vec`\n\
    \   |\n   = note: expected struct `Vec<(isize, isize)>`\n              found struct\
    \ `Vec<Vec<(usize, usize)>>`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0061, E0308, E0609.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_sorted_idx = vec![];\n    let mut col_sorted_idx = vec![];\n    let mut\
    \ row_sorted_idx = vec![];\n    let mut col_sorted_idx = vec![];\n    let mut\
    \ row_sorted_idx = vec![];\n    let mut col_sorted_idx = vec![];\n    let mut\
    \ row_sorted_idx = vec![];\n    let mut col_sorted_idx = vec![];\n    let mut\
    \ row_sorted_idx = vec![];\n    let mut col_sorted_idx = vec![];\n    let mut\
    \ row_sorted_idx = vec![];\n    let mut col_sorted_idx = vec![];\n    let mut\
    \ row_sorted_idx = vec![];\n    let mut col_sorted_idx = vec![];\n    let mut\
    \ row_sorted_idx = vec![];\n    let mut col_sorted_idx = vec![];\n    let mut\
    \ row_sorted_idx = vec![];\n    let mut col_sorted_idx = vec![];\n    let mut\
    \ row_sorted_idx = vec![];\n    let mut col_sorted_idx = vec![];\n    let mut\
    \ row_sorted_idx = vec![];\n    let mut col_sorted_idx = vec![];\n    let mut\
    \ row_sorted_idx = vec![];\n    let mut col_sorted_idx = vec![];\n    let mut\
    \ row_sorted_idx = vec![];\n    let mut col_sorted_idx = vec![];\n    let mut\
    \ row_sorted_idx = vec![];\n    let mut col_sorted_idx = vec![];\n    let mut\
    \ row_sorted_idx = vec![];\n    let mut col_sorted_idx = vec![];\n    let mut\
    \ row_sorted_idx = vec![];\n    let mut col_sorted_idx = vec![];\n    let mut\
    \ row_sorted_idx = vec![];\n    let mut col_sorted_idx = vec![];\n    let mut\
    \ row_sorted_idx = vec![];\n    let mut col_sorted_idx = vec![];\n    let mut\
    \ row_sorted_idx = vec![];\n    let mut col_sorted_idx = vec![];\n    let mut\
    \ row_sorted_idx = vec![];\n    let mut col_sorted_idx = vec![];\n    let mut\
    \ row_sorted_idx = vec![];\n    let mut col_sorted_idx = vec![];\n    let mut\
    \ row_sorted_idx = vec![];\n    let mut col_sorted_idx = vec![];\n    let mut\
    \ row_sorted_idx = vec![];\n    let mut col_sorted_idx = vec![];\n    let mut\
    \ row_sorted_idx = \n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmplz0vmxob.rs:69:1\n\
    \   |\n69 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut\
    \ col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n  \
    \  let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut\
    \ col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n  \
    \  let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut\
    \ col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n  \
    \  let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut\
    \ col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n  \
    \  let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let \n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpzfv6u_ru.rs:72:1\n  \
    \ |\n72 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res = vec![];\n    for row in lst {\n        let mut res = vec![];\n       \
    \ for col in row.iter().rev() {\n            if col == x {\n                res.push((col,\
    \ row.len()));\n            }\n        }\n        res.sort_by_key(|&(_, len)|\
    \ len.cmp(&x.cmp(&0)).unwrap());\n        res.sort_by_key(|&(_, len)| -len.cmp(&x.cmp(&0)).unwrap());\n\
    \        res.reverse();\n        res.push(vec![]);\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp2cg1l4qh.rs:21:20\n\
    \   |\n21 |             if col == x {\n   |                    ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2cg1l4qh.rs:25:45\n\
    \   |\n25 |         res.sort_by_key(|&(_, len)| len.cmp(&x.cmp(&0)).unwrap());\n\
    \   |                                             ^^^^^^^^^^ expected `usize`,\
    \ found enum `std::cmp::Ordering`\n   |\n   = note: expected reference `&usize`\n\
    \              found reference `&std::cmp::Ordering`\n\nerror[E0599]: no method\
    \ named `unwrap` found for enum `std::cmp::Ordering` in the current scope\n  -->\
    \ /tmp/tmp2cg1l4qh.rs:25:57\n   |\n25 |         res.sort_by_key(|&(_, len)| len.cmp(&x.cmp(&0)).unwrap());\n\
    \   |                                                         ^^^^^^ method not\
    \ found in `std::cmp::Ordering`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2cg1l4qh.rs:26:46\n\
    \   |\n26 |         res.sort_by_key(|&(_, len)| -len.cmp(&x.cmp(&0)).unwrap());\n\
    \   |                                              ^^^^^^^^^^ expected `usize`,\
    \ found enum `std::cmp::Ordering`\n   |\n   = note: expected reference `&usize`\n\
    \              found reference `&std::cmp::Ordering`\n\nerror[E0599]: no method\
    \ named `unwrap` found for enum `std::cmp::Ordering` in the current scope\n  -->\
    \ /tmp/tmp2cg1l4qh.rs:26:58\n   |\n26 |         res.sort_by_key(|&(_, len)| -len.cmp(&x.cmp(&0)).unwrap());\n\
    \   |                                                          ^^^^^^ method not\
    \ found in `std::cmp::Ordering`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2cg1l4qh.rs:28:18\n\
    \   |\n28 |         res.push(vec![]);\n   |                  ^^^^^^ expected tuple,\
    \ found struct `Vec`\n   |\n   = note: expected tuple `(&isize, usize)`\n    \
    \         found struct `Vec<_>`\n   = note: this error originates in the macro\
    \ `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror:\
    \ aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    for row in lst {\n        let mut row_result = vec![];\n\
    \        for el in row {\n            if el == x {\n                row_result.push((row,\
    \ el));\n            }\n        }\n        result.push(row_result);\n    }\n \
    \   result.sort_by(|a, b| a.iter().cmp(&b.iter()).reverse());\n    result.sort_by(|a,\
    \ b| b.iter().cmp(&a.iter()).reverse());\n    result\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&std::slice::Iter<'_, (Vec<isize>, isize)>` is not an iterator\n\
    \  --> /tmp/tmptpaoj5rh.rs:27:40\n   |\n27 |     result.sort_by(|a, b| a.iter().cmp(&b.iter()).reverse());\n\
    \   |                                        ^^^^^^^^^ `&std::slice::Iter<'_,\
    \ (Vec<isize>, isize)>` is not an iterator\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `&std::slice::Iter<'_, (Vec<isize>, isize)>`\n   = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `&std::slice::Iter<'_,\
    \ (Vec<isize>, isize)>`\nhelp: consider removing the leading `&`-reference\n \
    \  |\n27 -     result.sort_by(|a, b| a.iter().cmp(&b.iter()).reverse());\n27 +\
    \     result.sort_by(|a, b| a.iter().cmp(b.iter()).reverse());\n   | \nhelp: consider\
    \ changing this borrow's mutability\n   |\n27 |     result.sort_by(|a, b| a.iter().cmp(&mut\
    \ b.iter()).reverse());\n   |                                        ~~~~\n\n\
    error[E0277]: `&std::slice::Iter<'_, (Vec<isize>, isize)>` is not an iterator\n\
    \  --> /tmp/tmptpaoj5rh.rs:28:40\n   |\n28 |     result.sort_by(|a, b| b.iter().cmp(&a.iter()).reverse());\n\
    \   |                                        ^^^^^^^^^ `&std::slice::Iter<'_,\
    \ (Vec<isize>, isize)>` is not an iterator\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `&std::slice::Iter<'_, (Vec<isize>, isize)>`\n   = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `&std::slice::Iter<'_,\
    \ (Vec<isize>, isize)>`\nhelp: consider removing the leading `&`-reference\n \
    \  |\n28 -     result.sort_by(|a, b| b.iter().cmp(&a.iter()).reverse());\n28 +\
    \     result.sort_by(|a, b| b.iter().cmp(a.iter()).reverse());\n   | \nhelp: consider\
    \ changing this borrow's mutability\n   |\n28 |     result.sort_by(|a, b| b.iter().cmp(&mut\
    \ a.iter()).reverse());\n   |                                        ~~~~\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmptpaoj5rh.rs:29:5\n   |\n16 | fn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |     \
    \                                          ------------------- expected `Vec<(isize,\
    \ isize)>` beca"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows: Vec<(isize, isize)> = vec![];\n    let mut row_idx: usize = 0;\n    let\
    \ mut col_idx: usize = 0;\n    let mut row_len: usize = 0;\n    let mut col_len:\
    \ usize = 0;\n    for row in lst {\n        row_len += row.len();\n        if\
    \ row_len > x {\n            break;\n        }\n        row_idx += 1;\n      \
    \  row_len = x;\n        col_idx = 0;\n        for col in row {\n            col_len\
    \ += 1;\n            if col_len > x {\n                break;\n            }\n\
    \            col_idx += 1;\n            col_len = x;\n            rows.push((row_idx,\
    \ col_idx));\n        }\n    }\n    rows\n        .into_iter()\n        .sort_by(|a,\
    \ b| a.1.cmp(&b.1))\n        .sort_by(|a, b| b.0.cmp(&a.0))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyel2ksvs.rs:24:22\n   |\n\
    24 |         if row_len > x {\n   |                      ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n24 |         if row_len > x.try_into().unwrap()\
    \ {\n   |                      ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpyel2ksvs.rs:28:19\n   |\n28 |         row_len = x;\n  \
    \ |                   ^ expected `usize`, found `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpyel2ksvs.rs:32:26\n   |\n32 |             if col_len >\
    \ x {\n   |                          ^ expected `usize`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `usize` and panic if the converted value\
    \ doesn't fit\n   |\n32 |             if col_len > x.try_into().unwrap() {\n \
    \  |                          ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpyel2ksvs.rs:36:23\n   |\n36 |             col_len = x;\n\
    \   |                       ^ expected `usize`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyel2ksvs.rs:37:24\n   |\n37 |             rows.push((row_idx,\
    \ col_idx));\n   |                        ^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n37 |             rows.push((row_idx.try_into().unwrap(),\
    \ col_idx));\n   |                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyel2ksvs.rs:37:33\n   |\n37 |             rows.push((row_idx,\
    \ col_idx));\n   |                                 ^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n37 |             rows.push((row_idx, col_idx.try_into().unwrap()));\n\
    \   |                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]:\
    \ no method named `sort_by` found for struct `std::vec::IntoIter` in the current\
    \ scope\n  --> /tmp/tmpyel2ksvs.rs:42:10\n   |\n42 |         .sort_by(|a, b| a"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n\
    \    let mut row_idx = 1;\n    let mut col_idx = 1;\n    let mut row_max = rows;\n\
    \    let mut col_max = cols;\n    let mut row_min = rows;\n    let mut col_min\
    \ = cols;\n    while row_idx < rows && col_idx < cols {\n        if row_idx <\
    \ row_max && col_idx < col_max {\n            if lst[row_idx][col_idx] == x {\n\
    \                result.push((row_idx, col_idx));\n                row_idx +=\
    \ 1;\n                col_idx += 1;\n            }\n            row_idx += 1;\n\
    \            col_idx += 1;\n        } else if row_idx < row_max {\n          \
    \  row_max -= 1;\n            row_idx += 1;\n            row_min = rows;\n   \
    \         col_max = cols;\n            col_min = cols;\n            col_idx =\
    \ 1;\n        } else if col_idx < col_max {\n            col_max -= 1;\n     \
    \       col_idx += 1;\n            row_idx = 1;\n            col_min = cols;\n\
    \            row_max = rows;\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdgm7vwr9.rs:50:5\n   |\n\
    16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \                                               ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n50 |     result\n   |     ^^^^^^ expected\
    \ `isize`, found `usize`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \              found struct `Vec<(usize, usize)>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut row_idx = 1;\n    let mut col_idx = 1;\n    let\
    \ mut row_len = lst.len();\n    let mut col_len = lst[0].len();\n    while row_idx\
    \ < row_len {\n        let mut row_coord = vec![];\n        while col_idx < col_len\
    \ {\n            if lst[row_idx][col_idx] == x {\n                row_coord.push((row_idx,\
    \ col_idx));\n                break;\n            }\n            col_idx += 1;\n\
    \        }\n        result.push(row_coord);\n        row_idx += 1;\n        col_idx\
    \ = 1;\n        col_len = lst[0].len();\n    }\n    result.sort_by_key(|&(_, y)|\
    \ y.cmp(&x));\n    result.sort_by_key(|&(_, y)| y.cmp(&x));\n    result\n}\n\n\
    fn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwk5l3pzm.rs:36:26\n   |\n\
    36 |     result.sort_by_key(|&(_, y)| y.cmp(&x));\n   |                      \
    \    ^^^^^-\n   |                          |    |\n   |                      \
    \    |    expected due to this\n   |                          expected struct\
    \ `Vec`, found tuple\n   |\n   = note: expected struct `Vec<(usize, usize)>`\n\
    \               found tuple `(_, _)`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpwk5l3pzm.rs:37:26\n   |\n37 |     result.sort_by_key(|&(_, y)| y.cmp(&x));\n\
    \   |                          ^^^^^-\n   |                          |    |\n\
    \   |                          |    expected due to this\n   |               \
    \           expected struct `Vec`, found tuple\n   |\n   = note: expected struct\
    \ `Vec<(usize, usize)>`\n               found tuple `(_, _)`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwk5l3pzm.rs:38:5\n   |\n16 | fn get_row(lst:\
    \ Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |                  \
    \                             ------------------- expected `Vec<(isize, isize)>`\
    \ because of return type\n...\n38 |     result\n   |     ^^^^^^ expected tuple,\
    \ found struct `Vec`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \              found struct `Vec<Vec<(usize, usize)>>`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idxs = vec![];\n    let mut col_idxs = vec![];\n    let mut row_idxs_sorted\
    \ = vec![];\n    let mut col_idxs_sorted = vec![];\n    let mut row_idxs_sorted\
    \ = vec![];\n    let mut col_idxs_sorted = vec![];\n    let mut row_idxs_sorted\
    \ = vec![];\n    let mut col_idxs_sorted = vec![];\n    let mut row_idxs_sorted\
    \ = vec![];\n    let mut col_idxs_sorted = vec![];\n    let mut row_idxs_sorted\
    \ = vec![];\n    let mut col_idxs_sorted = vec![];\n    let mut row_idxs_sorted\
    \ = vec![];\n    let mut col_idxs_sorted = vec![];\n    let mut row_idxs_sorted\
    \ = vec![];\n    let mut col_idxs_sorted = vec![];\n    let mut row_idxs_sorted\
    \ = vec![];\n    let mut col_idxs_sorted = vec![];\n    let mut row_idxs_sorted\
    \ = vec![];\n    let mut col_idxs_sorted = vec![];\n    let mut row_idxs_sorted\
    \ = vec![];\n    let mut col_idxs_sorted = vec![];\n    let mut row_idxs_sorted\
    \ = vec![];\n    let mut col_idxs_sorted = vec![];\n    let mut row_idxs_sorted\
    \ = vec![];\n    let mut col_idxs_sorted = vec![];\n    let mut row_idxs_sorted\
    \ = vec![];\n    let mut col_idxs_sorted = vec![];\n    let mut row_idxs_sorted\
    \ = vec![];\n    let mut col_idxs_sorted = vec![];\n    let mut row_idxs_sorted\
    \ = vec![];\n    let mut col_idxs_sorted = vec![];\n    let mut row_idxs_sorted\
    \ = vec![];\n    let mut col_idxs_sorted = vec![];\n    let mut row_idxs_sorted\
    \ = vec![];\n    let mut col_idxs_sorted = vec![];\n    let mut row_idxs_sorted\
    \ = vec![];\n    let mut col_idxs_sorted = vec![];\n    let mut row_idxs_sorted\
    \ = vec![];\n    let mu\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_vzsk0ul.rs:61:11\n   |\n\
    61 |     let mu\n   |           ^ help: add `;` here\n62 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_vzsk0ul.rs:16:47\n \
    \  |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n\
    \   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749648
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    let mut row_len = lst.len();\n    let mut col_len = lst[0].len();\n\
    \    let mut row_idxs = vec![];\n    let mut col_idxs = vec![];\n    while row_idx\
    \ < row_len {\n        let mut row_idxs_new = vec![];\n        let mut col_idxs_new\
    \ = vec![];\n        while col_idx < col_len {\n            if row_idx == row_idx\
    \ {\n                row_idxs_new.push(row_idx);\n                col_idxs_new.push(col_idx);\n\
    \            }\n            if col_idx < col_len {\n                if row_idx\
    \ == row_idx {\n                    row_idxs_new.push(row_idx);\n            \
    \        col_idxs_new.push(col_idx + 1);\n                }\n                if\
    \ row_idx < row_len {\n                    if row_idx == row_idx {\n         \
    \               row_idxs_new.push(row_idx + 1);\n                        col_idxs_new.push(col_idx);\n\
    \                    }\n                    if row_idx < row_len {\n         \
    \               if row_idx == row_idx {\n                            row_idxs_new.push(row_idx\
    \ + 1);\n                            col_idxs_new.push(col_idx + 1);\n       \
    \                 }\n                        if row_idx < row_len {\n        \
    \                    if row_idx == row_idx {\n                               \
    \ row_idxs_new.push(row_idx + 1);\n                                col_idxs_new.push(col_idx\
    \ + 2);\n                            }\n                            if row_idx\
    \ < row_len {\n                                if row_idx == row_idx {\n     \
    \                               row_idxs_new.push(row_idx + 1);\n            \
    \                        col_idxs_new.push(col_idx + 3);\n                   \
    \             }\n                                if row_idx < row_len {\n    \
    \                                if row_idx == row_idx {\n                   \
    \                     row_idxs_new.push(row_idx + 1);\n                      \
    \                  col_idxs_new.push(col_idx + 4);\n                         \
    \           }\n                                    if row_idx < row_len {\n  \
    \                                      if row_idx == row_idx {\n             \
    \                               row_idxs_new.push(row_idx + 1);\n            \
    \                                col_idxs_new.push(col_idx + 5);\n           \
    \                             }\n                                        if row_idx\
    \ < row_len {\n                                            if row_idx == row_idx\
    \ {\n                                                row_idxs_new.push(row_idx\
    \ + 1);\n                                                col_idxs_new.push(col_idx\
    \ + 6);\n                                            }\n                     \
    \                       if row_idx < row_len {\n                             \
    \                   if row_idx == row_idx {\n                                \
    \                    row_idxs_new.push(row_idx + 1);\n                       \
    \                             col_idxs_new.push(col_idx + 7);\n              \
    \                                  }\n                                       \
    \         if row_idx < row_len {\n                                           \
    \         if \n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp7_pyejlt.rs:89:3\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                                                   -\
    \ unclosed delimiter\n...\n24 |     while row_idx < row_len {\n   |          \
    \                   - unclosed delimiter\n...\n27 |         while col_idx < col_len\
    \ {\n   |                                 - unclosed delimiter\n...\n32 |    \
    \         if col_idx < col_len {\n   |                                  - unclosed\
    \ delimiter\n...\n37 |                 if row_idx < row_len {\n   |          \
    \                            - unclosed delimiter\n...\n42 |                 \
    \    if row_idx < row_len {\n   |                                          - unclosed\
    \ delimiter\n...\n47 |                         if row_idx < row_len {\n   |  \
    \                                            - unclosed delimiter\n...\n52 | \
    \                            if row_idx < row_len {\n   |                    \
    \                              - unclosed delimiter\n...\n57 |               \
    \                  if row_idx < row_len {\n   |                              \
    \                        - unclosed delimiter\n...\n62 |                     \
    \                if row_idx < row_len {\n   |                                \
    \                          - unclosed delimiter\n...\n67 |                   \
    \                      if row_idx < row_len {\n   |                          \
    \                                    - unclosed delimiter\n...\n72 |         \
    \                                    if row_idx < row_len {\n   |            \
    \                                                      - unclosed delimiter\n\
    ...\n77 |                                                 if row_idx < row_len\
    \ {\n   |                                                                    \
    \  - this delimiter might not be properly closed...\n78 |                    \
    \                                 if \n79 | }\n   | - ...as it matches this but\
    \ it has different indentation\n...\n89 | }\n   |   ^\n\nerror: expected expression,\
    \ found `}"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut row_idx_max\
    \ = 0;\n    let mut row_idx_min = std::cmp::min::<isize>(lst.len(), x);\n    let\
    \ mut col_max = 0;\n    let mut col_min = 0;\n    let mut col_max_idx = 0;\n \
    \   let mut col_min_idx = 0;\n    let mut col_max_idx2 = 0;\n    let mut col_min_idx2\
    \ = 0;\n    let mut col_max_idx3 = 0;\n    let mut col_min_idx3 = 0;\n    let\
    \ mut col_max_idx4 = 0;\n    let mut col_min_idx4 = 0;\n    let mut col_max_idx5\
    \ = 0;\n    let mut col_min_idx5 = 0;\n    let mut col_max_idx6 = 0;\n    let\
    \ mut col_min_idx6 = 0;\n    let mut col_max_idx7 = 0;\n    let mut col_min_idx7\
    \ = 0;\n    let mut col_max_idx8 = 0;\n    let mut col_min_idx8 = 0;\n    let\
    \ mut col_max_idx9 = 0;\n    let mut col_min_idx9 = 0;\n    let mut col_max_idx10\
    \ = 0;\n    let mut col_min_idx10 = 0;\n    let mut col_max_idx11 = 0;\n    let\
    \ mut col_min_idx11 = 0;\n    let mut col_max_idx12 = 0;\n    let mut col_min_idx12\
    \ = 0;\n    let mut col_max_idx13 = 0;\n    let mut col_min_idx13 = 0;\n    let\
    \ mut col_max_idx14 = 0;\n    let mut col_min_idx14 = 0;\n    let mut col_max_idx15\
    \ = 0;\n    let mut col_min_idx15 = 0;\n    let mut col_max_idx16 = 0;\n    let\
    \ mut col_min_idx16 = 0;\n    let mut col_max_idx17 = 0;\n    let mut col_min_idx17\
    \ = 0;\n    let mut col_max_idx18 = 0;\n    let mut col_min_idx18 = 0;\n    let\
    \ mut col_max_idx19 = 0;\n    let mut col_min_idx19 = 0;\n    let mut col_max_idx20\
    \ = 0;\n    let mut col_min_idx20 = 0;\n    let mut col_max_idx21 = 0;\n    let\
    \ mut col_min_idx21 = 0;\n    let mut col_max_idx22 = 0;\n    let mut col_min_idx22\
    \ = 0;\n    let mut col_max_idx23 = 0;\n    let mut col_min_idx23 = 0;\n    let\
    \ mut col_max_idx24 = 0;\n    let mut col_min_idx24 = 0;\n    let mut col_max_idx25\
    \ = 0;\n    let mut col_min_idx25 = 0;\n    let mut col_max_\n}\n\nfn main() {\n\
    \    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpadss3jru.rs:73:21\n   |\n\
    73 |     let mut col_max_\n   |                     ^ help: add `;` here\n74 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpadss3jru.rs:20:50\n\
    \   |\n20 |     let mut row_idx_min = std::cmp::min::<isize>(lst.len(), x);\n\
    \   |                                                  ^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n20 |     let mut row_idx_min = std::cmp::min::<isize>(lst.len().try_into().unwrap(),\
    \ x);\n   |                                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpadss3jru.rs:16:47\n   |\n16 |\
    \ fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |  \
    \  -------                                    ^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749649
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    for row in lst {\n        let mut row_result = vec![];\n\
    \        for col in row.iter().rev() {\n            if col == x {\n          \
    \      row_result.push((row, col));\n            }\n        }\n        result.push(row_result);\n\
    \    }\n    result.sort_by(|a, b| a.0.cmp(&b.0));\n    result.sort_by(|a, b| b.1.cmp(&a.1));\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp7d381xs7.rs:21:20\n\
    \   |\n21 |             if col == x {\n   |                    ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n\nerror[E0609]: no field `0` on type `&Vec<(Vec<isize>,\
    \ &isize)>`\n  --> /tmp/tmp7d381xs7.rs:27:29\n   |\n27 |     result.sort_by(|a,\
    \ b| a.0.cmp(&b.0));\n   |                             ^ unknown field\n\nerror[E0609]:\
    \ no field `0` on type `&Vec<(Vec<isize>, &isize)>`\n  --> /tmp/tmp7d381xs7.rs:27:38\n\
    \   |\n27 |     result.sort_by(|a, b| a.0.cmp(&b.0));\n   |                  \
    \                    ^ unknown field\n\nerror[E0609]: no field `1` on type `&Vec<(Vec<isize>,\
    \ &isize)>`\n  --> /tmp/tmp7d381xs7.rs:28:29\n   |\n28 |     result.sort_by(|a,\
    \ b| b.1.cmp(&a.1));\n   |                             ^ unknown field\n\nerror[E0609]:\
    \ no field `1` on type `&Vec<(Vec<isize>, &isize)>`\n  --> /tmp/tmp7d381xs7.rs:28:38\n\
    \   |\n28 |     result.sort_by(|a, b| b.1.cmp(&a.1));\n   |                  \
    \                    ^ unknown field\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp7d381xs7.rs:29:5\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize)\
    \ -> Vec<(isize, isize)> {\n   |                                             \
    \  ------------------- expected `Vec<(isize, isize)>` because of return type\n\
    ...\n29 |     result\n   |     ^^^^^^ expected tuple, found struct `Vec`\n   |\n\
    \   = note: expected struct `Vec<(isize, isize)>`\n              found struct\
    \ `Vec<Vec<(Vec<isize>, &isize)>>`\n\nerror: aborting due to 6 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0609.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    let mut row_len = 0;\n    let mut col_len = 0;\n    let mut row_start\
    \ = 0;\n    let mut col_start = 0;\n    let mut row_end = 0;\n    let mut col_end\
    \ = 0;\n    for row in lst {\n        row_len = row.len();\n        col_len =\
    \ row.iter().map(|x| x.len()).sum();\n        row_end = row_start + row_len;\n\
    \        col_end = col_start + col_len;\n        if row_idx < x {\n          \
    \  row_start = row_idx;\n        }\n        if col_idx < x {\n            col_start\
    \ = col_idx;\n        }\n        if row_idx >= x {\n            break;\n     \
    \   }\n        if col_idx >= x {\n            break;\n        }\n        if row_idx\
    \ < x && col_idx < x {\n            row.swap(row_idx, col_idx);\n            row_idx\
    \ += 1;\n            col_idx += 1;\n        }\n    }\n    row.sort_by_key(|&(x,\
    \ y)| x.cmp(&y));\n    row.sort_by_key(|&(x, y)| y.cmp(&x));\n    row\n}\n\nfn\
    \ main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for reference `&isize` in the\
    \ current scope\n  --> /tmp/tmpow20wmc7.rs:28:40\n   |\n28 |         col_len =\
    \ row.iter().map(|x| x.len()).sum();\n   |                                   \
    \     ^^^ method not found in `&isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpow20wmc7.rs:32:25\n   |\n32 |             row_start = row_idx;\n   |\
    \                         ^^^^^^^ expected `usize`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpow20wmc7.rs:44:22\n   |\n44 |             row.swap(row_idx,\
    \ col_idx);\n   |                      ^^^^^^^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n44 |             row.swap(row_idx.try_into().unwrap(),\
    \ col_idx);\n   |                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpow20wmc7.rs:44:31\n   |\n44 |             row.swap(row_idx,\
    \ col_idx);\n   |                               ^^^^^^^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n44 |             row.swap(row_idx, col_idx.try_into().unwrap());\n\
    \   |                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n\
    \    let mut row_idx = 0;\n    let mut col_idx = 0;\n    while row_idx < rows\
    \ {\n        let mut row_result = vec![];\n        while col_idx < cols {\n  \
    \          if row_idx == row_idx {\n                row_result.push((row_idx,\
    \ col_idx));\n            }\n            if col_idx < cols {\n               \
    \ if row_idx < rows && col_idx < cols && lst[row_idx][col_idx] == x {\n      \
    \              col_idx++;\n                }\n            }\n            if col_idx\
    \ >= cols {\n                col_idx = 0;\n                row_idx++;\n      \
    \      }\n        }\n        result.push(row_result);\n    }\n    result.sort_by(|a,\
    \ b| a.iter().cmp(b.iter()).reverse());\n    result.sort_by(|a, b| b.iter().cmp(a.iter()).reverse());\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `+`\n  --> /tmp/tmpht3i_g62.rs:30:29\n\
    \   |\n30 |                     col_idx++;\n   |                             ^\
    \ expected expression\n\nerror: expected expression, found `+`\n  --> /tmp/tmpht3i_g62.rs:35:25\n\
    \   |\n35 |                 row_idx++;\n   |                         ^ expected\
    \ expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpht3i_g62.rs:42:5\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n42 |     result\n   |   \
    \  ^^^^^^ expected tuple, found struct `Vec`\n   |\n   = note: expected struct\
    \ `Vec<(isize, isize)>`\n              found struct `Vec<Vec<(usize, usize)>>`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n\
    \    let mut row_idx = 0;\n    let mut col_idx = 0;\n    while row_idx < rows\
    \ {\n        let mut row_sorted = vec![];\n        let mut col_sorted = vec![];\n\
    \        let mut row_idx2 = 0;\n        let mut col_idx2 = 0;\n        while col_idx\
    \ < cols {\n            if row_idx2 == row_idx {\n                row_sorted.push((row_idx,\
    \ col_idx));\n                col_idx2 += 1;\n                if col_idx2 == cols\
    \ {\n                    row_idx2 += 1;\n                    col_idx2 = 0;\n \
    \               }\n            } else {\n                col_sorted.push((row_idx2,\
    \ col_idx2));\n                row_idx2 += 1;\n                if row_idx2 ==\
    \ rows {\n                    row_idx2 += 1;\n                    col_idx2 = 0;\n\
    \                }\n            }\n            col_idx += 1;\n        }\n    \
    \    result.push(row_sorted);\n    }\n    result.sort_by_key(|x| x.0);\n    result.sort_by_key(|x|\
    \ x.1, |a, b| b.0 - a.0);\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `0` on type `&Vec<(usize, usize)>`\n  --> /tmp/tmp0klforu3.rs:47:30\n\
    \   |\n47 |     result.sort_by_key(|x| x.0);\n   |                           \
    \   ^ unknown field\n\nerror[E0061]: this function takes 1 argument but 2 arguments\
    \ were supplied\n   --> /tmp/tmp0klforu3.rs:48:12\n    |\n48  |     result.sort_by_key(|x|\
    \ x.1, |a, b| b.0 - a.0);\n    |            ^^^^^^^^^^^ -------  ----------------\
    \ supplied 2 arguments\n    |            |\n    |            expected 1 argument\n\
    \    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0klforu3.rs:49:5\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x:\
    \ isize) -> Vec<(isize, isize)> {\n   |                                      \
    \         ------------------- expected `Vec<(isize, isize)>` because of return\
    \ type\n...\n49 |     result\n   |     ^^^^^^ expected tuple, found struct `Vec`\n\
    \   |\n   = note: expected struct `Vec<(isize, isize)>`\n              found struct\
    \ `Vec<Vec<(usize, usize)>>`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0061, E0308, E0609.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    for row in lst {\n        if row_idx == x {\n            rows.push((row_idx,\
    \ col_idx));\n        }\n        for col in row {\n            col_idx = (col_idx\
    \ + 1) % row.len();\n            row_idx = (row_idx + 1) % row.len();\n      \
    \      rows.push((row_idx, col_idx));\n        }\n    }\n    rows.sort_by_key(|&(x,\
    \ y)| x.0);\n    rows.sort_by_key(|&(x, y)| y.0);\n    rows\n}\n\nfn main() {\n\
    \    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6bd_e7y7.rs:25:39\n   |\n\
    25 |             col_idx = (col_idx + 1) % row.len();\n   |                  \
    \                     ^^^^^^^^^ expected `isize`, found `usize`\n\nerror[E0277]:\
    \ cannot mod `isize` by `usize`\n  --> /tmp/tmp6bd_e7y7.rs:25:37\n   |\n25 | \
    \            col_idx = (col_idx + 1) % row.len();\n   |                      \
    \               ^ no implementation for `isize % usize`\n   |\n   = help: the\
    \ trait `Rem<usize>` is not implemented for `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp6bd_e7y7.rs:26:39\n   |\n26 |             row_idx = (row_idx\
    \ + 1) % row.len();\n   |                                       ^^^^^^^^^ expected\
    \ `isize`, found `usize`\n\nerror[E0277]: cannot mod `isize` by `usize`\n  -->\
    \ /tmp/tmp6bd_e7y7.rs:26:37\n   |\n26 |             row_idx = (row_idx + 1) %\
    \ row.len();\n   |                                     ^ no implementation for\
    \ `isize % usize`\n   |\n   = help: the trait `Rem<usize>` is not implemented\
    \ for `isize`\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't\
    \ have fields\n  --> /tmp/tmp6bd_e7y7.rs:30:34\n   |\n30 |     rows.sort_by_key(|&(x,\
    \ y)| x.0);\n   |                                  ^\n\nerror[E0610]: `isize`\
    \ is a primitive type and therefore doesn't have fields\n  --> /tmp/tmp6bd_e7y7.rs:31:34\n\
    \   |\n31 |     rows.sort_by_key(|&(x, y)| y.0);\n   |                       \
    \           ^\n\nerror: aborting due to 6 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308, E0610.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut row_idx_max\
    \ = 0;\n    let mut row_idx_min = 0;\n    let mut col_max = 0;\n    let mut col_min\
    \ = 0;\n    let mut col_max_idx = 0;\n    let mut col_min_idx = 0;\n    let mut\
    \ col_max_idx2 = 0;\n    let mut col_min_idx2 = 0;\n    let mut row_max = 0;\n\
    \    let mut row_min = 0;\n    let mut row_max_idx = 0;\n    let mut row_min_idx\
    \ = 0;\n    let mut col_max2 = 0;\n    let mut col_min2 = 0;\n    let mut col_max_idx2\
    \ = 0;\n    let mut col_min_idx2 = 0;\n    let mut row_max2 = 0;\n    let mut\
    \ row_min2 = 0;\n    let mut row_max_idx2 = 0;\n    let mut row_min_idx2 = 0;\n\
    \    let mut col_max3 = 0;\n    let mut col_min3 = 0;\n    let mut col_max_idx3\
    \ = 0;\n    let mut col_min_idx3 = 0;\n    let mut row_max3 = 0;\n    let mut\
    \ row_min3 = 0;\n    let mut row_max_idx3 = 0;\n    let mut row_min_idx3 = 0;\n\
    \    let mut col_max4 = 0;\n    let mut col_min4 = 0;\n    let mut col_max_idx4\
    \ = 0;\n    let mut col_min_idx4 = 0;\n    let mut row_max4 = 0;\n    let mut\
    \ row_min4 = 0;\n    let mut row_max_idx4 = 0;\n    let mut row_min_idx4 = 0;\n\
    \    let mut col_max5 = 0;\n    let mut col_min5 = 0;\n    let mut col_max_idx5\
    \ = 0;\n    let mut col_min_idx5 = 0;\n    let mut row_max5 = 0;\n    let mut\
    \ row_min5 = 0;\n    let mut row_max_idx5 = 0;\n    let mut row_min_idx5 = 0;\n\
    \    let mut col_max6 = 0;\n    let mut col_min6 = 0;\n    let mut col_max_idx6\
    \ = 0;\n    let mut col_min_idx6 = 0;\n    let mut row_max6 = 0;\n    let mut\
    \ row_min6 = 0;\n    let mut row_max_idx6 = 0;\n    let mut row_min_idx6 = 0;\n\
    \    let mut col_max7 = 0;\n    let mut col_min7 = 0;\n    let mut col_max_idx7\
    \ = 0;\n    let mut col_min_idx7 = 0;\n    let mut row_max7 = 0;\n    let mut\
    \ row_min7 = 0;\n    let mut row_max_idx7 = 0;\n    let mut row_min_idx7 = 0;\n\
    \    let mut col_max8 = 0;\n    let mut col_min8 = 0;\n    let mut col_\n}\n\n\
    fn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxbn9o3pk.rs:81:17\n   |\n\
    81 |     let mut col_\n   |                 ^ help: add `;` here\n82 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxbn9o3pk.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows = lst.len();\n    let mut cols = lst[0].len();\n    let mut coords = vec![];\n\
    \    let mut row_coords = vec![];\n    let mut col_coords = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorting\
    \ = false;\n    let mut col_sorting = false;\n    let mut row_sorting_index =\
    \ 0;\n    let mut col_sorting_index = 0;\n    let mut row = 0;\n    let mut col\
    \ = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while i < rows {\n       \
    \ while j < cols {\n            if lst[i][j] == x {\n                coords.push((i,\
    \ j));\n                i += 1;\n                j += 1;\n            }\n    \
    \        i += 1;\n        }\n        row += 1;\n        col = 0;\n        j =\
    \ 0;\n    }\n    coords.sort_by(|a, b| a.1.cmp(&b.1));\n    coords.sort_by(|a,\
    \ b| b.1.cmp(&a.1));\n    coords.sort_by(|a, b| b.0.cmp(&a.0));\n    coords.sort_by(|a,\
    \ b| b.0.cmp(&a.0));\n    coords.sort_by(|a, b| b.1.cmp(&a.1));\n    coords.sort_by(|a,\
    \ b| b.1.cmp(&a.1));\n    coords.sort_by(|a, b| b.0.cmp(&a.0));\n    coords.sort_by(|a,\
    \ b| b.0.cmp(&a.0));\n    coords.sort_by(|a, b| b.1.cmp(&a.1));\n    coords.sort_by(|a,\
    \ b| b.1.cmp(&a.1));\n    coords.sort_by(|a, b| b.0.cmp(&a.0));\n    coords.sort_by(|a,\
    \ b| b.0.cmp(&a.0));\n    coords.sort_by(|a, b| b.1.cmp(&a.1));\n    coords.sort_by(|a,\
    \ b| b.1.cmp(&a.1));\n    coords.sort_by(|a, b| b.0.cmp(&a.0));\n    coords.sort_by(|a,\
    \ b| b.0.cmp(&a.0));\n    coords.sort_by(|a, b| b.1.cmp(&a.1));\n    coords.sort_by(|a,\
    \ b| b.1.cmp(&a.1));\n    coords.sort_by(|a, b| b.0.cmp(&a.0));\n    coords.sort_by(|a,\
    \ b| b.0.cmp(&a.0));\n    coords.sort_by(|a, b| b.1.cmp(&a.1));\n    coords.sort_by(|a,\
    \ b| b.1.cmp(&a.1));\n    coords.sort_by(|a, b| b.0.cmp(&a.0));\n    coords.sort_by(|a,\
    \ b| b.0.cmp(&a.\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `)`\n  --> /tmp/tmpen1eh95u.rs:69:1\n   |\n69\
    \ | }\n   | ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpen1eh95u.rs:68:34\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                                                   -\
    \ closing delimiter possibly meant for this\n...\n68 |     coords.sort_by(|a,\
    \ b| b.0.cmp(&a.\n   |                                  ^ unclosed delimiter\n\
    69 | }\n   | ^ mismatched closing delimiter\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpen1eh95u.rs:68:35\n   |\n68 |     coords.sort_by(|a, b| b.0.cmp(&a.\n\
    \   |                                   ^^ expected `usize`, found `&(usize, usize)`\n\
    \   |\n   = note: expected reference `&usize`\n              found reference `&&(usize,\
    \ usize)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpen1eh95u.rs:68:5\n\
    \   |\n16 |   fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                                 -------------------\
    \ expected `Vec<(isize, isize)>` because of return type\n...\n68 | /     coords.sort_by(|a,\
    \ b| b.0.cmp(&a.\n69 | | }\n   | |_^ expected struct `Vec`, found `()`\n   |\n\
    \   = note: expected struct `Vec<(isize, isize)>`\n           found unit type\
    \ `()`\n\nerror: aborting due to 4 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows = lst.len();\n    let mut cols = lst[0].len();\n    let mut coords = vec![];\n\
    \    let mut row_coords = vec![];\n    let mut col_coords = vec![];\n    let mut\
    \ row_sort = vec![];\n    let mut col_sort = vec![];\n    let mut row_sort_idx\
    \ = vec![];\n    let mut col_sort_idx = vec![];\n    let mut row_sort_idx2 = vec![];\n\
    \    let mut col_sort_idx2 = vec![];\n    let mut row_sort_idx3 = vec![];\n  \
    \  let mut col_sort_idx3 = vec![];\n    let mut row_sort_idx4 = vec![];\n    let\
    \ mut col_sort_idx4 = vec![];\n    let mut row_sort_idx5 = vec![];\n    let mut\
    \ col_sort_idx5 = vec![];\n    let mut row_sort_idx6 = vec![];\n    let mut col_sort_idx6\
    \ = vec![];\n    let mut row_sort_idx7 = vec![];\n    let mut col_sort_idx7 =\
    \ vec![];\n    let mut row_sort_idx8 = vec![];\n    let mut col_sort_idx8 = vec![];\n\
    \    let mut row_sort_idx9 = vec![];\n    let mut col_sort_idx9 = vec![];\n  \
    \  let mut row_sort_idx10 = vec![];\n    let mut col_sort_idx10 = vec![];\n  \
    \  let mut row_sort_idx11 = vec![];\n    let mut col_sort_idx11 = vec![];\n  \
    \  let mut row_sort_idx12 = vec![];\n    let mut col_sort_idx12 = vec![];\n  \
    \  let mut row_sort_idx13 = vec![];\n    let mut col_sort_idx13 = vec![];\n  \
    \  let mut row_sort_idx14 = vec![];\n    let mut col_sort_idx14 = vec![];\n  \
    \  let mut row_sort_idx15 = vec![];\n    let mut col_sort_idx15 = vec![];\n  \
    \  let mut row_sort_idx16 = vec![];\n    let mut col_sort_idx16 = vec![];\n  \
    \  let mut row_sort_idx17 = vec![];\n    let mut col_sort_idx17 = vec![];\n  \
    \  let mut row_sort_idx18 = vec![];\n    let mut col_sort_idx18 = vec![];\n  \
    \  let mut row_sort_idx19 = vec![];\n    let mut col_sort_idx19 = vec![];\n  \
    \  let mut row_sort_idx20 = vec![];\n    let mut \n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp8uz9w704.rs:64:1\n\
    \   |\n64 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659749648
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows = lst.len();\n    let mut cols = lst[0].len();\n    let mut coords = vec![];\n\
    \    let mut row_coords = vec![];\n    let mut col_coords = vec![];\n    let mut\
    \ row_coords_sorted = vec![];\n    let mut col_coords_sorted = vec![];\n    let\
    \ mut row_coords_sorted_by_row = vec![];\n    let mut col_coords_sorted_by_row\
    \ = vec![];\n    let mut row_coords_sorted_by_col = vec![];\n    let mut col_coords_sorted_by_col\
    \ = vec![];\n    let mut row_coords_sorted_by_row_by_col = vec![];\n    let mut\
    \ col_coords_sorted_by_row_by_col = vec![];\n    let mut row_coords_sorted_by_col_by_row\
    \ = vec![];\n    let mut col_coords_sorted_by_col_by_row = vec![];\n    let mut\
    \ row_coords_sorted_by_row_by_col_by_col = vec![];\n    let mut col_coords_sorted_by_row_by_col_by_row\
    \ = vec![];\n    let mut row_coords_sorted_by_col_by_row_by_col = vec![];\n  \
    \  let mut col_coords_sorted_by_row_by_col_by_row_by_col = vec![];\n    let mut\
    \ row_coords_sorted_by_row_by_col_by_row_by_col_by_row = vec![];\n    let mut\
    \ col_coords_sorted_by_row_by_col_by_row_by_col_by_row = vec![];\n    let mut\
    \ row_coords_sorted_by_col_by_row_by_col_by_row_by_col = vec![];\n    let mut\
    \ col_coords_sorted_by_row_by_col_by_row_by_col_by_row_by_col = vec![];\n    let\
    \ mut row_coords_sorted_by_row_by_col_by_row_by_col_by_row_by_col_by_row = vec![];\n\
    \    let mut col_coords_sorted_by_row_by_col_by_row_by_col_by_row_by_col_by_row\
    \ = vec![];\n    let mut row_coords_sorted_by_row_by_col_by_row_by_col_by_row_by_col_by_row_by_col\
    \ = vec![];\n    let mut col_coords_sorted_by_row_by_col_by_row_by_col_by_row_by_col_by_row_by_col\
    \ = vec![];\n    let mut row_coords_sorted_by_row_by_col_by_row_by_col_by_row_by_col_by_row_by_col_by_row\
    \ = vec![];\n    let mut col_coords_sorted_by_row_by_col_by_row_by_col_by_row_by_col_by_row_by_col_by_row\
    \ = vec![];\n    let mut row_coords_sorted_by_row_by_col_by_row_by_col_by_row_by_col_by_row_by_col_by_row_by_col\
    \ = vec![];\n    let mut col_coords_\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpg01dmsls.rs:47:24\n   |\n\
    47 |     let mut col_coords_\n   |                        ^ help: add `;` here\n\
    48 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg01dmsls.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n\
    \    let mut row_idx = 0;\n    let mut col_idx = 0;\n    while row_idx < rows\
    \ && col_idx < cols {\n        if lst[row_idx][col_idx] == x {\n            result.push((row_idx,\
    \ col_idx));\n        }\n        if row_idx < rows {\n            row_idx += 1;\n\
    \            col_idx = 0;\n        } else {\n            col_idx += 1;\n     \
    \   }\n    }\n    result.sort_by_key(|&(x, y)| x.0);\n    result.sort_by_key(|&(x,\
    \ y)| y.0);\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0610]: `usize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmp_cxvg6jl.rs:33:36\n   |\n33 |     result.sort_by_key(|&(x, y)|\
    \ x.0);\n   |                                    ^\n\nerror[E0610]: `usize` is\
    \ a primitive type and therefore doesn't have fields\n  --> /tmp/tmp_cxvg6jl.rs:34:36\n\
    \   |\n34 |     result.sort_by_key(|&(x, y)| y.0);\n   |                     \
    \               ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_cxvg6jl.rs:35:5\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n35 |     result\n   |   \
    \  ^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n              found struct `Vec<(usize, usize)>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0610.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749650
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_idx\
    \ = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut\
    \ col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n  \
    \  let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut\
    \ col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n  \
    \  let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut\
    \ col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n  \
    \  let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut\
    \ col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n  \
    \  let mut row_sorted = vec![];\n\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzst0gf9u.rs:16:47\n   |\n\
    16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \    -------                                    ^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749649
