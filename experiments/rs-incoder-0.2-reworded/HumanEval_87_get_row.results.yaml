name: HumanEval_87_get_row
language: rs
results:
- program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ coords = vec![];\n    let mut row_coords = vec![];\n    let mut col_coords =\
    \ vec![];\n    for row in lst {\n        let mut row_coord = vec![];\n       \
    \ let mut col_coord = vec![];\n        for col in row {\n            if col ==\
    \ x {\n                row_coord.push((row, col));\n                col_coord.push((row,\
    \ col));\n            }\n        }\n        row_coords.push(row_coord);\n    \
    \    col_coords.push(col_coord);\n    }\n    coords.sort_by(|a, b| a.0.cmp(&b.0));\n\
    \    row_coords.sort_by(|a, b| b.0.cmp(&a.0));\n    col_coords.sort_by(|a, b|\
    \ b.0.cmp(&a.0));\n    coords\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed for `&T`\n  --> /tmp/tmpkc6ffjr_.rs:32:21\n\
    \   |\n32 |     coords.sort_by(|a, b| a.0.cmp(&b.0));\n   |                  \
    \   ^ consider giving this closure parameter the explicit type `&T`, where the\
    \ type parameter `T` is specified\n   |\n   = note: type must be known at this\
    \ point\n\nerror[E0609]: no field `0` on type `&_`\n  --> /tmp/tmpkc6ffjr_.rs:32:29\n\
    \   |\n32 |     coords.sort_by(|a, b| a.0.cmp(&b.0));\n   |                  \
    \           ^\n\nerror[E0609]: no field `0` on type `&Vec<(Vec<isize>, isize)>`\n\
    \  --> /tmp/tmpkc6ffjr_.rs:33:33\n   |\n33 |     row_coords.sort_by(|a, b| b.0.cmp(&a.0));\n\
    \   |                                 ^ unknown field\n\nerror[E0609]: no field\
    \ `0` on type `&Vec<(Vec<isize>, isize)>`\n  --> /tmp/tmpkc6ffjr_.rs:33:42\n \
    \  |\n33 |     row_coords.sort_by(|a, b| b.0.cmp(&a.0));\n   |               \
    \                           ^ unknown field\n\nerror[E0609]: no field `0` on type\
    \ `&Vec<(Vec<isize>, isize)>`\n  --> /tmp/tmpkc6ffjr_.rs:34:33\n   |\n34 |   \
    \  col_coords.sort_by(|a, b| b.0.cmp(&a.0));\n   |                           \
    \      ^ unknown field\n\nerror[E0609]: no field `0` on type `&Vec<(Vec<isize>,\
    \ isize)>`\n  --> /tmp/tmpkc6ffjr_.rs:34:42\n   |\n34 |     col_coords.sort_by(|a,\
    \ b| b.0.cmp(&a.0));\n   |                                          ^ unknown\
    \ field\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed\
    \ explanations: E0282, E0609.\nFor more information about an error, try `rustc\
    \ --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut row_idx_max\
    \ = 0;\n    let mut row_idx_min = 0;\n    let mut col_max = 0;\n    let mut col_min\
    \ = 0;\n    let mut col_max2 = 0;\n    let mut col_min2 = 0;\n    let mut col_max3\
    \ = 0;\n    let mut col_min3 = 0;\n    let mut col_max4 = 0;\n    let mut col_min4\
    \ = 0;\n    let mut col_max5 = 0;\n    let mut col_min5 = 0;\n    let mut col_max6\
    \ = 0;\n    let mut col_min6 = 0;\n    let mut col_max7 = 0;\n    let mut col_min7\
    \ = 0;\n    let mut col_max8 = 0;\n    let mut col_min8 = 0;\n    let mut col_max9\
    \ = 0;\n    let mut col_min9 = 0;\n    let mut col_max10 = 0;\n    let mut col_min10\
    \ = 0;\n    let mut col_max11 = 0;\n    let mut col_min11 = 0;\n    let mut col_max12\
    \ = 0;\n    let mut col_min12 = 0;\n    let mut col_max13 = 0;\n    let mut col_min13\
    \ = 0;\n    let mut col_max14 = 0;\n    let mut col_min14 = 0;\n    let mut col_max15\
    \ = 0;\n    let mut col_min15 = 0;\n    let mut col_max16 = 0;\n    let mut col_min16\
    \ = 0;\n    let mut col_max17 = 0;\n    let mut col_min17 = 0;\n    let mut col_max18\
    \ = 0;\n    let mut col_min18 = 0;\n    let mut col_max19 = 0;\n    let mut col_min19\
    \ = 0;\n    let mut col_max20 = 0;\n    let mut col_min20 = 0;\n    let mut col_max21\
    \ = 0;\n    let mut col_min21 = 0;\n    let mut col_max22 = 0;\n    let mut col_min22\
    \ = 0;\n    let mut col_max23 = 0;\n    let mut col_min23 = 0;\n    let mut col_max24\
    \ = 0;\n    let mut col_min24 = 0;\n    let mut col_max25 = 0;\n    let mut col_min25\
    \ = 0;\n    let mut col_max26 = 0;\n    let mut col_min26 = 0;\n    let mut col_max27\
    \ = 0;\n    let mut col_min27 = 0;\n    let mut col_max28 = 0;\n    let mut col_min28\
    \ = 0;\n    let mut col_max29 = 0;\n    let mut col_min29 = 0;\n    let mut col_max30\
    \ = 0;\n    let mut col_min30 = 0;\n    let mu\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpsa7tzda6.rs:81:11\n   |\n\
    81 |     let mu\n   |           ^ help: add `;` here\n82 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsa7tzda6.rs:16:47\n \
    \  |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n\
    \   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n\
    \    let mut row_idx = 0;\n    let mut col_idx = 0;\n    while col_idx < cols\
    \ {\n        if row_idx == rows {\n            break;\n        }\n        let\
    \ mut row_start = row_idx;\n        let mut row_end = row_idx;\n        let mut\
    \ col_start = col_idx;\n        let mut col_end = col_idx;\n        if row_idx\
    \ < rows {\n            row_end = row_idx + 1;\n        }\n        if col_idx\
    \ < cols {\n            col_end = col_idx + 1;\n        }\n        if row_start\
    \ > row_end {\n            break;\n        }\n        if col_start > col_end {\n\
    \            break;\n        }\n        if row_start == row_end && col_start ==\
    \ col_end {\n            if lst[row_start][col_start] == x {\n               \
    \ result.push((row_start, col_start));\n            }\n        }\n        row_idx\
    \ = row_end;\n        col_idx = col_end;\n    }\n    result.sort_by_key(|&(x,\
    \ y)| x.0);\n    result.sort_by_key(|&(x, y)| y.0);\n    result\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0610]: `usize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmpb_g_48j7.rs:50:36\n   |\n50 |     result.sort_by_key(|&(x, y)|\
    \ x.0);\n   |                                    ^\n\nerror[E0610]: `usize` is\
    \ a primitive type and therefore doesn't have fields\n  --> /tmp/tmpb_g_48j7.rs:51:36\n\
    \   |\n51 |     result.sort_by_key(|&(x, y)| y.0);\n   |                     \
    \               ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb_g_48j7.rs:52:5\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n52 |     result\n   |   \
    \  ^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n              found struct `Vec<(usize, usize)>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0610.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows = lst.len();\n    let mut cols = lst[0].len();\n    let mut coords = vec![];\n\
    \    let mut row_coords = vec![];\n    let mut col_coords = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sort\
    \ = vec![];\n    let mut col_sort = vec![];\n    let mut row_sort_idx = vec![];\n\
    \    let mut col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n    let\
    \ mut col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n    let mut\
    \ col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n    let mut col_sort_idx\
    \ = vec![];\n    let mut row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n\
    \    let mut row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n    let\
    \ mut row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n    let mut\
    \ row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n    let mut row_sort_idx\
    \ = vec![];\n    let mut col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n\
    \    let mut col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n    let\
    \ mut col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n    let mut\
    \ col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n    let mut col_sort_idx\
    \ = vec![];\n    let mut row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n\
    \    let mut row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n    let\
    \ mut row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n    let mut\
    \ row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n    let mut row_sort_idx\
    \ = vec![];\n    let mut col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n\
    \    let mut col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n    let\
    \ mut col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n    let mut\
    \ col_sort_idx = vec![];\n    let mut row_sort_\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpucvttksj.rs:68:22\n   |\n\
    68 |     let mut row_sort_\n   |                      ^ help: add `;` here\n69\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpucvttksj.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n\
    \    let mut row_idx = 0;\n    let mut col_idx = 0;\n    while col_idx < cols\
    \ {\n        if row_idx < rows {\n            let row = lst[row_idx];\n      \
    \      let col = row[col_idx];\n            if col == x {\n                result.push((row_idx,\
    \ col_idx));\n            }\n            col_idx += 1;\n        } else {\n   \
    \         break;\n        }\n        row_idx += 1;\n    }\n    result.sort_by_key(|&(x,\
    \ y)| x.0);\n    result.sort_by_key(|&(x, y)| y.0);\n    result\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0610]: `usize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmpn9wxkjtd.rs:35:36\n   |\n35 |     result.sort_by_key(|&(x, y)|\
    \ x.0);\n   |                                    ^\n\nerror[E0610]: `usize` is\
    \ a primitive type and therefore doesn't have fields\n  --> /tmp/tmpn9wxkjtd.rs:36:36\n\
    \   |\n36 |     result.sort_by_key(|&(x, y)| y.0);\n   |                     \
    \               ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn9wxkjtd.rs:37:5\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n37 |     result\n   |   \
    \  ^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n              found struct `Vec<(usize, usize)>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0610.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    for row in lst {\n        let mut row = row.clone();\n\
    \        let mut row_sorted = row.clone();\n        row_sorted.sort_by_key(|&x|\
    \ x.0);\n        let mut row_reversed = row_sorted.clone();\n        row_reversed.reverse();\n\
    \        for row in row_reversed {\n            if row.0 == x {\n            \
    \    result.push((row.0, row.1));\n                break;\n            }\n   \
    \     }\n    }\n    result.sort_by_key(|&x| x.0);\n    result.sort_by_key(|&x|\
    \ x.1);\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0610]: `isize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmpq7l45eja.rs:21:39\n   |\n21 |         row_sorted.sort_by_key(|&x|\
    \ x.0);\n   |                                       ^\n\nerror[E0610]: `isize`\
    \ is a primitive type and therefore doesn't have fields\n  --> /tmp/tmpq7l45eja.rs:25:20\n\
    \   |\n25 |             if row.0 == x {\n   |                    ^\n\nerror[E0610]:\
    \ `isize` is a primitive type and therefore doesn't have fields\n  --> /tmp/tmpq7l45eja.rs:26:34\n\
    \   |\n26 |                 result.push((row.0, row.1));\n   |               \
    \                   ^\n\nerror[E0610]: `isize` is a primitive type and therefore\
    \ doesn't have fields\n  --> /tmp/tmpq7l45eja.rs:26:41\n   |\n26 |           \
    \      result.push((row.0, row.1));\n   |                                    \
    \     ^\n\nerror: aborting due to 4 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0610`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows = lst.len();\n    let mut cols = lst[0].len();\n    let mut coords = vec![];\n\
    \    let mut row_coords = vec![];\n    let mut col_coords = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sor\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpa1objz2n.rs:68:20\n   |\n\
    68 |     let mut row_sor\n   |                    ^ help: add `;` here\n69 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa1objz2n.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows = lst.len();\n    let mut cols = lst[0].len();\n    let mut coords = vec![];\n\
    \    let mut row_coords = vec![];\n    let mut col_coords = vec![];\n    let mut\
    \ row_sort = vec![];\n    let mut col_sort = vec![];\n    let mut row_sort_idx\
    \ = 0;\n    let mut col_sort_idx = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    while i < rows {\n        let mut row_sort = vec![];\n        let mut col_sort\
    \ = vec![];\n        let mut row_sort_idx = 0;\n        let mut col_sort_idx =\
    \ 0;\n        while j < cols {\n            if lst[i][j] == x {\n            \
    \    row_sort.push((i, j));\n                row_sort_idx += 1;\n            \
    \    col_sort.push((j, i));\n                col_sort_idx += 1;\n            }\n\
    \            j += 1;\n        }\n        row_sort.sort_by_key(|&(_, y)| y);\n\
    \        col_sort.sort_by_key(|&(_, x)| x);\n        row_sort.reverse();\n   \
    \     col_sort.reverse();\n        row_sort.push(row_sort_idx);\n        col_sort.push(col_sort_idx);\n\
    \        coords.push(row_sort.clone());\n        coords.push(col_sort.clone());\n\
    \        i += 1;\n        j = 0;\n    }\n    coords\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk5mi74pc.rs:46:23\n   |\n\
    46 |         row_sort.push(row_sort_idx);\n   |                       ^^^^^^^^^^^^\
    \ expected tuple, found integer\n   |\n   = note: expected tuple `(usize, usize)`\n\
    \               found type `{integer}`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpk5mi74pc.rs:47:23\n   |\n47 |         col_sort.push(col_sort_idx);\n\
    \   |                       ^^^^^^^^^^^^ expected tuple, found integer\n   |\n\
    \   = note: expected tuple `(usize, usize)`\n               found type `{integer}`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpk5mi74pc.rs:53:5\n   |\n16 | fn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |     \
    \                                          ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n53 |     coords\n   |     ^^^^^^ expected\
    \ tuple, found struct `Vec`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \              found struct `Vec<Vec<(usize, usize)>>`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ rows = lst.len();\n    let mut cols = lst[0].len();\n    let mut coords = vec![];\n\
    \    let mut row_coords = vec![];\n    let mut col_coords = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorter:\
    \ Vec<(isize, isize)> = vec![];\n    let mut col_sorter: Vec<(isize, isize)> =\
    \ vec![];\n    let mut row = 0;\n    let mut col = 0;\n    let mut i = 0;\n  \
    \  let mut j = 0;\n    while i < rows {\n        row_sorter.clear();\n       \
    \ col_sorter.clear();\n        row_sorter.push((i, x));\n        col_sorter.push((x,\
    \ i));\n        row_sorted = row_sorter.iter().cloned().collect();\n        col_sorted\
    \ = col_sorter.iter().cloned().collect();\n        row_coords.clear();\n     \
    \   col_coords.clear();\n        row_coords.push((row, x));\n        col_coords.push((x,\
    \ row));\n        row_coords.sort_by(|a, b| a.1.cmp(&b.1));\n        col_coords.sort_by(|a,\
    \ b| b.1.cmp(&a.1));\n        row_coords.reverse();\n        col_coords.reverse();\n\
    \        row_coords.sort_by(|a, b| b.0.cmp(&a.0));\n        col_coords.sort_by(|a,\
    \ b| a.0.cmp(&b.0));\n        row_coords.reverse();\n        col_coords.reverse();\n\
    \        row_coords.sort_by(|a, b| b.1.cmp(&a.1));\n        col_coords.sort_by(|a,\
    \ b| a.1.cmp(&b.1));\n        row_coords.reverse();\n        col_coords.reverse();\n\
    \        row_coords.sort_by(|a, b| b.0.cmp(&a.0));\n        col_coords.sort_by(|a,\
    \ b| a.0.cmp(&b.0));\n        row_coords.reverse();\n        col_coords.reverse();\n\
    \        row_coords.sort_by(|a, b| b.1.cmp(&a.1));\n        col_coords.sort_by(|a,\
    \ b| a.1.cmp(&b.1));\n        row_coords.reverse();\n        col_coords.reverse();\n\
    \        row_coords.sort_by(|a, b| b.0.cmp(&a.0));\n        col_coords.sort_by(|a,\
    \ b| a.0.cmp(&b.0));\n        row_coords.reverse();\n        col_coords.reverse();\n\
    \        row_coords.sort_by(|a, b| b.1.cmp(&a.1));\n        col_coords.sort_by(|a,\
    \ b| a.1.cmp(&b.1));\n        row_coords.reverse();\n        \n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpoier_41i.rs:79:3\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                                                   -\
    \ unclosed delimiter\n...\n30 |     while i < rows {\n   |                   \
    \ - this delimiter might not be properly closed...\n...\n69 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n79 | }\n   |   ^\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpoier_41i.rs:33:26\n   |\n33 |  \
    \       row_sorter.push((i, x));\n   |                          ^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n33 |         row_sorter.push((i.try_into().unwrap(),\
    \ x));\n   |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpoier_41i.rs:34:29\n   |\n34 |         col_sorter.push((x,\
    \ i));\n   |                             ^ expected `isize`, found `usize`\n \
    \  |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n34 |         col_sorter.push((x, i.try_into().unwrap()));\n\
    \   |                              ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpoier_41i.rs:16:47\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>,\
    \ x: isize) -> Vec<(isize, isize)> {\n   |    -------                        \
    \            ^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<(isize, isize)>`\n           found unit\
    \ type `()`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ res = vec![];\n    let mut row = 0;\n    let mut col = 0;\n    let mut i = 0;\n\
    \    while i < lst.len() {\n        if row == x {\n            i += 1;\n     \
    \       continue;\n        }\n        let mut j = i;\n        while j < lst.len()\
    \ {\n            if col == x {\n                res.push((row, col));\n      \
    \          i += 1;\n                j += 1;\n                continue;\n     \
    \       }\n            if lst[j][col] > lst[j][col + 1] {\n                j +=\
    \ 1;\n                continue;\n            }\n            i += 1;\n        \
    \    col += 1;\n        }\n        row += 1;\n        col = 0;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp1tvkhs6g.rs:34:16\n\
    \   |\n34 |             if lst[j][col] > lst[j][col + 1] {\n   |             \
    \   ^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n \
    \  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp1tvkhs6g.rs:34:30\n\
    \   |\n34 |             if lst[j][col] > lst[j][col + 1] {\n   |             \
    \                 ^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut row_len\
    \ = 0;\n    let mut col_len = 0;\n    let mut col_len_idx = 0;\n    let mut col_len_idx_max\
    \ = 0;\n    let mut col_len_idx_min = 0;\n    let mut row_len_idx = 0;\n    let\
    \ mut row_len_idx_max = 0;\n    let mut row_len_idx_min = 0;\n    let mut row_idx\
    \ = 0;\n    let mut col_idx = 0;\n    let mut col_len = 0;\n    let mut col_len_idx\
    \ = 0;\n    let mut col_len_idx_max = 0;\n    let mut col_len_idx_min = 0;\n \
    \   let mut row_len_idx = 0;\n    let mut row_len_idx_max = 0;\n    let mut row_len_idx_min\
    \ = 0;\n    let mut row_idx = 0;\n    let mut col_idx = 0;\n    let mut col_len\
    \ = 0;\n    let mut col_len_idx = 0;\n    let mut col_len_idx_max = 0;\n    let\
    \ mut col_len_idx_min = 0;\n    let mut row_len_idx = 0;\n    let mut row_len_idx_max\
    \ = 0;\n    let mut row_len_idx_min = 0;\n    let mut row_idx = 0;\n    let mut\
    \ col_idx = 0;\n    let mut col_len = 0;\n    let mut col_len_idx = 0;\n    let\
    \ mut col_len_idx_max = 0;\n    let mut col_len_idx_min = 0;\n    let mut row_len_idx\
    \ = 0;\n    let mut row_len_idx_max = 0;\n    let mut row_len_idx_min = 0;\n \
    \   let mut row_idx = 0;\n    let mut col_idx = 0;\n    let mut col_len = 0;\n\
    \    let mut col_len_idx = 0;\n    let mut col_len_idx_max = 0;\n    let mut col_len_idx_min\
    \ = 0;\n    let mut row_len_idx = 0;\n    let mut row_len_idx_max = 0;\n    let\
    \ mut row_len_idx_min = 0;\n    let mut row_idx = 0;\n    let mut col_idx = 0;\n\
    \    let mut col_len = 0;\n    let mut col_len_idx = 0;\n    let mut col_len_idx_max\
    \ = 0;\n    let mut col_len_idx_min = 0;\n    let mut row_len_idx = 0;\n    let\
    \ mut row_len_idx_max = 0;\n    let mut row_len_idx_min = 0;\n    let mut row_idx\
    \ = 0;\n    let mut col_idx = 0;\n    let mut col_len = 0;\n    let mut col_len_idx\
    \ = 0;\n    let mut col_len_idx_max = 0;\n    let mut col_len_idx_min = 0;\n \
    \   let mut row_len_idx = 0;\n    let mu\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp0oj4sd6x.rs:79:11\n   |\n\
    79 |     let mu\n   |           ^ help: add `;` here\n80 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0oj4sd6x.rs:16:47\n \
    \  |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n\
    \   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut row_idx = 1;\n    let mut col_idx = 1;\n    let\
    \ mut row_len = lst.len();\n    let mut col_len = lst[0].len();\n    let mut row_start\
    \ = vec![];\n    let mut col_start = vec![];\n    while row_idx < row_len {\n\
    \        let mut row_end = vec![];\n        while col_idx < col_len {\n      \
    \      if row_idx == row_idx {\n                row_start.push(col_idx);\n   \
    \             col_start.push(row_idx);\n            }\n            if col_idx\
    \ < col_len {\n                if row_idx == row_idx {\n                    row_end.push(col_idx);\n\
    \                }\n                if row_idx < row_len {\n                 \
    \   if row_idx == row_idx {\n                        row_end.push(row_idx);\n\
    \                    }\n                    if row_idx < row_len {\n         \
    \               if row_idx == row_idx {\n                            row_end.push(row_idx);\n\
    \                        }\n                        if row_idx < row_len {\n \
    \                           if row_idx == row_idx {\n                        \
    \        row_end.push(row_idx);\n                            }\n             \
    \               if row_idx < row_len {\n                                if row_idx\
    \ == row_idx {\n                                    row_end.push(row_idx);\n \
    \                               }\n                                if row_idx\
    \ < row_len {\n                                    if row_idx == row_idx {\n \
    \                                       row_end.push(row_idx);\n             \
    \                       }\n                                    if row_idx < row_len\
    \ {\n                                        if row_idx == row_idx {\n       \
    \                                     row_end.push(row_idx);\n               \
    \                         }\n                                        if row_idx\
    \ < row_len {\n                                            if row_idx == row_idx\
    \ {\n                                                row_end.push(row_idx);\n\
    \                                            }\n                             \
    \               if row_idx < row_len {\n                                     \
    \           if row_idx == row_idx {\n                                        \
    \            row_end.push(row_idx);\n                                        \
    \        }\n                                                if row_idx < row_len\
    \ {\n                                                    if row_idx == row_idx\
    \ {\n                                                        row_end.push(row_idx);\n\
    \                                                    }\n                     \
    \                               if row_idx < row_len {\n                     \
    \                                   if row_idx == row_idx {\n                \
    \                                            row_end.push(row_idx);\n        \
    \                                                }\n                         \
    \                               if row_idx < row_len {\n                     \
    \                                       if row_idx == row_idx {\n            \
    \                                                    row_end.push(row_idx);\n\
    \                                                            }\n             \
    \                                               if row_idx < row_len {\n     \
    \                                                           if row_idx == row_idx\
    \ {\n                                                                    row_end.push(row_idx);\n\
    \                                                                }\n         \
    \                                                       if row_idx < row_len {\n\
    \                                                                    if row_idx\
    \ == row_idx {\n                                                             \
    \           row_end.push(row_idx);\n                                         \
    \                           }\n                                              \
    \                      if row_idx < \n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpl8p1x47v.rs:98:3\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                                                   -\
    \ unclosed delimiter\n...\n24 |     while row_idx < row_len {\n   |          \
    \                   - unclosed delimiter\n25 |         let mut row_end = vec![];\n\
    26 |         while col_idx < col_len {\n   |                                 -\
    \ unclosed delimiter\n...\n31 |             if col_idx < col_len {\n   |     \
    \                             - unclosed delimiter\n...\n35 |                \
    \ if row_idx < row_len {\n   |                                      - unclosed\
    \ delimiter\n...\n39 |                     if row_idx < row_len {\n   |      \
    \                                    - unclosed delimiter\n...\n43 |         \
    \                if row_idx < row_len {\n   |                                \
    \              - unclosed delimiter\n...\n47 |                             if\
    \ row_idx < row_len {\n   |                                                  -\
    \ unclosed delimiter\n...\n51 |                                 if row_idx < row_len\
    \ {\n   |                                                      - unclosed delimiter\n\
    ...\n55 |                                     if row_idx < row_len {\n   |   \
    \                                                       - unclosed delimiter\n\
    ...\n59 |                                         if row_idx < row_len {\n   |\
    \                                                              - unclosed delimiter\n\
    ...\n63 |                                             if row_idx < row_len {\n\
    \   |                                                                  - unclosed\
    \ delimiter\n...\n67 |                                                 if row_idx\
    \ < row_len {\n   |                                                          \
    \            - unclosed delimiter\n...\n71 |                                 \
    \                    if row_idx < row_len {\n   |                            \
    \                                              - unclosed delimit"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx: usize = 0;\n    let\
    \ mut col: usize = 0;\n    let mut col_max: usize = 0;\n    let mut row_max =\
    \ lst.len();\n    let mut col_min = row_max;\n    let mut col_max_idx: usize =\
    \ 0;\n    let mut col_min_idx: usize = 0;\n    let mut row_min_idx: usize = 0;\n\
    \    let mut col_max_idx: usize = 0;\n    let mut row_min_idx: usize = 0;\n  \
    \  let mut row_min_idx: usize = 0;\n    let mut row_min_idx: usize = 0;\n    let\
    \ mut row_min_idx: usize = 0;\n    let mut row_min_idx: usize = 0;\n    let mut\
    \ row_min_idx: usize = 0;\n    let mut row_min_idx: usize = 0;\n    let mut row_min_idx:\
    \ usize = 0;\n    let mut row_min_idx: usize = 0;\n    let mut row_min_idx: usize\
    \ = 0;\n    let mut row_min_idx: usize = 0;\n    let mut row_min_idx: usize =\
    \ 0;\n    let mut row_min_idx: usize = 0;\n    let mut row_min_idx: usize = 0;\n\
    \    let mut row_min_idx: usize = 0;\n    let mut row_min_idx: usize = 0;\n  \
    \  let mut row_min_idx: usize = 0;\n    let mut row_min_idx: usize = 0;\n    let\
    \ mut row_min_idx: usize = 0;\n    let mut row_min_idx: usize = 0;\n    let mut\
    \ row_min_idx: usize = 0;\n    let mut row_min_idx: usize = 0;\n    let mut row_min_idx:\
    \ usize = 0;\n    let mut row_min_idx: usize = 0;\n    let mut row_min_idx: usize\
    \ = 0;\n    let mut row_min_idx: usize = 0;\n    let mut row_min_idx: usize =\
    \ 0;\n    let mut row_min_idx: usize = 0;\n    let mut row_min_idx: usize = 0;\n\
    \    let mut row_min_idx: usize = 0;\n    let mut row_min_idx: usize = 0;\n  \
    \  let mut row_min_idx: usize = 0;\n    let mut row_min_idx: usize = 0;\n    let\
    \ mut row_min_idx: usize = 0;\n    let mut row_min_idx: usize = 0;\n    let mut\
    \ row_min_idx: usize = 0;\n    let mut row_min_idx: \n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error: expected type, found `}`\n  --> /tmp/tmpywl9_bnt.rs:64:1\n   |\n\
    63 |     let mut row_min_idx: \n   |         --------------- while parsing the\
    \ type for `mut row_min_idx`\n64 | }\n   | ^ expected type\n\nerror: aborting\
    \ due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    let mut row_len = lst.len();\n    let mut col_len = lst[0].len();\n\
    \    while row_idx < row_len {\n        let mut row_idx = row_idx;\n        while\
    \ col_idx < col_len {\n            if row_idx == row_len {\n                row_idx\
    \ = 0;\n                col_idx = 0;\n            }\n            if col_idx ==\
    \ col_len {\n                row_idx++;\n                col_idx = 0;\n      \
    \      }\n            if lst[row_idx][col_idx] == x {\n                row.push((row_idx,\
    \ col_idx));\n                col_idx++;\n                break;\n           \
    \ }\n            col_idx++;\n        }\n    }\n    row.sort_by_key(|&(x, y)| x.0);\n\
    \    row.sort_by_key(|&(x, y)| y.0);\n    row.iter().map(|&(x, y)| {\n       \
    \ (x.0, y.0)\n    }).collect()\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmprl3vmt_7.rs:30:24\n\
    \   |\n30 |                 row_idx++;\n   |                        ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n30 |               \
    \  { let tmp = row_idx; row_idx += 1; tmp };\n   |                 +++++++++++\
    \        ~~~~~~~~~~~~~~~~~~~~~\n30 -                 row_idx++;\n30 +        \
    \         row_idx += 1;\n   | \n\nerror: Rust has no postfix increment operator\n\
    \  --> /tmp/tmprl3vmt_7.rs:35:24\n   |\n35 |                 col_idx++;\n   |\
    \                        ^^ not a valid postfix operator\n   |\nhelp: use `+=\
    \ 1` instead\n   |\n35 |                 { let tmp = col_idx; col_idx += 1; tmp\
    \ };\n   |                 +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n35 -    \
    \             col_idx++;\n35 +                 col_idx += 1;\n   | \n\nerror:\
    \ Rust has no postfix increment operator\n  --> /tmp/tmprl3vmt_7.rs:38:20\n  \
    \ |\n38 |             col_idx++;\n   |                    ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n38 |             { let tmp =\
    \ col_idx; col_idx += 1; tmp };\n   |             +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n\
    38 -             col_idx++;\n38 +             col_idx += 1;\n   | \n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprl3vmt_7.rs:34:27\n   |\n34 |              \
    \   row.push((row_idx, col_idx));\n   |                           ^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n34 |                 row.push((row_idx.try_into().unwrap(),\
    \ col_idx));\n   |                                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprl3vmt_7.rs:34:36\n   |\n34 |              \
    \   row.push((row_idx, col_idx));\n   |                                    ^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n34 |           \
    \      row.push((row_idx, col_idx.try_into().unwrap()));\n   |               \
    \                            +++++"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n\
    \    let mut row_idx = vec![0; rows];\n    let mut col_idx = vec![0; cols];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![0; rows];\n    let mut col_idx = vec![0; cols];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_idx\
    \ = vec![0; rows];\n    let mut col_idx = vec![0; cols];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_idx = vec![0; rows];\n\
    \    let mut col_idx = vec![0; cols];\n    let mut row_sorted = vec![];\n    let\
    \ mut col_sorted = vec![];\n    let mut row_idx = vec![0; rows];\n    let mut\
    \ col_idx = vec![0; cols];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![0; rows];\n    let mut col_idx = vec![0;\
    \ cols];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_idx = vec![0; rows];\n    let mut col_idx = vec![0; cols];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![0; rows];\n    let mut col_idx = vec![0; cols];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_idx\
    \ = vec![0; rows];\n    let mut col_idx = vec![0; cols];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_idx = vec![0; rows];\n\
    \    let mut col_idx = vec![0; cols];\n    let mut row_sorted = vec![];\n    let\
    \ mut col_sorted = vec![];\n    let mut row_idx = vec![0; rows];\n    let mut\
    \ col_idx = vec![0; cols];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![0; rows];\n    let mut col_idx = vec![0;\
    \ cols];\n    let mu\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpmux8bbb_.rs:66:11\n   |\n\
    66 |     let mu\n   |           ^ help: add `;` here\n67 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmux8bbb_.rs:16:47\n \
    \  |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n\
    \   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut\
    \ col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n  \
    \  let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut\
    \ col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n  \
    \  let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut\
    \ col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n  \
    \  let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let mut col_idx = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_idx = vec![];\n    let mut\
    \ col_idx = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n  \
    \  let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx = vec![];\n    let \n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpzfv6u_ru.rs:72:1\n  \
    \ |\n72 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut row_idx_max\
    \ = 0;\n    let mut col_max = 0;\n    let mut col_min = 0;\n    let mut col_sum\
    \ = 0;\n    let mut col_sum_max = 0;\n    let mut row_sum = 0;\n    let mut row_sum_max\
    \ = 0;\n    let mut row_max = 0;\n    let mut row_min = 0;\n    let mut row_min_index\
    \ = 0;\n    let mut col_min_index = 0;\n    let mut col_sum_index = 0;\n    let\
    \ mut col_sum_min_index = 0;\n    let mut row_sum_index = 0;\n    let mut row_sum_min_index\
    \ = 0;\n    let mut row_max_index = 0;\n    let mut row_min_index = 0;\n    for\
    \ row in lst {\n        let mut col_max = 0;\n        let mut col_min = 0;\n \
    \       let mut col_sum = 0;\n        let mut col_sum_max = 0;\n        let mut\
    \ row_sum = 0;\n        let mut row_sum_max = 0;\n        let mut row_max = 0;\n\
    \        let mut row_min = 0;\n        let mut row_min_index = 0;\n        let\
    \ mut col_min_index = 0;\n        let mut col_sum_index = 0;\n        let mut\
    \ col_sum_min_index = 0;\n        let mut row_sum_index = 0;\n        let mut\
    \ row_sum_min_index = 0;\n        let mut row_max_index = 0;\n        let mut\
    \ row_min_index = 0;\n        for col in row {\n            if col > col_max {\n\
    \                col_max = col;\n            }\n            if col < col_min {\n\
    \                col_min = col;\n            }\n            col_sum += col;\n\
    \            if col > col_sum_max {\n                col_sum_max = col;\n    \
    \        }\n            if col < col_sum_min {\n                col_sum_min =\
    \ col;\n            }\n            row_sum += col;\n            if col > row_sum_max\
    \ {\n                row_sum_max = col;\n            }\n            if col < row_sum_min\
    \ {\n                row_sum_min = col;\n            }\n            row_max =\
    \ col;\n            if col > row_max {\n                row_max = col;\n     \
    \       }\n            if col < row_min {\n                row_min = col;\n  \
    \          }\n            if col > row_min_index {\n                row_min_index\
    \ = col;\n            }\n            if col < col_min_index {\n              \
    \  col_min_index = col;\n            }\n            if col > col_sum_index {\n\
    \                col_sum_index = col;\n            }\n            if col < col_sum_min_index\
    \ {\n                col_sum_min_index = col;\n            }\n            if col\
    \ > \n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpr0rcnqiw.rs:104:3\n\
    \    |\n16  | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    |                                                                   -\
    \ unclosed delimiter\n...\n36  |     for row in lst {\n    |                 \
    \   - unclosed delimiter\n...\n53  |         for col in row {\n    |         \
    \               - this delimiter might not be properly closed...\n...\n94  | }\n\
    \    | - ...as it matches this but it has different indentation\n...\n104 | }\n\
    \    |   ^\n\nerror: expected expression, found `}`\n  --> /tmp/tmpr0rcnqiw.rs:94:1\n\
    \   |\n94 | }\n   | ^ expected expression\n\nerror[E0425]: cannot find value `col_sum_min`\
    \ in this scope\n  --> /tmp/tmpr0rcnqiw.rs:64:22\n   |\n64 |             if col\
    \ < col_sum_min {\n   |                      ^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `col_sum_max`\n\nerror[E0425]: cannot find value\
    \ `col_sum_min` in this scope\n  --> /tmp/tmpr0rcnqiw.rs:65:17\n   |\n65 |   \
    \              col_sum_min = col;\n   |                 ^^^^^^^^^^^ help: a local\
    \ variable with a similar name exists: `col_sum_max`\n\nerror[E0425]: cannot find\
    \ value `row_sum_min` in this scope\n  --> /tmp/tmpr0rcnqiw.rs:71:22\n   |\n71\
    \ |             if col < row_sum_min {\n   |                      ^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `row_sum_max`\n\nerror[E0425]:\
    \ cannot find value `row_sum_min` in this scope\n  --> /tmp/tmpr0rcnqiw.rs:72:17\n\
    \   |\n72 |                 row_sum_min = col;\n   |                 ^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `row_sum_max`\n\nerror[E0308]:\
    \ mismatched types\n   --> /tmp/tmpr0rcnqiw.rs:36:5\n    |\n16  |   fn get_row(lst:\
    \ Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    |                 \
    \                                ------------------- expected `Vec<(isize, isize)>`\
    \ because of return type\n...\n36  | /     for row in lst {\n37  | |         let\
    \ mut col_max = 0;\n38  | |         let mut col_min = 0;\n39  | |         let\
    \ mut col_sum = 0;\n...   |\n103 | |     assert"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    for row in lst {\n        let mut cols = vec![];\n   \
    \     for col in row.iter().cloned() {\n            cols.push((col, row.iter().cloned().filter(|&x|\
    \ x == x).count()));\n        }\n        cols.sort_by_key(|&(_, count)| -count);\n\
    \        cols.sort_by_key(|&(_, count)| count);\n        result.push(cols.iter().cloned().map(|&(_,\
    \ count)| {\n            (count, row.iter().cloned().filter(|&x| x == x).count())\n\
    \        }).collect::<Vec<_>>());\n    }\n    result.sort_by_key(|&(_, count)|\
    \ -count);\n    result.sort_by_key(|&(_, count)| count);\n    result.iter().cloned().map(|&(_,\
    \ count)| {\n        (count, vec![])\n    }).collect::<Vec<_>>()\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmpp1z77wo_.rs:23:40\n\
    \   |\n23 |         cols.sort_by_key(|&(_, count)| -count);\n   |            \
    \                            ^^^^^^ cannot apply unary operator `-`\n   |\n  \
    \ = note: unsigned values cannot be negated\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpp1z77wo_.rs:25:47\n   |\n25 |         result.push(cols.iter().cloned().map(|&(_,\
    \ count)| {\n   |                                               ^^^^^^^^^^-\n\
    \   |                                               |         |\n   |        \
    \                                       |         expected due to this\n   | \
    \                                              expected tuple, found reference\n\
    \   |\n   = note:  expected tuple `(isize, usize)`\n           found reference\
    \ `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp1z77wo_.rs:29:26\n  \
    \ |\n29 |     result.sort_by_key(|&(_, count)| -count);\n   |                \
    \          ^^^^^^^^^-\n   |                          |        |\n   |        \
    \                  |        expected due to this\n   |                       \
    \   expected struct `Vec`, found tuple\n   |\n   = note: expected struct `Vec<(_,\
    \ usize)>`\n               found tuple `(_, _)`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpp1z77wo_.rs:30:26\n   |\n30 |     result.sort_by_key(|&(_, count)|\
    \ count);\n   |                          ^^^^^^^^^-\n   |                    \
    \      |        |\n   |                          |        expected due to this\n\
    \   |                          expected struct `Vec`, found tuple\n   |\n   =\
    \ note: expected struct `Vec<(_, usize)>`\n               found tuple `(_, _)`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpp1z77wo_.rs:31:33\n   |\n31 |\
    \     result.iter().cloned().map(|&(_, count)| {\n   |                       \
    \          ^^^^^^^^^^-\n   |                                 |         |\n   |\
    \                                 |         expected due to this\n   |       \
    \                          expected struct `Vec`, found reference\n   |\n   =\
    \ note: expected struct `Vec<(_, usize)>`\n           found r"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ result = vec![];\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n\
    \    let mut row_idx = 0;\n    let mut col_idx = 0;\n    while row_idx < rows\
    \ {\n        while col_idx < cols {\n            if lst[row_idx][col_idx] == x\
    \ {\n                result.push((row_idx, col_idx));\n                break;\n\
    \            }\n            col_idx += 1;\n        }\n        col_idx = 0;\n \
    \       row_idx += 1;\n    }\n    result.sort_by_key(|&(x, y)| x.0);\n    result.sort_by_key(|&(x,\
    \ y)| y.0);\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0610]: `usize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmpokev0spl.rs:33:36\n   |\n33 |     result.sort_by_key(|&(x, y)|\
    \ x.0);\n   |                                    ^\n\nerror[E0610]: `usize` is\
    \ a primitive type and therefore doesn't have fields\n  --> /tmp/tmpokev0spl.rs:34:36\n\
    \   |\n34 |     result.sort_by_key(|&(x, y)| y.0);\n   |                     \
    \               ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpokev0spl.rs:35:5\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n35 |     result\n   |   \
    \  ^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n              found struct `Vec<(usize, usize)>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0610.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested vectors,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the vector,\n/// and return vector of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// vec![]\n\
    /// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n/// vec![(2, 2)]\nfn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n    let mut\
    \ row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n    let mut row_idx2\
    \ = 0;\n    let mut row_idx3 = 0;\n    let mut row_idx4 = 0;\n    let mut row_idx5\
    \ = 0;\n    let mut row_idx6 = 0;\n    let mut row_idx7 = 0;\n    let mut row_idx8\
    \ = 0;\n    let mut row_idx9 = 0;\n    let mut row_idx10 = 0;\n    let mut row_idx11\
    \ = 0;\n    let mut row_idx12 = 0;\n    let mut row_idx13 = 0;\n    let mut row_idx14\
    \ = 0;\n    let mut row_idx15 = 0;\n    let mut row_idx16 = 0;\n    let mut row_idx17\
    \ = 0;\n    let mut row_idx18 = 0;\n    let mut row_idx19 = 0;\n    let mut row_idx20\
    \ = 0;\n    let mut row_idx21 = 0;\n    let mut row_idx22 = 0;\n    let mut row_idx23\
    \ = 0;\n    let mut row_idx24 = 0;\n    let mut row_idx25 = 0;\n    let mut row_idx26\
    \ = 0;\n    let mut row_idx27 = 0;\n    let mut row_idx28 = 0;\n    let mut row_idx29\
    \ = 0;\n    let mut row_idx30 = 0;\n    let mut row_idx31 = 0;\n    let mut row_idx32\
    \ = 0;\n    let mut row_idx33 = 0;\n    let mut row_idx34 = 0;\n    let mut row_idx35\
    \ = 0;\n    let mut row_idx36 = 0;\n    let mut row_idx37 = 0;\n    let mut row_idx38\
    \ = 0;\n    let mut row_idx39 = 0;\n    let mut row_idx40 = 0;\n    let mut row_idx41\
    \ = 0;\n    let mut row_idx42 = 0;\n    let mut row_idx43 = 0;\n    let mut row_idx44\
    \ = 0;\n    let mut row_idx45 = 0;\n    let mut row_idx46 = 0;\n    let mut row_idx47\
    \ = 0;\n    let mut row_idx48 = 0;\n    let mut row_idx49 = 0;\n    let mut row_idx50\
    \ = 0;\n    let mut row_idx51 = 0;\n    let mut row_idx52 = 0;\n    let mut row_idx53\
    \ = 0;\n    let mut row_idx54 = 0;\n    let mut row_idx55 = 0;\n    let mut row_idx56\
    \ = 0;\n    let mut row_idx57 = 0;\n    let mut row_idx58 = 0;\n    let mut row_idx59\
    \ = 0;\n    let mut row_idx60 = 0;\n    let mut row_idx61 = 0;\n    let mut row_idx62\
    \ = 0;\n    let mut row_\n}\n\nfn main() {\n    let candidate = get_row;\n   \
    \ assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1,\
    \ 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmppjyfu577.rs:80:17\n   |\n\
    80 |     let mut row_\n   |                 ^ help: add `;` here\n81 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppjyfu577.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
