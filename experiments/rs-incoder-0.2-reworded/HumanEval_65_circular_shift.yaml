name: HumanEval_65_circular_shift
language: rs
prompt: "/// Circular shift the digits of the integer x, shift the digits right by\
  \ shift\n/// and return the result as a string.\n/// If shift > number of digits,\
  \ return digits reversed.\n/// >>> circular_shift(12, 1)\n/// String::from(\"21\"\
  )\n/// >>> circular_shift(12, 2)\n/// String::from(\"12\")\nfn circular_shift(x:\
  \ isize, shift: isize) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = circular_shift;\n    assert_eq!(candidate(100,\
  \ 2), String::from(\"001\"));\n    assert_eq!(candidate(12, 2), String::from(\"\
  12\"));\n    assert_eq!(candidate(97, 8), String::from(\"79\"));\n    assert_eq!(candidate(12,\
  \ 1), String::from(\"21\"));\n    assert_eq!(candidate(11, 101), String::from(\"\
  11\"));\n}\n"
completions: ["    let mut s = String::new();\n    let mut digits = x.to_string();\n\
    \    for i in 0..shift {\n        s += &digits[digits.len() - 1 - i];\n    }\n\
    \    s", "    let mut result = String::new();\n    let mut remaining = x;\n  \
    \  while remaining > 0 {\n        let digit = remaining % 10;\n        remaining\
    \ = remaining / 10;\n        result.push((digit + shift) % 10);\n    }\n    result.reverse()",
  "    let mut s = String::new();\n    let mut carry = 0;\n    for &d in x.to_string().chars()\
    \ {\n        let digit = d.to_digit(10);\n        let digit = digit + carry %\
    \ 10;\n        carry = digit / 10;\n        s += digit.to_string();\n    }\n \
    \   if carry > 0 {\n        s += carry.to_string();\n    }\n    if shift > s.len()\
    \ {\n        s[s.len() - shift..].to_owned()\n    } else {\n        s[0..shift].to_owned()\n\
    \    }", "    let mut s = String::new();\n    for i in 0..shift {\n        if\
    \ i >= x.len() {\n            s.push('0');\n        } else {\n            s.push(x[i]);\n\
    \        }\n    }\n    for i in 0..shift {\n        if i >= x.len() {\n      \
    \      s.push('0');\n        } else {\n            s.push(x[x.len() - 1 - i]);\n\
    \        }\n    }\n    s", "    let mut s = String::new();\n    let mut digits\
    \ = x.to_string();\n    for i in 0..shift {\n        s.push(*digits[0..shift].chars().next().unwrap());\n\
    \    }\n    s.push(*digits[shift..].chars().next().unwrap());\n    s", "    let\
    \ mut result = String::new();\n    let mut digits = x.to_string();\n    for i\
    \ in 0..shift {\n        result.push_str(&digits[..]);\n        digits.rotate_left(1);\n\
    \    }\n    result.push_str(&digits[..]);\n    result", "    let mut digits =\
    \ String::new();\n    let mut remainder = x;\n    while remainder > 0 {\n    \
    \    let digit = remainder % 10;\n        remainder = remainder / 10;\n      \
    \  digits.push(digit.to_string());\n    }\n    if shift > digits.len() {\n   \
    \     digits.reverse();\n    }\n    digits", "    let mut digits = x.to_string();\n\
    \    digits = digits[..(digits.len() - shift)].to_string();\n    digits = digits.reverse();\n\
    \    String::from(digits)", "    let mut s = String::new();\n    let mut digits\
    \ = x.to_string();\n    for i in 0..shift {\n        s += &digits[(digits.len()\
    \ - i) % digits.len()];\n    }\n    s + &digits[digits.len() - shift]", "    let\
    \ mut s = String::new();\n    let mut digits = x.to_string();\n    for i in 0..shift\
    \ {\n        digits = digits[..digits.len() - i];\n    }\n    s += digits;\n \
    \   s", "    let mut result = String::new();\n    let mut digits = x.to_string();\n\
    \    for i in 0..shift {\n        result.push_str(&digits[(digits.len() - i) %\
    \ digits.len()]);\n    }\n    result", "    let mut s = String::new();\n    let\
    \ mut digits = x.to_string();\n    for i in 0..shift {\n        s += &digits[(digits.len()\
    \ - i) % digits.len()];\n    }\n    s + &digits[digits.len() - shift]", "    let\
    \ mut s = String::new();\n    let mut digits = x.to_string();\n    for i in 0..shift\
    \ {\n        s += digits[i as usize];\n    }\n    s += digits[shift as usize..];\n\
    \    s", "    let mut s = String::new();\n    let mut remainder = x;\n    let\
    \ mut shift = shift % 10;\n    while shift != 0 {\n        remainder = remainder\
    \ / 10;\n        shift = shift % 10;\n        s.push((remainder % 10) + shift);\n\
    \    }\n    String::from(s)", "    let mut s = String::new();\n    let mut digits\
    \ = x.to_string();\n    let mut shift = shift % digits.len();\n    while shift\
    \ > 0 {\n        digits = digits.chars().skip(shift).collect::<String>();\n  \
    \      shift -= digits.len();\n    }\n    digits = digits.chars().collect::<String>();\n\
    \    s += digits;\n    s", "    let mut s = String::new();\n    let mut carry\
    \ = 0;\n    for &d in x.to_string().chars() {\n        let digit = d.to_digit(10);\n\
    \        let digit = digit + carry % 10;\n        carry = digit / 10;\n      \
    \  s += digit.to_string();\n    }\n    if carry > 0 {\n        s += carry.to_string();\n\
    \    }\n    if shift > s.len() {\n        s[s.len() - shift..].to_owned()\n  \
    \  } else {\n        s[0..shift].to_owned()\n    }", "    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    for i in 0..shift {\n        s += &digits[(digits.len()\
    \ - i) % digits.len()];\n    }\n    String::from(s)", "    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    for i in 0..shift {\n        s += digits[i\
    \ as usize];\n    }\n    s += digits[shift as usize..];\n    s", "    let mut\
    \ s = String::new();\n    let mut remainder = x;\n    while remainder > 0 {\n\
    \        remainder %= 10;\n        s.push((remainder as char).to_string());\n\
    \        remainder /= 10;\n    }\n    if shift > s.len() {\n        s.push((remainder\
    \ as char).to_string());\n    }\n    String::from(s)", "    let mut s = String::new();\n\
    \    let mut carry = 0;\n    let mut digits = x.to_string().chars().enumerate().map(|(i,\
    \ c)| {\n        if i >= shift {\n            carry += 1;\n            i -= shift;\n\
    \        }\n        let digit = c.to_digit(10);\n        s.push((digit as char)\
    \ + &carry);\n        carry = 0;\n        digit\n    });\n    if carry > 0 {\n\
    \        s.push((carry as char) + &carry);\n    }\n    String::from(s)"]
stop_tokens:
- "\n}"
