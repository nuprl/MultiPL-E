name: HumanEval_115_max_fill
language: rs
prompt: "/// You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each well\
  \ has a corresponding bucket that can be used to extract water from it, \n/// and\
  \ all buckets have the same capacity.\n/// Your task is to use the buckets to empty\
  \ the wells.\n/// Output the number of times you need to lower the buckets.\n///\
  \ Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
  \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
  \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
  \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
  /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <=\
  \ grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\n\
  fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
  \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
  \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n   \
  \ assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
  \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1,\
  \ 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
completions: ["    let mut cnt = 0;\n    let mut min_bucket = grid[0].len();\n   \
    \ for row in grid.iter() {\n        let mut min_bucket = row.len();\n        for\
    \ col in row.iter() {\n            if col == 0 {\n                min_bucket =\
    \ std::cmp::min(min_bucket, min_bucket);\n            }\n        }\n        cnt\
    \ += min_bucket - min_bucket % capacity;\n    }\n    cnt", "    let mut ans =\
    \ isize::MAX;\n    let mut buckets = vec![vec![0; capacity]; grid.len()];\n  \
    \  for row in grid.iter() {\n        let mut bucket = buckets[row.len()].clone();\n\
    \        for cell in row.iter() {\n            if cell == 1 {\n              \
    \  bucket[cell] = 1;\n            } else {\n                bucket[cell] = bucket[cell]\
    \ - 1;\n            }\n        }\n        if bucket.iter().all(|&b| b == 0) &&\
    \ buckets.iter().all(|&b| b.iter().all(|&b| b == 0)) {\n            ans = ans.saturating_sub(1);\n\
    \        }\n    }\n    ans", "    let mut cnt = 0;\n    for row in grid.iter()\
    \ {\n        for col in row.iter() {\n            if *col == 0 {\n           \
    \     cnt += 1;\n            }\n        }\n    }\n    cnt += max_fill_helper(grid,\
    \ capacity);\n    cnt", "    let mut max_flow = 0;\n    let mut flow = 0;\n  \
    \  for row in grid.iter() {\n        let mut flow = row[0];\n        let mut max_flow\
    \ = flow;\n        for row in grid.iter() {\n            if row[0] == 0 {\n  \
    \              flow -= 1;\n            } else {\n                flow += 1;\n\
    \            }\n            if flow > max_flow {\n                max_flow = flow;\n\
    \            }\n        }\n    }\n    return max_flow;", "    let mut cnt = 0;\n\
    \    let mut max_cnt = 0;\n    let mut min_cnt = std::i32::MAX;\n    let mut min_grid\
    \ = grid.clone();\n    let mut min_capacity = capacity;\n    while min_cnt > 0\
    \ {\n        let mut min_grid = min_grid.clone();\n        for r in 0..min_grid.len()\
    \ {\n            for c in 0..min_grid[r].len() {\n                if min_grid[r][c]\
    \ == 1 {\n                    min_grid[r][c] = 0;\n                    min_cnt\
    \ -= 1;\n                }\n            }\n        }\n        let mut min_capacity\
    \ = min_capacity;\n        for r in 0..min_grid.len() {\n            for c in\
    \ 0..min_grid[r].len() {\n                if min_grid[r][c] == 0 {\n         \
    \           min_capacity -= 1;\n                }\n            }\n        }\n\
    \        if min_capacity == 0 {\n            cnt += 1;\n        }\n        if\
    \ min_capacity < capacity {\n            max_cnt = cnt;\n            cnt = 1;\n\
    \            min_cnt = std::i32::MAX;\n            min_grid = min_grid.clone();\n\
    \            min_capacity = capacity;\n        }\n    }\n    max_cnt", "    let\
    \ mut cnt = 0;\n    let mut min_bucket = grid[0].len();\n    for row in grid.iter()\
    \ {\n        let mut min_bucket = row[0].len();\n        for col in row.iter()\
    \ {\n            if col[0] == 0 {\n                cnt += 1;\n               \
    \ min_bucket = min(min_bucket, col[1]);\n            }\n        }\n        if\
    \ min_bucket < capacity {\n            cnt += 1;\n            min_bucket = capacity;\n\
    \        }\n    }\n    cnt", "    let mut cnt = 0;\n    let mut max_cnt = 0;\n\
    \    let mut max_grid = grid.clone();\n    for row in 0..grid.len() {\n      \
    \  for col in 0..grid[row].len() {\n            if grid[row][col] == 1 {\n   \
    \             cnt += 1;\n                max_cnt = std::cmp::max(max_cnt, cnt);\n\
    \                grid[row][col] = 0;\n            }\n        }\n    }\n    for\
    \ row in 0..grid.len() {\n        for col in 0..grid[row].len() {\n          \
    \  if grid[row][col] == 0 {\n                grid[row][col] = 1;\n           \
    \     cnt -= 1;\n                max_cnt = std::cmp::max(max_cnt, cnt);\n    \
    \        }\n        }\n    }\n    max_cnt", "    let mut cnt = 0;\n    let mut\
    \ max_cnt = 0;\n    let mut max_well = vec![vec![0; capacity]; grid.len()];\n\
    \    let mut min_well = vec![vec![0; capacity]; grid.len()];\n    for row in grid.iter()\
    \ {\n        let mut cnt = 0;\n        for col in row.iter() {\n            if\
    \ col == 1 {\n                cnt += 1;\n            }\n        }\n        if\
    \ cnt > max_cnt {\n            max_cnt = cnt;\n            max_well = row;\n \
    \       }\n    }\n    for row in grid.iter() {\n        let mut cnt = 0;\n   \
    \     for col in row.iter() {\n            if col == 0 {\n                cnt\
    \ += 1;\n            }\n        }\n        if cnt < min_well[row.len() - 1][col.len()\
    \ - 1] {\n            min_well = row;\n        }\n    }\n    cnt += max_cnt -\
    \ min_well[grid.len() - 1][grid.len() - 1];\n    cnt", "    let mut cnt = 0;\n\
    \    let mut max_cnt = 0;\n    let mut min_cnt = std::i32::MAX;\n    let mut min_bucket\
    \ = std::i32::MAX;\n    for row in grid.iter() {\n        let mut cnt = 0;\n \
    \       let mut max_cnt = 0;\n        let mut min_cnt = std::i32::MAX;\n     \
    \   let mut min_bucket = std::i32::MAX;\n        for col in row.iter() {\n   \
    \         if *col == 1 {\n                cnt += 1;\n                if cnt >\
    \ max_cnt {\n                    max_cnt = cnt;\n                }\n         \
    \       if min_cnt > cnt {\n                    min_cnt = cnt;\n             \
    \   }\n                if min_bucket > cnt {\n                    min_bucket =\
    \ cnt;\n                }\n            }\n        }\n        if min_cnt > capacity\
    \ {\n            cnt -= min_cnt - capacity;\n        }\n        if cnt > capacity\
    \ {\n            cnt -= capacity - min_cnt;\n        }\n        if cnt > max_cnt\
    \ {\n            max_cnt = cnt;\n        }\n        if min_cnt > max_cnt {\n \
    \           min_cnt = max_cnt;\n        }\n        if min_bucket > max_cnt {\n\
    \            min_bucket = max_cnt;\n        }\n        cnt -= min_bucket - capacity;\n\
    \        if cnt > capacity {\n            cnt -= capacity - min_bucket;\n    \
    \    }\n        if cnt > max_cnt {\n            max_cnt = cnt;\n        }\n  \
    \      if min_cnt > max_cnt {\n            min_cnt = max_cnt;\n        }\n   \
    \     if min_bucket > max_cnt {\n            min_bucket = max_cnt;\n        }\n\
    \        cnt -= min_bucket - capacity;\n        if cnt > capacity {\n        \
    \    cnt -= capacity - min_bucket;\n        }\n        if cnt > max_cnt {\n  \
    \          max_cnt = cnt;\n        }\n        if min_cnt > max_cnt {\n       \
    \     min_cnt = max_cnt;\n        }\n        if min_bucket > max_cnt {\n     \
    \       min_bucket = max_cnt;\n        }\n        cnt -= min_bucket - capacity;\n\
    \        if cnt > capacity {\n            cnt -= capacity - min_bucket;\n    \
    \    }\n        if cnt > max_cnt {\n            max_cnt = cnt;\n        }\n  \
    \      if min_cnt > max_cnt {\n            min_cnt = max_cnt;\n        }\n   \
    \     if min_bucket > max_cnt {\n            min_bucket = max_cnt;\n        }\n\
    \        cnt -= min_bucket - capacity;\n        if cnt > capacity {\n        \
    \    cnt -= capacity - min_bucket;\n        }\n        if cnt > max_cnt {\n  \
    \          max_cnt = cnt;\n        }\n        if min_cnt > max_cnt {\n       \
    \     min_cnt = max_cnt", "    let mut cnt = 0;\n    let mut max_cnt = 0;\n  \
    \  let mut max_grid = grid.clone();\n    for row in 0..grid.len() {\n        for\
    \ col in 0..grid[row].len() {\n            if grid[row][col] == 1 {\n        \
    \        cnt += 1;\n                if cnt > max_cnt {\n                    max_cnt\
    \ = cnt;\n                    max_grid = grid.clone();\n                }\n  \
    \          }\n        }\n    }\n    cnt", "    let mut counter = 0;\n    let mut\
    \ max_capacity = 0;\n    for row in grid.iter() {\n        let mut max_row = 0;\n\
    \        for cell in row.iter() {\n            if cell == 1 {\n              \
    \  max_row += 1;\n            }\n        }\n        if max_row > max_capacity\
    \ {\n            max_capacity = max_row;\n        }\n    }\n    for row in grid.iter()\
    \ {\n        let mut max_row = 0;\n        for cell in row.iter() {\n        \
    \    if cell == 1 {\n                max_row += 1;\n            }\n        }\n\
    \        if max_row > max_capacity {\n            counter += 1;\n        }\n \
    \   }\n    counter", "    let mut max_flow = 0;\n    let mut flow = 0;\n    let\
    \ mut flow_index = 0;\n    let mut flow_index2 = 0;\n    let mut flow_index3 =\
    \ 0;\n    let mut flow_index4 = 0;\n    let mut flow_index5 = 0;\n    let mut\
    \ flow_index6 = 0;\n    let mut flow_index7 = 0;\n    let mut flow_index8 = 0;\n\
    \    let mut flow_index9 = 0;\n    let mut flow_index10 = 0;\n    let mut flow_index11\
    \ = 0;\n    let mut flow_index12 = 0;\n    let mut flow_index13 = 0;\n    let\
    \ mut flow_index14 = 0;\n    let mut flow_index15 = 0;\n    let mut flow_index16\
    \ = 0;\n    let mut flow_index17 = 0;\n    let mut flow_index18 = 0;\n    let\
    \ mut flow_index19 = 0;\n    let mut flow_index20 = 0;\n    let mut flow_index21\
    \ = 0;\n    let mut flow_index22 = 0;\n    let mut flow_index23 = 0;\n    let\
    \ mut flow_index24 = 0;\n    let mut flow_index25 = 0;\n    let mut flow_index26\
    \ = 0;\n    let mut flow_index27 = 0;\n    let mut flow_index28 = 0;\n    let\
    \ mut flow_index29 = 0;\n    let mut flow_index30 = 0;\n    let mut flow_index31\
    \ = 0;\n    let mut flow_index32 = 0;\n    let mut flow_index33 = 0;\n    let\
    \ mut flow_index34 = 0;\n    let mut flow_index35 = 0;\n    let mut flow_index36\
    \ = 0;\n    let mut flow_index37 = 0;\n    let mut flow_index38 = 0;\n    let\
    \ mut flow_index39 = 0;\n    let mut flow_index40 = 0;\n    let mut flow_index41\
    \ = 0;\n    let mut flow_index42 = 0;\n    let mut flow_index43 = 0;\n    let\
    \ mut flow_index44 = 0;\n    let mut flow_index45 = 0;\n    let mut flow_index46\
    \ = 0;\n    let mut flow_index47 = 0;\n    let mut flow_index48 = 0;\n    let\
    \ mut flow_index49 = 0;\n    let mut flow_index50 = 0;\n    let mut flow_index51\
    \ = 0;\n    let mut flow_index52 = 0;\n    let mut flow_index53 = 0;\n    let\
    \ mut flow_index54 = 0;\n    let mut flow_index55 = 0;\n    let mut flow_index56\
    \ = 0;\n    let mut flow_index57 = 0;\n    let mut flow_index58 = 0;\n    let\
    \ mut flow_index59 = 0;\n    let mut flow_index60 = 0;\n    let mut flow_index61\
    \ = 0;\n    let mut flow_index62 = 0;\n    let mut flow_index63 = 0;\n", "   \
    \ let mut cnt = 0;\n    for row in grid.iter() {\n        let mut cnt = 0;\n \
    \       for cell in row.iter() {\n            if cell == 1 {\n               \
    \ cnt += 1;\n            }\n        }\n        if cnt > capacity {\n         \
    \   cnt -= 1;\n        }\n        cnt += 1;\n    }\n    cnt", "    let mut cnt\
    \ = 0;\n    let mut max_capacity = 0;\n    for row in grid.iter() {\n        let\
    \ mut max_row = 0;\n        for col in row.iter() {\n            if col == 0 {\n\
    \                max_row += 1;\n            }\n        }\n        if max_row >\
    \ max_capacity {\n            max_capacity = max_row;\n        }\n    }\n    for\
    \ row in grid.iter() {\n        let mut max_row = 0;\n        for col in row.iter()\
    \ {\n            if col == 0 {\n                cnt += 1;\n            }\n   \
    \     }\n        if max_row > max_capacity {\n            max_capacity = max_row;\n\
    \        }\n    }\n    cnt", "    let mut cnt = 0;\n    let mut max_capacity =\
    \ capacity;\n    for row in grid.iter() {\n        let mut cnt = 0;\n        let\
    \ mut max_capacity = capacity;\n        for cell in row.iter() {\n           \
    \ if cell == 1 {\n                cnt += 1;\n                if cnt > max_capacity\
    \ {\n                    max_capacity = cnt;\n                }\n            }\n\
    \        }\n        cnt += 1;\n        if cnt > max_capacity {\n            max_capacity\
    \ = cnt;\n        }\n    }\n    return max_capacity;", "    let mut cnt = 0;\n\
    \    let mut max_cnt = 0;\n    let mut max_grid = grid.clone();\n    for row in\
    \ grid.iter() {\n        let mut cnt = 0;\n        for col in row.iter() {\n \
    \           if *col == 1 {\n                cnt += 1;\n            }\n       \
    \ }\n        if cnt > max_cnt {\n            max_cnt = cnt;\n            max_grid\
    \ = row.clone();\n        }\n    }\n    for row in max_grid.iter() {\n       \
    \ for col in row.iter() {\n            if *col == 0 {\n                *col =\
    \ 1;\n            }\n        }\n    }\n    for row in grid.iter() {\n        for\
    \ col in row.iter() {\n            if *col == 0 {\n                *col = 1;\n\
    \            }\n        }\n    }\n    for row in max_grid.iter() {\n        for\
    \ col in row.iter() {\n            if *col == 1 {\n                *col = 0;\n\
    \            }\n        }\n    }\n    for row in grid.iter() {\n        for col\
    \ in row.iter() {\n            if *col == 1 {\n                *col = 0;\n   \
    \         }\n        }\n    }\n    for row in max_grid.iter() {\n        for col\
    \ in row.iter() {\n            if *col == 0 {\n                *col = 1;\n   \
    \         }\n        }\n    }\n    for row in grid.iter() {\n        for col in\
    \ row.iter() {\n            if *col == 1 {\n                *col = 0;\n      \
    \      }\n        }\n    }\n    for row in max_grid.iter() {\n        for col\
    \ in row.iter() {\n            if *col == 0 {\n                *col = 1;\n   \
    \         }\n        }\n    }\n    for row in grid.iter() {\n        for col in\
    \ row.iter() {\n            if *col == 1 {\n                *col = 0;\n      \
    \      }\n        }\n    }\n    for row in max_grid.iter() {\n        for col\
    \ in row.iter() {\n            if *col == 0 {\n                *col = 1;\n   \
    \         }\n        }\n    }\n    for row in grid.iter() {\n        for col in\
    \ row.iter() {\n            if *col == 1 {\n                *col = 0;\n      \
    \      }\n        }\n    }\n    for row in max_grid.iter() {\n        for col\
    \ in row.iter() {\n            if *col == 0 {\n                *col = 1;\n   \
    \         }\n        }\n    }\n    for row in grid.iter() {\n        for col in\
    \ row.iter() {\n            if *col == 1 {\n                *col = 0;\n      \
    \      }\n        }\n    }\n    for row in max_grid.iter() {\n        for col\
    \ in row.iter() {\n            if *col == 0 {\n                *col = 1;\n   \
    \         }\n        }\n    }\n    for row in grid.iter() {\n        for col in\
    \ row.iter() {\n            if *col == 1 {\n                *col = 0;\n      \
    \      }\n        }\n    }\n    for row in max_grid.iter() {\n        for col\
    \ in row.iter() {\n            if *col == 0 {\n                *col = 1;", " \
    \   let mut cnt = 0;\n    for row in grid.iter() {\n        let mut cnt = 0;\n\
    \        for cell in row.iter() {\n            if cell == 1 {\n              \
    \  cnt += 1;\n            }\n        }\n        if cnt > capacity {\n        \
    \    cnt -= 1;\n        }\n        cnt += 1;\n    }\n    cnt", "    let mut cnt\
    \ = 0;\n    let mut max_cnt = 0;\n    let mut max_grid = grid.clone();\n    for\
    \ row in 0..grid.len() {\n        for col in 0..grid[row].len() {\n          \
    \  if grid[row][col] == 1 {\n                cnt += 1;\n                if cnt\
    \ > max_cnt {\n                    max_cnt = cnt;\n                    max_grid\
    \ = grid.clone();\n                }\n            }\n        }\n    }\n    max_cnt\
    \ += 1;\n    if max_cnt > capacity {\n        max_cnt = capacity;\n        max_grid\
    \ = grid.clone();\n    }\n    max_cnt", "    let mut cnt = 0;\n    let mut max_cnt\
    \ = 0;\n    let mut min_cnt = std::i32::MAX;\n    for row in grid.iter() {\n \
    \       let mut cnt = 0;\n        for col in row.iter() {\n            if *col\
    \ == 1 {\n                cnt += 1;\n            }\n        }\n        if cnt\
    \ > max_cnt {\n            max_cnt = cnt;\n        }\n        if cnt < min_cnt\
    \ {\n            min_cnt = cnt;\n        }\n    }\n    if max_cnt > capacity {\n\
    \        max_cnt = capacity;\n    }\n    if min_cnt < capacity {\n        min_cnt\
    \ = capacity;\n    }\n    cnt -= min_cnt;\n    cnt += max_cnt;\n    cnt", "  \
    \  let mut cnt = 0;\n    let mut buckets = vec![0; grid.len()];\n    for row in\
    \ grid.iter() {\n        let mut cur_cap = buckets[row.len() - 1];\n        for\
    \ cell in row.iter() {\n            if cell == 1 {\n                cur_cap -=\
    \ 1;\n            }\n            buckets[cell.len() - 1] += cur_cap;\n       \
    \ }\n    }\n    for bucket in buckets.iter() {\n        if bucket > capacity {\n\
    \            cnt += 1;\n        }\n    }\n    cnt"]
stop_tokens:
- "\n}"
