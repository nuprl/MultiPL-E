language: rs
name: HumanEval_132_is_nested
results:
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp152c764l.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpicgbg3uz.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpzqtrjr79.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n\
    \    let mut open_brackets: usize = 0;\n    let mut close_brackets: usize = 0;\n\
    \    for c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n\
    \            open_brackets += 1;\n        } else if c == '{' {\n            stack.push(c);\n\
    \            open_brackets += 1;\n        } else if c == '}' {\n            close_brackets\
    \ += 1;\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else if c == '[' {\n       \
    \     close_brackets += 1;\n            if stack.len() == 0 {\n              \
    \  return false;\n            }\n            stack.pop();\n        } else if c\
    \ == '}' {\n            close_brackets += 1;\n            if stack.len() == 0\
    \ {\n                return false;\n            }\n            stack.pop();\n\
    \        } else if c == '[' {\n            stack.push(c);\n            open_brackets\
    \ += 1;\n        } else if c == '}' {\n            close_brackets += 1;\n    \
    \        if stack.len() == 0 {\n                return false;\n            }\n\
    \            stack.pop();\n        }\n    }\n    stack.len() == 0 && close_brackets\
    \ == open_brackets\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptc9zah03.rs:22:24\n   |\n\
    22 |             stack.push(c);\n   |                        ^ expected `usize`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptc9zah03.rs:25:24\n\
    \   |\n25 |             stack.push(c);\n   |                        ^ expected\
    \ `usize`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptc9zah03.rs:46:24\n\
    \   |\n46 |             stack.push(c);\n   |                        ^ expected\
    \ `usize`, found `char`\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4g6g31g1.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = Vec::new();\n\
    \    let mut open_brackets: usize = 0;\n    let mut close_brackets: usize = 0;\n\
    \    let mut open_brackets_stack: Vec<usize> = Vec::new();\n    let mut close_brackets_stack:\
    \ Vec<usize> = Vec::new();\n    let mut open_brackets_stack_len: usize = 0;\n\
    \    let mut close_brackets_stack_len: usize = 0;\n    let mut open_brackets_stack_len2:\
    \ usize = 0;\n    let mut close_brackets_stack_len2: usize = 0;\n    let mut open_brackets_stack_len3:\
    \ usize = 0;\n    let mut close_brackets_stack_len3: usize = 0;\n    let mut open_brackets_stack_len4:\
    \ usize = 0;\n    let mut close_brackets_stack_len4: usize = 0;\n    let mut open_brackets_stack_len5:\
    \ usize = 0;\n    let mut close_brackets_stack_len5: usize = 0;\n    let mut open_brackets_stack_len6:\
    \ usize = 0;\n    let mut close_brackets_stack_len6: usize = 0;\n    let mut open_brackets_stack_len7:\
    \ usize = 0;\n    let mut close_brackets_stack_len7: usize = 0;\n    let mut open_brackets_stack_len8:\
    \ usize = 0;\n    let mut close_brackets_stack_len8: usize = 0;\n    let mut open_brackets_stack_len9:\
    \ usize = 0;\n    let mut close_brackets_stack_len9: usize = 0;\n    let mut open_brackets_stack_len10:\
    \ usize = 0;\n    let mut close_brackets_stack_len10: usize = 0;\n    let mut\
    \ open_brackets_stack_len11: usize = 0;\n    let mut close_brackets_stack_len11:\
    \ usize = 0;\n    let mut open_brackets_stack_len12: usize = 0;\n    let mut close_brackets_stack_len12:\
    \ usize = 0;\n    let mut open_brackets_stack_len13: usize = 0;\n    let mut close_brackets_stack_len13:\
    \ usize = 0;\n    let mut open_brackets_stack_len14: usize = 0;\n    let mut close_brackets_\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpnl2dru_1.rs:49:28\n   |\n\
    49 |     let mut close_brackets_\n   |                            ^ help: add\
    \ `;` here\n50 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnl2dru_1.rs:16:33\n   |\n16 | fn is_nested(string: String) -> bool\
    \ {\n   |    ---------                    ^^^^ expected `bool`, found `()`\n \
    \  |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = Vec::new();\n\
    \    let mut open_brackets: usize = 0;\n    let mut close_brackets: usize = 0;\n\
    \    let mut i = 0;\n    while i < string.len() {\n        if string[i] == ']'\
    \ {\n            close_brackets++;\n            if close_brackets == 1 {\n   \
    \             stack.pop();\n            }\n        } else if string[i] == '['\
    \ {\n            open_brackets++;\n            if open_brackets == 1 {\n     \
    \           stack.push(i);\n            }\n        } else {\n            close_brackets\
    \ = 0;\n            open_brackets = 0;\n        }\n        i += 1;\n    }\n  \
    \  stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpk__nke70.rs:23:27\n\
    \   |\n23 |             close_brackets++;\n   |                           ^^ not\
    \ a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n23 |       \
    \      { let tmp = close_brackets; close_brackets += 1; tmp };\n   |         \
    \    +++++++++++               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n23 -            \
    \ close_brackets++;\n23 +             close_brackets += 1;\n   | \n\nerror: Rust\
    \ has no postfix increment operator\n  --> /tmp/tmpk__nke70.rs:28:26\n   |\n28\
    \ |             open_brackets++;\n   |                          ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n28 |             { let\
    \ tmp = open_brackets; open_brackets += 1; tmp };\n   |             +++++++++++\
    \              ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n28 -             open_brackets++;\n\
    28 +             open_brackets += 1;\n   | \n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpk__nke70.rs:22:12\n   |\n22 |  \
    \       if string[i] == ']' {\n   |            ^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpk__nke70.rs:27:19\n   |\n27 |         } else if string[i] == '['\
    \ {\n   |                   ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n      "
  stdout: ''
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n\
    \    let mut index = 0;\n    let mut open_brackets = 0;\n    let mut close_brackets\
    \ = 0;\n    while index < string.len() {\n        if string[index] == '[' {\n\
    \            stack.push(index);\n            open_brackets += 1;\n        }\n\
    \        if string[index] == ']' {\n            close_brackets += 1;\n       \
    \     if open_brackets > close_brackets {\n                return true;\n    \
    \        }\n        }\n        index += 1;\n    }\n    false\n}\n\nfn main() {\n\
    \    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\"\
    )), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpz1zujw2p.rs:22:12\n\
    \   |\n22 |         if string[index] == '[' {\n   |            ^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpz1zujw2p.rs:26:12\n   |\n26 |         if string[index] == ']' {\n\
    \   |            ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp8dmqj7df.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp7d8d8wt7.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpkuo53p8w.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n\
    \    let mut bracket_count = 1;\n    let mut bracket_stack: Vec<usize> = vec![];\n\
    \    let mut bracket_stack_count = 1;\n    let mut bracket_stack_string: String\
    \ = String::new();\n    let mut bracket_stack_string_count = 0;\n    let mut bracket_stack_string_index\
    \ = 0;\n    let mut bracket_stack_string_len = 0;\n    let mut bracket_stack_string_p\
    \ = &mut bracket_stack_string;\n    let mut bracket_stack_string_p = &mut bracket_stack_string;\n\
    \    let mut bracket_stack_string_p = &mut bracket_stack_string;\n    let mut\
    \ bracket_stack_string_p = &mut bracket_stack_string;\n    let mut bracket_stack_string_p\
    \ = &mut bracket_stack_string;\n    let mut bracket_stack_string_p = &mut bracket_stack_string;\n\
    \    let mut bracket_stack_string_p = &mut bracket_stack_string;\n    let mut\
    \ bracket_stack_string_p = &mut bracket_stack_string;\n    let mut bracket_stack_string_p\
    \ = &mut bracket_stack_string;\n    let mut bracket_stack_string_p = &mut bracket_stack_string;\n\
    \    let mut bracket_stack_string_p = &mut bracket_stack_string;\n    let mut\
    \ bracket_stack_string_p = &mut bracket_stack_string;\n    let mut bracket_stack_string_p\
    \ = &mut bracket_stack_string;\n    let mut bracket_stack_string_p = &mut bracket_stack_string;\n\
    \    let mut bracket_stack_string_p = &mut bracket_stack_string;\n    let mut\
    \ bracket_stack_string_p = &mut bracket_stack_string;\n    let mut bracket_stack_string_p\
    \ = &mut bracket_stack_string;\n    let mut bracket_stack_string_p = &mut bracket_stack_string;\n\
    \    let mut bracket_stack_string_p = &mut bracket_stack_string;\n    let mut\
    \ bracket_stack_string_p = &mut bracket_stack_string;\n    let mut bracket_stack_string_p\
    \ = &mu\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp0qyt7rp_.rs:45:41\n   |\n\
    45 |     let mut bracket_stack_string_p = &mu\n   |                          \
    \               ^ help: add `;` here\n46 | }\n   | - unexpected token\n\nerror[E0425]:\
    \ cannot find value `mu` in this scope\n  --> /tmp/tmp0qyt7rp_.rs:45:39\n   |\n\
    45 |     let mut bracket_stack_string_p = &mu\n   |                          \
    \             ^^ not found in this scope\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp0qyt7rp_.rs:16:33\n   |\n16 | fn is_nested(string: String) -> bool\
    \ {\n   |    ---------                    ^^^^ expected `bool`, found `()`\n \
    \  |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpbbjpl_qp.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpc_4mzrs8.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = Vec::new();\n\
    \    let mut bracket_count = 0;\n    let mut bracket_open = false;\n    let mut\
    \ bracket_closed = false;\n    let mut bracket_opening_count = 0;\n    let mut\
    \ bracket_opening_open = false;\n    let mut bracket_opening_closed = false;\n\
    \    let mut bracket_closing_count = 0;\n    let mut bracket_closing_open = false;\n\
    \    let mut bracket_closing_closed = false;\n    let mut bracket_opening_opening_count\
    \ = 0;\n    let mut bracket_opening_opening_open = false;\n    let mut bracket_opening_opening_closed\
    \ = false;\n    let mut bracket_opening_closing_count = 0;\n    let mut bracket_opening_closing_open\
    \ = false;\n    let mut bracket_opening_closing_closed = false;\n    let mut bracket_closing_opening_count\
    \ = 0;\n    let mut bracket_closing_opening_open = false;\n    let mut bracket_closing_opening_closed\
    \ = false;\n    let mut bracket_closing_closing_count = 0;\n    let mut bracket_closing_closing_open\
    \ = false;\n    let mut bracket_closing_closing_closed = false;\n    let mut bracket_closing_opening_opening_count\
    \ = 0;\n    let mut bracket_closing_opening_opening_open = false;\n    let mut\
    \ bracket_closing_opening_opening_closed = false;\n    let mut bracket_closing_opening_closing_count\
    \ = 0;\n    let mut bracket_closing_opening_closing_open = false;\n    let mut\
    \ bracket_closing_opening_closing_closed = false;\n    let mut bracket_closing_closing_opening_opening_count\
    \ = 0;\n    let mut bracket_closing_closing_opening_opening_open = false;\n  \
    \  let mut bracket_closing_closing_opening_opening_closed = false;\n    let mut\
    \ bracket_closing_closing_opening_closing_count = 0;\n    let mut bracket_closing_closing_opening_closing_open\
    \ = false;\n    let mut bracket_closing_closing_opening_closing_closed = false;\n\
    \    let mut bracket_closing_closing_closing_opening_opening_count = 0;\n    let\
    \ mut bracket_closing_closing_closing_opening_opening_open = false;\n    let mut\
    \ bracket_closing_closing_opening_closing_opening_closed = false;\n    let mut\
    \ bracket_closing_closing_\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_zsfsbmn.rs:54:37\n   |\n\
    54 |     let mut bracket_closing_closing_\n   |                              \
    \       ^ help: add `;` here\n55 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_zsfsbmn.rs:16:33\n   |\n16 | fn is_nested(string:\
    \ String) -> bool {\n   |    ---------                    ^^^^ expected `bool`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpfg4de2lx.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(0);\n\
    \    let mut i = 0;\n    while i < string.len() {\n        if stack.is_empty()\
    \ {\n            return false;\n        }\n        let mut j = i;\n        while\
    \ j < string.len() && string[j] == string[stack.last()] {\n            j = j +\
    \ 1;\n        }\n        if j == i {\n            stack.pop();\n        } else\
    \ {\n            stack.push(j);\n        }\n        i = j;\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpq2iw71bt.rs:25:35\n\
    \   |\n25 |         while j < string.len() && string[j] == string[stack.last()]\
    \ {\n   |                                   ^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `Option<&{integer}>`\n\
    \  --> /tmp/tmpq2iw71bt.rs:25:48\n   |\n25 |         while j < string.len() &&\
    \ string[j] == string[stack.last()] {\n   |                                  \
    \              ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `Option<&{integer}>`\n\
    \   |\n   = help: the trait `Index<Option<&{integer}>>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    let\
    \ mut open_brackets = 0;\n    let mut closed_brackets = 0;\n    let mut i = 0;\n\
    \    while i < string.len() {\n        if string[i] == '[' {\n            stack.push(i);\n\
    \            open_brackets += 1;\n        } else if string[i] == ']' {\n     \
    \       closed_brackets += 1;\n            if open_brackets == closed_brackets\
    \ {\n                stack.pop();\n            } else {\n                open_brackets\
    \ -= 1;\n            }\n        } else {\n            i += 1;\n        }\n   \
    \ }\n    stack.len() == 0 && open_brackets == closed_brackets\n}\n\nfn main()\
    \ {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpspzdu75t.rs:22:12\n\
    \   |\n22 |         if string[i] == '[' {\n   |            ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpspzdu75t.rs:25:19\n   |\n25 |         } else if string[i] == ']'\
    \ {\n   |                   ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = vec![0;\
    \ string.len()];\n    let mut i = 0;\n    let mut open_brackets = 0;\n    while\
    \ i < string.len() {\n        if string[i] == ']' {\n            stack.pop();\n\
    \            open_brackets -= 1;\n        }\n        if string[i] == '[' {\n \
    \           stack.push(i);\n            open_brackets += 1;\n        }\n     \
    \   i += 1;\n    }\n    open_brackets == 0\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpva_lof9l.rs:21:12\n\
    \   |\n21 |         if string[i] == ']' {\n   |            ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpva_lof9l.rs:25:12\n   |\n25 |         if string[i] == '[' {\n \
    \  |            ^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = Vec::new();\n\
    \    let mut open_brackets: usize = 0;\n    let mut close_brackets: usize = 0;\n\
    \    for c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n\
    \            open_brackets += 1;\n        } else if c == '[' {\n            close_brackets\
    \ += 1;\n            if close_brackets == open_brackets {\n                stack.pop();\n\
    \                close_brackets -= 1;\n            }\n        }\n    }\n    stack.len()\
    \ == 0 && close_brackets == open_brackets\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoj_1mj59.rs:22:24\n   |\n\
    22 |             stack.push(c);\n   |                        ^ expected `usize`,\
    \ found `char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = Vec::new();\n\
    \    let mut open_brackets: usize = 0;\n    let mut close_brackets: usize = 0;\n\
    \    let mut open_brackets_stack: Vec<usize> = Vec::new();\n    let mut close_brackets_stack:\
    \ Vec<usize> = Vec::new();\n    let mut open_brackets_stack_index: usize = 0;\n\
    \    let mut close_brackets_stack_index: usize = 0;\n    let mut open_brackets_stack_index2:\
    \ usize = 0;\n    let mut close_brackets_stack_index2: usize = 0;\n    let mut\
    \ open_brackets_stack_index3: usize = 0;\n    let mut close_brackets_stack_index3:\
    \ usize = 0;\n    let mut open_brackets_stack_index4: usize = 0;\n    let mut\
    \ close_brackets_stack_index4: usize = 0;\n    let mut open_brackets_stack_index5:\
    \ usize = 0;\n    let mut close_brackets_stack_index5: usize = 0;\n    let mut\
    \ open_brackets_stack_index6: usize = 0;\n    let mut close_brackets_stack_index6:\
    \ usize = 0;\n    let mut open_brackets_stack_index7: usize = 0;\n    let mut\
    \ close_brackets_stack_index7: usize = 0;\n    let mut open_brackets_stack_index8:\
    \ usize = 0;\n    let mut close_brackets_stack_index8: usize = 0;\n    let mut\
    \ open_brackets_stack_index9: usize = 0;\n    let mut close_brackets_stack_index9:\
    \ usize = 0;\n    let mut open_brackets_stack_index10: usize = 0;\n    let mut\
    \ close_brackets_stack_index10: usize = 0;\n    let mut open_brackets_stack_index11:\
    \ usize = 0;\n    let mut close_brackets_stack_index11: usize = 0;\n    let mut\
    \ open_brackets_stack_index12: usize = 0;\n    let mut close_brackets_stack_index12:\
    \ usize = 0;\n    let mut open_brackets_stack_index13: usize = 0;\n    let mut\
    \ close_brackets_stack_index13: usize = 0;\n    let mut open_brackets_stack_index14:\
    \ usize = 0;\n    let mut close_brackets_\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpi3g3q1bm.rs:49:28\n   |\n\
    49 |     let mut close_brackets_\n   |                            ^ help: add\
    \ `;` here\n50 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpi3g3q1bm.rs:16:33\n   |\n16 | fn is_nested(string: String) -> bool\
    \ {\n   |    ---------                    ^^^^ expected `bool`, found `()`\n \
    \  |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = Vec::new();\n\
    \    stack.push(0);\n    let mut i = 0;\n    while i < string.len() {\n      \
    \  if string[i] == ']' {\n            if stack.is_empty() {\n                return\
    \ false;\n            }\n            let index = stack.pop();\n            if\
    \ index == i {\n                return true;\n            }\n        }\n     \
    \   stack.push(i);\n        i += 1;\n    }\n    false\n}\n\nfn main() {\n    let\
    \ candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpnl5sbfzi.rs:21:12\n\
    \   |\n21 |         if string[i] == ']' {\n   |            ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnl5sbfzi.rs:26:25\n\
    \   |\n26 |             if index == i {\n   |                         ^\n   |\
    \                         |\n   |                         expected enum `Option`,\
    \ found `usize`\n   |                         help: try using a variant of the\
    \ expected enum: `Some(i)`\n   |\n   = note: expected enum `Option<usize>`\n \
    \             found type `usize`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    let\
    \ mut open_brackets = 0;\n    for c in string.chars() {\n        if c == '[' {\n\
    \            stack.push(c);\n            open_brackets += 1;\n        } else if\
    \ c == ']' {\n            open_brackets -= 1;\n            if open_brackets ==\
    \ 0 {\n                stack.pop();\n            }\n        } else {\n       \
    \     stack.pop();\n        }\n    }\n    stack.len() == 0 && open_brackets ==\
    \ 0\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpyap6roq1.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n\
    \    let mut index = 0;\n    let mut open_brackets = 0;\n    let mut closed_brackets\
    \ = 0;\n    while index < string.len() {\n        if string[index] == '[' {\n\
    \            stack.push(index);\n            open_brackets += 1;\n        }\n\
    \        if string[index] == ']' {\n            closed_brackets += 1;\n      \
    \      if open_brackets == closed_brackets {\n                return true;\n \
    \           }\n        }\n        index += 1;\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpa6pefnrw.rs:22:12\n\
    \   |\n22 |         if string[index] == '[' {\n   |            ^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpa6pefnrw.rs:26:12\n   |\n26 |         if string[index]\
    \ == ']' {\n   |            ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = Vec::new();\n\
    \    let mut index = 0;\n    let mut bracket_count = 0;\n    while index < string.len()\
    \ {\n        if string[index] == '[' {\n            stack.push(index);\n     \
    \       bracket_count += 1;\n        }\n        if string[index] == ']' {\n  \
    \          bracket_count -= 1;\n            if bracket_count == 0 {\n        \
    \        stack.pop();\n            }\n        }\n        index += 1;\n    }\n\
    \    bracket_count == 0\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpd11t0cb4.rs:21:12\n\
    \   |\n21 |         if string[index] == '[' {\n   |            ^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpd11t0cb4.rs:25:12\n   |\n25 |         if string[index]\
    \ == ']' {\n   |            ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    let\
    \ mut open_brackets = Vec::new();\n    let mut close_brackets = Vec::new();\n\
    \    \n    for ch in string.chars() {\n        if ch == '[' {\n            stack.push(ch);\n\
    \            open_brackets.push(ch);\n        } else if ch == ']' {\n        \
    \    if stack.len() == 0 {\n                return false;\n            }\n   \
    \         \n            if open_brackets.len() == 0 {\n                return\
    \ false;\n            }\n            \n            if stack.pop() != open_brackets.pop()\
    \ {\n                return false;\n            }\n            \n            close_brackets.push(ch);\n\
    \        } else if ch == '[' {\n            if stack.len() == 0 {\n          \
    \      return false;\n            }\n            \n            if open_brackets.len()\
    \ == 0 {\n                return false;\n            }\n            \n       \
    \     if stack.pop() != open_brackets.pop() {\n                return false;\n\
    \            }\n            \n            if close_brackets.len() == 0 {\n   \
    \             return false;\n            }\n            \n            if close_brackets.pop()\
    \ != ch {\n                return false;\n            }\n        }\n    }\n  \
    \  \n    stack.len() == 0 && close_brackets.len() == 0\n}\n\nfn main() {\n   \
    \ let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkqtevkrg.rs:56:40\n   |\n\
    56 |             if close_brackets.pop() != ch {\n   |                       \
    \                 ^^\n   |                                        |\n   |    \
    \                                    expected enum `Option`, found `char`\n  \
    \ |                                        help: try using a variant of the expected\
    \ enum: `Some(ch)`\n   |\n   = note: expected enum `Option<char>`\n          \
    \    found type `char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = Vec::new();\n\
    \    let mut index = 0;\n    let mut open_brackets = 0;\n    let mut close_brackets\
    \ = 0;\n    let mut open_brackets_stack: Vec<usize> = Vec::new();\n    let mut\
    \ close_brackets_stack: Vec<usize> = Vec::new();\n    let mut open_brackets_index\
    \ = 0;\n    let mut close_brackets_index = 0;\n    let mut open_brackets_index2\
    \ = 0;\n    let mut close_brackets_index2 = 0;\n    let mut open_brackets_index3\
    \ = 0;\n    let mut close_brackets_index3 = 0;\n    let mut open_brackets_index4\
    \ = 0;\n    let mut close_brackets_index4 = 0;\n    let mut open_brackets_index5\
    \ = 0;\n    let mut close_brackets_index5 = 0;\n    let mut open_brackets_index6\
    \ = 0;\n    let mut close_brackets_index6 = 0;\n    let mut open_brackets_index7\
    \ = 0;\n    let mut close_brackets_index7 = 0;\n    let mut open_brackets_index8\
    \ = 0;\n    let mut close_brackets_index8 = 0;\n    let mut open_brackets_index9\
    \ = 0;\n    let mut close_brackets_index9 = 0;\n    let mut open_brackets_index10\
    \ = 0;\n    let mut close_brackets_index10 = 0;\n    let mut open_brackets_index11\
    \ = 0;\n    let mut close_brackets_index11 = 0;\n    let mut open_brackets_index12\
    \ = 0;\n    let mut close_brackets_index12 = 0;\n    let mut open_brackets_index13\
    \ = 0;\n    let mut close_brackets_index13 = 0;\n    let mut open_brackets_index14\
    \ = 0;\n    let mut close_brackets_index14 = 0;\n    let mut open_brackets_index15\
    \ = 0;\n    let mut close_brackets_index15 = 0;\n    let mut open_brackets_index16\
    \ = 0;\n    let mut close_brackets_index16 = 0;\n    let mut open_brackets_index17\
    \ = 0;\n    let mut close_brackets_index17 = 0;\n    let mut open_brackets_index18\
    \ = 0;\n    let mut close_brackets_index18 = 0;\n    let mut open_brackets_\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvhh0x9bx.rs:59:27\n   |\n\
    59 |     let mut open_brackets_\n   |                           ^ help: add `;`\
    \ here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpvhh0x9bx.rs:16:33\n   |\n16 | fn is_nested(string: String) -> bool {\n\
    \   |    ---------                    ^^^^ expected `bool`, found `()`\n   | \
    \   |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n\
    \    let mut index = 0;\n    let mut bracket_count = 0;\n    let mut bracket_depth\
    \ = 0;\n    let mut bracket_open = false;\n    let mut bracket_closed = false;\n\
    \    loop {\n        if index >= string.len() {\n            return bracket_count\
    \ == 0;\n        }\n        let c = string[index];\n        if c == '[' {\n  \
    \          bracket_open = true;\n            stack.push(index);\n            bracket_depth\
    \ += 1;\n        }\n        if c == '[' {\n            bracket_open = true;\n\
    \            stack.push(index);\n            bracket_depth += 1;\n        }\n\
    \        if c == '{' {\n            bracket_open = true;\n            stack.push(index);\n\
    \            bracket_depth += 1;\n        }\n        if c == '{' {\n         \
    \   bracket_open = true;\n            stack.push(index);\n            bracket_depth\
    \ += 1;\n        }\n        if c == '}' {\n            bracket_closed = true;\n\
    \            bracket_count -= 1;\n            if bracket_depth == 0 {\n      \
    \          bracket_count += 1;\n            }\n            bracket_depth -= 1;\n\
    \        }\n        if c == '}' {\n            bracket_closed = true;\n      \
    \      bracket_count -= 1;\n            if bracket_depth == 0 {\n            \
    \    bracket_count += 1;\n            }\n            bracket_depth -= 1;\n   \
    \     }\n        if c == ']' {\n            bracket_closed = true;\n         \
    \   bracket_count -= 1;\n            if bracket_depth == 0 {\n               \
    \ bracket_count += 1;\n            }\n            bracket_depth -= 1;\n      \
    \  }\n        if c == ']' {\n            bracket_closed = true;\n            bracket_count\
    \ -= 1;\n            if bracket_depth == 0 {\n                bracket_count +=\
    \ 1;\n            }\n            bracket_depth -= 1;\n        }\n        if c\
    \ == '[' {\n            bracket_open = true;\n            stack.push(index);\n\
    \            bracket_depth += 1;\n        }\n        if c == '{' {\n         \
    \   bracket_open = true;\n            stack.push(index);\n            bracket_depth\
    \ += 1;\n        }\n        if c == '}' {\n            bracket_closed = true;\n\
    \            bracket_count -= 1;\n            if bracket_depth == 0 {\n      \
    \          bracket_count += 1;\n            }\n            bracket_depth -= 1;\n\
    \        }\n        if c == '}' {\n            bracket_closed = true;\n      \
    \      \n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp_j4p9evi.rs:119:3\n\
    \    |\n16  | fn is_nested(string: String) -> bool {\n    |                  \
    \                    - unclosed delimiter\n...\n23  |     loop {\n    |      \
    \    - unclosed delimiter\n...\n98  |         if c == '}' {\n    |           \
    \          - this delimiter might not be properly closed...\n...\n101 | }\n  \
    \  | - ...as it matches this but it has different indentation\n...\n119 | }\n\
    \    |   ^\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n \
    \ --> /tmp/tmp_j4p9evi.rs:27:17\n   |\n27 |         let c = string[index];\n \
    \  |                 ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(0);\n\
    \    let mut i = 0;\n    while i < string.len() {\n        if string[i] == '['\
    \ {\n            stack.push(i);\n            i += 1;\n        } else if string[i]\
    \ == ']' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            let index = stack.pop();\n            if index ==\
    \ i {\n                return true;\n            }\n            i += 1;\n    \
    \    }\n        i += 1;\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpjcbctnkc.rs:21:12\n\
    \   |\n21 |         if string[i] == '[' {\n   |            ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpjcbctnkc.rs:24:19\n   |\n24 |         } else if string[i]\
    \ == ']' {\n   |                   ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpjcbctnkc.rs:29:25\n   |\n29 |  \
    \           if index == i {\n   |                         ^\n   |            \
    \             |\n   |                         expected enum `Option`, found `usize`\n\
    \   |                         help: try using a variant of the expected enum:\
    \ `Some(i)`\n   |\n   = note: expected enum `Option<usize>`\n              found\
    \ type `usize`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().all(|c| is_nested(c))\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8iz8g1z0.rs:17:38\n   |\n\
    17 |     string.chars().all(|c| is_nested(c))\n   |                          \
    \            ^- help: try using a conversion method: `.to_string()`\n   |    \
    \                                  |\n   |                                   \
    \   expected struct `String`, found `char`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n\
    \    let mut index = 0;\n    while index < string.len() {\n        if string[index]\
    \ == '[' {\n            stack.push(index);\n        }\n        if string[index]\
    \ == ']' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        }\n        index += 1;\n   \
    \ }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpgj9agnkf.rs:20:12\n\
    \   |\n20 |         if string[index] == '[' {\n   |            ^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpgj9agnkf.rs:23:12\n   |\n23 |         if string[index]\
    \ == ']' {\n   |            ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = Vec::new();\n\
    \    let mut i = 0;\n    let mut open_brackets = 0;\n    let mut closed_brackets\
    \ = 0;\n    while i < string.len() {\n        if string[i] == '[' {\n        \
    \    stack.push(i);\n            open_brackets += 1;\n        } else if string[i]\
    \ == ']' {\n            closed_brackets += 1;\n            if open_brackets ==\
    \ closed_brackets {\n                return true;\n            }\n           \
    \ open_brackets -= 1;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpwexkna4c.rs:22:12\n\
    \   |\n22 |         if string[i] == '[' {\n   |            ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpwexkna4c.rs:25:19\n   |\n25 |         } else if string[i]\
    \ == ']' {\n   |                   ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    let\
    \ mut open_brackets = 0;\n    let mut close_brackets = 0;\n    for c in string.chars()\
    \ {\n        if c == '[' {\n            stack.push(c);\n            open_brackets\
    \ += 1;\n        } else if c == '{' {\n            stack.push(c);\n          \
    \  open_brackets += 1;\n        } else if c == '}' {\n            close_brackets\
    \ += 1;\n            if open_brackets == close_brackets {\n                stack.pop();\n\
    \            }\n        } else if c == ']' {\n            close_brackets += 1;\n\
    \            if open_brackets == close_brackets {\n                stack.pop();\n\
    \            }\n        }\n    }\n    stack.len() == 0 && close_brackets == 0\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpf7wnqb2x.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    let\
    \ mut open_brackets = 0;\n    for c in string.chars() {\n        if c == '[' {\n\
    \            stack.push(c);\n            open_brackets += 1;\n        } else if\
    \ c == '[' && stack.len() > 0 {\n            stack.pop();\n            open_brackets\
    \ -= 1;\n        } else if c == '[' && open_brackets == 0 {\n            return\
    \ true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmplv6u9k_a.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = Vec::new();\n\
    \    let mut open_brackets: usize = 0;\n    let mut close_brackets: usize = 0;\n\
    \    let mut bracket_level: usize = 0;\n    let mut bracket_levels: Vec<usize>\
    \ = Vec::new();\n    let mut bracket_levels_len: usize = 0;\n    let mut bracket_levels_lens:\
    \ Vec<usize> = Vec::new();\n    let mut bracket_levels_lens_len: usize = 0;\n\
    \    let mut bracket_levels_lens_lens: Vec<usize> = Vec::new();\n    let mut bracket_levels_lens_lens_len:\
    \ usize = 0;\n    let mut bracket_levels_lens_lens_lens: Vec<usize> = Vec::new();\n\
    \    let mut bracket_levels_lens_lens_lens_len: usize = 0;\n    let mut bracket_levels_lens_lens_lens_lens:\
    \ Vec<usize> = Vec::new();\n    let mut bracket_levels_lens_lens_lens_lens_len:\
    \ usize = 0;\n    let mut bracket_levels_lens_lens_lens_lens_len: usize = 0;\n\
    \    let mut bracket_levels_lens_lens_lens_lens_lens_: usize = 0;\n    let mut\
    \ bracket_levels_lens_lens_lens_lens_lens_len: usize = 0;\n    let mut bracket_levels_lens_lens_lens_lens_lens_lens_:\
    \ usize = 0;\n    let mut bracket_levels_lens_lens_lens_lens_lens_lens_lens_:\
    \ usize = 0;\n    let mut bracket_levels_lens_lens_lens_lens_lens_lens_lens_lens_:\
    \ usize = 0;\n    let mut bracket_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_:\
    \ usize = 0;\n    let mut bracket_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_:\
    \ usize = 0;\n    let mut bracket_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_:\
    \ \n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected type, found `}`\n  --> /tmp/tmppcg3_rvm.rs:40:1\n   |\n\
    39 |     let mut bracket_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_:\
    \ \n   |         ------------------------------------------------------------------------------------\
    \ while parsing the type for `mut bracket_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_`\n\
    40 | }\n   | ^ expected type\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    let\
    \ mut open_brackets = 0;\n    for ch in string.chars() {\n        if ch == '['\
    \ {\n            stack.push(ch);\n            open_brackets += 1;\n        } else\
    \ if ch == ']' {\n            open_brackets -= 1;\n            if open_brackets\
    \ == 0 {\n                stack.pop();\n            }\n        } else {\n    \
    \        stack.push(ch);\n        }\n    }\n    stack.len() > 0 && stack.len()\
    \ == open_brackets\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp34opjzp3.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = Vec::new();\n\
    \    let mut open_brackets: usize = 0;\n    let mut closed_brackets: usize = 0;\n\
    \    let mut open_brackets_stack: Vec<usize> = Vec::new();\n    let mut closed_brackets_stack:\
    \ Vec<usize> = Vec::new();\n    let mut i = 0;\n    let mut j = 0;\n    let mut\
    \ k = 0;\n    while i < string.len() {\n        if string[i] == '[' {\n      \
    \      stack.push(open_brackets);\n            open_brackets_stack.push(open_brackets);\n\
    \            i += 1;\n        }\n        if string[i] == ']' {\n            closed_brackets\
    \ += 1;\n            closed_brackets_stack.push(closed_brackets);\n          \
    \  open_brackets -= 1;\n            i += 1;\n        }\n        if string[i] ==\
    \ '{' {\n            stack.push(closed_brackets);\n            closed_brackets_stack.push(closed_brackets);\n\
    \            i += 1;\n        }\n        if string[i] == '}' {\n            closed_brackets\
    \ -= 1;\n            closed_brackets_stack.push(closed_brackets);\n          \
    \  open_brackets += 1;\n            i += 1;\n        }\n        if string[i] ==\
    \ ']' && open_brackets == 0 {\n            closed_brackets += 1;\n           \
    \ closed_brackets_stack.push(closed_brackets);\n            i += 1;\n        }\n\
    \        if string[i] == '}' && closed_brackets == 0 {\n            open_brackets\
    \ += 1;\n            open_brackets_stack.push(open_brackets);\n            i +=\
    \ 1;\n        }\n        if string[i] == ']' && open_brackets == 0 && closed_brackets\
    \ == 0 {\n            i += 1;\n        }\n        if string[i] == '{' && open_brackets\
    \ == 0 && closed_brackets == 0 {\n            i += 1;\n        }\n        if string[i]\
    \ == '[' && open_brackets == 0 && closed_brackets == 0 {\n            i += 1;\n\
    \        }\n        if string[i] == '[' && open_brackets == 0 && closed_brackets\
    \ > 0 {\n            open_brackets += 1;\n            open_brackets_stack.push(open_brackets);\n\
    \            i += 1;\n        }\n        if string[i] == ']' && open_brackets\
    \ > 0 && closed_brackets == 0 {\n            open_brackets -= 1;\n           \
    \ open_brackets_stack.push(open_brackets);\n            i += 1;\n        }\n \
    \       if string[i] == '}' && open_brackets > 0 && closed_brackets == 0 {\n}\n\
    \nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpeaaoaik9.rs:96:3\n\
    \   |\n16 | fn is_nested(string: String) -> bool {\n   |                     \
    \                 - unclosed delimiter\n...\n25 |     while i < string.len() {\n\
    \   |                            - unclosed delimiter\n...\n77 |         if string[i]\
    \ == '}' && open_brackets > 0 && closed_brackets == 0 {\n   |                \
    \                                                          - this delimiter might\
    \ not be properly closed...\n78 | }\n   | - ...as it matches this but it has different\
    \ indentation\n...\n96 | }\n   |   ^\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmpeaaoaik9.rs:26:12\n   |\n26 |         if\
    \ string[i] == '[' {\n   |            ^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpeaaoaik9.rs:31:12\n\
    \   |\n31 |         if string[i] == ']' {\n   |            ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpeaaoaik9.rs:37:12\n   |\n37 |         if string[i]\
    \ == '{' {\n   |            ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpeaaoaik9.rs:42:12\n\
    \   |\n42 |         if string[i] == '}' {\n   |            ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpeaaoaik9.rs:48:12\n   |\n48 |         if string[i]\
    \ == ']' && open_brackets == 0 {\n   |            ^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpeaaoaik9.rs:5"
  stdout: ''
  timestamp: 1659748672
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = Vec::new();\n\
    \    let mut index = 0;\n    let mut open_brackets = 0;\n    let mut closed_brackets\
    \ = 0;\n    let mut open_brackets_index = 0;\n    let mut closed_brackets_index\
    \ = 0;\n    let mut open_brackets_depth = 0;\n    let mut closed_brackets_depth\
    \ = 0;\n    let mut open_brackets_depth_index = 0;\n    let mut closed_brackets_depth_index\
    \ = 0;\n    let mut open_brackets_depth_index2 = 0;\n    let mut closed_brackets_depth_index2\
    \ = 0;\n    let mut open_brackets_depth_index3 = 0;\n    let mut closed_brackets_depth_index3\
    \ = 0;\n    let mut open_brackets_depth_index4 = 0;\n    let mut closed_brackets_depth_index4\
    \ = 0;\n    let mut open_brackets_depth_index5 = 0;\n    let mut closed_brackets_depth_index5\
    \ = 0;\n    let mut open_brackets_depth_index6 = 0;\n    let mut closed_brackets_depth_index6\
    \ = 0;\n    let mut open_brackets_depth_index7 = 0;\n    let mut closed_brackets_depth_index7\
    \ = 0;\n    let mut open_brackets_depth_index8 = 0;\n    let mut closed_brackets_depth_index8\
    \ = 0;\n    let mut open_brackets_depth_index9 = 0;\n    let mut closed_brackets_depth_index9\
    \ = 0;\n    let mut open_brackets_depth_index10 = 0;\n    let mut closed_brackets_depth_index10\
    \ = 0;\n    let mut open_brackets_depth_index11 = 0;\n    let mut closed_brackets_depth_index11\
    \ = 0;\n    let mut open_brackets_depth_index12 = 0;\n    let mut closed_brackets_depth_index12\
    \ = 0;\n    let mut open_brackets_depth_index13 = 0;\n    let mut closed_brackets_depth_index13\
    \ = 0;\n    let mut open_brackets_depth_index14 = 0;\n    let mut closed_brackets_depth_index14\
    \ = 0;\n    let mut open_brackets_depth_index15 = 0;\n    let mut closed_brackets_depth_index15\
    \ = 0;\n    let mut open_brackets_depth_index16 = 0;\n    let mut closed_brackets_depth_index16\
    \ = 0;\n    let mut open_brackets_depth_index17 = 0;\n    let mut closed_brackets_depth_index17\
    \ = 0;\n    let mut open_brackets_depth_index18 = 0;\n    let mut \n}\n\nfn main()\
    \ {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp_19nmh8y.rs:61:1\n\
    \   |\n61 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().all(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpwqd_0nes.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = Vec::new();\n\
    \    let mut open_brackets = 0;\n    let mut close_brackets = 0;\n    let mut\
    \ i = 0;\n    while i < string.len() {\n        if string[i] == '[' {\n      \
    \      stack.push(i);\n            open_brackets += 1;\n        } else if string[i]\
    \ == ']' {\n            close_brackets += 1;\n            if close_brackets ==\
    \ open_brackets {\n                stack.pop();\n            }\n        }\n  \
    \      i += 1;\n    }\n    stack.len() == 0 || stack.pop() == 0\n}\n\nfn main()\
    \ {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpoz4r57mw.rs:22:12\n\
    \   |\n22 |         if string[i] == '[' {\n   |            ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpoz4r57mw.rs:25:19\n   |\n25 |         } else if string[i]\
    \ == ']' {\n   |                   ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpoz4r57mw.rs:33:40\n   |\n33 |  \
    \   stack.len() == 0 || stack.pop() == 0\n   |                               \
    \         ^\n   |                                        |\n   |             \
    \                           expected enum `Option`, found integer\n   |      \
    \                                  help: try using a variant of the expected enum:\
    \ `Some(0)`\n   |\n   = note: expected enum `Option<usize>`\n              found\
    \ type `{integer}`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = Vec::new();\n\
    \    let mut i = 0;\n    let mut open_brackets = 0;\n    let mut close_brackets\
    \ = 0;\n    let mut open_brackets_stack: Vec<usize> = Vec::new();\n    let mut\
    \ close_brackets_stack: Vec<usize> = Vec::new();\n    let mut open_brackets_stack_size\
    \ = 0;\n    let mut close_brackets_stack_size = 0;\n    let mut open_brackets_stack_ptr\
    \ = 0;\n    let mut close_brackets_stack_ptr = 0;\n    let mut open_brackets_stack_ptr_end\
    \ = 0;\n    let mut close_brackets_stack_ptr_end = 0;\n    let mut open_brackets_stack_ptr_end_ptr\
    \ = 0;\n    let mut close_brackets_stack_ptr_end_ptr = 0;\n    let mut open_brackets_stack_ptr_end_ptr_end\
    \ = 0;\n    let mut close_brackets_stack_ptr_end_ptr_end = 0;\n    let mut open_brackets_stack_ptr_end_ptr_end_ptr\
    \ = 0;\n    let mut close_brackets_stack_ptr_end_ptr_end_ptr = 0;\n    let mut\
    \ open_brackets_stack_ptr_end_ptr_end_ptr_end = 0;\n    let mut close_brackets_stack_ptr_end_ptr_end_ptr_end\
    \ = 0;\n    let mut open_brackets_stack_ptr_end_ptr_end_ptr_end_ptr = 0;\n   \
    \ let mut close_brackets_stack_ptr_end_ptr_end_ptr_end_ptr = 0;\n    let mut open_brackets_stack_ptr_end_ptr_end_ptr_end_ptr_end\
    \ = 0;\n    let mut close_brackets_stack_ptr_end_ptr_end_ptr_end_ptr_end = 0;\n\
    \    let mut open_brackets_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr = 0;\n  \
    \  let mut close_brackets_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr = 0;\n   \
    \ let mut open_brackets_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end = 0;\n \
    \   let mut close_brackets_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr =\
    \ 0;\n    let mut open_brackets_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr_end_ptr\
    \ = 0;\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjwpyr4xs.rs:16:33\n   |\n\
    16 | fn is_nested(string: String) -> bool {\n   |    ---------               \
    \     ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().all(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpwqd_0nes.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n\
    \    let mut i = 0;\n    while i < string.len() {\n        if let Some(index)\
    \ = get_index(&string, &mut i) {\n            stack.push(index);\n           \
    \ i += index - 1;\n        } else {\n            i += 1;\n        }\n    }\n \
    \   stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_index` in this scope\n  --> /tmp/tmpkkvms9jf.rs:20:30\n\
    \   |\n20 |         if let Some(index) = get_index(&string, &mut i) {\n   |  \
    \                            ^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().all(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpwqd_0nes.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = Vec::new();\n\
    \    let mut open_brackets: Vec<usize> = Vec::new();\n    let mut close_brackets:\
    \ Vec<usize> = Vec::new();\n    let mut open_brackets_size: usize = 0;\n    let\
    \ mut close_brackets_size: usize = 0;\n    let mut open_brackets_depth: usize\
    \ = 0;\n    let mut close_brackets_depth: usize = 0;\n    let mut open_brackets_depth_increment:\
    \ usize = 0;\n    let mut close_brackets_depth_increment: usize = 0;\n    let\
    \ mut open_brackets_depth_increment_increment: usize = 0;\n    let mut close_brackets_depth_increment_increment:\
    \ usize = 0;\n    let mut open_brackets_depth_increment_increment_increment: usize\
    \ = 0;\n    let mut close_brackets_depth_increment_increment_increment: usize\
    \ = 0;\n    let mut open_brackets_depth_increment_increment_increment_increment:\
    \ usize = 0;\n    let mut close_brackets_depth_increment_increment_increment_increment:\
    \ usize = 0;\n    let mut open_brackets_depth_increment_increment_increment_increment_increment:\
    \ usize = 0;\n    let mut close_brackets_depth_increment_increment_increment_increment_increment:\
    \ usize = 0;\n    let mut open_brackets_depth_increment_increment_increment_increment_increment_increment:\
    \ usize = 0;\n    let mut close_brackets_depth_increment_increment_increment_increment_increment_increment:\
    \ usize = 0;\n    let mut open_brackets_depth_increment_increment_increment_increment_increment_increment_increment:\
    \ usize = 0;\n    let mut close_brackets_depth_increment_increment_increment_increment_increment_increment:\
    \ usize = 0;\n    let mut open_brackets_depth_increment_increment_increment_increment_increment_increment_increment_increment:\
    \ usize = 0;\n    let mut close_brackets_depth_increment_increment_increment_increment_increment_increment_increment:\
    \ usize = 0;\n    let mut open_brackets_depth_increment_increment_increment_increment_increment_increment_increment_increment_increment:\
    \ usize = 0;\n    let mut close_brackets_depth_increment_increment_increment_increment_increment_increment_increment_increment:\
    \ usize = 0;\n    let mut open_brackets_depth_increment_increment_increment_increment_increment_\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpayzg396m.rs:42:83\n   |\n\
    42 |     let mut open_brackets_depth_increment_increment_increment_increment_increment_\n\
    \   |                                                                        \
    \           ^ help: add `;` here\n43 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpayzg396m.rs:16:33\n   |\n16 | fn is_nested(string:\
    \ String) -> bool {\n   |    ---------                    ^^^^ expected `bool`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    let\
    \ mut open_brackets = 0;\n    let mut closed_brackets = 0;\n    let mut i = 0;\n\
    \    while i < string.len() {\n        if string[i] == '[' {\n            stack.push(string[i]);\n\
    \            open_brackets += 1;\n        } else if string[i] == ']' {\n     \
    \       closed_brackets += 1;\n            if open_brackets == closed_brackets\
    \ {\n                open_brackets -= 1;\n                if open_brackets ==\
    \ 0 {\n                    return true;\n                }\n            }\n  \
    \      }\n        i += 1;\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpmdhr2l5t.rs:22:12\n\
    \   |\n22 |         if string[i] == '[' {\n   |            ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpmdhr2l5t.rs:23:24\n   |\n23 |             stack.push(string[i]);\n\
    \   |                        ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpmdhr2l5t.rs:25:19\n\
    \   |\n25 |         } else if string[i] == ']' {\n   |                   ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = Vec::new();\n\
    \    let mut bracket_count = 0;\n    let mut bracket_level = 0;\n    for c in\
    \ string.chars() {\n        if c == '[' {\n            stack.push(bracket_level);\n\
    \            bracket_level += 1;\n        }\n        if c == '[' {\n         \
    \   bracket_count += 1;\n        }\n        if c == ']' {\n            bracket_count\
    \ -= 1;\n        }\n        if c == ']' {\n            bracket_level -= 1;\n \
    \       }\n        if bracket_level == 0 {\n            if bracket_count == 0\
    \ {\n                return true;\n            }\n        }\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpdedk1hri.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n\
    \    let mut index = 0;\n    while index < string.len() {\n        let mut open_brackets\
    \ = false;\n        let mut close_brackets = false;\n        let mut open_brackets_index\
    \ = 0;\n        let mut close_brackets_index = 0;\n        while index < string.len()\
    \ {\n            if string[index] == '[' {\n                open_brackets = true;\n\
    \                open_brackets_index = index;\n            } else if string[index]\
    \ == ']' {\n                close_brackets = true;\n                close_brackets_index\
    \ = index;\n            } else if open_brackets && close_brackets {\n        \
    \        stack.unshift(close_brackets_index - open_brackets_index);\n        \
    \        open_brackets_index = 0;\n                close_brackets_index = 0;\n\
    \                open_brackets = false;\n                close_brackets = false;\n\
    \            } else if open_brackets {\n                open_brackets_index +=\
    \ 1;\n            } else if close_brackets {\n                close_brackets_index\
    \ += 1;\n            }\n            index += 1\n        }\n        if stack.len()\
    \ > 0 {\n            return true;\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpfmbsj8kr.rs:25:16\n\
    \   |\n25 |             if string[index] == '[' {\n   |                ^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpfmbsj8kr.rs:28:23\n   |\n28 |            \
    \ } else if string[index] == ']' {\n   |                       ^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0599]: no method named `unshift` found for\
    \ struct `Vec<usize>` in the current scope\n  --> /tmp/tmpfmbsj8kr.rs:32:23\n\
    \   |\n32 |                 stack.unshift(close_brackets_index - open_brackets_index);\n\
    \   |                       ^^^^^^^ method not found in `Vec<usize>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n\
    \    let mut bracket_count = 0;\n    let mut open_brackets = 0;\n    for c in\
    \ string.chars() {\n        if c == '[' {\n            stack.push(bracket_count);\n\
    \            open_brackets += 1;\n        }\n        if c == '[' {\n         \
    \   bracket_count += 1;\n        }\n        if c == '[' {\n            bracket_count\
    \ += 1;\n        }\n        if c == '[' {\n            bracket_count += 1;\n \
    \       }\n        if c == '[' {\n            bracket_count += 1;\n        }\n\
    \        if c == '[' {\n            bracket_count += 1;\n        }\n        if\
    \ c == '[' {\n            bracket_count += 1;\n        }\n        if c == '['\
    \ {\n            bracket_count += 1;\n        }\n        if c == '[' {\n     \
    \       bracket_count += 1;\n        }\n        if c == '[' {\n            bracket_count\
    \ += 1;\n        }\n        if c == '[' {\n            bracket_count += 1;\n \
    \       }\n        if c == '[' {\n            bracket_count += 1;\n        }\n\
    \        if c == '[' {\n            bracket_count += 1;\n        }\n        if\
    \ c == '[' {\n            bracket_count += 1;\n        }\n        if c == '['\
    \ {\n            bracket_count += 1;\n        }\n        if c == '[' {\n     \
    \       bracket_count += 1;\n        }\n        if c == '[' {\n            bracket_count\
    \ += 1;\n        }\n        if c == '[' {\n            bracket_count += 1;\n \
    \       }\n        if c == '[' {\n            bracket_count += 1;\n        }\n\
    \        if c == '[' {\n            bracket_count += 1;\n        }\n        if\
    \ c == '[' {\n            bracket_count += 1;\n        }\n        if c == '['\
    \ {\n            bracket_count += 1;\n        }\n        if c == '[' {\n     \
    \       bracket_count += 1;\n        }\n        if c == '[' {\n            bracket_count\
    \ += 1;\n        }\n        if c == '[' {\n            bracket_count += 1;\n \
    \       }\n        if c == '[' {\n            bracket_count += 1;\n        }\n\
    \        if c == '[' {\n            bracket_count += 1;\n        }\n        if\
    \ c == '[' {\n            bracket_count += 1;\n        }\n        if c == '['\
    \ {\n            bracket_count += 1;\n        }\n        if c\n}\n\nfn main()\
    \ {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpjz10c4g8.rs:128:3\n\
    \    |\n16  | fn is_nested(string: String) -> bool {\n    |                  \
    \                    - unclosed delimiter\n...\n20  |     for c in string.chars()\
    \ {\n    |                             - this delimiter might not be properly\
    \ closed...\n...\n110 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n128 | }\n    |   ^\n\nerror: expected `{`, found `}`\n   -->\
    \ /tmp/tmpjz10c4g8.rs:110:1\n    |\n109 |         if c\n    |         -- this\
    \ `if` expression has a condition, but no block\n110 | }\n    | ^ expected `{`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpjz10c4g8.rs:16:33\n   |\n16 |\
    \ fn is_nested(string: String) -> bool {\n   |    ---------                  \
    \  ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    let\
    \ mut inside_bracket = false;\n    let mut inside_quote = false;\n    let mut\
    \ inside_paren = false;\n    let mut inside_curly_bracket = false;\n    let mut\
    \ inside_curly_brace = false;\n    let mut inside_curly_brace_bracket = false;\n\
    \    let mut inside_curly_brace_quote = false;\n    let mut inside_curly_brace_paren\
    \ = false;\n    let mut inside_curly_brace_curly_bracket = false;\n    let mut\
    \ inside_curly_brace_curly_brace = false;\n    let mut inside_curly_brace_curly_brace_bracket\
    \ = false;\n    let mut inside_curly_brace_curly_brace_quote = false;\n    let\
    \ mut inside_curly_brace_curly_brace_paren = false;\n    let mut inside_curly_brace_curly_brace_curly_bracket\
    \ = false;\n    let mut inside_curly_brace_curly_brace_curly_brace = false;\n\
    \    let mut inside_curly_brace_curly_brace_curly_brace_bracket = false;\n   \
    \ let mut inside_curly_brace_curly_brace_curly_brace_quote = false;\n    let mut\
    \ inside_curly_brace_curly_brace_curly_brace_paren = false;\n    let mut inside_curly_brace_curly_brace_curly_brace_curly_bracket\
    \ = false;\n    let mut inside_curly_brace_curly_brace_curly_brace_curly_brace\
    \ = false;\n    let mut inside_curly_brace_curly_brace_curly_brace_curly_brace_bracket\
    \ = false;\n    let mut inside_curly_brace_curly_brace_curly_brace_curly_brace_quote\
    \ = false;\n    let mut inside_curly_brace_curly_brace_curly_brace_curly_brace_paren\
    \ = false;\n    let mut inside_curly_brace_curly_brace_curly_brace_curly_brace_curly_bracket\
    \ = false;\n    let mut inside_curly_brace_curly_brace_curly_brace_curly_brace_curly_brace\
    \ = false;\n    let mut inside_curly_brace_curly_brace_curly_brace_curly_brace_curly_brace_bracket\
    \ = false;\n    let mut inside_curly_brace_curly_brace_curly_brace_curly_brace_curly_brace_quote\
    \ = false;\n    let mut inside_curly_brace_curly_brace_curly_brace_curly_bra\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpdxxw8pc6.rs:45:65\n   |\n\
    45 |     let mut inside_curly_brace_curly_brace_curly_brace_curly_bra\n   |  \
    \                                                               ^ help: add `;`\
    \ here\n46 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpdxxw8pc6.rs:16:33\n   |\n16 | fn is_nested(string: String) -> bool {\n\
    \   |    ---------                    ^^^^ expected `bool`, found `()`\n   | \
    \   |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = Vec::new();\n\
    \    let mut open_brackets: usize = 0;\n    let mut close_brackets: usize = 0;\n\
    \    for c in string.chars() {\n        if c == '[' {\n            stack.push(open_brackets);\n\
    \            open_brackets += 1;\n        } else if c == '{' {\n            stack.push(close_brackets);\n\
    \            close_brackets += 1;\n        } else if c == '[' {\n            open_brackets\
    \ += 1;\n        } else if c == '}' {\n            close_brackets += 1;\n    \
    \    } else if c == ']' {\n            if open_brackets == stack.pop() {\n   \
    \             close_brackets -= 1;\n            } else {\n                open_brackets\
    \ += 1;\n            }\n        }\n    }\n    stack.len() == 0 && close_brackets\
    \ == 0\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpacrc3xi2.rs:32:33\n   |\n\
    32 |             if open_brackets == stack.pop() {\n   |                     \
    \            ^^^^^^^^^^^ expected `usize`, found enum `Option`\n   |\n   = note:\
    \ expected type `usize`\n              found enum `Option<usize>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = Vec::new();\n\
    \    let mut open_brackets: usize = 0;\n    let mut close_brackets: usize = 0;\n\
    \    let mut i = 0;\n    while i < string.len() {\n        if string[i] == '['\
    \ {\n            stack.push(i);\n            open_brackets += 1;\n        } else\
    \ if string[i] == ']' {\n            close_brackets += 1;\n            if close_brackets\
    \ == open_brackets {\n                stack.pop();\n            }\n        } else\
    \ if string[i] == '{' {\n            stack.push(i);\n        } else if string[i]\
    \ == '}' {\n            close_brackets += 1;\n            if close_brackets ==\
    \ open_brackets {\n                stack.pop();\n            }\n        }\n  \
    \      i += 1;\n    }\n    stack.len() > 0 && stack.len() == open_brackets\n}\n\
    \nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpbsb9e5ng.rs:22:12\n\
    \   |\n22 |         if string[i] == '[' {\n   |            ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpbsb9e5ng.rs:25:19\n   |\n25 |         } else if string[i]\
    \ == ']' {\n   |                   ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpbsb9e5ng.rs:30:19\n\
    \   |\n30 |         } else if string[i] == '{' {\n   |                   ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpbsb9e5ng.rs:32:19\n   |\n32 |         } else\
    \ if string[i] == '}' {\n   |                   ^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = Vec::new();\n\
    \    let mut i = 0;\n    let mut open_brackets = 0;\n    let mut closed_brackets\
    \ = 0;\n    while i < string.len() {\n        if string[i] == ']' {\n        \
    \    closed_brackets += 1;\n            if open_brackets == closed_brackets {\n\
    \                stack.pop();\n            } else {\n                open_brackets\
    \ -= 1;\n            }\n        } else if string[i] == '[' {\n            open_brackets\
    \ += 1;\n            stack.push(i);\n        } else {\n            i += 1;\n \
    \       }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate =\
    \ is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpvr9lz13a.rs:22:12\n\
    \   |\n22 |         if string[i] == ']' {\n   |            ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpvr9lz13a.rs:29:19\n   |\n29 |         } else if string[i]\
    \ == '[' {\n   |                   ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n\
    \    let mut i = 0;\n    while i < string.len() {\n        if string[i] == '['\
    \ {\n            stack.push(i);\n        }\n        if string[i] == ']' {\n  \
    \          if stack.len() == 0 {\n                return false;\n            }\n\
    \            stack.pop();\n        }\n        i += 1;\n    }\n    stack.len()\
    \ == 0\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmplksejcoe.rs:20:12\n\
    \   |\n20 |         if string[i] == '[' {\n   |            ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmplksejcoe.rs:23:12\n   |\n23 |         if string[i]\
    \ == ']' {\n   |            ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    let\
    \ mut open_brackets = Vec::new();\n    let mut closed_brackets = Vec::new();\n\
    \    let mut open_brackets_count = Vec::new();\n    let mut closed_brackets_count\
    \ = Vec::new();\n    let mut open_brackets_count_stack = Vec::new();\n    let\
    \ mut closed_brackets_count_stack = Vec::new();\n    let mut open_brackets_count_stack\
    \ = Vec::new();\n    let mut closed_brackets_count_stack = Vec::new();\n    let\
    \ mut open_brackets_count_stack = Vec::new();\n    let mut closed_brackets_count_stack\
    \ = Vec::new();\n    let mut open_brackets_count_stack = Vec::new();\n    let\
    \ mut closed_brackets_count_stack = Vec::new();\n    let mut open_brackets_count_stack\
    \ = Vec::new();\n    let mut closed_brackets_count_stack = Vec::new();\n    let\
    \ mut open_brackets_count_stack = Vec::new();\n    let mut closed_brackets_count_stack\
    \ = Vec::new();\n    let mut open_brackets_count_stack = Vec::new();\n    let\
    \ mut closed_brackets_count_stack = Vec::new();\n    let mut open_brackets_count_stack\
    \ = Vec::new();\n    let mut closed_brackets_count_stack = Vec::new();\n    let\
    \ mut open_brackets_count_stack = Vec::new();\n    let mut closed_brackets_count_stack\
    \ = Vec::new();\n    let mut open_brackets_count_stack = Vec::new();\n    let\
    \ mut closed_brackets_count_stack = Vec::new();\n    let mut open_brackets_count_stack\
    \ = Vec::new();\n    let mut closed_brackets_count_stack = Vec::new();\n    let\
    \ mut open_brackets_count_stack = Vec::new();\n    let mut closed_brackets_count_stack\
    \ = Vec::new();\n    let mut open_brackets_count_stack = Vec::new();\n    let\
    \ mut closed_brackets_count_stack = Vec::new();\n    let mut open_brackets_count_stack\
    \ = Vec::new();\n    let mut closed_brackets_count_stack = Vec::new();\n    let\
    \ mut open_brackets_count_stack = Vec::new();\n\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt_ew6ddu.rs:16:33\n   |\n\
    16 | fn is_nested(string: String) -> bool {\n   |    ---------               \
    \     ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    let\
    \ mut open_brackets = 0;\n    let mut close_brackets = 0;\n    for c in string.chars()\
    \ {\n        if c == '[' {\n            stack.push(c);\n            open_brackets\
    \ += 1;\n        } else if c == ']' {\n            close_brackets += 1;\n    \
    \        if close_brackets == open_brackets {\n                stack.pop();\n\
    \            }\n        }\n    }\n    stack.len() > 0 && stack.len() == open_brackets\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbvm0hhzb.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    let\
    \ mut bracket_count = 0;\n    let mut bracket_open = false;\n    let mut bracket_closed\
    \ = false;\n    let mut bracket_stack = Vec::new();\n    for c in string.chars()\
    \ {\n        if c == '[' {\n            bracket_open = true;\n            stack.push(c);\n\
    \            bracket_stack.push(c);\n        } else if c == '{' {\n          \
    \  bracket_open = true;\n            stack.push(c);\n            bracket_stack.push(c);\n\
    \        } else if c == '}' {\n            bracket_closed = true;\n          \
    \  bracket_open = false;\n            stack.push(c);\n        } else if c == '['\
    \ {\n            bracket_open = true;\n            stack.push(c);\n          \
    \  bracket_stack.push(c);\n        } else if c == '}' {\n            bracket_closed\
    \ = true;\n            bracket_open = false;\n            stack.push(c);\n   \
    \     } else if c == ']' {\n            if bracket_open {\n                bracket_open\
    \ = false;\n                bracket_closed = true;\n                bracket_count\
    \ += 1;\n            }\n            if bracket_closed {\n                bracket_count\
    \ -= 1;\n                if bracket_count == 0 {\n                    bracket_stack.pop();\n\
    \                    stack.pop();\n                }\n            }\n        }\n\
    \    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpfpb034qn.rs:63:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = Vec::new();\n\
    \    let mut open_brackets: Vec<usize> = Vec::new();\n    let mut close_brackets:\
    \ Vec<usize> = Vec::new();\n    let mut open_brackets_stack: Vec<usize> = Vec::new();\n\
    \    let mut close_brackets_stack: Vec<usize> = Vec::new();\n    let mut open_brackets_stack_size:\
    \ usize = 0;\n    let mut close_brackets_stack_size: usize = 0;\n    let mut open_brackets_stack_index:\
    \ usize = 0;\n    let mut close_brackets_stack_index: usize = 0;\n    let mut\
    \ open_brackets_stack_index2: usize = 0;\n    let mut close_brackets_stack_index2:\
    \ usize = 0;\n    let mut open_brackets_stack_index3: usize = 0;\n    let mut\
    \ close_brackets_stack_index3: usize = 0;\n    let mut open_brackets_stack_index4:\
    \ usize = 0;\n    let mut close_brackets_stack_index4: usize = 0;\n    let mut\
    \ open_brackets_stack_index5: usize = 0;\n    let mut close_brackets_stack_index5:\
    \ usize = 0;\n    let mut open_brackets_stack_index6: usize = 0;\n    let mut\
    \ close_brackets_stack_index6: usize = 0;\n    let mut open_brackets_stack_index7:\
    \ usize = 0;\n    let mut close_brackets_stack_index7: usize = 0;\n    let mut\
    \ open_brackets_stack_index8: usize = 0;\n    let mut close_brackets_stack_index8:\
    \ usize = 0;\n    let mut open_brackets_stack_index9: usize = 0;\n    let mut\
    \ close_brackets_stack_index9: usize = 0;\n    let mut open_brackets_stack_index10:\
    \ usize = 0;\n    let mut close_brackets_stack_index10: usize = 0;\n    let mut\
    \ open_brackets_stack_index11: usize = 0;\n    let mut close_brackets_stack_index11:\
    \ usize = 0;\n    let mut open_brackets_stack_index12: usize = 0;\n    let mut\
    \ close_brackets_stack_index12: usize = 0;\n    let mut open_brackets_stack_index13:\
    \ \n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected type, found `}`\n  --> /tmp/tmp5n3g7tuo.rs:49:1\n   |\n\
    48 |     let mut open_brackets_stack_index13: \n   |         -------------------------------\
    \ while parsing the type for `mut open_brackets_stack_index13`\n49 | }\n   | ^\
    \ expected type\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n\
    \    let mut open_brackets = 0;\n    for c in string.chars() {\n        if c ==\
    \ '[' {\n            stack.push(c);\n            open_brackets += 1;\n       \
    \ } else if c == ']' {\n            open_brackets -= 1;\n            if open_brackets\
    \ == 0 {\n                stack.pop();\n            }\n        }\n    }\n    stack.len()\
    \ == 0 && open_brackets == 0\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl_0j3ztx.rs:21:24\n   |\n\
    21 |             stack.push(c);\n   |                        ^ expected `usize`,\
    \ found `char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = Vec::new();\n\
    \    let mut i = 0;\n    while i < string.len() {\n        if string[i] == '['\
    \ {\n            stack.push(i);\n            i += 1;\n        } else if string[i]\
    \ == ']' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            let top = stack.len() - 1;\n            if stack[top]\
    \ != i {\n                return false;\n            }\n            stack.pop();\n\
    \            i += 1;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    stack.len() == 0\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpdqn_kdi7.rs:20:12\n\
    \   |\n20 |         if string[i] == '[' {\n   |            ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpdqn_kdi7.rs:23:19\n   |\n23 |         } else if string[i]\
    \ == ']' {\n   |                   ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    let\
    \ mut bracket_count = 0;\n    let mut open_brackets = 0;\n    for c in string.chars()\
    \ {\n        if c == '[' {\n            stack.push(c);\n            open_brackets\
    \ += 1;\n        }\n        if c == '[' {\n            bracket_count += 1;\n \
    \       }\n        if c == ']' {\n            open_brackets -= 1;\n        }\n\
    \        if c == ']' {\n            bracket_count -= 1;\n        }\n        if\
    \ open_brackets == 0 && bracket_count == 0 {\n            return true;\n     \
    \   }\n        if open_brackets == 0 && bracket_count == 1 {\n            return\
    \ false;\n        }\n        if open_brackets > 0 && bracket_count > 0 {\n   \
    \         return false;\n        }\n    }\n    false\n}\n\nfn main() {\n    let\
    \ candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmph5zrljes.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = Vec::new();\n\
    \    let mut open_brackets: usize = 0;\n    let mut close_brackets: usize = 0;\n\
    \    let mut bracket_level: usize = 0;\n    let mut bracket_open: usize = 0;\n\
    \    let mut bracket_close: usize = 0;\n    let mut bracket_open_brackets: usize\
    \ = 0;\n    let mut bracket_close_brackets: usize = 0;\n    let mut bracket_open_brackets_level:\
    \ usize = 0;\n    let mut bracket_close_brackets_level: usize = 0;\n    let mut\
    \ bracket_open_brackets_level2: usize = 0;\n    let mut bracket_close_brackets_level2:\
    \ usize = 0;\n    let mut bracket_open_brackets_level3: usize = 0;\n    let mut\
    \ bracket_close_brackets_level3: usize = 0;\n    let mut bracket_open_brackets_level4:\
    \ usize = 0;\n    let mut bracket_close_brackets_level4: usize = 0;\n    let mut\
    \ bracket_open_brackets_level5: usize = 0;\n    let mut bracket_close_brackets_level5:\
    \ usize = 0;\n    let mut bracket_open_brackets_level6: usize = 0;\n    let mut\
    \ bracket_close_brackets_level6: usize = 0;\n    let mut bracket_open_brackets_level7:\
    \ usize = 0;\n    let mut bracket_close_brackets_level7: usize = 0;\n    let mut\
    \ bracket_open_brackets_level8: usize = 0;\n    let mut bracket_close_brackets_level8:\
    \ usize = 0;\n    let mut bracket_open_brackets_level9: usize = 0;\n    let mut\
    \ bracket_close_brackets_level9: usize = 0;\n    let mut bracket_open_brackets_level10:\
    \ usize = 0;\n    let mut bracket_close_brackets_level10: usize = 0;\n    let\
    \ mut bracket_open_brackets_level11: usize = 0;\n    let mut bracket_close_brackets_level11:\
    \ usize = 0;\n    let mut bracket_open_brackets_level12: usize = 0;\n    let mu\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpgmof2w0m.rs:48:11\n   |\n\
    48 |     let mu\n   |           ^ help: add `;` here\n49 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgmof2w0m.rs:16:33\n \
    \  |\n16 | fn is_nested(string: String) -> bool {\n   |    ---------         \
    \           ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().all(|c| {\n       \
    \ if c == '[' {\n            true\n        } else if c == '{' {\n            true\n\
    \        } else if c == '(' {\n            true\n        } else if c == ']' {\n\
    \            true\n        } else if c == '}' {\n            true\n        } else\
    \ if c == '\"' {\n            true\n        } else if c == '\\\\' {\n        \
    \    true\n        } else {\n            false\n        }\n    })\n}\n\nfn main()\
    \ {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpgi7w5v2x.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n\
    \    let mut open_brackets = 0;\n    for c in string.chars() {\n        if c ==\
    \ '[' {\n            stack.push(c);\n            open_brackets += 1;\n       \
    \ } else if c == '[' && stack.len() > 0 {\n            stack.pop();\n        \
    \    open_brackets -= 1;\n        } else if c == ']' {\n            if open_brackets\
    \ == 0 {\n                return false;\n            }\n            stack.pop();\n\
    \            open_brackets -= 1;\n        }\n    }\n    open_brackets == 0\n}\n\
    \nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf5ti__9b.rs:21:24\n   |\n\
    21 |             stack.push(c);\n   |                        ^ expected `usize`,\
    \ found `char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    let\
    \ mut open_brackets = Vec::new();\n    let mut close_brackets = Vec::new();\n\
    \    let mut open_brackets_size = Vec::new();\n    let mut close_brackets_size\
    \ = Vec::new();\n    let mut open_brackets_depth = Vec::new();\n    let mut close_brackets_depth\
    \ = Vec::new();\n    let mut open_brackets_depth_size = Vec::new();\n    let mut\
    \ close_brackets_depth_size = Vec::new();\n    let mut open_brackets_depth_counter\
    \ = Vec::new();\n    let mut close_brackets_depth_counter = Vec::new();\n    let\
    \ mut open_brackets_depth_counter_size = Vec::new();\n    let mut close_brackets_depth_counter_size\
    \ = Vec::new();\n    let mut open_brackets_depth_counter_counter = Vec::new();\n\
    \    let mut close_brackets_depth_counter_counter = Vec::new();\n    let mut open_brackets_depth_counter_counter_size\
    \ = Vec::new();\n    let mut close_brackets_depth_counter_counter_size = Vec::new();\n\
    \    let mut open_brackets_depth_counter_counter_counter = Vec::new();\n    let\
    \ mut close_brackets_depth_counter_counter_counter = Vec::new();\n    let mut\
    \ open_brackets_depth_counter_counter_counter_size = Vec::new();\n    let mut\
    \ close_brackets_depth_counter_counter_counter_size = Vec::new();\n    let mut\
    \ open_brackets_depth_counter_counter_counter_counter = Vec::new();\n    let mut\
    \ close_brackets_depth_counter_counter_counter_counter = Vec::new();\n    let\
    \ mut open_brackets_depth_counter_counter_counter_counter_size = Vec::new();\n\
    \    let mut close_brackets_depth_counter_counter_counter_counter_size = Vec::new();\n\
    \    let mut open_brackets_depth_counter_counter_counter_counter_counter = Vec::new();\n\
    \    let mut close_brackets_depth_counter_counter_counter_counter_counter = Vec::new();\n\
    \    let mut open_brackets_depth_counter_counter_counter_counter_counter_size\
    \ = Vec::new();\n    let mut close_brackets_depth_counter_counter_counter_counter_counter_size\
    \ = Vec::new();\n    let mut open_brackets_depth_counter_counter_counter_counter_counter_counter\
    \ = Vec::new();\n    let mut close_bracket\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpuak1oxdc.rs:47:26\n   |\n\
    47 |     let mut close_bracket\n   |                          ^ help: add `;`\
    \ here\n48 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpuak1oxdc.rs:16:33\n   |\n16 | fn is_nested(string: String) -> bool {\n\
    \   |    ---------                    ^^^^ expected `bool`, found `()`\n   | \
    \   |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = Vec::new();\n\
    \    let mut index = 0;\n    \n    while index < string.len() {\n        if string[index]\
    \ == '[' {\n            stack.push(index);\n        }\n        if string[index]\
    \ == ']' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        }\n        index += 1;\n   \
    \ }\n    \n    stack.len() == 0\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpy_3ovd_l.rs:21:12\n\
    \   |\n21 |         if string[index] == '[' {\n   |            ^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpy_3ovd_l.rs:24:12\n   |\n24 |         if string[index]\
    \ == ']' {\n   |            ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    let\
    \ mut brackets = Vec::new();\n    let mut open_brackets = Vec::new();\n    let\
    \ mut close_brackets = Vec::new();\n    let mut open_brackets_size = Vec::new();\n\
    \    let mut close_brackets_size = Vec::new();\n    let mut open_brackets_depth\
    \ = Vec::new();\n    let mut close_brackets_depth = Vec::new();\n    let mut open_brackets_depth_size\
    \ = Vec::new();\n    let mut close_brackets_depth_size = Vec::new();\n    let\
    \ mut open_brackets_depth_size_max = Vec::new();\n    let mut close_brackets_depth_size_max\
    \ = Vec::new();\n    let mut open_brackets_depth_size_min = Vec::new();\n    let\
    \ mut close_brackets_depth_size_min = Vec::new();\n    let mut open_brackets_depth_size_max_index\
    \ = Vec::new();\n    let mut close_brackets_depth_size_max_index = Vec::new();\n\
    \    let mut open_brackets_depth_size_min_index = Vec::new();\n    let mut close_brackets_depth_size_min_index\
    \ = Vec::new();\n    let mut open_brackets_depth_size_max_index_max = Vec::new();\n\
    \    let mut close_brackets_depth_size_max_index_max = Vec::new();\n    let mut\
    \ open_brackets_depth_size_max_index_min = Vec::new();\n    let mut close_brackets_depth_size_max_index_min\
    \ = Vec::new();\n    let mut open_brackets_depth_size_max_index_min_index = Vec::new();\n\
    \    let mut close_brackets_depth_size_max_index_min_index = Vec::new();\n   \
    \ let mut open_brackets_depth_size_max_index_min_max = Vec::new();\n    let mut\
    \ close_brackets_depth_size_max_index_min_max = Vec::new();\n    let mut open_brackets_depth_size_max_index_min_min\
    \ = Vec::new();\n    let mut close_brackets_depth_size_max_index_min_min = Vec::new();\n\
    \    let mut open_brackets_depth_size_max_index_min_min_index = Vec::new();\n\
    \    let mut close_brackets_depth_size_max_index_min_min_index = Vec::new();\n\
    \    let mut open_brackets_depth_size_max_index_min_min_max = Vec::new();\n\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsawdcrxf.rs:16:33\n   |\n\
    16 | fn is_nested(string: String) -> bool {\n   |    ---------               \
    \     ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    let\
    \ mut brackets = 0;\n    for c in string.chars() {\n        if c == '[' {\n  \
    \          stack.push(c);\n            brackets += 1;\n        } else if c ==\
    \ ']' {\n            brackets -= 1;\n            if brackets == 0 {\n        \
    \        return stack.pop().is_some();\n            }\n        }\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpbmzxl6mq.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = Vec::new();\n\
    \    let mut i = 0;\n    while i < string.len() {\n        if string[i] == '['\
    \ {\n            stack.push(i);\n        }\n        if string[i] == ']' {\n  \
    \          if stack.len() == 0 {\n                return false;\n            }\n\
    \            let top = stack.len();\n            let mut j = i;\n            while\
    \ j > 0 && string[j-1] == '[' {\n                j -= 1;\n            }\n    \
    \        if j == i {\n                stack.pop();\n            } else {\n   \
    \             stack.pop();\n                stack.pop();\n            }\n    \
    \    }\n        i += 1;\n    }\n    stack.len() == 0\n}\n\nfn main() {\n    let\
    \ candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpkph4leaa.rs:20:12\n\
    \   |\n20 |         if string[i] == '[' {\n   |            ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpkph4leaa.rs:23:12\n   |\n23 |         if string[i]\
    \ == ']' {\n   |            ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpkph4leaa.rs:29:28\n\
    \   |\n29 |             while j > 0 && string[j-1] == '[' {\n   |            \
    \                ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(0);\n\
    \    let mut i = 0;\n    while i < string.len() {\n        if stack.is_empty()\
    \ {\n            return false;\n        }\n        let mut j = i;\n        while\
    \ j < string.len() && string[j] == string[stack.pop().unwrap()] {\n          \
    \  j += 1\n        }\n        if j == i {\n            return false;\n       \
    \ }\n        stack.push(j);\n        i = j;\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\"\
    )), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp6xotwcr_.rs:25:35\n\
    \   |\n25 |         while j < string.len() && string[j] == string[stack.pop().unwrap()]\
    \ {\n   |                                   ^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmp6xotwcr_.rs:25:48\n   |\n25 |         while j < string.len() &&\
    \ string[j] == string[stack.pop().unwrap()] {\n   |                          \
    \                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().all(|c| {\n       \
    \ if c == '[' {\n            true\n        } else if c == '{' {\n            true\n\
    \        } else if c == '}' {\n            true\n        } else if c == '(' {\n\
    \            true\n        } else if c == ')' {\n            true\n        } else\
    \ {\n            false\n        }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9nlqyl05.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    let\
    \ mut open_brackets = 0;\n    let mut closed_brackets = 0;\n    let mut i = 0;\n\
    \    while i < string.len() {\n        if string[i] == '[' {\n            stack.push(string[i]);\n\
    \            open_brackets += 1;\n        } else if string[i] == ']' {\n     \
    \       closed_brackets += 1;\n            if closed_brackets == open_brackets\
    \ {\n                stack.pop();\n                open_brackets -= 1;\n     \
    \       }\n        } else if string[i] == '{' {\n            stack.push(string[i]);\n\
    \        } else if string[i] == '}' {\n            if stack.len() == 0 {\n   \
    \             return false;\n            }\n            closed_brackets += 1;\n\
    \            if closed_brackets == open_brackets {\n                stack.pop();\n\
    \                open_brackets -= 1;\n            }\n        }\n        i += 1;\n\
    \    }\n    stack.len() == 0 && open_brackets == 0 && closed_brackets == 0\n}\n\
    \nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpyvmoe8ox.rs:22:12\n\
    \   |\n22 |         if string[i] == '[' {\n   |            ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpyvmoe8ox.rs:23:24\n   |\n23 |             stack.push(string[i]);\n\
    \   |                        ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpyvmoe8ox.rs:25:19\n\
    \   |\n25 |         } else if string[i] == ']' {\n   |                   ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpyvmoe8ox.rs:31:19\n   |\n31 |         } else\
    \ if string[i] == '{' {\n   |                   ^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n \
    \ --> /tmp/tmpyvmoe8ox.rs:32:24\n   |\n32 |             stack.push(string[i]);\n\
    \   |                        ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpyvmoe8ox.rs:33:19\n\
    \   |\n33 |         } else if string[i] == '}' {\n   |                   ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror: aborting due to 6 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = Vec::new();\n\
    \    let mut open_brackets: usize = 0;\n    let mut closed_brackets: usize = 0;\n\
    \    let mut i = 0;\n    while i < string.len() {\n        if string[i] == '['\
    \ {\n            stack.push(i);\n            open_brackets += 1;\n        } else\
    \ if string[i] == ']' {\n            closed_brackets += 1;\n            if closed_brackets\
    \ == open_brackets {\n                stack.pop();\n            }\n        }\n\
    \        i += 1;\n    }\n    stack.len() > 0 && stack[stack.len() - 1] == string.len()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp4b2avq98.rs:22:12\n\
    \   |\n22 |         if string[i] == '[' {\n   |            ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmp4b2avq98.rs:25:19\n   |\n25 |         } else if string[i]\
    \ == ']' {\n   |                   ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    let\
    \ mut open_brackets = 0;\n    for c in string.chars() {\n        if c == '[' {\n\
    \            stack.push(c);\n            open_brackets += 1;\n        } else if\
    \ c == '[' && stack.len() > 0 && stack.pop() == '[' {\n            open_brackets\
    \ -= 1;\n        } else if c == '[' && stack.len() > 0 && stack.pop() == '[' &&\
    \ open_brackets == 0 {\n            return true;\n        }\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa5npuu6z.rs:23:65\n   |\n\
    23 |         } else if c == '[' && stack.len() > 0 && stack.pop() == '[' {\n \
    \  |                                                                 ^^^\n   |\
    \                                                                 |\n   |    \
    \                                                             expected enum `Option`,\
    \ found `char`\n   |                                                         \
    \        help: try using a variant of the expected enum: `Some('[')`\n   |\n \
    \  = note: expected enum `Option<char>`\n              found type `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpa5npuu6z.rs:25:65\n   |\n25 |         } else\
    \ if c == '[' && stack.len() > 0 && stack.pop() == '[' && open_brackets == 0 {\n\
    \   |                                                                 ^^^\n  \
    \ |                                                                 |\n   |  \
    \                                                               expected enum\
    \ `Option`, found `char`\n   |                                               \
    \                  help: try using a variant of the expected enum: `Some('[')`\n\
    \   |\n   = note: expected enum `Option<char>`\n              found type `char`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = Vec::new();\n\
    \    let mut i = 0;\n    while i < string.len() {\n        if string[i] == '['\
    \ {\n            stack.push(i);\n        }\n        if string[i] == ']' {\n  \
    \          if stack.len() == 0 {\n                return false;\n            }\n\
    \            stack.pop();\n        }\n        i += 1;\n    }\n    stack.len()\
    \ == 0\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpzarxa0sx.rs:20:12\n\
    \   |\n20 |         if string[i] == '[' {\n   |            ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpzarxa0sx.rs:23:12\n   |\n23 |         if string[i]\
    \ == ']' {\n   |            ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n\
    \    let mut open_brackets = 0;\n    let mut closed_brackets = 0;\n    let mut\
    \ i = 0;\n    while i < string.len() {\n        if string[i] == '[' {\n      \
    \      stack.push(i);\n            open_brackets += 1;\n        } else if string[i]\
    \ == ']' {\n            closed_brackets += 1;\n            if closed_brackets\
    \ == open_brackets {\n                stack.pop();\n            }\n        }\n\
    \        i += 1;\n    }\n    stack.len() == 0 && closed_brackets == open_brackets\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpp7n8bwz0.rs:22:12\n\
    \   |\n22 |         if string[i] == '[' {\n   |            ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpp7n8bwz0.rs:25:19\n   |\n25 |         } else if string[i]\
    \ == ']' {\n   |                   ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    let\
    \ mut inside_quote = false;\n    let mut inside_bracket = false;\n    for c in\
    \ string.chars() {\n        if c == '[' {\n            stack.push(c);\n      \
    \      inside_bracket = true;\n        } else if c == '{' {\n            stack.push(c);\n\
    \        } else if c == '}' {\n            stack.pop();\n            inside_bracket\
    \ = false;\n        } else if c == '\"' {\n            inside_quote = !inside_quote;\n\
    \        } else if c == ']' {\n            if stack.len() == 0 {\n           \
    \     return false;\n            }\n            stack.pop();\n        } else {\n\
    \            if stack.len() == 0 {\n                return false;\n          \
    \  }\n            stack.pop();\n            stack.push(c);\n        }\n    }\n\
    \    stack.len() == 0\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpdq2hpgvl.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748673
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    let\
    \ mut open_brackets = 0;\n    for c in string.chars() {\n        if c == '[' {\n\
    \            stack.push(c);\n            open_brackets += 1;\n        } else if\
    \ c == '[' && stack.len() > 0 && stack.pop() == '[' {\n            open_brackets\
    \ -= 1;\n        }\n        if open_brackets == 0 {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1wik4axp.rs:23:65\n   |\n\
    23 |         } else if c == '[' && stack.len() > 0 && stack.pop() == '[' {\n \
    \  |                                                                 ^^^\n   |\
    \                                                                 |\n   |    \
    \                                                             expected enum `Option`,\
    \ found `char`\n   |                                                         \
    \        help: try using a variant of the expected enum: `Some('[')`\n   |\n \
    \  = note: expected enum `Option<char>`\n              found type `char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    let\
    \ mut open_brackets = 0;\n    let mut closed_brackets = 0;\n    let mut i = 0;\n\
    \    while i < string.len() {\n        if string[i] == '[' {\n            stack.push(string[i]);\n\
    \            open_brackets += 1;\n        } else if string[i] == ']' {\n     \
    \       closed_brackets += 1;\n            if closed_brackets == open_brackets\
    \ {\n                stack.pop();\n            }\n        } else if string[i]\
    \ == '{' {\n            stack.push(string[i]);\n        } else if string[i] ==\
    \ '}' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            closed_brackets += 1;\n            if closed_brackets\
    \ == open_brackets {\n                stack.pop();\n            }\n        }\n\
    \        i += 1;\n    }\n    stack.len() == 0 && closed_brackets == open_brackets\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp0jef7ios.rs:22:12\n\
    \   |\n22 |         if string[i] == '[' {\n   |            ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmp0jef7ios.rs:23:24\n   |\n23 |             stack.push(string[i]);\n\
    \   |                        ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp0jef7ios.rs:25:19\n\
    \   |\n25 |         } else if string[i] == ']' {\n   |                   ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmp0jef7ios.rs:30:19\n   |\n30 |         } else\
    \ if string[i] == '{' {\n   |                   ^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n \
    \ --> /tmp/tmp0jef7ios.rs:31:24\n   |\n31 |             stack.push(string[i]);\n\
    \   |                        ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp0jef7ios.rs:32:19\n\
    \   |\n32 |         } else if string[i] == '}' {\n   |                   ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror: aborting due to 6 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n\
    \    let mut open_brackets: usize = 0;\n    let mut close_brackets: usize = 0;\n\
    \    let mut bracket_level: usize = 0;\n    let mut bracket_levels: Vec<usize>\
    \ = vec![];\n    let mut bracket_levels_len: usize = 0;\n    let mut bracket_levels_lens:\
    \ Vec<usize> = vec![];\n    let mut bracket_levels_lens_len: usize = 0;\n    let\
    \ mut bracket_levels_lens_lens: Vec<usize> = vec![];\n    let mut bracket_levels_lens_lens_len:\
    \ usize = 0;\n    let mut bracket_levels_lens_lens_lens: Vec<usize> = vec![];\n\
    \    let mut bracket_levels_lens_lens_lens_len: usize = 0;\n    let mut bracket_levels_lens_lens_lens_lens:\
    \ Vec<usize> = vec![];\n    let mut bracket_levels_lens_lens_lens_lens_len: usize\
    \ = 0;\n    let mut bracket_levels_lens_lens_lens_lens_lens: usize = 0;\n    let\
    \ mut bracket_levels_lens_lens_lens_lens_lens_len: usize = 0;\n    let mut bracket_levels_lens_lens_lens_lens_lens_lens_len:\
    \ usize = 0;\n    let mut bracket_levels_lens_lens_lens_lens_lens_lens_lens_lens_:\
    \ usize = 0;\n    let mut bracket_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_:\
    \ usize = 0;\n    let mut bracket_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_:\
    \ usize = 0;\n    let mut bracket_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_:\
    \ usize = 0;\n    let mut bracket_levels_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_lens_:\
    \ usize = 0;\n    let mut bracket_levels_lens_lens_lens_lens_\n}\n\nfn main()\
    \ {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpq86izs4n.rs:39:48\n   |\n\
    39 |     let mut bracket_levels_lens_lens_lens_lens_\n   |                   \
    \                             ^ help: add `;` here\n40 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq86izs4n.rs:16:33\n \
    \  |\n16 | fn is_nested(string: String) -> bool {\n   |    ---------         \
    \           ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = vec![0;\
    \ string.len()];\n    let mut i = 0;\n    while i < string.len() {\n        if\
    \ string[i] == ']' {\n            if stack.is_empty() {\n                return\
    \ false;\n            }\n            let top = stack.pop();\n            if top\
    \ != i {\n                return false;\n            }\n        } else {\n   \
    \         stack[stack.len() - 1] = i;\n        }\n        i += 1;\n    }\n   \
    \ stack.is_empty()\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpohq3rke5.rs:20:12\n\
    \   |\n20 |         if string[i] == ']' {\n   |            ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpohq3rke5.rs:25:23\n\
    \   |\n25 |             if top != i {\n   |                       ^\n   |    \
    \                   |\n   |                       expected enum `Option`, found\
    \ `usize`\n   |                       help: try using a variant of the expected\
    \ enum: `Some(i)`\n   |\n   = note: expected enum `Option<usize>`\n          \
    \    found type `usize`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n\
    \    let mut open_brackets: usize = 0;\n    let mut close_brackets: usize = 0;\n\
    \    let mut open_brackets_stack: Vec<usize> = vec![];\n    let mut close_brackets_stack:\
    \ Vec<usize> = vec![];\n    let mut open_brackets_stack_len: usize = 0;\n    let\
    \ mut close_brackets_stack_len: usize = 0;\n    let mut open_brackets_stack_len2:\
    \ usize = 0;\n    let mut close_brackets_stack_len2: usize = 0;\n    let mut open_brackets_stack_len3:\
    \ usize = 0;\n    let mut close_brackets_stack_len3: usize = 0;\n    let mut open_brackets_stack_len4:\
    \ usize = 0;\n    let mut close_brackets_stack_len4: usize = 0;\n    let mut open_brackets_stack_len5:\
    \ usize = 0;\n    let mut close_brackets_stack_len5: usize = 0;\n    let mut open_brackets_stack_len6:\
    \ usize = 0;\n    let mut close_brackets_stack_len6: usize = 0;\n    let mut open_brackets_stack_len7:\
    \ usize = 0;\n    let mut close_brackets_stack_len7: usize = 0;\n    let mut open_brackets_stack_len8:\
    \ usize = 0;\n    let mut close_brackets_stack_len8: usize = 0;\n    let mut open_brackets_stack_len9:\
    \ usize = 0;\n    let mut close_brackets_stack_len9: usize = 0;\n    let mut open_brackets_stack_len10:\
    \ usize = 0;\n    let mut close_brackets_stack_len10: usize = 0;\n    let mut\
    \ open_brackets_stack_len11: usize = 0;\n    let mut close_brackets_stack_len11:\
    \ usize = 0;\n    let mut open_brackets_stack_len12: usize = 0;\n    let mut close_brackets_stack_len12:\
    \ usize = 0;\n    let mut open_brackets_stack_len13: usize = 0;\n    let mut close_brackets_stack_len13:\
    \ usize = 0;\n    let mut open_brackets_stack_len14: usize = 0;\n    let mut close_brackets_stack_len14\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpjfr4t5ke.rs:49:39\n   |\n\
    49 |     let mut close_brackets_stack_len14\n   |                            \
    \           ^ help: add `;` here\n50 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjfr4t5ke.rs:16:33\n   |\n16 | fn is_nested(string:\
    \ String) -> bool {\n   |    ---------                    ^^^^ expected `bool`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(0);\n\
    \    \n    let mut i = 0;\n    while i < string.len() {\n        if string[i]\
    \ == '[' {\n            stack.push(1);\n            i += 1;\n        } else if\
    \ string[i] == ']' {\n            if stack.pop() != 1 {\n                return\
    \ false;\n            }\n            i += 1;\n        } else {\n            if\
    \ stack.pop() != 0 {\n                return false;\n            }\n         \
    \   i += 1;\n        }\n    }\n    \n    stack.pop() == 0\n}\n\nfn main() {\n\
    \    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\"\
    )), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmprfuw0uj6.rs:22:12\n\
    \   |\n22 |         if string[i] == '[' {\n   |            ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmprfuw0uj6.rs:25:19\n   |\n25 |         } else if string[i]\
    \ == ']' {\n   |                   ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmprfuw0uj6.rs:26:31\n   |\n26 |  \
    \           if stack.pop() != 1 {\n   |                               ^\n   |\
    \                               |\n   |                               expected\
    \ enum `Option`, found integer\n   |                               help: try using\
    \ a variant of the expected enum: `Some(1)`\n   |\n   = note: expected enum `Option<{integer}>`\n\
    \              found type `{integer}`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmprfuw0uj6.rs:31:31\n   |\n31 |             if stack.pop() != 0 {\n  \
    \ |                               ^\n   |                               |\n  \
    \ |                               expected enum `Option`, found integer\n   |\
    \                               help: try using a variant of the expected enum:\
    \ `Some(0)`\n   |\n   = note: expected enum `Option<{integer}>`\n            \
    \  found type `{integer}`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprfuw0uj6.rs:38:20\n\
    \   |\n38 |     stack.pop() == 0\n   |                    ^\n   |            \
    \        |\n   |                    expected enum `Option`, found integer\n  \
    \ |                    help: try using a variant of the expected enum: `Some(0)`\n\
    \   |\n   = note: expected enum `Option<{integer}>`\n              found type\
    \ `{integer}`\n\nerror: aborting due to 5 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(0);\n\
    \    let mut i = 0;\n    while i < string.len() {\n        let mut j = i;\n  \
    \      while j < string.len() && string[j] == string[j] {\n            j = j +\
    \ 1;\n        }\n        if j - i > 1 {\n            stack.pop();\n          \
    \  stack.push(j);\n        }\n        i = j;\n    }\n    stack.pop();\n    stack.len()\
    \ > 1\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmprnq1x04z.rs:22:35\n\
    \   |\n22 |         while j < string.len() && string[j] == string[j] {\n   | \
    \                                  ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmprnq1x04z.rs:22:48\n\
    \   |\n22 |         while j < string.len() && string[j] == string[j] {\n   | \
    \                                               ^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = Vec::new();\n\
    \    let mut i = 0;\n    while i < string.len() {\n        if string[i] == '['\
    \ {\n            stack.push(i);\n            i += 1;\n        } else if string[i]\
    \ == ']' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            let top = stack.len();\n            stack.pop();\n\
    \            if top != stack.len() {\n                return false;\n        \
    \    }\n            i += 1;\n        } else {\n            i += 1;\n        }\n\
    \    }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpj3ndrmqm.rs:20:12\n\
    \   |\n20 |         if string[i] == '[' {\n   |            ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpj3ndrmqm.rs:23:19\n   |\n23 |         } else if string[i]\
    \ == ']' {\n   |                   ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    let\
    \ mut in_bracket = false;\n    let mut in_quote = false;\n    let mut in_string\
    \ = false;\n    let mut in_escape = false;\n    let mut in_comment = false;\n\
    \    let mut in_comment = false;\n    let mut in_comment = false;\n    let mut\
    \ in_comment = false;\n    let mut in_comment = false;\n    let mut in_comment\
    \ = false;\n    let mut in_comment = false;\n    let mut in_comment = false;\n\
    \    let mut in_comment = false;\n    let mut in_comment = false;\n    let mut\
    \ in_comment = false;\n    let mut in_comment = false;\n    let mut in_comment\
    \ = false;\n    let mut in_comment = false;\n    let mut in_comment = false;\n\
    \    let mut in_comment = false;\n    let mut in_comment = false;\n    let mut\
    \ in_comment = false;\n    let mut in_comment = false;\n    let mut in_comment\
    \ = false;\n    let mut in_comment = false;\n    let mut in_comment = false;\n\
    \    let mut in_comment = false;\n    let mut in_comment = false;\n    let mut\
    \ in_comment = false;\n    let mut in_comment = false;\n    let mut in_comment\
    \ = false;\n    let mut in_comment = false;\n    let mut in_comment = false;\n\
    \    let mut in_comment = false;\n    let mut in_comment = false;\n    let mut\
    \ in_comment = false;\n    let mut in_comment = false;\n    let mut in_comment\
    \ = false;\n    let mut in_comment = false;\n    let mut in_comment = false;\n\
    \    let mut in_comment = false;\n    let mut in_comment = false;\n    let mut\
    \ in_comment = false;\n    let mut in_comment = false;\n    let mut in_comment\
    \ = false;\n    let mut in_comment = false;\n    let mut in_comment = false;\n\
    \    let mut in_comment = false;\n    let mut in_comment = false;\n    let mut\
    \ in_comment = false;\n    let mut in_comment = false;\n    let mut in_comment\
    \ = false;\n    let mut in_comment = false;\n    let mut in_comment = false;\n\
    \    let mut in_comment = false;\n    let mut in_comment = false;\n    let mut\
    \ in_comment = false;\n    let mut in_comment = false;\n    let mut in_comment\
    \ = false;\n    let mut in_comment = false;\n    let mut in_comment = false;\n\
    \    let mut in_comment = false;\n    let mut in_comment = false;\n    let mut\
    \ in_comment = false;\n    let mut in_comment = false;\n    let mut in_comment\
    \ = false;\n    let mut in_comment = false;\n    let mut in_comment = false;\n\
    \    let mut in_comment = false;\n    let mut in_comment = false;\n    let mut\
    \ in_comment = false;\n    let mut in_comment\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpyin1lj7t.rs:89:23\n   |\n\
    89 |     let mut in_comment\n   |                       ^ help: add `;` here\n\
    90 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyin1lj7t.rs:16:33\n\
    \   |\n16 | fn is_nested(string: String) -> bool {\n   |    ---------        \
    \            ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().all(|c| {\n       \
    \ if c == '[' {\n            true\n        } else if c == ']' {\n            true\n\
    \        } else if c == '{' {\n            true\n        } else if c == '}' {\n\
    \            true\n        } else if c == '(' {\n            true\n        } else\
    \ if c == ')' {\n            true\n        } else {\n            false\n     \
    \   }\n    })\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwh20fk7v.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748673
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    let\
    \ mut bracket_count = 0;\n    let mut bracket_open = false;\n    let mut bracket_closed\
    \ = false;\n    let mut bracket_open_index = 0;\n    let mut bracket_closed_index\
    \ = 0;\n    let mut bracket_open_index2 = 0;\n    let mut bracket_closed_index2\
    \ = 0;\n    let mut bracket_open_index3 = 0;\n    let mut bracket_closed_index3\
    \ = 0;\n    let mut bracket_open_index4 = 0;\n    let mut bracket_closed_index4\
    \ = 0;\n    let mut bracket_open_index5 = 0;\n    let mut bracket_closed_index5\
    \ = 0;\n    let mut bracket_open_index6 = 0;\n    let mut bracket_closed_index6\
    \ = 0;\n    let mut bracket_open_index7 = 0;\n    let mut bracket_closed_index7\
    \ = 0;\n    let mut bracket_open_index8 = 0;\n    let mut bracket_closed_index8\
    \ = 0;\n    let mut bracket_open_index9 = 0;\n    let mut bracket_closed_index9\
    \ = 0;\n    let mut bracket_open_index10 = 0;\n    let mut bracket_closed_index10\
    \ = 0;\n    let mut bracket_open_index11 = 0;\n    let mut bracket_closed_index11\
    \ = 0;\n    let mut bracket_open_index12 = 0;\n    let mut bracket_closed_index12\
    \ = 0;\n    let mut bracket_open_index13 = 0;\n    let mut bracket_closed_index13\
    \ = 0;\n    let mut bracket_open_index14 = 0;\n    let mut bracket_closed_index14\
    \ = 0;\n    let mut bracket_open_index15 = 0;\n    let mut bracket_closed_index15\
    \ = 0;\n    let mut bracket_open_index16 = 0;\n    let mut bracket_closed_index16\
    \ = 0;\n    let mut bracket_open_index17 = 0;\n    let mut bracket_closed_index17\
    \ = 0;\n    let mut bracket_open_index18 = 0;\n    let mut bracket_closed_index18\
    \ = 0;\n    let mut bracket_open_index19 = 0;\n    let mut bracket_closed_index19\
    \ = 0;\n    let mut bracket_open_index20 = 0;\n    let mut bracket_closed_index20\
    \ = 0;\n    let mut bracket_open_index21 = 0;\n    let mut bracket_closed_index21\
    \ = 0;\n    let mut \n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp2su8ds4g.rs:64:1\n\
    \   |\n64 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    let\
    \ mut in_bracket = false;\n    let mut bracket_count = 0;\n    for ch in string.chars()\
    \ {\n        if ch == '[' {\n            stack.push(ch);\n            in_bracket\
    \ = true;\n            bracket_count += 1;\n        } else if ch == ']' {\n  \
    \          bracket_count -= 1;\n            if bracket_count == 0 {\n        \
    \        stack.pop();\n                in_bracket = false;\n            }\n  \
    \      } else if ch == '[' && in_bracket {\n            bracket_count += 1;\n\
    \        } else if ch == ']' && in_bracket {\n            bracket_count -= 1;\n\
    \        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate =\
    \ is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpsoasq2p0.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748673
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    stack.push(0);\n\
    \    let mut i = 0;\n    while i < string.len() {\n        if stack.is_empty()\
    \ {\n            return false;\n        }\n        let mut j = i;\n        while\
    \ j < string.len() {\n            if string[j] == ']' {\n                stack.pop();\n\
    \            } else {\n                stack.push(i + 1);\n                j =\
    \ j + 1;\n            }\n        }\n        i = i + 1;\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpli07f6fd.rs:26:16\n\
    \   |\n26 |             if string[j] == ']' {\n   |                ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748673
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    let\
    \ mut open_brackets = 0;\n    let mut closed_brackets = 0;\n    let mut i = 0;\n\
    \    while i < string.len() {\n        if string[i] == '[' {\n            stack.push(string[i]);\n\
    \            open_brackets += 1;\n        }\n        if string[i] == ']' {\n \
    \           closed_brackets += 1;\n            if closed_brackets == open_brackets\
    \ {\n                return true;\n            }\n            stack.pop();\n \
    \       }\n        i += 1;\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpdtwaf5qz.rs:22:12\n\
    \   |\n22 |         if string[i] == '[' {\n   |            ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpdtwaf5qz.rs:23:24\n   |\n23 |             stack.push(string[i]);\n\
    \   |                        ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpdtwaf5qz.rs:26:12\n\
    \   |\n26 |         if string[i] == ']' {\n   |            ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror: aborting due to 3 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748673
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n\
    \    let mut open_brackets: usize = 0;\n    let mut closed_brackets: usize = 0;\n\
    \    let mut i = 0;\n    while i < string.len() {\n        if string[i] == ']'\
    \ {\n            closed_brackets += 1;\n            i += 1;\n        } else if\
    \ string[i] == '[' {\n            open_brackets += 1;\n            i += 1;\n \
    \       } else {\n            i += 1;\n        }\n        if open_brackets ==\
    \ closed_brackets {\n            stack.append(i);\n        }\n    }\n    stack.len()\
    \ > 0 && stack[0] < string.len()\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp9si8tx4d.rs:22:12\n\
    \   |\n22 |         if string[i] == ']' {\n   |            ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmp9si8tx4d.rs:25:19\n   |\n25 |         } else if string[i]\
    \ == '[' {\n   |                   ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp9si8tx4d.rs:32:26\n   |\n32 |  \
    \           stack.append(i);\n   |                          ^ expected `&mut Vec<usize>`,\
    \ found `usize`\n   |\n   = note: expected mutable reference `&mut Vec<usize>`\n\
    \                           found type `usize`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748673
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n\
    \    let mut i = 0;\n    while i < string.len() {\n        if string[i] == '['\
    \ {\n            stack.push(i);\n        } else if string[i] == ']' {\n      \
    \      if stack.is_empty() {\n                return false;\n            }\n \
    \           let index = stack.pop();\n            if index == i {\n          \
    \      return true;\n            }\n        }\n        i += 1;\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmphvf0_j0x.rs:20:12\n\
    \   |\n20 |         if string[i] == '[' {\n   |            ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmphvf0_j0x.rs:22:19\n   |\n22 |         } else if string[i]\
    \ == ']' {\n   |                   ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmphvf0_j0x.rs:27:25\n   |\n27 |  \
    \           if index == i {\n   |                         ^\n   |            \
    \             |\n   |                         expected enum `Option`, found `usize`\n\
    \   |                         help: try using a variant of the expected enum:\
    \ `Some(i)`\n   |\n   = note: expected enum `Option<usize>`\n              found\
    \ type `usize`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748673
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n\
    \    let mut bracket_count = 0;\n    let mut bracket_stack: Vec<usize> = vec![];\n\
    \    \n    for c in string.chars() {\n        if c == '[' {\n            stack.push(bracket_count);\n\
    \            bracket_stack.push(bracket_count);\n            bracket_count +=\
    \ 1;\n        } else if c == ']' {\n            bracket_count -= 1;\n        \
    \    if bracket_stack.pop() != stack.pop() {\n                return false;\n\
    \            }\n        }\n    }\n    \n    stack.pop() == 0\n}\n\nfn main() {\n\
    \    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\"\
    )), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp70xsgk0p.rs:34:20\n   |\n\
    34 |     stack.pop() == 0\n   |                    ^\n   |                   \
    \ |\n   |                    expected enum `Option`, found integer\n   |     \
    \               help: try using a variant of the expected enum: `Some(0)`\n  \
    \ |\n   = note: expected enum `Option<usize>`\n              found type `{integer}`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748673
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    let\
    \ mut open_brackets = 0;\n    let mut close_brackets = 0;\n    let mut open_brackets_stack\
    \ = Vec::new();\n    let mut close_brackets_stack = Vec::new();\n    let mut bracket_stack\
    \ = Vec::new();\n    let mut bracket_stack_size = -1;\n    let mut bracket_stack_pos\
    \ = -1;\n    let mut bracket_stack_end = -1;\n    let mut bracket_stack_pos =\
    \ -1;\n    let mut bracket_stack_end = -1;\n    let mut bracket_stack_pos = -1;\n\
    \    let mut bracket_stack_end = -1;\n    let mut bracket_stack_pos = -1;\n  \
    \  let mut bracket_stack_end = -1;\n    let mut bracket_stack_pos = -1;\n    let\
    \ mut bracket_stack_end = -1;\n    let mut bracket_stack_pos = -1;\n    let mut\
    \ bracket_stack_end = -1;\n    let mut bracket_stack_pos = -1;\n    let mut bracket_stack_end\
    \ = -1;\n    let mut bracket_stack_pos = -1;\n    let mut bracket_stack_end =\
    \ -1;\n    let mut bracket_stack_pos = -1;\n    let mut bracket_stack_end = -1;\n\
    \    let mut bracket_stack_pos = -1;\n    let mut bracket_stack_end = -1;\n  \
    \  let mut bracket_stack_pos = -1;\n    let mut bracket_stack_end = -1;\n    let\
    \ mut bracket_stack_pos = -1;\n    let mut bracket_stack_end = -1;\n    let mut\
    \ bracket_stack_pos = -1;\n    let mut bracket_stack_end = -1;\n    let mut bracket_stack_pos\
    \ = -1;\n    let mut bracket_stack_end = -1;\n    let mut bracket_stack_pos =\
    \ -1;\n    let mut bracket_stack_end = -1;\n    let mut bracket_stack_pos = -1;\n\
    \    let mut bracket_stack_end = -1;\n    let mut bracket_stack_pos = -1;\n  \
    \  let mut bracket_stack_end = -1;\n    let mut bracket_stack_pos = -1;\n    let\
    \ mut bracket_stack_end = -1;\n    let mut bracket_stack_pos = -1;\n    let mut\
    \ bracket_stack_end = -1;\n    let mut bracket_stack_pos = -1;\n    let mut bracket_stack_end\
    \ = -1;\n    let mut bracket_stack_pos = -1;\n    let mut bracket_stack_end =\
    \ -1;\n    let mut bracket_stack_pos = -1;\n    let \n}\n\nfn main() {\n    let\
    \ candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpedzpizv1.rs:68:1\n  \
    \ |\n68 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748673
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = Vec::new();\n\
    \    let mut open_brackets: Vec<usize> = Vec::new();\n    let mut close_brackets:\
    \ Vec<usize> = Vec::new();\n    let mut open_brackets_size: usize = 0;\n    let\
    \ mut close_brackets_size: usize = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut k = 0;\n    let mut string_size = string.len();\n    while i < string_size\
    \ {\n        if string[i] == '[' {\n            stack.push(0);\n            open_brackets.push(0);\n\
    \            close_brackets.push(0);\n            open_brackets_size = 0;\n  \
    \          close_brackets_size = 0;\n            i += 1;\n        } else if string[i]\
    \ == ']' {\n            open_brackets_size += 1;\n            close_brackets_size\
    \ += 1;\n            if open_brackets_size == close_brackets_size {\n        \
    \        let mut stack_size = stack.len();\n                while stack_size !=\
    \ 0 {\n                    let mut stack_size = stack.pop();\n               \
    \     let mut open_brackets_size = open_brackets.len();\n                    while\
    \ open_brackets_size != 0 {\n                        let mut open_brackets_size\
    \ = open_brackets.pop();\n                        let mut close_brackets_size\
    \ = close_brackets.len();\n                        while close_brackets_size !=\
    \ 0 {\n                            let mut close_brackets_size = close_brackets.pop();\n\
    \                            if open_brackets_size == close_brackets_size {\n\
    \                                return true;\n                            }\n\
    \                        }\n                    }\n                }\n       \
    \     }\n            i += 1;\n        } else {\n            i += 1;\n        }\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpc_esi4qo.rs:27:12\n\
    \   |\n27 |         if string[i] == '[' {\n   |            ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpc_esi4qo.rs:34:19\n   |\n34 |         } else if string[i]\
    \ == ']' {\n   |                   ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748673
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    let\
    \ mut open_brackets = 0;\n    let mut closed_brackets = 0;\n    let mut open_brackets_stack\
    \ = Vec::new();\n    let mut closed_brackets_stack = Vec::new();\n    let mut\
    \ open_brackets_stack = Vec::new();\n    let mut closed_brackets_stack = Vec::new();\n\
    \    let mut open_brackets_stack = Vec::new();\n    let mut closed_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack = Vec::new();\n    let mut closed_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack = Vec::new();\n    let mut closed_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack = Vec::new();\n    let mut closed_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack = Vec::new();\n    let mut closed_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack = Vec::new();\n    let mut closed_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack = Vec::new();\n    let mut closed_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack = Vec::new();\n    let mut closed_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack = Vec::new();\n    let mut closed_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack = Vec::new();\n    let mut closed_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack = Vec::new();\n    let mut closed_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack = Vec::new();\n    let mut closed_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack = Vec::new();\n    let mut closed_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack = Vec::new();\n    let mut closed_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack = Vec::new();\n    let mut closed_bracket\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpx6yolkqv.rs:53:27\n   |\n\
    53 |     let mut closed_bracket\n   |                           ^ help: add `;`\
    \ here\n54 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpx6yolkqv.rs:16:33\n   |\n16 | fn is_nested(string: String) -> bool {\n\
    \   |    ---------                    ^^^^ expected `bool`, found `()`\n   | \
    \   |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748673
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n\
    \    let mut open_brackets: Vec<usize> = vec![];\n    let mut close_brackets:\
    \ Vec<usize> = vec![];\n    let mut open_brackets_size: usize = 0;\n    let mut\
    \ close_brackets_size: usize = 0;\n    let mut open_brackets_depth: usize = 0;\n\
    \    let mut close_brackets_depth: usize = 0;\n    let mut open_brackets_depth_increment:\
    \ usize = 0;\n    let mut close_brackets_depth_increment: usize = 0;\n    let\
    \ mut open_brackets_depth_increment_increment: usize = 0;\n    let mut close_brackets_depth_increment_increment:\
    \ usize = 0;\n    let mut open_brackets_depth_increment_increment_increment: usize\
    \ = 0;\n    let mut close_brackets_depth_increment_increment_increment: usize\
    \ = 0;\n    let mut open_brackets_depth_increment_increment_increment_increment:\
    \ usize = 0;\n    let mut close_brackets_depth_increment_increment_increment_increment:\
    \ usize = 0;\n    let mut open_brackets_depth_increment_increment_increment_increment_increment:\
    \ usize = 0;\n    let mut close_brackets_depth_increment_increment_increment_increment_increment:\
    \ usize = 0;\n    let mut open_brackets_depth_increment_increment_increment_increment_increment_increment:\
    \ usize = 0;\n    let mut close_brackets_depth_increment_increment_increment_increment_increment_increment:\
    \ usize = 0;\n    let mut open_brackets_depth_increment_increment_increment_increment_increment_increment_increment:\
    \ usize = 0;\n    let mut close_brackets_depth_increment_increment_increment_increment_increment_increment:\
    \ usize = 0;\n    let mut open_brackets_depth_increment_increment_increment_increment_increment_increment_increment_increment:\
    \ usize = 0;\n    let mut close_brackets_depth_increment_increment_increment_increment_increment_increment_increment:\
    \ usize = 0;\n    let mut open_brackets_depth_increment_increment_increment_increment_increment_increment_increment_increment_increment:\
    \ usize = 0;\n    let mut close_brackets_depth_increment_increment_increment_increment_increment_increment_increment_increment:\
    \ usize = 0;\n    let mut open_brackets_depth_increment_increment_increment_increment_increment_increment_increment_\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp38ynela_.rs:42:103\n   |\n\
    42 |     let mut open_brackets_depth_increment_increment_increment_increment_increment_increment_increment_\n\
    \   |                                                                        \
    \                               ^ help: add `;` here\n43 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp38ynela_.rs:16:33\n \
    \  |\n16 | fn is_nested(string: String) -> bool {\n   |    ---------         \
    \           ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748673
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n\
    \    let mut bracket_count = 0;\n    let mut bracket_open = false;\n    let mut\
    \ bracket_closed = false;\n    let mut bracket_open_index = 0;\n    let mut bracket_closed_index\
    \ = 0;\n    let mut bracket_open_index2 = 0;\n    let mut bracket_closed_index2\
    \ = 0;\n    let mut bracket_open_index3 = 0;\n    let mut bracket_closed_index3\
    \ = 0;\n    let mut bracket_open_index4 = 0;\n    let mut bracket_closed_index4\
    \ = 0;\n    let mut bracket_open_index5 = 0;\n    let mut bracket_closed_index5\
    \ = 0;\n    let mut bracket_open_index6 = 0;\n    let mut bracket_closed_index6\
    \ = 0;\n    let mut bracket_open_index7 = 0;\n    let mut bracket_closed_index7\
    \ = 0;\n    let mut bracket_open_index8 = 0;\n    let mut bracket_closed_index8\
    \ = 0;\n    let mut bracket_open_index9 = 0;\n    let mut bracket_closed_index9\
    \ = 0;\n    let mut bracket_open_index10 = 0;\n    let mut bracket_closed_index10\
    \ = 0;\n    let mut bracket_open_index11 = 0;\n    let mut bracket_closed_index11\
    \ = 0;\n    let mut bracket_open_index12 = 0;\n    let mut bracket_closed_index12\
    \ = 0;\n    let mut bracket_open_index13 = 0;\n    let mut bracket_closed_index13\
    \ = 0;\n    let mut bracket_open_index14 = 0;\n    let mut bracket_closed_index14\
    \ = 0;\n    let mut bracket_open_index15 = 0;\n    let mut bracket_closed_index15\
    \ = 0;\n    let mut bracket_open_index16 = 0;\n    let mut bracket_closed_index16\
    \ = 0;\n    let mut bracket_open_index17 = 0;\n    let mut bracket_closed_index17\
    \ = 0;\n    let mut bracket_open_index18 = 0;\n    let mut bracket_closed_index18\
    \ = 0;\n    let mut bracket_open_index19 = 0;\n    let mut bracket_closed_index19\
    \ = 0;\n    let mut bracket_open_index20 = 0;\n    let mut bracket_closed_index20\
    \ = 0;\n    let mut bracket_open_index21 = 0;\n    let mut bracket_closed_index21\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpm1v6o4ss.rs:62:35\n   |\n\
    62 |     let mut bracket_closed_index21\n   |                                \
    \   ^ help: add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpm1v6o4ss.rs:16:33\n   |\n16 | fn is_nested(string: String)\
    \ -> bool {\n   |    ---------                    ^^^^ expected `bool`, found\
    \ `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or\
    \ `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748673
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = Vec::new();\n\
    \    let mut open_brackets: usize = 0;\n    let mut closed_brackets: usize = 0;\n\
    \    let mut i = 0;\n    while i < string.len() {\n        if string[i] == '['\
    \ {\n            stack.push(i);\n            open_brackets += 1;\n        } else\
    \ if string[i] == ']' {\n            closed_brackets += 1;\n            if closed_brackets\
    \ == open_brackets {\n                stack.pop();\n                open_brackets\
    \ -= 1;\n            }\n        }\n        i += 1;\n    }\n    stack.len() ==\
    \ 0 && open_brackets == closed_brackets\n}\n\nfn main() {\n    let candidate =\
    \ is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp9mwt45xg.rs:22:12\n\
    \   |\n22 |         if string[i] == '[' {\n   |            ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmp9mwt45xg.rs:25:19\n   |\n25 |         } else if string[i]\
    \ == ']' {\n   |                   ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748673
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = vec![0;\
    \ string.len()];\n    let mut i = 0;\n    let mut open_brackets = 0;\n    while\
    \ i < string.len() {\n        if string[i] == '[' {\n            stack.push(i);\n\
    \            open_brackets += 1;\n        }\n        if string[i] == ']' {\n \
    \           open_brackets -= 1;\n            if open_brackets == 0 {\n       \
    \         stack.pop();\n            }\n        }\n        i += 1;\n    }\n   \
    \ stack.len() != 0\n}\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpqjfjkwm4.rs:21:12\n\
    \   |\n21 |         if string[i] == '[' {\n   |            ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpqjfjkwm4.rs:25:12\n   |\n25 |         if string[i]\
    \ == ']' {\n   |            ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748673
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n\
    \    let mut index = 0;\n    let mut bracket_count = 0;\n    let mut bracket_open\
    \ = false;\n    let mut bracket_closed = false;\n    loop {\n        match string[index]\
    \ {\n            '[' => {\n                bracket_open = true;\n            \
    \    stack.push(index);\n            }\n            '[' => {\n               \
    \ bracket_count++;\n            }\n            ']' => {\n                bracket_count--;\n\
    \                if bracket_count == 0 {\n                    bracket_closed =\
    \ true;\n                }\n            }\n            _ => {\n              \
    \  bracket_open = false;\n                bracket_closed = false;\n          \
    \  }\n        }\n        index += 1;\n        if index >= string.len() {\n   \
    \         break;\n        }\n    }\n    bracket_count > 0\n}\n\nfn main() {\n\
    \    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\"\
    )), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected expression, found `+`\n  --> /tmp/tmpv2r4hl5q.rs:29:31\n\
    \   |\n29 |                 bracket_count++;\n   |                           \
    \    ^ expected expression\n\nerror: expected expression, found `;`\n  --> /tmp/tmpv2r4hl5q.rs:32:32\n\
    \   |\n32 |                 bracket_count--;\n   |                           \
    \     ^ expected expression\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `{integer}`\n  --> /tmp/tmpv2r4hl5q.rs:23:15\n   |\n23 |         match string[index]\
    \ {\n   |               ^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748673
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = Vec::new();\n\
    \    let mut bracket_count = 1;\n    let mut bracket_level = 0;\n    let mut bracket_start\
    \ = -1;\n    let mut bracket_end = -1;\n    let mut bracket_string = string;\n\
    \    \n    for c in bracket_string.chars() {\n        if c == '[' {\n        \
    \    stack.push(bracket_count);\n            bracket_count = 1;\n            bracket_level\
    \ += 1;\n            bracket_start = c;\n        }\n        \n        if c ==\
    \ ']' {\n            bracket_count -= 1;\n            bracket_level -= 1;\n  \
    \          \n            if bracket_level == 0 {\n                bracket_end\
    \ = c;\n                \n                if bracket_start == bracket_end {\n\
    \                    return true;\n                }\n            }\n        }\n\
    \    }\n    \n    false\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppbb78an1.rs:29:29\n   |\n\
    29 |             bracket_start = c;\n   |                             ^ expected\
    \ integer, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppbb78an1.rs:37:31\n\
    \   |\n37 |                 bracket_end = c;\n   |                           \
    \    ^ expected integer, found `char`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748673
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    let\
    \ mut open_brackets = 0;\n    let mut close_brackets = 0;\n    let mut bracket_count\
    \ = 0;\n    for c in string.chars() {\n        if c == '[' {\n            stack.push(c);\n\
    \            open_brackets += 1;\n        } else if c == '{' {\n            stack.push(c);\n\
    \            close_brackets += 1;\n        } else if c == '}' {\n            if\
    \ open_brackets > close_brackets {\n                return false;\n          \
    \  }\n            open_brackets -= 1;\n            close_brackets += 1;\n    \
    \    } else if c == '[' {\n            if open_brackets > close_brackets {\n \
    \               return false;\n            }\n            open_brackets += 1;\n\
    \        } else if c == '}' {\n            if open_brackets > close_brackets {\n\
    \                return false;\n            }\n            close_brackets += 1;\n\
    \        } else if c == '[' {\n            open_brackets += 1;\n        } else\
    \ if c == '}' {\n            close_brackets += 1;\n        }\n        bracket_count\
    \ += 1;\n    }\n    bracket_count == stack.len()\n}\n\nfn main() {\n    let candidate\
    \ = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmph5oddvok.rs:56:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748673
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = Vec::new();\n\
    \    let mut open_brackets: usize = 0;\n    let mut close_brackets: usize = 0;\n\
    \    let mut i = 0;\n    while i < string.len() {\n        if string[i] == '['\
    \ {\n            stack.push(i);\n            open_brackets += 1;\n        }\n\
    \        if string[i] == ']' {\n            close_brackets += 1;\n           \
    \ if open_brackets > close_brackets {\n                return false;\n       \
    \     }\n            open_brackets -= 1;\n        }\n        i += 1;\n    }\n\
    \    stack.len() > 0 && stack.pop() == string.len()\n}\n\nfn main() {\n    let\
    \ candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][]\")), false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []]\")), false);\n    assert_eq!(candidate(String::from(\"[[]][[\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n\
    \    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpp4r5fxfj.rs:22:12\n\
    \   |\n22 |         if string[i] == '[' {\n   |            ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpp4r5fxfj.rs:26:12\n   |\n26 |         if string[i]\
    \ == ']' {\n   |            ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpp4r5fxfj.rs:35:39\n   |\n35 |  \
    \   stack.len() > 0 && stack.pop() == string.len()\n   |                     \
    \                  ^^^^^^^^^^^^\n   |                                       |\n\
    \   |                                       expected enum `Option`, found `usize`\n\
    \   |                                       help: try using a variant of the expected\
    \ enum: `Some(string.len())`\n   |\n   = note: expected enum `Option<usize>`\n\
    \              found type `usize`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748673
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().all(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpwqd_0nes.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack = Vec::new();\n    let\
    \ mut i = 0;\n    while i < string.len() {\n        if string[i] == '[' {\n  \
    \          stack.push(1);\n            i += 1;\n        } else if string[i] ==\
    \ ']' {\n            stack.pop();\n            i += 1;\n        } else {\n   \
    \         i += 1;\n        }\n    }\n    stack.len() > 1\n}\n\nfn main() {\n \
    \   let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\"\
    )), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp0jjp_916.rs:20:12\n\
    \   |\n20 |         if string[i] == '[' {\n   |            ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmp0jjp_916.rs:23:19\n   |\n23 |         } else if string[i]\
    \ == ']' {\n   |                   ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748673
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = vec![];\n\
    \    let mut index = 0;\n    while index < string.len() {\n        if string[index]\
    \ == '[' {\n            stack.push(index);\n        }\n        if string[index]\
    \ == ']' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        }\n        index += 1;\n   \
    \ }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate = is_nested;\n\
    \    assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpgj9agnkf.rs:20:12\n\
    \   |\n20 |         if string[index] == '[' {\n   |            ^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpgj9agnkf.rs:23:12\n   |\n23 |         if string[index]\
    \ == ']' {\n   |            ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748672
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = Vec::new();\n\
    \    let mut open_brackets: Vec<usize> = Vec::new();\n    let mut close_brackets:\
    \ Vec<usize> = Vec::new();\n    let mut open_brackets_size: usize = 0;\n    let\
    \ mut close_brackets_size: usize = 0;\n    let mut open_brackets_depth: usize\
    \ = 0;\n    let mut close_brackets_depth: usize = 0;\n    let mut open_brackets_depth_increment:\
    \ usize = 0;\n    let mut close_brackets_depth_increment: usize = 0;\n    let\
    \ mut open_brackets_depth_increment_size: usize = 0;\n    let mut close_brackets_depth_increment_size:\
    \ usize = 0;\n    let mut open_brackets_depth_increment_depth: usize = 0;\n  \
    \  let mut close_brackets_depth_increment_depth: usize = 0;\n    let mut open_brackets_depth_increment_depth_increment:\
    \ usize = 0;\n    let mut close_brackets_depth_increment_depth_increment: usize\
    \ = 0;\n    let mut open_brackets_depth_increment_depth_increment_size: usize\
    \ = 0;\n    let mut close_brackets_depth_increment_depth_increment_size: usize\
    \ = 0;\n    let mut open_brackets_depth_increment_depth_increment_depth: usize\
    \ = 0;\n    let mut close_brackets_depth_increment_depth_increment_depth: usize\
    \ = 0;\n    let mut open_brackets_depth_increment_depth_increment_depth_increment:\
    \ usize = 0;\n    let mut close_brackets_depth_increment_depth_increment_depth_increment:\
    \ usize = 0;\n    let mut open_brackets_depth_increment_depth_increment_depth_increment_size:\
    \ usize = 0;\n    let mut close_brackets_depth_increment_depth_increment_depth_increment_size:\
    \ usize = 0;\n    let mut open_brackets_depth_increment_depth_increment_depth_increment_depth:\
    \ usize = 0;\n    let mut close_brackets_depth_increment_depth_increment_depth_increment:\
    \ usize = 0;\n    let mut open_brackets_depth_increment_depth_increment_depth_increment_depth:\
    \ usize = 0;\n    let mut close_brackets_depth_increment_depth_increment_depth_increment_depth:\
    \ usize = 0;\n    let mut open_brackets_depth_increment_\n}\n\nfn main() {\n \
    \   let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"[[]]\"\
    )), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5nd9i0nv.rs:44:43\n   |\n\
    44 |     let mut open_brackets_depth_increment_\n   |                        \
    \                   ^ help: add `;` here\n45 | }\n   | - unexpected token\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp5nd9i0nv.rs:16:33\n   |\n16 | fn\
    \ is_nested(string: String) -> bool {\n   |    ---------                    ^^^^\
    \ expected `bool`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748673
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    let mut stack: Vec<usize> = Vec::new();\n\
    \    let mut open_brackets: usize = 0;\n    let mut close_brackets: usize = 0;\n\
    \    let mut open_brackets_stack: Vec<usize> = Vec::new();\n    let mut close_brackets_stack:\
    \ Vec<usize> = Vec::new();\n    let mut open_brackets_stack_len: usize = 0;\n\
    \    let mut close_brackets_stack_len: usize = 0;\n    let mut open_brackets_stack_len2:\
    \ usize = 0;\n    let mut close_brackets_stack_len2: usize = 0;\n    let mut open_brackets_stack_len3:\
    \ usize = 0;\n    let mut close_brackets_stack_len3: usize = 0;\n    let mut open_brackets_stack_len4:\
    \ usize = 0;\n    let mut close_brackets_stack_len4: usize = 0;\n    let mut open_brackets_stack_len5:\
    \ usize = 0;\n    let mut close_brackets_stack_len5: usize = 0;\n    let mut open_brackets_stack_len6:\
    \ usize = 0;\n    let mut close_brackets_stack_len6: usize = 0;\n    let mut open_brackets_stack_len7:\
    \ usize = 0;\n    let mut close_brackets_stack_len7: usize = 0;\n    let mut open_brackets_stack_len8:\
    \ usize = 0;\n    let mut close_brackets_stack_len8: usize = 0;\n    let mut open_brackets_stack_len9:\
    \ usize = 0;\n    let mut close_brackets_stack_len9: usize = 0;\n    let mut open_brackets_stack_len10:\
    \ usize = 0;\n    let mut close_brackets_stack_len10: usize = 0;\n    let mut\
    \ open_brackets_stack_len11: usize = 0;\n    let mut close_brackets_stack_len11:\
    \ usize = 0;\n    let mut open_brackets_stack_len12: usize = 0;\n    let mut close_brackets_stack_len12:\
    \ usize = 0;\n    let mut open_brackets_stack_len13: usize = 0;\n    let mut close_brackets_stack_len13:\
    \ usize = 0;\n    let mut open_brackets_stack_len14: usize = 0;\n    let mut close_brackets_\n\
    }\n\nfn main() {\n    let candidate = is_nested;\n    assert_eq!(candidate(String::from(\"\
    [[]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]][[[[[]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][]\")), false);\n    assert_eq!(candidate(String::from(\"\
    []\")), false);\n    assert_eq!(candidate(String::from(\"[[[[]]]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"[[]\")), false);\n\
    \    assert_eq!(candidate(String::from(\"[]]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[]][[\")), true);\n    assert_eq!(candidate(String::from(\"[[][]]\")), true);\n\
    \    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"]]]]]]]]\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpnl2dru_1.rs:49:28\n   |\n\
    49 |     let mut close_brackets_\n   |                            ^ help: add\
    \ `;` here\n50 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnl2dru_1.rs:16:33\n   |\n16 | fn is_nested(string: String) -> bool\
    \ {\n   |    ---------                    ^^^^ expected `bool`, found `()`\n \
    \  |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 101
  program: "/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return true if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// >>> is_nested(String::from(\"[[]]\"))\n/// true\n/// >>> is_nested(String::from(\"\
    []]]]]]][[[[[]\"))\n/// false\n/// >>> is_nested(String::from(\"[][]\"))\n///\
    \ false\n/// >>> is_nested(String::from(\"[]\"))\n/// false\n/// >>> is_nested(String::from(\"\
    [[][]]\"))\n/// true\n/// >>> is_nested(String::from(\"[[]][[\"))\n/// true\n\
    fn is_nested(string: String) -> bool {\n    string.chars().any(|c| c == '[' ||\
    \ c == '{' || c == '(')\n}\n\nfn main() {\n    let candidate = is_nested;\n  \
    \  assert_eq!(candidate(String::from(\"[[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    []]]]]]][[[[[]\")), false);\n    assert_eq!(candidate(String::from(\"[][]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[]\")), false);\n    assert_eq!(candidate(String::from(\"\
    [[[[]]]]\")), true);\n    assert_eq!(candidate(String::from(\"[]]]]]]]]]]\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"[][][[]]\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[]\")), false);\n    assert_eq!(candidate(String::from(\"[]]\")), false);\n \
    \   assert_eq!(candidate(String::from(\"[[]][[\")), true);\n    assert_eq!(candidate(String::from(\"\
    [[][]]\")), true);\n    assert_eq!(candidate(String::from(\"\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"[[[[[[[[\")), false);\n    assert_eq!(candidate(String::from(\"\
    ]]]]]]]]\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0sua6bax.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
