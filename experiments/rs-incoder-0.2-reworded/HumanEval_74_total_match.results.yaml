language: rs
name: HumanEval_74_total_match
results:
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = vec![];\n    for x in lst1 {\n        for y in lst2 {\n            if x.len()\
    \ < y.len() {\n                total_chars.push(y);\n                break;\n\
    \            }\n        }\n    }\n    total_chars\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpayyltm_r.rs:21:18\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n21  |  \
    \       for y in lst2 {\n    |                  ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n21  |         for y in &lst2 {\n    |          \
    \        +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut total_len = 0;\n    for s in lst1 {\n        total_len += s.len();\n\
    \    }\n    for s in lst2 {\n        total_len += s.len();\n    }\n    if total_len\
    \ == 0 {\n        return vec![];\n    }\n    if total_len == lst1.len() {\n  \
    \      return lst1;\n    }\n    if total_len == lst2.len() {\n        return lst2;\n\
    \    }\n    let mut total_len = 0;\n    for s in lst1 {\n        total_len +=\
    \ s.len();\n    }\n    for s in lst2 {\n        total_len += s.len();\n    }\n\
    \    if total_len == 0 {\n        return vec![];\n    }\n    if total_len == lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_len == lst2.len() {\n        return\
    \ lst2;\n    }\n    let mut total_len = 0;\n    for s in lst1 {\n        total_len\
    \ += s.len();\n    }\n    for s in lst2 {\n        total_len += s.len();\n   \
    \ }\n    if total_len == 0 {\n        return vec![];\n    }\n    if total_len\
    \ == lst1.len() {\n        return lst1;\n    }\n    if total_len == lst2.len()\
    \ {\n        return lst2;\n    }\n    let mut total_len = 0;\n    for s in lst1\
    \ {\n        total_len += s.len();\n    }\n    for s in lst2 {\n        total_len\
    \ += s.len();\n    }\n    if total_len == 0 {\n        return vec![];\n    }\n\
    \    if total_len == lst1.len() {\n        return lst1;\n    }\n    if total_len\
    \ == lst2.len() {\n        return lst2;\n    }\n    let mut total_len = 0;\n \
    \   for s in lst1 {\n        total_len += s.len();\n    }\n    for s in lst2 {\n\
    \        total_len += s.len();\n    }\n    if total_len == 0 {\n        return\
    \ vec![];\n    }\n    if total_len == lst1.len() {\n        return lst1;\n   \
    \ }\n    if total_len == lst2.len() {\n        return lst2;\n    }\n    let mut\
    \ total_len = 0;\n    for s in lst1 {\n        total_len += s.len();\n    }\n\
    \    for s in lst2 {\n        total_len += s.len();\n    }\n    if total_len ==\
    \ 0 {\n        return vec![];\n    }\n    if total_len == lst1.len() {\n     \
    \   return lst1;\n    }\n    if total_len == lst2.len() {\n        return lst2;\n\
    \    }\n    let mut total_len = 0;\n    for s in lst1 {\n        total_len +=\
    \ s.len();\n    }\n    for s in lst2 {\n        total_len += s.len();\n    }\n\
    \    if total_len == 0 {\n        return vec!\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp2__6373j.rs:134:3\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                                                   \
    \  - unclosed delimiter\n...\n119 |     if total_len == 0 {\n    |           \
    \            - this delimiter might not be properly closed...\n120 |         return\
    \ vec!\n121 | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n134 | }\n    |   ^\n\nerror: expected one of `(`, `[`, or `{`, found `}`\n\
    \   --> /tmp/tmp2__6373j.rs:121:1\n    |\n120 |         return vec!\n    |   \
    \                 - expected one of `(`, `[`, or `{`\n121 | }\n    | ^ unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2__6373j.rs:15:57\n \
    \  |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |    -----------                                          ^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_match:\
    \ Vec<String> = vec![];\n    for x in lst1 {\n        if lst2.iter().any(|y| y.contains(&x))\
    \ {\n            total_match.push(x);\n        }\n    }\n    total_match\n}\n\n\
    fn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmp90qhij2l.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for elem in lst2 {\n        total_chars += elem.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for elem in lst2 {\n        total_chars +=\
    \ elem.len();\n    }\n    if total_chars == lst1.len() {\n        return lst1;\n\
    \    }\n    let mut total_chars = lst1.len();\n    for elem in lst2 {\n      \
    \  total_chars += elem.len();\n    }\n    if total_chars == lst1.len() {\n   \
    \     return lst1;\n    }\n    let mut total_chars = lst1.len();\n    for elem\
    \ in lst2 {\n        total_chars += elem.len();\n    }\n    if total_chars ==\
    \ lst1.len() {\n        return lst1;\n    }\n    let mut total_chars = lst1.len();\n\
    \    for elem in lst2 {\n        total_chars += elem.len();\n    }\n    if total_chars\
    \ == lst1.len() {\n        return lst1;\n    }\n    let mut total_chars = lst1.len();\n\
    \    for elem in lst2 {\n        total_chars += elem.len();\n    }\n    if total_chars\
    \ == lst1.len() {\n        return lst1;\n    }\n    let mut total_chars = lst1.len();\n\
    \    for elem in lst2 {\n        total_chars += elem.len();\n    }\n    if total_chars\
    \ == lst1.len() {\n        return lst1;\n    }\n    let mut total_chars = lst1.len();\n\
    \    for elem in lst2 {\n        total_chars += elem.len();\n    }\n    if total_chars\
    \ == lst1.len() {\n        return lst1;\n    }\n    let mut total_chars = lst1.len();\n\
    \    for elem in lst2 {\n        total_chars += elem.len();\n    }\n    if total_chars\
    \ == lst1.len() {\n        return lst1;\n    }\n    let mut total_chars = lst1.len();\n\
    \    for elem in lst2 {\n        total_chars += elem.len();\n    }\n    if total_chars\
    \ == lst1.len() {\n        return lst1;\n    }\n    let mut total_chars = lst1.len();\n\
    \    for elem in lst2 {\n        total_chars += elem.len();\n    }\n    if total_chars\
    \ == lst1.len() {\n        return lst1;\n    }\n    let mut total_chars = lst1.len();\n\
    \    for elem in lst2 {\n        total_chars += elem.len();\n    }\n    if total_chars\
    \ == lst1.len() {\n        return lst1;\n    }\n    let mut total_\n}\n\nfn main()\
    \ {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n   --> /tmp/tmpfndp9yfe.rs:103:19\n   \
    \ |\n103 |     let mut total_\n    |                   ^ help: add `;` here\n\
    104 | }\n    | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfndp9yfe.rs:15:57\n\
    \   |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |    -----------                                          ^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    if lst1.len()\
    \ > lst2.len() {\n        lst1.reverse();\n    }\n    lst1.iter().zip(lst2.iter()).filter(|&(a,\
    \ b)| a < b).collect()\n}\n\nfn main() {\n    let candidate = total_match;\n \
    \   assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `(&String, &String)`\n    --> /tmp/tmpukf8p42y.rs:22:58\n\
    \     |\n22   |     lst1.iter().zip(lst2.iter()).filter(|&(a, b)| a < b).collect()\n\
    \     |                                                          ^^^^^^^ value\
    \ of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=(&String,\
    \ &String)>`\n     |\n     = help: the trait `FromIterator<(&String, &String)>`\
    \ is not implemented for `Vec<String>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_match:\
    \ Vec<String> = vec![];\n    for el1 in lst1 {\n        for el2 in lst2 {\n  \
    \          if el1.len() < el2.len() {\n                total_match.push(el1);\n\
    \                break;\n            }\n        }\n    }\n    total_match\n}\n\
    \nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpzd1npvqc.rs:21:20\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n21  |  \
    \       for el2 in lst2 {\n    |                    ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n21  |         for el2 in &lst2 {\n    |        \
    \            +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_match:\
    \ Vec<String> = vec![];\n    for el1 in lst1 {\n        for el2 in lst2 {\n  \
    \          if el1.len() < el2.len() {\n                total_match.push(el1);\n\
    \                break;\n            }\n        }\n    }\n    total_match\n}\n\
    \nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmput5zrwfx.rs:21:20\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n21  |  \
    \       for el2 in lst2 {\n    |                    ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n21  |         for el2 in &lst2 {\n    |        \
    \            +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n    }\n\
    \    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let mut\
    \ total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n\n}\n\nfn main() {\n   \
    \ let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpdu5x5fzy.rs:119:3\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                                                   \
    \  - unclosed delimiter\n...\n104 |     for v in lst2 {\n    |               \
    \    - this delimiter might not be properly closed...\n105 | \n106 | }\n    |\
    \ - ...as it matches this but it has different indentation\n...\n119 | }\n   \
    \ |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdu5x5fzy.rs:15:57\n \
    \  |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |    -----------                                          ^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    if lst1.len()\
    \ > lst2.len() {\n        lst1.reverse();\n    }\n    if lst2.len() > lst1.len()\
    \ {\n        lst2.reverse();\n    }\n    let mut result = vec![];\n    for i in\
    \ 0..lst1.len() {\n        let mut count = 0;\n        for j in 0..lst2.len()\
    \ {\n            if lst1[i] == lst2[j] {\n                count += 1;\n      \
    \      }\n        }\n        if count > lst1.len() {\n            result.push(lst1[i]);\n\
    \        }\n    }\n    if result.len() == 0 {\n        result\n    } else {\n\
    \        result\n    }\n}\n\nfn main() {\n    let candidate = total_match;\n \
    \   assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `lst1` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpy5ol2zaw.rs:20:9\n   |\n15 | fn total_match(lst1: Vec<String>,\
    \ lst2: Vec<String>) -> Vec<String> {\n   |                ---- help: consider\
    \ changing this to be mutable: `mut lst1`\n...\n20 |         lst1.reverse();\n\
    \   |         ^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot\
    \ borrow `lst2` as mutable, as it is not declared as mutable\n  --> /tmp/tmpy5ol2zaw.rs:23:9\n\
    \   |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |                                   ---- help: consider changing this\
    \ to be mutable: `mut lst2`\n...\n23 |         lst2.reverse();\n   |         ^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n\
    \  --> /tmp/tmpy5ol2zaw.rs:34:25\n   |\n34 |             result.push(lst1[i]);\n\
    \   |                         ^^^^^^^ move occurs because value has type `String`,\
    \ which does not implement the `Copy` trait\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0507, E0596.\nFor more information\
    \ about an error, try `rustc --explain E0507`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = vec![];\n    for el1 in lst1 {\n        for el2 in lst2 {\n            if\
    \ el1.len() < el2.len() {\n                total_chars.push(el1);\n          \
    \      break;\n            }\n        }\n    }\n    total_chars\n}\n\nfn main()\
    \ {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpp11fnkle.rs:21:20\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n21  |  \
    \       for el2 in lst2 {\n    |                    ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n21  |         for el2 in &lst2 {\n    |        \
    \            +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_match:\
    \ Vec<String> = vec![];\n    for x in lst1 {\n        for y in lst2 {\n      \
    \      if x.len() < y.len() {\n                total_match.push(x);\n        \
    \        break;\n            }\n        }\n    }\n    total_match\n}\n\nfn main()\
    \ {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpvrf8ma1g.rs:21:18\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n21  |  \
    \       for y in lst2 {\n    |                  ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n21  |         for y in &lst2 {\n    |          \
    \        +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut total_len = 0;\n    for s in lst1 {\n        total_len += s.len();\n\
    \    }\n    for s in lst2 {\n        total_len += s.len();\n    }\n    if total_len\
    \ == 0 {\n        return vec![];\n    }\n    let mut total_matches: Vec<String>\
    \ = vec![];\n    for s in lst1 {\n        if total_len < s.len() {\n         \
    \   break;\n        }\n        total_matches.push(s);\n    }\n    for s in lst2\
    \ {\n        if total_len < s.len() {\n            break;\n        }\n       \
    \ total_matches.push(s);\n    }\n    total_matches\n}\n\nfn main() {\n    let\
    \ candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst1`\n   --> /tmp/tmp28vp2e9c.rs:27:14\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n16  |     let mut total_len = 0;\n\
    17  |     for s in lst1 {\n    |              ---- `lst1` moved due to this implicit\
    \ call to `.into_iter()`\n...\n27  |     for s in lst1 {\n    |              ^^^^\
    \ value used here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `lst1`\nhelp: consider iterating over a slice of\
    \ the `Vec<String>`'s content to avoid moving into the `for` loop\n    |\n17 \
    \ |     for s in &lst1 {\n    |              +\n\nerror[E0382]: use of moved value:\
    \ `lst2`\n  --> /tmp/tmp28vp2e9c.rs:33:14\n   |\n15 | fn total_match(lst1: Vec<String>,\
    \ lst2: Vec<String>) -> Vec<String> {\n   |                                  \
    \ ---- move occurs because `lst2` has type `Vec<String>`, which does not implement\
    \ the `Copy` trait\n...\n20 |     for s in lst2 {\n   |              ---- `lst2`\
    \ moved due to this implicit call to `.into_iter()`\n...\n33 |     for s in lst2\
    \ {\n   |              ^^^^ value used here after move\n   |\nhelp: consider iterating\
    \ over a slice of the `Vec<String>`'s content to avoid moving into the `for` loop\n\
    \   |\n20 |     for s in &lst2 {\n   |              +\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = vec![0; lst1.len()];\n    for x in lst1 {\n        for y in lst2 {\n     \
    \       if x.len() < y.len() {\n                total_chars[x.len()] += 1;\n \
    \           }\n        }\n    }\n    total_chars\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjxbpvttp.rs:27:5\n   |\n\
    15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n \
    \  |                                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n27 |     total_chars\n   |     ^^^^^^^^^^^\
    \ expected struct `String`, found integer\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<{integer}>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_match:\
    \ Vec<String> = vec![];\n    for i in 0..lst1.len() {\n        let mut j = 0;\n\
    \        while j < lst2.len() && lst1[i].chars().all(|c| c < lst2[j].chars().max())\
    \ {\n            j += 1\n        }\n        total_match.push(lst1[i]);\n    }\n\
    \    total_match\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf64zlp8v.rs:22:61\n   |\n\
    22 |         while j < lst2.len() && lst1[i].chars().all(|c| c < lst2[j].chars().max())\
    \ {\n   |                                                             ^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<char>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_len\
    \ = 0;\n    for el in lst1 {\n        total_len += el.len();\n    }\n    let mut\
    \ total_len2 = 0;\n    for el in lst2 {\n        total_len2 += el.len();\n   \
    \ }\n    if total_len == total_len2 {\n        return lst1;\n    }\n    let mut\
    \ total_len = total_len;\n    for el in lst2 {\n        total_len -= el.len();\n\
    \    }\n    let mut total_len2 = total_len2;\n    for el in lst1 {\n        total_len2\
    \ -= el.len();\n    }\n    if total_len == total_len2 {\n        return lst1;\n\
    \    }\n    let mut total_len = total_len;\n    for el in lst2 {\n        total_len\
    \ -= el.len();\n    }\n    let mut total_len2 = total_len2;\n    for el in lst1\
    \ {\n        total_len2 -= el.len();\n    }\n    if total_len == total_len2 {\n\
    \        return lst1;\n    }\n    let mut total_len = total_len;\n    for el in\
    \ lst2 {\n        total_len -= el.len();\n    }\n    let mut total_len2 = total_len2;\n\
    \    for el in lst1 {\n        total_len2 -= el.len();\n    }\n    if total_len\
    \ == total_len2 {\n        return lst1;\n    }\n    let mut total_len = total_len;\n\
    \    for el in lst2 {\n        total_len -= el.len();\n    }\n    let mut total_len2\
    \ = total_len2;\n    for el in lst1 {\n        total_len2 -= el.len();\n    }\n\
    \    if total_len == total_len2 {\n        return lst1;\n    }\n    let mut total_len\
    \ = total_len;\n    for el in lst2 {\n        total_len -= el.len();\n    }\n\
    \    let mut total_len2 = total_len2;\n    for el in lst1 {\n        total_len2\
    \ -= el.len();\n    }\n    if total_len == total_len2 {\n        return lst1;\n\
    \    }\n    let mut total_len = total_len;\n    for el in lst2 {\n        total_len\
    \ -= el.len();\n    }\n    let mut total_len2 = total_len2;\n    for el in lst1\
    \ {\n        total_len2 -= el.len();\n    }\n    if total_len == total_len2 {\n\
    \        return lst1;\n    }\n    let mut total_len = total_len;\n    for el in\
    \ lst2 {\n        total_len -= el.len();\n    }\n    let mut total_len2 = total_len2;\n\
    \    for el in lst1 {\n        total_len2 -= el.len();\n    }\n    if total_len\
    \ == total_len2 {\n        return lst\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpvpeqs2af.rs:119:3\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                                                   \
    \  - unclosed delimiter\n...\n104 |     if total_len == total_len2 {\n    |  \
    \                              - this delimiter might not be properly closed...\n\
    105 |         return lst\n106 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n119 | }\n    |   ^\n\nerror[E0425]: cannot find value `lst`\
    \ in this scope\n   --> /tmp/tmpvpeqs2af.rs:105:16\n    |\n105 |         return\
    \ lst\n    |                ^^^ help: a local variable with a similar name exists:\
    \ `lst1`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvpeqs2af.rs:15:57\n\
    \   |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |    -----------                                          ^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_len\
    \ = lst1.len();\n    for i in 0..total_len {\n        if lst1[i] < lst2[i] {\n\
    \            total_len = i;\n            break;\n        }\n    }\n    lst1.iter().take(total_len).collect()\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&String`\n    --> /tmp/tmp3s_9_rrg.rs:26:33\n     |\n\
    26   |     lst1.iter().take(total_len).collect()\n     |                     \
    \            ^^^^^^^ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&String>`\n\
    \     |\n     = help: the trait `FromIterator<&String>` is not implemented for\
    \ `Vec<String>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n    }\n\
    \    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let mut\
    \ total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n\n}\n\nfn main() {\n   \
    \ let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpcuct50dv.rs:119:3\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                                                   \
    \  - unclosed delimiter\n...\n104 |     for s in lst2 {\n    |               \
    \    - this delimiter might not be properly closed...\n105 | \n106 | }\n    |\
    \ - ...as it matches this but it has different indentation\n...\n119 | }\n   \
    \ |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcuct50dv.rs:15:57\n \
    \  |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |    -----------                                          ^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut total_match: Vec<String> = Vec::new();\n    for el1 in lst1 {\n \
    \       for el2 in lst2 {\n            if el1.len() < el2.len() {\n          \
    \      total_match.push(el1);\n                break;\n            }\n       \
    \ }\n    }\n    total_match\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmp7kl80kr8.rs:18:20\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n18  |  \
    \       for el2 in lst2 {\n    |                    ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n18  |         for el2 in &lst2 {\n    |        \
    \            +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = vec![];\n    for v in lst1 {\n        total_chars.iter().filter(|&x| x < v).count();\n\
    \    }\n    for v in lst2 {\n        total_chars.iter().filter(|&x| x < v).count();\n\
    \    }\n    total_chars\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&str` with `String`\n  --> /tmp/tmpv_j4q90a.rs:21:42\n\
    \   |\n21 |         total_chars.iter().filter(|&x| x < v).count();\n   |     \
    \                                     ^ no implementation for `&str < String`\
    \ and `&str > String`\n   |\n   = help: the trait `PartialOrd<String>` is not\
    \ implemented for `&str`\n   = help: the following other types implement trait\
    \ `PartialOrd<Rhs>`:\n             String\n             str\n\nerror[E0277]: the\
    \ size for values of type `str` cannot be known at compilation time\n  --> /tmp/tmpv_j4q90a.rs:21:28\n\
    \   |\n21 |         total_chars.iter().filter(|&x| x < v).count();\n   |     \
    \                       ^^^^^^ doesn't have a size known at compile-time\n   |\n\
    \   = help: the trait `Sized` is not implemented for `str`\n   = help: the trait\
    \ `Iterator` is implemented for `std::slice::Iter<'a, T>`\n   = note: required\
    \ because of the requirements on the impl of `Iterator` for `std::slice::Iter<'_,\
    \ str>`\n\nerror[E0277]: the size for values of type `str` cannot be known at\
    \ compilation time\n  --> /tmp/tmpv_j4q90a.rs:21:9\n   |\n21 |         total_chars.iter().filter(|&x|\
    \ x < v).count();\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't\
    \ have a size known at compile-time\n   |\n   = help: the trait `Sized` is not\
    \ implemented for `str`\nnote: required by a bound in `std::slice::Iter`\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n   -->\
    \ /tmp/tmpv_j4q90a.rs:21:21\n    |\n21  |         total_chars.iter().filter(|&x|\
    \ x < v).count();\n    |                     ^^^^ doesn't have a size known at\
    \ compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\n\
    note: required by a bound in `core::slice::<impl [T]>::iter`\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n   -->\
    \ /tmp/tmpv_j4q90a.rs:19:27\n    |\n19  |     let mut total_chars = vec![];\n\
    \    |                           ^^^^^^ doesn't have a size known at compile-time\n\
    \    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required\
    \ by a bo"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n    }\n\
    \    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let mut\
    \ total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n\n}\n\nfn main() {\n   \
    \ let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpk2jkmrwk.rs:119:3\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                                                   \
    \  - unclosed delimiter\n...\n104 |     for s in lst2 {\n    |               \
    \    - this delimiter might not be properly closed...\n105 | \n106 | }\n    |\
    \ - ...as it matches this but it has different indentation\n...\n119 | }\n   \
    \ |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk2jkmrwk.rs:15:57\n \
    \  |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |    -----------                                          ^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    if lst1.len()\
    \ > lst2.len() {\n        let mut lst = lst1;\n        lst.extend(lst2.iter().take(lst1.len()));\n\
    \        return lst;\n    }\n    let mut lst = lst2;\n    lst.extend(lst1.iter().take(lst2.len()));\n\
    \    return lst;\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::iter::Take<std::slice::Iter<'_,\
    \ String>> as IntoIterator>::Item == String`\n  --> /tmp/tmplyq3yscm.rs:21:13\n\
    \   |\n21 |         lst.extend(lst2.iter().take(lst1.len()));\n   |          \
    \   ^^^^^^ expected `&String`, found struct `String`\n\nerror[E0271]: type mismatch\
    \ resolving `<std::iter::Take<std::slice::Iter<'_, String>> as IntoIterator>::Item\
    \ == String`\n  --> /tmp/tmplyq3yscm.rs:25:9\n   |\n25 |     lst.extend(lst1.iter().take(lst2.len()));\n\
    \   |         ^^^^^^ expected `&String`, found struct `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0271`.\n"
  stdout: ''
  timestamp: 1659748969
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut total_len = lst1.len();\n    for i in 0..total_len {\n        if\
    \ lst1[i] < lst2[i] {\n            total_len = i;\n            break;\n      \
    \  }\n    }\n    lst1.iter().take(total_len).collect()\n}\n\nfn main() {\n   \
    \ let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&String`\n  --> /tmp/tmpsggitejp.rs:23:33\n   |\n23 |\
    \     lst1.iter().take(total_len).collect()\n   |                            \
    \     ^^^^^^^ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&String>`\n\
    \   |\n   = help: the trait `FromIterator<&String>` is not implemented for `Vec<String>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_len\
    \ = 0;\n    for el in lst1 {\n        total_len += el.len();\n    }\n    let mut\
    \ total_len2 = 0;\n    for el in lst2 {\n        total_len2 += el.len();\n   \
    \ }\n    if total_len == total_len2 {\n        return lst1;\n    }\n    let mut\
    \ total_len3 = 0;\n    for el in lst1 {\n        total_len3 += el.len();\n   \
    \ }\n    for el in lst2 {\n        total_len3 += el.len();\n    }\n    if total_len3\
    \ == total_len2 {\n        return lst1;\n    }\n    let mut total_len4 = 0;\n\
    \    for el in lst1 {\n        total_len4 += el.len();\n    }\n    for el in lst2\
    \ {\n        total_len4 += el.len();\n    }\n    if total_len4 == total_len3 {\n\
    \        return lst1;\n    }\n    let mut total_len5 = 0;\n    for el in lst1\
    \ {\n        total_len5 += el.len();\n    }\n    for el in lst2 {\n        total_len5\
    \ += el.len();\n    }\n    if total_len5 == total_len4 {\n        return lst1;\n\
    \    }\n    let mut total_len6 = 0;\n    for el in lst1 {\n        total_len6\
    \ += el.len();\n    }\n    for el in lst2 {\n        total_len6 += el.len();\n\
    \    }\n    if total_len6 == total_len5 {\n        return lst1;\n    }\n    let\
    \ mut total_len7 = 0;\n    for el in lst1 {\n        total_len7 += el.len();\n\
    \    }\n    for el in lst2 {\n        total_len7 += el.len();\n    }\n    if total_len7\
    \ == total_len6 {\n        return lst1;\n    }\n    let mut total_len8 = 0;\n\
    \    for el in lst1 {\n        total_len8 += el.len();\n    }\n    for el in lst2\
    \ {\n        total_len8 += el.len();\n    }\n    if total_len8 == total_len7 {\n\
    \        return lst1;\n    }\n    let mut total_len9 = 0;\n    for el in lst1\
    \ {\n        total_len9 += el.len();\n    }\n    for el in lst2 {\n        total_len9\
    \ += el.len();\n    }\n    if total_len9 == total_len8 {\n        return lst1;\n\
    \    }\n    let mut total_len10 = 0;\n    for el in lst1 {\n        total_len10\
    \ += el.len();\n    }\n    for el in lst2 {\n        total_len10 += el.len();\n\
    \    }\n    if total_len10 == total_len9 {\n        return lst\n}\n\nfn main()\
    \ {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpx25p0yeg.rs:122:3\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                                                   \
    \  - unclosed delimiter\n...\n107 |     if total_len10 == total_len9 {\n    |\
    \                                  - this delimiter might not be properly closed...\n\
    108 |         return lst\n109 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n122 | }\n    |   ^\n\nerror[E0425]: cannot find value `lst`\
    \ in this scope\n   --> /tmp/tmpx25p0yeg.rs:108:16\n    |\n108 |         return\
    \ lst\n    |                ^^^ help: a local variable with a similar name exists:\
    \ `lst1`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx25p0yeg.rs:15:57\n\
    \   |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |    -----------                                          ^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748969
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut res\
    \ = vec![];\n    for i in 0..lst1.len() {\n        if lst1[i] < lst2[i] {\n  \
    \          res.push(lst1[i]);\n        }\n    }\n    res\n}\n\nfn main() {\n \
    \   let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpp7cdvh0q.rs:22:22\n\
    \   |\n22 |             res.push(lst1[i]);\n   |                      ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659748969
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_len\
    \ = 0;\n    for v in lst1 {\n        total_len += v.len();\n    }\n    let mut\
    \ total_len2 = total_len;\n    for v in lst2 {\n        total_len2 += v.len();\n\
    \    }\n    if total_len2 > total_len {\n        return lst1;\n    }\n    return\
    \ lst2;\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst1`\n   --> /tmp/tmp0yvqaz9l.rs:28:16\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n20  |     for v in lst1 {\n\
    \    |              ----\n    |              |\n    |              `lst1` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&lst1`\n...\n28  |         return\
    \ lst1;\n    |                ^^^^ value used here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `lst1`\n\nerror[E0382]:\
    \ use of moved value: `lst2`\n  --> /tmp/tmp0yvqaz9l.rs:30:12\n   |\n15 | fn total_match(lst1:\
    \ Vec<String>, lst2: Vec<String>) -> Vec<String> {\n   |                     \
    \              ---- move occurs because `lst2` has type `Vec<String>`, which does\
    \ not implement the `Copy` trait\n...\n24 |     for v in lst2 {\n   |        \
    \      ----\n   |              |\n   |              `lst2` moved due to this implicit\
    \ call to `.into_iter()`\n   |              help: consider borrowing to avoid\
    \ moving into the for loop: `&lst2`\n...\n30 |     return lst2;\n   |        \
    \    ^^^^ value used here after move\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748969
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_match:\
    \ Vec<String> = vec![];\n    for el1 in lst1 {\n        for el2 in lst2 {\n  \
    \          if el1.len() < el2.len() {\n                total_match.push(el1);\n\
    \                break;\n            }\n        }\n    }\n    total_match\n}\n\
    \nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmput5zrwfx.rs:21:20\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n21  |  \
    \       for el2 in lst2 {\n    |                    ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n21  |         for el2 in &lst2 {\n    |        \
    \            +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_match:\
    \ Vec<String> = vec![];\n    for i in 0..lst1.len() {\n        let mut total_chars\
    \ = lst1[i].chars().filter(|c| c < lst2[i].chars()).count();\n        total_match\
    \ += vec![lst1[i]].repeat(total_chars);\n    }\n    return total_match;\n}\n\n\
    fn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7q6zn616.rs:21:62\n   |\n\
    21 |         let mut total_chars = lst1[i].chars().filter(|c| c < lst2[i].chars()).count();\n\
    \   |                                                              ^^^^^^^^^^^^^^^\
    \ expected `&char`, found struct `Chars`\n\nerror[E0277]: the trait bound `String:\
    \ Copy` is not satisfied\n  --> /tmp/tmp7q6zn616.rs:22:38\n   |\n22 |        \
    \ total_match += vec![lst1[i]].repeat(total_chars);\n   |                    \
    \                  ^^^^^^ the trait `Copy` is not implemented for `String`\n\n\
    error[E0368]: binary assignment operation `+=` cannot be applied to type `Vec<String>`\n\
    \  --> /tmp/tmp7q6zn616.rs:22:9\n   |\n22 |         total_match += vec![lst1[i]].repeat(total_chars);\n\
    \   |         -----------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |         |\n\
    \   |         cannot use `+=` on type `Vec<String>`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0368.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_len\
    \ = 0;\n    for s in lst1 {\n        total_len += s.len();\n    }\n    let mut\
    \ total_len2 = total_len;\n    for s in lst2 {\n        total_len2 += s.len();\n\
    \    }\n    if total_len2 > total_len {\n        return lst1;\n    }\n    return\
    \ lst2;\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst1`\n   --> /tmp/tmp2nfp_576.rs:28:16\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n20  |     for s in lst1 {\n\
    \    |              ----\n    |              |\n    |              `lst1` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&lst1`\n...\n28  |         return\
    \ lst1;\n    |                ^^^^ value used here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `lst1`\n\nerror[E0382]:\
    \ use of moved value: `lst2`\n  --> /tmp/tmp2nfp_576.rs:30:12\n   |\n15 | fn total_match(lst1:\
    \ Vec<String>, lst2: Vec<String>) -> Vec<String> {\n   |                     \
    \              ---- move occurs because `lst2` has type `Vec<String>`, which does\
    \ not implement the `Copy` trait\n...\n24 |     for s in lst2 {\n   |        \
    \      ----\n   |              |\n   |              `lst2` moved due to this implicit\
    \ call to `.into_iter()`\n   |              help: consider borrowing to avoid\
    \ moving into the for loop: `&lst2`\n...\n30 |     return lst2;\n   |        \
    \    ^^^^ value used here after move\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748969
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_match:\
    \ Vec<String> = vec![];\n    for x in lst1 {\n        if lst2.iter().any(|y| x.chars().any(|z|\
    \ z.cmp(y) < 0)) {\n            total_match.push(x);\n        }\n    }\n    total_match\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcvldgio7.rs:21:56\n   |\n\
    21 |         if lst2.iter().any(|y| x.chars().any(|z| z.cmp(y) < 0)) {\n   | \
    \                                                       ^ expected `char`, found\
    \ struct `String`\n   |\n   = note: expected reference `&char`\n             \
    \ found reference `&String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcvldgio7.rs:21:61\n\
    \   |\n21 |         if lst2.iter().any(|y| x.chars().any(|z| z.cmp(y) < 0)) {\n\
    \   |                                                             ^ expected enum\
    \ `std::cmp::Ordering`, found integer\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    if lst1.len()\
    \ > lst2.len() {\n        let mut result = vec![];\n        for el1 in lst1 {\n\
    \            for el2 in lst2 {\n                if el1.len() < el2.len() {\n \
    \                   result.push(el1);\n                    break;\n          \
    \      }\n            }\n        }\n        return result;\n    }\n    let mut\
    \ result = vec![];\n    for el1 in lst1 {\n        for el2 in lst2 {\n       \
    \     if el1.len() > el2.len() {\n                result.push(el1);\n        \
    \        break;\n            }\n        }\n    }\n    return result;\n}\n\nfn\
    \ main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmp7su7qw5h.rs:22:24\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n22  |  \
    \           for el2 in lst2 {\n    |                        ^^^^\n    |      \
    \                  |\n    |                        `lst2` moved due to this implicit\
    \ call to `.into_iter()`, in previous iteration of loop\n    |               \
    \         help: consider borrowing to avoid moving into the for loop: `&lst2`\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `lst2`\n\nerror[E0382]: use of moved value: `lst2`\n  --> /tmp/tmp7su7qw5h.rs:33:20\n\
    \   |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n33 |   \
    \      for el2 in lst2 {\n   |                    ^^^^\n   |                 \
    \   |\n   |                    `lst2` moved due to this implicit call to `.into_iter()`,\
    \ in previous iteration of loop\n   |                    help: consider borrowing\
    \ to avoid moving into the for loop: `&lst2`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748969
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n    }\n\
    \    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let mut\
    \ total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n\n}\n\nfn main() {\n   \
    \ let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpdu5x5fzy.rs:119:3\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                                                   \
    \  - unclosed delimiter\n...\n104 |     for v in lst2 {\n    |               \
    \    - this delimiter might not be properly closed...\n105 | \n106 | }\n    |\
    \ - ...as it matches this but it has different indentation\n...\n119 | }\n   \
    \ |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdu5x5fzy.rs:15:57\n \
    \  |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |    -----------                                          ^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_len\
    \ = 0;\n    for s in lst1 {\n        total_len += s.len();\n    }\n    let mut\
    \ total_len2 = total_len;\n    for s in lst2 {\n        total_len2 += s.len();\n\
    \    }\n    if total_len == total_len2 {\n        return lst1;\n    }\n    let\
    \ mut total_len3 = 0;\n    for s in lst1 {\n        total_len3 += s.len();\n \
    \   }\n    for s in lst2 {\n        total_len3 += s.len();\n    }\n    if total_len3\
    \ == total_len2 {\n        return lst1;\n    }\n    let mut total_len4 = 0;\n\
    \    for s in lst1 {\n        total_len4 += s.len();\n    }\n    for s in lst2\
    \ {\n        total_len4 += s.len();\n    }\n    if total_len4 == total_len3 {\n\
    \        return lst1;\n    }\n    let mut total_len5 = 0;\n    for s in lst1 {\n\
    \        total_len5 += s.len();\n    }\n    for s in lst2 {\n        total_len5\
    \ += s.len();\n    }\n    if total_len5 == total_len4 {\n        return lst1;\n\
    \    }\n    let mut total_len6 = 0;\n    for s in lst1 {\n        total_len6 +=\
    \ s.len();\n    }\n    for s in lst2 {\n        total_len6 += s.len();\n    }\n\
    \    if total_len6 == total_len5 {\n        return lst1;\n    }\n    let mut total_len7\
    \ = 0;\n    for s in lst1 {\n        total_len7 += s.len();\n    }\n    for s\
    \ in lst2 {\n        total_len7 += s.len();\n    }\n    if total_len7 == total_len6\
    \ {\n        return lst1;\n    }\n    let mut total_len8 = 0;\n    for s in lst1\
    \ {\n        total_len8 += s.len();\n    }\n    for s in lst2 {\n        total_len8\
    \ += s.len();\n    }\n    if total_len8 == total_len7 {\n        return lst1;\n\
    \    }\n    let mut total_len9 = 0;\n    for s in lst1 {\n        total_len9 +=\
    \ s.len();\n    }\n    for s in lst2 {\n        total_len9 += s.len();\n    }\n\
    \    if total_len9 == total_len8 {\n        return lst1;\n    }\n    let mut total_len10\
    \ = 0;\n    for s in lst1 {\n        total_len10 += s.len();\n    }\n    for s\
    \ in lst2 {\n        total_len10 += s.len();\n    }\n    if total_len10 == total_len9\
    \ {\n        return lst1;\n    }\n    let mut total_len11 = 0;\n    for s in lst1\
    \ {\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpsszyskdj.rs:125:3\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                                                   \
    \  - unclosed delimiter\n...\n111 |     for s in lst1 {\n    |               \
    \    - this delimiter might not be properly closed...\n112 | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n125 | }\n    |   ^\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpsszyskdj.rs:15:57\n   |\n15 | fn\
    \ total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n   |   \
    \ -----------                                          ^^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748969
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_len\
    \ = 0;\n    for x in lst1 {\n        total_len += x.len();\n    }\n    for x in\
    \ lst2 {\n        total_len += x.len();\n    }\n    if total_len == lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_len == lst2.len() {\n        return\
    \ lst2;\n    }\n    let mut total_len = 0;\n    for x in lst1 {\n        total_len\
    \ += x.len();\n    }\n    for x in lst2 {\n        total_len += x.len();\n   \
    \ }\n    if total_len == lst1.len() {\n        return lst1;\n    }\n    if total_len\
    \ == lst2.len() {\n        return lst2;\n    }\n    let mut total_len = 0;\n \
    \   for x in lst1 {\n        total_len += x.len();\n    }\n    for x in lst2 {\n\
    \        total_len += x.len();\n    }\n    if total_len == lst1.len() {\n    \
    \    return lst1;\n    }\n    if total_len == lst2.len() {\n        return lst2;\n\
    \    }\n    let mut total_len = 0;\n    for x in lst1 {\n        total_len +=\
    \ x.len();\n    }\n    for x in lst2 {\n        total_len += x.len();\n    }\n\
    \    if total_len == lst1.len() {\n        return lst1;\n    }\n    if total_len\
    \ == lst2.len() {\n        return lst2;\n    }\n    let mut total_len = 0;\n \
    \   for x in lst1 {\n        total_len += x.len();\n    }\n    for x in lst2 {\n\
    \        total_len += x.len();\n    }\n    if total_len == lst1.len() {\n    \
    \    return lst1;\n    }\n    if total_len == lst2.len() {\n        return lst2;\n\
    \    }\n    let mut total_len = 0;\n    for x in lst1 {\n        total_len +=\
    \ x.len();\n    }\n    for x in lst2 {\n        total_len += x.len();\n    }\n\
    \    if total_len == lst1.len() {\n        return lst1;\n    }\n    if total_len\
    \ == lst2.len() {\n        return lst2;\n    }\n    let mut total_len = 0;\n \
    \   for x in lst1 {\n        total_len += x.len();\n    }\n    for x in lst2 {\n\
    \        total_len += x.len();\n    }\n    if total_len == lst1.len() {\n    \
    \    return lst1;\n    }\n    if total_len == lst2.len() {\n        return lst2;\n\
    \    }\n    let mut total_len = 0;\n    for x in lst1 {\n        total_len +=\
    \ x.len();\n    }\n    for x in lst2 {\n        total_len += x.len();\n    }\n\
    \    if total_len == lst1.\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n   --> /tmp/tmpp3170m2v.rs:118:1\n    |\n\
    118 | }\n    | ^\n\nerror: expected `{`, found `}`\n   --> /tmp/tmpp3170m2v.rs:118:1\n\
    \    |\n117 |     if total_len == lst1.\n    |     -- this `if` expression has\
    \ a condition, but no block\n118 | }\n    | ^ expected `{`\n\nerror: aborting\
    \ due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659748969
- exit_code: 101
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n    }\n\
    \    if total_chars == lst1.len() {\n        return lst1;\n    }\n    lst1\n}\n\
    \nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmpq5d9s_ja.rs:32:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = vec![];\n    for s in lst1 {\n        let mut total_chars_in_s = vec![];\n\
    \        for c in s {\n            total_chars_in_s.push(cs.chars().filter(|c|\
    \ c < s.len()).count());\n        }\n        total_chars += total_chars_in_s;\n\
    \    }\n    for s in lst2 {\n        let mut total_chars_in_s = vec![];\n    \
    \    for c in s {\n            total_chars_in_s.push(cs.chars().filter(|c| c <\
    \ s.len()).count());\n        }\n        total_chars += total_chars_in_s;\n  \
    \  }\n    total_chars\n}\n\nfn main() {\n    let candidate = total_match;\n  \
    \  assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `cs` in this scope\n  --> /tmp/tmpcfonkr8y.rs:23:35\n\
    \   |\n23 |             total_chars_in_s.push(cs.chars().filter(|c| c < s.len()).count());\n\
    \   |                                   ^^ help: a local variable with a similar\
    \ name exists: `c`\n\nerror[E0425]: cannot find value `cs` in this scope\n  -->\
    \ /tmp/tmpcfonkr8y.rs:30:35\n   |\n30 |             total_chars_in_s.push(cs.chars().filter(|c|\
    \ c < s.len()).count());\n   |                                   ^^ help: a local\
    \ variable with a similar name exists: `c`\n\nerror[E0277]: `String` is not an\
    \ iterator\n   --> /tmp/tmpcfonkr8y.rs:22:18\n    |\n22  |         for c in s\
    \ {\n    |                  ^ `String` is not an iterator; try calling `.chars()`\
    \ or `.bytes()`\n    |\n    = help: the trait `Iterator` is not implemented for\
    \ `String`\n    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `String`\nnote: required by `into_iter`\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `Vec<_>`\n  --> /tmp/tmpcfonkr8y.rs:25:9\n\
    \   |\n25 |         total_chars += total_chars_in_s;\n   |         -----------^^^^^^^^^^^^^^^^^^^^\n\
    \   |         |\n   |         cannot use `+=` on type `Vec<_>`\n\nerror[E0277]:\
    \ `String` is not an iterator\n   --> /tmp/tmpcfonkr8y.rs:29:18\n    |\n29  |\
    \         for c in s {\n    |                  ^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n    |\n    = help: the trait `Iterator`\
    \ is not implemented for `String`\n    = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\nnote: required by `into_iter`\n\n\
    error[E0368]: binary assignment operation `+=` cannot be applied to type `Vec<_>`\n\
    \  --> /tmp/tmpcfonkr8y.rs:32:9\n   |\n32 |         total_chars += total_chars_in_s;\n\
    \   |         -----------^^^^^^^^^^^^^^^^^^^^\n   |         |\n   |         cannot\
    \ use `+=` on type `Vec<_>`\n\nerror: aborting due to 6 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0368, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    if lst1.len()\
    \ < lst2.len() {\n        let mut result = vec![];\n        for elem in lst1 {\n\
    \            if lst2.iter().any(|x| x.contains(elem)) {\n                result.push(elem);\n\
    \            }\n        }\n        return result;\n    }\n    let mut result =\
    \ vec![];\n    for elem in lst2 {\n        if lst1.iter().any(|x| x.contains(elem))\
    \ {\n            result.push(elem);\n        }\n    }\n    return result;\n}\n\
    \nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n  -->\
    \ /tmp/tmp9e21v4w5.rs:22:47\n   |\n22 |             if lst2.iter().any(|x| x.contains(elem))\
    \ {\n   |                                               ^^^^\n   |           \
    \                                    |\n   |                                 \
    \              expected an implementor of trait `Pattern<'_>`\n   |          \
    \                                     help: consider borrowing here: `&elem`\n\
    \   |\n   = note: the trait bound `String: Pattern<'_>` is not satisfied\n   =\
    \ note: required because of the requirements on the impl of `Pattern<'_>` for\
    \ `String`\n\nerror[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n\
    \  --> /tmp/tmp9e21v4w5.rs:30:43\n   |\n30 |         if lst1.iter().any(|x| x.contains(elem))\
    \ {\n   |                                           ^^^^\n   |               \
    \                            |\n   |                                         \
    \  expected an implementor of trait `Pattern<'_>`\n   |                      \
    \                     help: consider borrowing here: `&elem`\n   |\n   = note:\
    \ the trait bound `String: Pattern<'_>` is not satisfied\n   = note: required\
    \ because of the requirements on the impl of `Pattern<'_>` for `String`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748969
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_len\
    \ = 0;\n    for el1 in lst1 {\n        for el2 in lst2 {\n            if el1.len()\
    \ < el2.len() {\n                total_len += el1.len();\n            }\n    \
    \    }\n    }\n    lst1.iter().filter(|el| el.len() < total_len).collect()\n}\n\
    \nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&String`\n  --> /tmp/tmp17psdr72.rs:27:51\n   |\n27 |\
    \     lst1.iter().filter(|el| el.len() < total_len).collect()\n   |          \
    \                                         ^^^^^^^ value of type `Vec<String>`\
    \ cannot be built from `std::iter::Iterator<Item=&String>`\n   |\n   = help: the\
    \ trait `FromIterator<&String>` is not implemented for `Vec<String>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n    }\n\
    \    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let mut\
    \ total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n\n}\n\nfn main() {\n   \
    \ let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpdu5x5fzy.rs:119:3\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                                                   \
    \  - unclosed delimiter\n...\n104 |     for v in lst2 {\n    |               \
    \    - this delimiter might not be properly closed...\n105 | \n106 | }\n    |\
    \ - ...as it matches this but it has different indentation\n...\n119 | }\n   \
    \ |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdu5x5fzy.rs:15:57\n \
    \  |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |    -----------                                          ^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut res\
    \ = vec![];\n    for x in lst1 {\n        if lst2.iter().any(|y| x.chars().any(|z|\
    \ z.cmp(y) < 0)) {\n            res.push(x);\n        }\n    }\n    res\n}\n\n\
    fn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqrf8dy4_.rs:21:56\n   |\n\
    21 |         if lst2.iter().any(|y| x.chars().any(|z| z.cmp(y) < 0)) {\n   | \
    \                                                       ^ expected `char`, found\
    \ struct `String`\n   |\n   = note: expected reference `&char`\n             \
    \ found reference `&String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqrf8dy4_.rs:21:61\n\
    \   |\n21 |         if lst2.iter().any(|y| x.chars().any(|z| z.cmp(y) < 0)) {\n\
    \   |                                                             ^ expected enum\
    \ `std::cmp::Ordering`, found integer\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_len\
    \ = 0;\n    for el in lst1 {\n        total_len += el.len();\n    }\n    let mut\
    \ total_len2 = total_len;\n    for el in lst2 {\n        total_len2 += el.len();\n\
    \    }\n    if total_len2 == total_len {\n        return lst1;\n    }\n    lst1\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst1`\n   --> /tmp/tmp0vggx2ih.rs:28:16\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n20  |     for el in lst1 {\n\
    \    |               ----\n    |               |\n    |               `lst1` moved\
    \ due to this implicit call to `.into_iter()`\n    |               help: consider\
    \ borrowing to avoid moving into the for loop: `&lst1`\n...\n28  |         return\
    \ lst1;\n    |                ^^^^ value used here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `lst1`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748969
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = vec![];\n    for v in lst1 {\n        if lst2.iter().any(|&x| x == v) {\n\
    \            total_chars.push(v);\n        }\n    }\n    total_chars\n}\n\nfn\
    \ main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of a shared reference\n  --> /tmp/tmpdvepursh.rs:21:29\n\
    \   |\n21 |         if lst2.iter().any(|&x| x == v) {\n   |                  \
    \           ^-\n   |                             ||\n   |                    \
    \         |data moved here\n   |                             |move occurs because\
    \ `x` has type `String`, which does not implement the `Copy` trait\n   |     \
    \                        help: consider removing the `&`: `x`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0507`.\n"
  stdout: ''
  timestamp: 1659748969
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n    }\n\
    \    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let mut\
    \ total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n\n}\n\nfn main() {\n   \
    \ let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpk2jkmrwk.rs:119:3\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                                                   \
    \  - unclosed delimiter\n...\n104 |     for s in lst2 {\n    |               \
    \    - this delimiter might not be properly closed...\n105 | \n106 | }\n    |\
    \ - ...as it matches this but it has different indentation\n...\n119 | }\n   \
    \ |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk2jkmrwk.rs:15:57\n \
    \  |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |    -----------                                          ^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = vec![];\n    for elem in lst1 {\n        if lst2.iter().any(|x| elem.contains(&x))\
    \ {\n            total_chars.push(elem);\n        }\n    }\n    total_chars\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `String`\n  --> /tmp/tmpv86g_43b.rs:21:46\n\
    \   |\n21 |         if lst2.iter().any(|x| elem.contains(&x)) {\n   |        \
    \                                      ^^ expected an `Fn<(char,)>` closure, found\
    \ `String`\n   |\n   = help: the trait `Fn<(char,)>` is not implemented for `String`\n\
    \   = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&String`\n   = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&&String`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_len\
    \ = 0;\n    for el1 in lst1 {\n        for el2 in lst2 {\n            if el1.len()\
    \ < el2.len() {\n                total_len += el1.len();\n            }\n    \
    \    }\n    }\n    total_len\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp45iika8c.rs:27:5\n   |\n\
    15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n \
    \  |                                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n27 |     total_len\n   |     ^^^^^^^^^\
    \ expected struct `Vec`, found `usize`\n   |\n   = note: expected struct `Vec<String>`\n\
    \                found type `usize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_len\
    \ = 0;\n    for el1 in lst1 {\n        for el2 in lst2 {\n            if el1.len()\
    \ < el2.len() {\n                total_len += el1.len();\n            }\n    \
    \    }\n    }\n    total_len\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp45iika8c.rs:27:5\n   |\n\
    15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n \
    \  |                                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n27 |     total_len\n   |     ^^^^^^^^^\
    \ expected struct `Vec`, found `usize`\n   |\n   = note: expected struct `Vec<String>`\n\
    \                found type `usize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_len\
    \ = 0;\n    for el1 in lst1 {\n        for el2 in lst2 {\n            if el1.len()\
    \ < el2.len() {\n                total_len += el1.len();\n            }\n    \
    \    }\n    }\n    lst1.iter().filter(|el| el.len() < total_len).collect()\n}\n\
    \nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&String`\n  --> /tmp/tmp17psdr72.rs:27:51\n   |\n27 |\
    \     lst1.iter().filter(|el| el.len() < total_len).collect()\n   |          \
    \                                         ^^^^^^^ value of type `Vec<String>`\
    \ cannot be built from `std::iter::Iterator<Item=&String>`\n   |\n   = help: the\
    \ trait `FromIterator<&String>` is not implemented for `Vec<String>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_len\
    \ = 0;\n    for s in lst1 {\n        total_len += s.len();\n    }\n    let mut\
    \ total_len2 = total_len;\n    for s in lst2 {\n        total_len2 += s.len();\n\
    \    }\n    if total_len2 > total_len {\n        return lst1;\n    }\n    return\
    \ lst2;\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst1`\n   --> /tmp/tmp2nfp_576.rs:28:16\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n20  |     for s in lst1 {\n\
    \    |              ----\n    |              |\n    |              `lst1` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&lst1`\n...\n28  |         return\
    \ lst1;\n    |                ^^^^ value used here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `lst1`\n\nerror[E0382]:\
    \ use of moved value: `lst2`\n  --> /tmp/tmp2nfp_576.rs:30:12\n   |\n15 | fn total_match(lst1:\
    \ Vec<String>, lst2: Vec<String>) -> Vec<String> {\n   |                     \
    \              ---- move occurs because `lst2` has type `Vec<String>`, which does\
    \ not implement the `Copy` trait\n...\n24 |     for s in lst2 {\n   |        \
    \      ----\n   |              |\n   |              `lst2` moved due to this implicit\
    \ call to `.into_iter()`\n   |              help: consider borrowing to avoid\
    \ moving into the for loop: `&lst2`\n...\n30 |     return lst2;\n   |        \
    \    ^^^^ value used here after move\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748969
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut res\
    \ = vec![];\n    for elem in lst1 {\n        if lst2.iter().any(|x| elem.cmp(x)\
    \ < 0) {\n            res.push(elem);\n        }\n    }\n    return res;\n}\n\n\
    fn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1aiagta_.rs:21:46\n   |\n\
    21 |         if lst2.iter().any(|x| elem.cmp(x) < 0) {\n   |                 \
    \                             ^ expected enum `std::cmp::Ordering`, found integer\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut res\
    \ = vec![];\n    for i in 0..lst1.len() {\n        if lst1[i] < lst2[i] {\n  \
    \          res.push(lst1[i]);\n        }\n    }\n    res\n}\n\nfn main() {\n \
    \   let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpp7cdvh0q.rs:22:22\n\
    \   |\n22 |             res.push(lst1[i]);\n   |                      ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659748969
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n    }\n\
    \    lst1.iter().filter(|&x| x < &lst2).collect()\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuwtj72yp.rs:23:33\n   |\n\
    23 |     lst1.iter().filter(|&x| x < &lst2).collect()\n   |                  \
    \               ^^^^^ expected struct `String`, found struct `Vec`\n   |\n   =\
    \ note: expected reference `&String`\n              found reference `&Vec<String>`\n\
    \nerror[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&String`\n  --> /tmp/tmpuwtj72yp.rs:23:40\n   |\n23 |\
    \     lst1.iter().filter(|&x| x < &lst2).collect()\n   |                     \
    \                   ^^^^^^^ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&String>`\n\
    \   |\n   = help: the trait `FromIterator<&String>` is not implemented for `Vec<String>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = vec![0; lst1.len()];\n    for x in lst1 {\n        for y in lst2 {\n     \
    \       if x.len() < y.len() {\n                total_chars[x.len()] += 1;\n \
    \           }\n        }\n    }\n    total_chars\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjxbpvttp.rs:27:5\n   |\n\
    15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n \
    \  |                                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n27 |     total_chars\n   |     ^^^^^^^^^^^\
    \ expected struct `String`, found integer\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<{integer}>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_match:\
    \ Vec<String> = vec![];\n    for elem in lst1 {\n        if lst2.iter().any(|x|\
    \ elem.contains(x)) {\n            total_match.push(elem);\n        }\n    }\n\
    \    total_match\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmp6iany0wt.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 101
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n    }\n\
    \    if total_chars < lst1.len() {\n        return lst1;\n    }\n    lst1\n}\n\
    \nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmpoe90ipmm.rs:32:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut res\
    \ = vec![];\n    for el1 in lst1 {\n        for el2 in lst2 {\n            if\
    \ el1.len() < el2.len() {\n                res.push(el1);\n                break;\n\
    \            }\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpjbenuehs.rs:21:20\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n21  |  \
    \       for el2 in lst2 {\n    |                    ^^^^\n    |              \
    \      |\n    |                    `lst2` moved due to this implicit call to `.into_iter()`,\
    \ in previous iteration of loop\n    |                    help: consider borrowing\
    \ to avoid moving into the for loop: `&lst2`\n    |\nnote: this function takes\
    \ ownership of the receiver `self`, which moves `lst2`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut res\
    \ = vec![];\n    for elem in lst1 {\n        if lst2.iter().any(|x| x.contains(elem))\
    \ {\n            res.push(elem);\n        }\n    }\n    return res;\n}\n\nfn main()\
    \ {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n  -->\
    \ /tmp/tmpenpd7kb4.rs:21:43\n   |\n21 |         if lst2.iter().any(|x| x.contains(elem))\
    \ {\n   |                                           ^^^^\n   |               \
    \                            |\n   |                                         \
    \  expected an implementor of trait `Pattern<'_>`\n   |                      \
    \                     help: consider borrowing here: `&elem`\n   |\n   = note:\
    \ the trait bound `String: Pattern<'_>` is not satisfied\n   = note: required\
    \ because of the requirements on the impl of `Pattern<'_>` for `String`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut total_match: Vec<String> = Vec::new();\n    for el1 in lst1 {\n \
    \       for el2 in lst2 {\n            if el1.len() < el2.len() {\n          \
    \      total_match.push(el1);\n                break;\n            }\n       \
    \ }\n    }\n    if total_match.len() == 0 {\n        total_match = lst1;\n   \
    \ }\n    total_match\n}\n\nfn main() {\n    let candidate = total_match;\n   \
    \ assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpv1kqokcs.rs:18:20\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n18  |  \
    \       for el2 in lst2 {\n    |                    ^^^^\n    |              \
    \      |\n    |                    `lst2` moved due to this implicit call to `.into_iter()`,\
    \ in previous iteration of loop\n    |                    help: consider borrowing\
    \ to avoid moving into the for loop: `&lst2`\n    |\nnote: this function takes\
    \ ownership of the receiver `self`, which moves `lst2`\n\nerror[E0382]: use of\
    \ moved value: `lst1`\n  --> /tmp/tmpv1kqokcs.rs:26:23\n   |\n15 | fn total_match(lst1:\
    \ Vec<String>, lst2: Vec<String>) -> Vec<String> {\n   |                ---- move\
    \ occurs because `lst1` has type `Vec<String>`, which does not implement the `Copy`\
    \ trait\n16 |     let mut total_match: Vec<String> = Vec::new();\n17 |     for\
    \ el1 in lst1 {\n   |                ----\n   |                |\n   |       \
    \         `lst1` moved due to this implicit call to `.into_iter()`\n   |     \
    \           help: consider borrowing to avoid moving into the for loop: `&lst1`\n\
    ...\n26 |         total_match = lst1;\n   |                       ^^^^ value used\
    \ here after move\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    if lst1.len()\
    \ > lst2.len() {\n        let mut lst = lst1;\n        lst.extend(&mut lst2[lst2.len()..]);\n\
    \        return lst;\n    }\n    let mut lst = lst2;\n    lst.extend(&mut lst1[lst1.len()..]);\n\
    \    return lst;\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<&mut [String] as IntoIterator>::Item\
    \ == String`\n  --> /tmp/tmpnfzspf5d.rs:21:13\n   |\n21 |         lst.extend(&mut\
    \ lst2[lst2.len()..]);\n   |             ^^^^^^ expected `&mut String`, found\
    \ struct `String`\n\nerror[E0271]: type mismatch resolving `<&mut [String] as\
    \ IntoIterator>::Item == String`\n  --> /tmp/tmpnfzspf5d.rs:25:9\n   |\n25 | \
    \    lst.extend(&mut lst1[lst1.len()..]);\n   |         ^^^^^^ expected `&mut\
    \ String`, found struct `String`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut total_match: Vec<String> = vec![];\n    for elem in lst1 {\n    \
    \    if lst2.iter().any(|x| x.contains(elem)) {\n            total_match.push(elem);\n\
    \        }\n    }\n    total_match\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n  -->\
    \ /tmp/tmpiv_yzotp.rs:18:43\n   |\n18 |         if lst2.iter().any(|x| x.contains(elem))\
    \ {\n   |                                           ^^^^\n   |               \
    \                            |\n   |                                         \
    \  expected an implementor of trait `Pattern<'_>`\n   |                      \
    \                     help: consider borrowing here: `&elem`\n   |\n   = note:\
    \ the trait bound `String: Pattern<'_>` is not satisfied\n   = note: required\
    \ because of the requirements on the impl of `Pattern<'_>` for `String`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_len\
    \ = 0;\n    for s in lst1 {\n        total_len += s.len();\n    }\n    for s in\
    \ lst2 {\n        total_len += s.len();\n    }\n    if total_len == lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_len == lst2.len() {\n        return\
    \ lst2;\n    }\n    let mut total_len = 0;\n    for s in lst1 {\n        total_len\
    \ += s.len();\n    }\n    for s in lst2 {\n        total_len += s.len();\n   \
    \ }\n    if total_len < lst1.len() {\n        return lst1;\n    }\n    if total_len\
    \ < lst2.len() {\n        return lst2;\n    }\n    let mut total_len = 0;\n  \
    \  for s in lst1 {\n        total_len += s.len();\n    }\n    for s in lst2 {\n\
    \        total_len += s.len();\n    }\n    if total_len == lst1.len() {\n    \
    \    return lst1;\n    }\n    if total_len == lst2.len() {\n        return lst2;\n\
    \    }\n    let mut total_len = 0;\n    for s in lst1 {\n        total_len +=\
    \ s.len();\n    }\n    for s in lst2 {\n        total_len += s.len();\n    }\n\
    \    if total_len > lst1.len() {\n        return lst1;\n    }\n    if total_len\
    \ > lst2.len() {\n        return lst2;\n    }\n    let mut total_len = 0;\n  \
    \  for s in lst1 {\n        total_len += s.len();\n    }\n    for s in lst2 {\n\
    \        total_len += s.len();\n    }\n    if total_len == lst1.len() {\n    \
    \    return lst1;\n    }\n    if total_len == lst2.len() {\n        return lst2;\n\
    \    }\n    let mut total_len = 0;\n    for s in lst1 {\n        total_len +=\
    \ s.len();\n    }\n    for s in lst2 {\n        total_len += s.len();\n    }\n\
    \    if total_len < lst1.len() {\n        return lst1;\n    }\n    if total_len\
    \ < lst2.len() {\n        return lst2;\n    }\n    let mut total_len = 0;\n  \
    \  for s in lst1 {\n        total_len += s.len();\n    }\n    for s in lst2 {\n\
    \        total_len += s.len();\n    }\n    if total_len > lst1.len() {\n     \
    \   return lst1;\n    }\n    if total_len > lst2.len() {\n        return lst2;\n\
    \    }\n    let mut total_len = 0;\n    for s in lst1 {\n        total_len +=\
    \ s.len();\n    }\n    for s in lst2 {\n        total_len += s.len();\n    }\n\
    \    if total_len == lst1.\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n   --> /tmp/tmp94q_keyj.rs:118:1\n    |\n\
    118 | }\n    | ^\n\nerror: expected `{`, found `}`\n   --> /tmp/tmp94q_keyj.rs:118:1\n\
    \    |\n117 |     if total_len == lst1.\n    |     -- this `if` expression has\
    \ a condition, but no block\n118 | }\n    | ^ expected `{`\n\nerror: aborting\
    \ due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 101
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    if lst1.len()\
    \ < lst2.len() {\n        let mut result = vec![String::from(\"0\")];\n      \
    \  for elem in lst2 {\n            if elem < lst1[0] {\n                result.push(elem);\n\
    \            }\n        }\n        return result;\n    }\n    let mut result =\
    \ vec![String::from(\"0\")];\n    for elem in lst1 {\n        if elem < lst2[0]\
    \ {\n            result.push(elem);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmpi38f485q.rs:40:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = vec![];\n    for x in lst1 {\n        for y in lst2 {\n            if x.len()\
    \ < y.len() {\n                total_chars.push(y);\n                break;\n\
    \            }\n        }\n    }\n    total_chars\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpayyltm_r.rs:21:18\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n21  |  \
    \       for y in lst2 {\n    |                  ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n21  |         for y in &lst2 {\n    |          \
    \        +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n    }\n\
    \    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let mut\
    \ total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n\n}\n\nfn main() {\n   \
    \ let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpdu5x5fzy.rs:119:3\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                                                   \
    \  - unclosed delimiter\n...\n104 |     for v in lst2 {\n    |               \
    \    - this delimiter might not be properly closed...\n105 | \n106 | }\n    |\
    \ - ...as it matches this but it has different indentation\n...\n119 | }\n   \
    \ |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdu5x5fzy.rs:15:57\n \
    \  |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |    -----------                                          ^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n    }\n\
    \    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let mut\
    \ total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n\n}\n\nfn main() {\n   \
    \ let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpdu5x5fzy.rs:119:3\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                                                   \
    \  - unclosed delimiter\n...\n104 |     for v in lst2 {\n    |               \
    \    - this delimiter might not be properly closed...\n105 | \n106 | }\n    |\
    \ - ...as it matches this but it has different indentation\n...\n119 | }\n   \
    \ |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdu5x5fzy.rs:15:57\n \
    \  |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |    -----------                                          ^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = vec![0; lst1.len()];\n    for x in lst1 {\n        for y in lst2 {\n     \
    \       if x.len() < y.len() {\n                total_chars[x.len()] += 1;\n \
    \           }\n        }\n    }\n    total_chars\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjxbpvttp.rs:27:5\n   |\n\
    15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n \
    \  |                                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n27 |     total_chars\n   |     ^^^^^^^^^^^\
    \ expected struct `String`, found integer\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<{integer}>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n    }\n\
    \    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let mut\
    \ total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n\n}\n\nfn main() {\n   \
    \ let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpk2jkmrwk.rs:119:3\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                                                   \
    \  - unclosed delimiter\n...\n104 |     for s in lst2 {\n    |               \
    \    - this delimiter might not be properly closed...\n105 | \n106 | }\n    |\
    \ - ...as it matches this but it has different indentation\n...\n119 | }\n   \
    \ |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk2jkmrwk.rs:15:57\n \
    \  |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |    -----------                                          ^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut total_match: Vec<String> = Vec::new();\n    for el1 in lst1 {\n \
    \       for el2 in lst2 {\n            if el1.len() < el2.len() {\n          \
    \      total_match.push(el1);\n                break;\n            }\n       \
    \ }\n    }\n    total_match\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmp7kl80kr8.rs:18:20\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n18  |  \
    \       for el2 in lst2 {\n    |                    ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n18  |         for el2 in &lst2 {\n    |        \
    \            +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_len\
    \ = 0;\n    for v in lst1 {\n        total_len += v.len();\n    }\n    for v in\
    \ lst2 {\n        total_len += v.len();\n    }\n    if total_len == 0 {\n    \
    \    return vec![];\n    }\n    let mut total_chars = 0;\n    for v in lst1 {\n\
    \        total_chars += v.chars().count();\n    }\n    for v in lst2 {\n     \
    \   total_chars += v.chars().count();\n    }\n    if total_chars == total_len\
    \ {\n        return lst1;\n    }\n    vec![]\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst1`\n   --> /tmp/tmp9eg0lhsi.rs:30:14\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n20  |     for v in lst1 {\n\
    \    |              ----\n    |              |\n    |              `lst1` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&lst1`\n...\n30  |     for v in\
    \ lst1 {\n    |              ^^^^ value used here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `lst1`\n\nerror[E0382]:\
    \ use of moved value: `lst2`\n  --> /tmp/tmp9eg0lhsi.rs:33:14\n   |\n15 | fn total_match(lst1:\
    \ Vec<String>, lst2: Vec<String>) -> Vec<String> {\n   |                     \
    \              ---- move occurs because `lst2` has type `Vec<String>`, which does\
    \ not implement the `Copy` trait\n...\n23 |     for v in lst2 {\n   |        \
    \      ----\n   |              |\n   |              `lst2` moved due to this implicit\
    \ call to `.into_iter()`\n   |              help: consider borrowing to avoid\
    \ moving into the for loop: `&lst2`\n...\n33 |     for v in lst2 {\n   |     \
    \         ^^^^ value used here after move\n\nerror[E0382]: use of moved value:\
    \ `lst1`\n  --> /tmp/tmp9eg0lhsi.rs:37:16\n   |\n15 | fn total_match(lst1: Vec<String>,\
    \ lst2: Vec<String>) -> Vec<String> {\n   |                ---- move occurs because\
    \ `lst1` has type `Vec<String>`, which does not implement the `Copy` trait\n...\n\
    30 |     for v in lst1 {\n   |              ----\n   |              |\n   |  \
    \            `lst1` moved due to this implicit call to `.into_iter()`\n   |  \
    \            help: consider borrowing to avoid moving into the for loop: `&lst1`\n\
    ...\n37 |         return lst1;\n   |                ^^^^ value used here after\
    \ move\n\nerror: aborting due to 3 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_len\
    \ = 0;\n    for el1 in lst1 {\n        for el2 in lst2 {\n            if el1.len()\
    \ < el2.len() {\n                break;\n            }\n            total_len\
    \ += el1.len();\n        }\n    }\n    lst1.iter().filter(|el| el1.len() < total_len).collect()\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `el1` in this scope\n  --> /tmp/tmp4g5ggdpe.rs:28:29\n\
    \   |\n28 |     lst1.iter().filter(|el| el1.len() < total_len).collect()\n   |\
    \                             ^^^ help: a local variable with a similar name exists:\
    \ `el`\n\nerror[E0277]: a value of type `Vec<String>` cannot be built from an\
    \ iterator over elements of type `&String`\n  --> /tmp/tmp4g5ggdpe.rs:28:52\n\
    \   |\n28 |     lst1.iter().filter(|el| el1.len() < total_len).collect()\n   |\
    \                                                    ^^^^^^^ value of type `Vec<String>`\
    \ cannot be built from `std::iter::Iterator<Item=&String>`\n   |\n   = help: the\
    \ trait `FromIterator<&String>` is not implemented for `Vec<String>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n    }\n\
    \    lst1.iter().filter(|&x| x < lst2).collect()\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsmc2jo99.rs:23:33\n   |\n\
    23 |     lst1.iter().filter(|&x| x < lst2).collect()\n   |                   \
    \              ^^^^ expected `&String`, found struct `Vec`\n   |\n   = note: expected\
    \ reference `&String`\n                 found struct `Vec<String>`\n\nerror[E0277]:\
    \ a value of type `Vec<String>` cannot be built from an iterator over elements\
    \ of type `&String`\n  --> /tmp/tmpsmc2jo99.rs:23:39\n   |\n23 |     lst1.iter().filter(|&x|\
    \ x < lst2).collect()\n   |                                       ^^^^^^^ value\
    \ of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&String>`\n\
    \   |\n   = help: the trait `FromIterator<&String>` is not implemented for `Vec<String>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_len\
    \ = 0;\n    for el1 in lst1 {\n        for el2 in lst2 {\n            if el1.len()\
    \ < el2.len() {\n                total_len += el1.len();\n            }\n    \
    \    }\n    }\n    lst1.iter().filter(|el| el1.len() < total_len).collect()\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `el1` in this scope\n  --> /tmp/tmpwwshlfzp.rs:27:29\n\
    \   |\n27 |     lst1.iter().filter(|el| el1.len() < total_len).collect()\n   |\
    \                             ^^^ help: a local variable with a similar name exists:\
    \ `el`\n\nerror[E0277]: a value of type `Vec<String>` cannot be built from an\
    \ iterator over elements of type `&String`\n  --> /tmp/tmpwwshlfzp.rs:27:52\n\
    \   |\n27 |     lst1.iter().filter(|el| el1.len() < total_len).collect()\n   |\
    \                                                    ^^^^^^^ value of type `Vec<String>`\
    \ cannot be built from `std::iter::Iterator<Item=&String>`\n   |\n   = help: the\
    \ trait `FromIterator<&String>` is not implemented for `Vec<String>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_len\
    \ = 0;\n    for v in lst1 {\n        total_len += v.len();\n    }\n    let mut\
    \ total_len2 = total_len;\n    for v in lst2 {\n        total_len2 += v.len();\n\
    \    }\n    if total_len == total_len2 {\n        return lst1;\n    }\n    let\
    \ mut total_len3 = 0;\n    for v in lst1 {\n        total_len3 += v.len();\n \
    \   }\n    let mut total_len4 = 0;\n    for v in lst2 {\n        total_len4 +=\
    \ v.len();\n    }\n    if total_len3 == total_len4 {\n        return lst1;\n \
    \   }\n    let mut total_len5 = 0;\n    for v in lst1 {\n        total_len5 +=\
    \ v.len();\n    }\n    let mut total_len6 = 0;\n    for v in lst2 {\n        total_len6\
    \ += v.len();\n    }\n    if total_len5 == total_len6 {\n        return lst1;\n\
    \    }\n    let mut total_len7 = 0;\n    for v in lst1 {\n        total_len7 +=\
    \ v.len();\n    }\n    let mut total_len8 = 0;\n    for v in lst2 {\n        total_len8\
    \ += v.len();\n    }\n    if total_len7 == total_len8 {\n        return lst1;\n\
    \    }\n    let mut total_len9 = 0;\n    for v in lst1 {\n        total_len9 +=\
    \ v.len();\n    }\n    let mut total_len10 = 0;\n    for v in lst2 {\n       \
    \ total_len10 += v.len();\n    }\n    if total_len9 == total_len10 {\n       \
    \ return lst1;\n    }\n    let mut total_len11 = 0;\n    for v in lst1 {\n   \
    \     total_len11 += v.len();\n    }\n    let mut total_len12 = 0;\n    for v\
    \ in lst2 {\n        total_len12 += v.len();\n    }\n    if total_len11 == total_len12\
    \ {\n        return lst1;\n    }\n    let mut total_len13 = 0;\n    for v in lst1\
    \ {\n        total_len13 += v.len();\n    }\n    let mut total_len14 = 0;\n  \
    \  for v in lst2 {\n        total_len14 += v.len();\n    }\n    if total_len13\
    \ == total_len14 {\n        return lst1;\n    }\n    let mut total_len15 = 0;\n\
    \    for v in lst1 {\n        total_len15 += v.len();\n    }\n    let mut total_len16\
    \ = 0;\n    for v in lst2 {\n        total_len16 += v.len();\n    }\n    if total_len15\
    \ == total_len16 {\n        return lst1;\n    }\n    let mut total_len17 = 0;\n\
    \n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvh26ar0f.rs:15:57\n   |\n\
    15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n \
    \  |    -----------                                          ^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n\
    \           found unit type `()`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = vec![];\n    for el1 in lst1 {\n        for el2 in lst2 {\n            if\
    \ el1.len() < el2.len() {\n                total_chars.push(el1);\n          \
    \      break;\n            }\n        }\n    }\n    total_chars\n}\n\nfn main()\
    \ {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpp11fnkle.rs:21:20\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n21  |  \
    \       for el2 in lst2 {\n    |                    ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n21  |         for el2 in &lst2 {\n    |        \
    \            +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for elem in lst2 {\n        total_chars += elem.len();\n\
    \    }\n    if total_chars < lst1.len() {\n        return lst1;\n    }\n    lst1\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmpfbfsatm0.rs:32:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for el in lst2 {\n        if el > total_chars {\n       \
    \     total_chars = el;\n        }\n    }\n    lst1.iter().filter(|&x| x < total_chars).collect()\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp954qwcw9.rs:21:17\n   |\n\
    21 |         if el > total_chars {\n   |                 ^^^^^^^^^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                 |\n   |    \
    \             expected struct `String`, found `usize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp954qwcw9.rs:22:27\n   |\n22 |             total_chars =\
    \ el;\n   |                           ^^ expected `usize`, found struct `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp954qwcw9.rs:25:33\n   |\n25 |\
    \     lst1.iter().filter(|&x| x < total_chars).collect()\n   |               \
    \                  ^^^^^^^^^^^ expected `&String`, found `usize`\n\nerror[E0277]:\
    \ a value of type `Vec<String>` cannot be built from an iterator over elements\
    \ of type `&String`\n  --> /tmp/tmp954qwcw9.rs:25:46\n   |\n25 |     lst1.iter().filter(|&x|\
    \ x < total_chars).collect()\n   |                                           \
    \   ^^^^^^^ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&String>`\n\
    \   |\n   = help: the trait `FromIterator<&String>` is not implemented for `Vec<String>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut total_match: Vec<String> = vec![];\n    for el1 in lst1 {\n     \
    \   for el2 in lst2 {\n            if el1.len() < el2.len() {\n              \
    \  total_match.push(el1);\n                break;\n            }\n        }\n\
    \    }\n    total_match\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpp_sfjfr0.rs:18:20\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n18  |  \
    \       for el2 in lst2 {\n    |                    ^^^^\n    |              \
    \      |\n    |                    `lst2` moved due to this implicit call to `.into_iter()`,\
    \ in previous iteration of loop\n    |                    help: consider borrowing\
    \ to avoid moving into the for loop: `&lst2`\n    |\nnote: this function takes\
    \ ownership of the receiver `self`, which moves `lst2`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 101
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut res\
    \ = vec![];\n    for x in lst1 {\n        if !lst2.contains(&x) {\n          \
    \  res.push(x);\n        }\n    }\n    return res;\n}\n\nfn main() {\n    let\
    \ candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmp_oy9pfh4.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 101
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n    }\n\
    \    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let mut\
    \ res = vec![];\n    for s in lst1 {\n        if total_chars < s.len() {\n   \
    \         res.push(s);\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmpk9w1ogvd.rs:38:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 101
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for s in lst2 {\n        if total_chars > s.len() {\n   \
    \         total_chars = s.len();\n        }\n    }\n    lst1\n}\n\nfn main() {\n\
    \    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmpyhu0xng1.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for x in lst1 {\n        if lst2.iter().any(|y| y.contains(x))\
    \ {\n            total_chars += 1;\n        }\n    }\n    lst1.iter().filter(|x|\
    \ x < lst2).map(|x| x).collect()\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n  -->\
    \ /tmp/tmpwyjfgymm.rs:21:43\n   |\n21 |         if lst2.iter().any(|y| y.contains(x))\
    \ {\n   |                                           ^\n   |                  \
    \                         |\n   |                                           expected\
    \ an implementor of trait `Pattern<'_>`\n   |                                \
    \           help: consider borrowing here: `&x`\n   |\n   = note: the trait bound\
    \ `String: Pattern<'_>` is not satisfied\n   = note: required because of the requirements\
    \ on the impl of `Pattern<'_>` for `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwyjfgymm.rs:25:32\n   |\n25 |     lst1.iter().filter(|x| x < lst2).map(|x|\
    \ x).collect()\n   |                                ^^^^ expected `&&String`,\
    \ found struct `Vec`\n   |\n   = note: expected reference `&&String`\n       \
    \          found struct `Vec<String>`\n\nerror[E0277]: a value of type `Vec<String>`\
    \ cannot be built from an iterator over elements of type `&String`\n  --> /tmp/tmpwyjfgymm.rs:25:49\n\
    \   |\n25 |     lst1.iter().filter(|x| x < lst2).map(|x| x).collect()\n   |  \
    \                                               ^^^^^^^ value of type `Vec<String>`\
    \ cannot be built from `std::iter::Iterator<Item=&String>`\n   |\n   = help: the\
    \ trait `FromIterator<&String>` is not implemented for `Vec<String>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_len\
    \ = 0;\n    for s in lst1 {\n        total_len += s.len();\n    }\n    for s in\
    \ lst2 {\n        total_len += s.len();\n    }\n    if total_len == 0 {\n    \
    \    return vec![];\n    }\n    let mut total_matches = vec![];\n    for s in\
    \ lst1 {\n        if total_len < s.len() {\n            break;\n        }\n  \
    \      total_matches.push(s);\n    }\n    for s in lst2 {\n        if total_len\
    \ < s.len() {\n            break;\n        }\n        total_matches.push(s);\n\
    \    }\n    total_matches\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst1`\n   --> /tmp/tmprdlhcc3_.rs:30:14\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n20  |     for s in lst1 {\n\
    \    |              ----\n    |              |\n    |              `lst1` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&lst1`\n...\n30  |     for s in\
    \ lst1 {\n    |              ^^^^ value used here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `lst1`\n\nerror[E0382]:\
    \ use of moved value: `lst2`\n  --> /tmp/tmprdlhcc3_.rs:36:14\n   |\n15 | fn total_match(lst1:\
    \ Vec<String>, lst2: Vec<String>) -> Vec<String> {\n   |                     \
    \              ---- move occurs because `lst2` has type `Vec<String>`, which does\
    \ not implement the `Copy` trait\n...\n23 |     for s in lst2 {\n   |        \
    \      ----\n   |              |\n   |              `lst2` moved due to this implicit\
    \ call to `.into_iter()`\n   |              help: consider borrowing to avoid\
    \ moving into the for loop: `&lst2`\n...\n36 |     for s in lst2 {\n   |     \
    \         ^^^^ value used here after move\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_len\
    \ = 0;\n    for v in lst1 {\n        total_len += v.len();\n    }\n    for v in\
    \ lst2 {\n        total_len += v.len();\n    }\n    if total_len == 0 {\n    \
    \    return vec![];\n    }\n    let mut total_matches: Vec<String> = vec![];\n\
    \    for v in lst1 {\n        if v.len() <= total_len {\n            total_matches.push(v);\n\
    \        }\n    }\n    for v in lst2 {\n        if v.len() <= total_len {\n  \
    \          total_matches.push(v);\n        }\n    }\n    total_matches\n}\n\n\
    fn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst1`\n   --> /tmp/tmp86qvdh2m.rs:30:14\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n20  |     for v in lst1 {\n\
    \    |              ----\n    |              |\n    |              `lst1` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&lst1`\n...\n30  |     for v in\
    \ lst1 {\n    |              ^^^^ value used here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `lst1`\n\nerror[E0382]:\
    \ use of moved value: `lst2`\n  --> /tmp/tmp86qvdh2m.rs:35:14\n   |\n15 | fn total_match(lst1:\
    \ Vec<String>, lst2: Vec<String>) -> Vec<String> {\n   |                     \
    \              ---- move occurs because `lst2` has type `Vec<String>`, which does\
    \ not implement the `Copy` trait\n...\n23 |     for v in lst2 {\n   |        \
    \      ----\n   |              |\n   |              `lst2` moved due to this implicit\
    \ call to `.into_iter()`\n   |              help: consider borrowing to avoid\
    \ moving into the for loop: `&lst2`\n...\n35 |     for v in lst2 {\n   |     \
    \         ^^^^ value used here after move\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 101
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_match:\
    \ Vec<String> = vec![];\n    for x in lst1 {\n        if lst2.iter().any(|y| y.contains(&x))\
    \ {\n            total_match.push(x);\n        }\n    }\n    total_match\n}\n\n\
    fn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmp90qhij2l.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = vec![];\n    for str1 in lst1 {\n        for str2 in lst2 {\n            if\
    \ str1.len() < str2.len() {\n                total_chars.push(str1);\n       \
    \         break;\n            }\n        }\n    }\n    total_chars\n}\n\nfn main()\
    \ {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmphbtjh8ko.rs:21:21\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n21  |  \
    \       for str2 in lst2 {\n    |                     ^^^^\n    |            \
    \         |\n    |                     `lst2` moved due to this implicit call\
    \ to `.into_iter()`, in previous iteration of loop\n    |                    \
    \ help: consider borrowing to avoid moving into the for loop: `&lst2`\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `lst2`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 101
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n    }\n\
    \    if total_chars == lst1.len() {\n        return lst1;\n    }\n    lst1\n}\n\
    \nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmpq5d9s_ja.rs:32:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut total_match: Vec<String> = vec![];\n    for el1 in lst1 {\n     \
    \   for el2 in lst2 {\n            if el1.len() < el2.len() {\n              \
    \  total_match.push(el1);\n                break;\n            }\n        }\n\
    \    }\n    total_match\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpp_sfjfr0.rs:18:20\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n18  |  \
    \       for el2 in lst2 {\n    |                    ^^^^\n    |              \
    \      |\n    |                    `lst2` moved due to this implicit call to `.into_iter()`,\
    \ in previous iteration of loop\n    |                    help: consider borrowing\
    \ to avoid moving into the for loop: `&lst2`\n    |\nnote: this function takes\
    \ ownership of the receiver `self`, which moves `lst2`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = vec![];\n    for x in lst1 {\n        for y in lst2 {\n            if x.len()\
    \ < y.len() {\n                total_chars.push(y);\n            }\n        }\n\
    \    }\n    return total_chars;\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpxo4jirzx.rs:21:18\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n21  |  \
    \       for y in lst2 {\n    |                  ^^^^\n    |                  |\n\
    \    |                  `lst2` moved due to this implicit call to `.into_iter()`,\
    \ in previous iteration of loop\n    |                  help: consider borrowing\
    \ to avoid moving into the for loop: `&lst2`\n    |\nnote: this function takes\
    \ ownership of the receiver `self`, which moves `lst2`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n    }\n\
    \    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let mut\
    \ total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n\n}\n\nfn main() {\n   \
    \ let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpdu5x5fzy.rs:119:3\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                                                   \
    \  - unclosed delimiter\n...\n104 |     for v in lst2 {\n    |               \
    \    - this delimiter might not be properly closed...\n105 | \n106 | }\n    |\
    \ - ...as it matches this but it has different indentation\n...\n119 | }\n   \
    \ |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdu5x5fzy.rs:15:57\n \
    \  |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |    -----------                                          ^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_match:\
    \ Vec<String> = vec![];\n    for i in 0..lst1.len() {\n        if lst1[i] < lst2[i]\
    \ {\n            total_match.push(lst1[i]);\n        }\n    }\n    total_match\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmp9jcy4wi6.rs:22:30\n\
    \   |\n22 |             total_match.push(lst1[i]);\n   |                     \
    \         ^^^^^^^ move occurs because value has type `String`, which does not\
    \ implement the `Copy` trait\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    if lst1.len()\
    \ > lst2.len() {\n        lst2.reverse();\n    }\n    let mut result = vec![];\n\
    \    for i in 0..lst1.len() {\n        let mut found = false;\n        for j in\
    \ 0..lst2.len() {\n            if lst1[i] == lst2[j] {\n                found\
    \ = true;\n                break;\n            }\n        }\n        if found\
    \ {\n            break;\n        }\n        result.push(lst1[i]);\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `lst2` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp5n8fhc52.rs:20:9\n   |\n15 | fn total_match(lst1: Vec<String>,\
    \ lst2: Vec<String>) -> Vec<String> {\n   |                                  \
    \ ---- help: consider changing this to be mutable: `mut lst2`\n...\n20 |     \
    \    lst2.reverse();\n   |         ^^^^ cannot borrow as mutable\n\nerror[E0507]:\
    \ cannot move out of index of `Vec<String>`\n  --> /tmp/tmp5n8fhc52.rs:34:21\n\
    \   |\n34 |         result.push(lst1[i]);\n   |                     ^^^^^^^ move\
    \ occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0507, E0596.\nFor more information about an error, try `rustc\
    \ --explain E0507`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = vec![0; lst1.len()];\n    for x in lst1 {\n        for y in lst2 {\n     \
    \       if x.len() < y.len() {\n                total_chars[x.len()] += 1;\n \
    \           }\n        }\n    }\n    total_chars\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjxbpvttp.rs:27:5\n   |\n\
    15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n \
    \  |                                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n27 |     total_chars\n   |     ^^^^^^^^^^^\
    \ expected struct `String`, found integer\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<{integer}>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut total_match: Vec<String> = vec![];\n    for i in 0..lst1.len() {\n\
    \        let mut found = false;\n        for j in 0..lst2.len() {\n          \
    \  if lst1[i] == lst2[j] {\n                found = true;\n                break;\n\
    \            }\n        }\n        if found == true {\n            total_match.push(lst1[i]);\n\
    \        }\n    }\n    total_match\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmp89kd9z7x.rs:26:30\n\
    \   |\n26 |             total_match.push(lst1[i]);\n   |                     \
    \         ^^^^^^^ move occurs because value has type `String`, which does not\
    \ implement the `Copy` trait\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n    }\n\
    \    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let mut\
    \ total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n\n}\n\nfn main() {\n   \
    \ let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpdu5x5fzy.rs:119:3\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                                                   \
    \  - unclosed delimiter\n...\n104 |     for v in lst2 {\n    |               \
    \    - this delimiter might not be properly closed...\n105 | \n106 | }\n    |\
    \ - ...as it matches this but it has different indentation\n...\n119 | }\n   \
    \ |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdu5x5fzy.rs:15:57\n \
    \  |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |    -----------                                          ^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for v in lst2 {\n        if v < lst1[0] {\n            total_chars\
    \ += v.len();\n        }\n    }\n    total_chars\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk0ywhu4a.rs:25:5\n   |\n\
    15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n \
    \  |                                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n25 |     total_chars\n   |     ^^^^^^^^^^^\
    \ expected struct `Vec`, found `usize`\n   |\n   = note: expected struct `Vec<String>`\n\
    \                found type `usize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_match:\
    \ Vec<String> = vec![];\n    for x in lst1 {\n        for y in lst2 {\n      \
    \      if x.len() < y.len() {\n                total_match.push(x);\n        \
    \        break;\n            }\n        }\n    }\n    total_match\n}\n\nfn main()\
    \ {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpvrf8ma1g.rs:21:18\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n21  |  \
    \       for y in lst2 {\n    |                  ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n21  |         for y in &lst2 {\n    |          \
    \        +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = vec![0; lst1.len()];\n    for &s in lst1 {\n        for &s2 in lst2 {\n  \
    \          if s.len() < s2.len() {\n                break;\n            }\n  \
    \          total_chars[s.len()] += 1;\n        }\n    }\n    total_chars\n}\n\n\
    fn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphrgz9jnn.rs:20:9\n   |\n\
    20 |     for &s in lst1 {\n   |         ^^    ---- this expression has type `String`\n\
    \   |         |\n   |         expected struct `String`, found reference\n   |\n\
    \   = note: expected struct `String`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphrgz9jnn.rs:21:13\n   |\n21 |         for &s2\
    \ in lst2 {\n   |             ^^^    ---- this expression has type `String`\n\
    \   |             |\n   |             expected struct `String`, found reference\n\
    \   |\n   = note: expected struct `String`\n           found reference `&_`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmphrgz9jnn.rs:28:5\n   |\n15 | fn\
    \ total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n   |   \
    \                                                      ----------- expected `Vec<String>`\
    \ because of return type\n...\n28 |     total_chars\n   |     ^^^^^^^^^^^ expected\
    \ struct `String`, found integer\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<{integer}>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut total_match: Vec<String> = Vec::new();\n    for el1 in lst1 {\n \
    \       for el2 in lst2 {\n            if el1.len() < el2.len() {\n          \
    \      total_match.push(el1);\n                break;\n            }\n       \
    \ }\n    }\n    total_match\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmp7kl80kr8.rs:18:20\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n18  |  \
    \       for el2 in lst2 {\n    |                    ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n18  |         for el2 in &lst2 {\n    |        \
    \            +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for x in lst1 {\n        total_chars += x.len();\n    }\n\
    \    for x in lst2 {\n        total_chars += x.len();\n    }\n    if total_chars\
    \ < lst2.len() {\n        return lst1;\n    }\n    lst2\n}\n\nfn main() {\n  \
    \  let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `lst2`\n   --> /tmp/tmpcefcs3i2.rs:26:22\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n23  |  \
    \   for x in lst2 {\n    |              ----\n    |              |\n    |    \
    \          `lst2` moved due to this implicit call to `.into_iter()`\n    |   \
    \           help: consider borrowing to avoid moving into the for loop: `&lst2`\n\
    ...\n26  |     if total_chars < lst2.len() {\n    |                      ^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `lst2`\n\nerror[E0382]: use of moved value:\
    \ `lst1`\n  --> /tmp/tmpcefcs3i2.rs:27:16\n   |\n15 | fn total_match(lst1: Vec<String>,\
    \ lst2: Vec<String>) -> Vec<String> {\n   |                ---- move occurs because\
    \ `lst1` has type `Vec<String>`, which does not implement the `Copy` trait\n...\n\
    20 |     for x in lst1 {\n   |              ----\n   |              |\n   |  \
    \            `lst1` moved due to this implicit call to `.into_iter()`\n   |  \
    \            help: consider borrowing to avoid moving into the for loop: `&lst1`\n\
    ...\n27 |         return lst1;\n   |                ^^^^ value used here after\
    \ move\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 101
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n    }\n\
    \    if total_chars < lst1.len() {\n        return lst1;\n    }\n    lst1\n}\n\
    \nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmpoe90ipmm.rs:32:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut total_len = 0;\n    for s in lst1 {\n        total_len += s.len();\n\
    \    }\n    for s in lst2 {\n        total_len += s.len();\n    }\n    if total_len\
    \ == 0 {\n        return lst1;\n    }\n    if total_len == lst1.len() {\n    \
    \    return lst1;\n    }\n    if total_len == lst2.len() {\n        return lst2;\n\
    \    }\n    let mut total_len = 0;\n    for s in lst1 {\n        total_len +=\
    \ s.len();\n    }\n    for s in lst2 {\n        total_len += s.len();\n    }\n\
    \    if total_len == 0 {\n        return lst1;\n    }\n    if total_len == lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_len == lst2.len() {\n        return\
    \ lst2;\n    }\n    let mut total_len = 0;\n    for s in lst1 {\n        total_len\
    \ += s.len();\n    }\n    for s in lst2 {\n        total_len += s.len();\n   \
    \ }\n    if total_len == 0 {\n        return lst1;\n    }\n    if total_len ==\
    \ lst1.len() {\n        return lst1;\n    }\n    if total_len == lst2.len() {\n\
    \        return lst2;\n    }\n    let mut total_len = 0;\n    for s in lst1 {\n\
    \        total_len += s.len();\n    }\n    for s in lst2 {\n        total_len\
    \ += s.len();\n    }\n    if total_len == 0 {\n        return lst1;\n    }\n \
    \   if total_len == lst1.len() {\n        return lst1;\n    }\n    if total_len\
    \ == lst2.len() {\n        return lst2;\n    }\n    let mut total_len = 0;\n \
    \   for s in lst1 {\n        total_len += s.len();\n    }\n    for s in lst2 {\n\
    \        total_len += s.len();\n    }\n    if total_len == 0 {\n        return\
    \ lst1;\n    }\n    if total_len == lst1.len() {\n        return lst1;\n    }\n\
    \    if total_len == lst2.len() {\n        return lst2;\n    }\n    let mut total_len\
    \ = 0;\n    for s in lst1 {\n        total_len += s.len();\n    }\n    for s in\
    \ lst2 {\n        total_len += s.len();\n    }\n    if total_len == 0 {\n    \
    \    return lst1;\n    }\n    if total_len == lst1.len() {\n        return lst1;\n\
    \    }\n    if total_len == lst2.len() {\n        return lst2;\n    }\n    let\
    \ mut total_len = 0;\n    for s in lst1 {\n        total_len += s.len();\n   \
    \ }\n    for s in lst2 {\n        total_len += s.len();\n    }\n    if total_len\
    \ == 0 {\n        return lst1;\n    }\n    if total_len\n}\n\nfn main() {\n  \
    \  let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmpxfr0brub.rs:123:1\n    |\n\
    122 |     if total_len\n    |     -- this `if` expression has a condition, but\
    \ no block\n123 | }\n    | ^ expected `{`\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut total_len = 0;\n    for el1 in lst1 {\n        for el2 in lst2 {\n\
    \            if el1.len() < el2.len() {\n                total_len += el1.len();\n\
    \            } else {\n                total_len += el2.len();\n            }\n\
    \        }\n    }\n    if total_len == lst1.len() {\n        lst1\n    } else\
    \ {\n        lst2\n    }\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmphv_5cits.rs:18:20\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n18  |  \
    \       for el2 in lst2 {\n    |                    ^^^^\n    |              \
    \      |\n    |                    `lst2` moved due to this implicit call to `.into_iter()`,\
    \ in previous iteration of loop\n    |                    help: consider borrowing\
    \ to avoid moving into the for loop: `&lst2`\n    |\nnote: this function takes\
    \ ownership of the receiver `self`, which moves `lst2`\n\nerror[E0382]: borrow\
    \ of moved value: `lst1`\n  --> /tmp/tmphv_5cits.rs:26:21\n   |\n15 | fn total_match(lst1:\
    \ Vec<String>, lst2: Vec<String>) -> Vec<String> {\n   |                ---- move\
    \ occurs because `lst1` has type `Vec<String>`, which does not implement the `Copy`\
    \ trait\n16 |     let mut total_len = 0;\n17 |     for el1 in lst1 {\n   |   \
    \             ----\n   |                |\n   |                `lst1` moved due\
    \ to this implicit call to `.into_iter()`\n   |                help: consider\
    \ borrowing to avoid moving into the for loop: `&lst1`\n...\n26 |     if total_len\
    \ == lst1.len() {\n   |                     ^^^^ value borrowed here after move\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    if lst1.len()\
    \ > lst2.len() {\n        let mut lst = lst1;\n        lst.extend(&mut lst2[0..lst1.len()]);\n\
    \        return lst;\n    }\n    let mut lst = lst2;\n    lst.extend(&mut lst1[0..lst2.len()]);\n\
    \    return lst;\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<&mut [String] as IntoIterator>::Item\
    \ == String`\n  --> /tmp/tmpgan7zxbu.rs:21:13\n   |\n21 |         lst.extend(&mut\
    \ lst2[0..lst1.len()]);\n   |             ^^^^^^ expected `&mut String`, found\
    \ struct `String`\n\nerror[E0271]: type mismatch resolving `<&mut [String] as\
    \ IntoIterator>::Item == String`\n  --> /tmp/tmpgan7zxbu.rs:25:9\n   |\n25 | \
    \    lst.extend(&mut lst1[0..lst2.len()]);\n   |         ^^^^^^ expected `&mut\
    \ String`, found struct `String`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n    }\n\
    \    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let mut\
    \ total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n\n}\n\nfn main() {\n   \
    \ let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpdu5x5fzy.rs:119:3\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                                                   \
    \  - unclosed delimiter\n...\n104 |     for v in lst2 {\n    |               \
    \    - this delimiter might not be properly closed...\n105 | \n106 | }\n    |\
    \ - ...as it matches this but it has different indentation\n...\n119 | }\n   \
    \ |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdu5x5fzy.rs:15:57\n \
    \  |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |    -----------                                          ^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = vec![];\n    for el1 in lst1 {\n        for el2 in lst2 {\n            if\
    \ el1.len() < el2.len() {\n                total_chars.push(el1);\n          \
    \      break;\n            }\n        }\n    }\n    total_chars\n}\n\nfn main()\
    \ {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpp11fnkle.rs:21:20\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n21  |  \
    \       for el2 in lst2 {\n    |                    ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n21  |         for el2 in &lst2 {\n    |        \
    \            +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_len\
    \ = 0;\n    for v in lst1 {\n        total_len += v.len();\n    }\n    let mut\
    \ total_len2 = total_len;\n    for v in lst2 {\n        total_len2 += v.len();\n\
    \    }\n    if total_len2 > total_len {\n        return lst1;\n    }\n    return\
    \ lst2;\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst1`\n   --> /tmp/tmp0yvqaz9l.rs:28:16\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n20  |     for v in lst1 {\n\
    \    |              ----\n    |              |\n    |              `lst1` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&lst1`\n...\n28  |         return\
    \ lst1;\n    |                ^^^^ value used here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `lst1`\n\nerror[E0382]:\
    \ use of moved value: `lst2`\n  --> /tmp/tmp0yvqaz9l.rs:30:12\n   |\n15 | fn total_match(lst1:\
    \ Vec<String>, lst2: Vec<String>) -> Vec<String> {\n   |                     \
    \              ---- move occurs because `lst2` has type `Vec<String>`, which does\
    \ not implement the `Copy` trait\n...\n24 |     for v in lst2 {\n   |        \
    \      ----\n   |              |\n   |              `lst2` moved due to this implicit\
    \ call to `.into_iter()`\n   |              help: consider borrowing to avoid\
    \ moving into the for loop: `&lst2`\n...\n30 |     return lst2;\n   |        \
    \    ^^^^ value used here after move\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748969
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_len\
    \ = 0;\n    for s in lst1 {\n        total_len += s.len();\n    }\n    let mut\
    \ total_len2 = 0;\n    for s in lst2 {\n        total_len2 += s.len();\n    }\n\
    \    if total_len == total_len2 {\n        return lst1;\n    }\n    let mut total_len3\
    \ = 0;\n    for s in lst2 {\n        total_len3 += s.len();\n    }\n    if total_len3\
    \ > total_len {\n        return lst1;\n    }\n    let mut total_len4 = 0;\n  \
    \  for s in lst1 {\n        total_len4 += s.len();\n    }\n    if total_len4 >\
    \ total_len3 {\n        return lst1;\n    }\n    let mut total_len5 = 0;\n   \
    \ for s in lst1 {\n        total_len5 += s.len();\n    }\n    if total_len5 >\
    \ total_len4 {\n        return lst1;\n    }\n    let mut total_len6 = 0;\n   \
    \ for s in lst2 {\n        total_len6 += s.len();\n    }\n    if total_len6 >\
    \ total_len5 {\n        return lst1;\n    }\n    let mut total_len7 = 0;\n   \
    \ for s in lst2 {\n        total_len7 += s.len();\n    }\n    if total_len7 >\
    \ total_len6 {\n        return lst1;\n    }\n    let mut total_len8 = 0;\n   \
    \ for s in lst2 {\n        total_len8 += s.len();\n    }\n    if total_len8 >\
    \ total_len7 {\n        return lst1;\n    }\n    let mut total_len9 = 0;\n   \
    \ for s in lst2 {\n        total_len9 += s.len();\n    }\n    if total_len9 >\
    \ total_len8 {\n        return lst1;\n    }\n    let mut total_len10 = 0;\n  \
    \  for s in lst2 {\n        total_len10 += s.len();\n    }\n    if total_len10\
    \ > total_len9 {\n        return lst1;\n    }\n    let mut total_len11 = 0;\n\
    \    for s in lst2 {\n        total_len11 += s.len();\n    }\n    if total_len11\
    \ > total_len10 {\n        return lst1;\n    }\n    let mut total_len12 = 0;\n\
    \    for s in lst2 {\n        total_len12 += s.len();\n    }\n    if total_len12\
    \ > total_len11 {\n        return lst1;\n    }\n    let mut total_len13 = 0;\n\
    \    for s in lst2 {\n        total_len13 += s.len();\n    }\n    if total_len13\
    \ > total_len12 {\n        return lst1;\n    }\n    let mut total_len14 = 0;\n\
    \    for s in lst2 {\n        total_len14\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp0n7rb443.rs:123:3\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                                                   \
    \  - unclosed delimiter\n...\n108 |     for s in lst2 {\n    |               \
    \    - this delimiter might not be properly closed...\n109 |         total_len14\n\
    110 | }\n    | - ...as it matches this but it has different indentation\n...\n\
    123 | }\n    |   ^\n\nerror[E0308]: mismatched types\n   --> /tmp/tmp0n7rb443.rs:109:9\n\
    \    |\n109 |         total_len14\n    |         ^^^^^^^^^^^ expected `()`, found\
    \ integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0n7rb443.rs:15:57\n\
    \   |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |    -----------                                          ^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_match:\
    \ Vec<String> = vec![];\n    for i in 0..lst1.len() {\n        if lst1[i] < lst2[i]\
    \ {\n            total_match.push(lst1[i]);\n        }\n    }\n    total_match\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmp9jcy4wi6.rs:22:30\n\
    \   |\n22 |             total_match.push(lst1[i]);\n   |                     \
    \         ^^^^^^^ move occurs because value has type `String`, which does not\
    \ implement the `Copy` trait\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n    }\n\
    \    lst1.iter().filter(|s| s.len() <= total_chars).collect()\n}\n\nfn main()\
    \ {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&String`\n  --> /tmp/tmpztun2k46.rs:23:52\n   |\n23 |\
    \     lst1.iter().filter(|s| s.len() <= total_chars).collect()\n   |         \
    \                                           ^^^^^^^ value of type `Vec<String>`\
    \ cannot be built from `std::iter::Iterator<Item=&String>`\n   |\n   = help: the\
    \ trait `FromIterator<&String>` is not implemented for `Vec<String>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n    }\n\
    \    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let mut\
    \ total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n\n}\n\nfn main() {\n   \
    \ let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpdu5x5fzy.rs:119:3\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                                                   \
    \  - unclosed delimiter\n...\n104 |     for v in lst2 {\n    |               \
    \    - this delimiter might not be properly closed...\n105 | \n106 | }\n    |\
    \ - ...as it matches this but it has different indentation\n...\n119 | }\n   \
    \ |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdu5x5fzy.rs:15:57\n \
    \  |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |    -----------                                          ^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut total_len = 0;\n    for s in lst1 {\n        total_len += s.len();\n\
    \    }\n    for s in lst2 {\n        total_len += s.len();\n    }\n    if total_len\
    \ == lst1.len() {\n        return lst1;\n    }\n    if total_len == lst2.len()\
    \ {\n        return lst2;\n    }\n    let mut total_len = total_len;\n    let\
    \ mut i = 0;\n    while total_len > lst1.len() {\n        total_len -= lst1.len()\
    \ - i;\n        i += 1;\n    }\n    while total_len > lst2.len() {\n        total_len\
    \ -= lst2.len() - i;\n        i += 1;\n    }\n    lst1.split_off(i).unwrap()\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for struct `Vec<String>` in\
    \ the current scope\n  --> /tmp/tmp7gar3lz3.rs:39:23\n   |\n39 |     lst1.split_off(i).unwrap()\n\
    \   |                       ^^^^^^ method not found in `Vec<String>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n    }\n\
    \    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let mut\
    \ total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n\n}\n\nfn main() {\n   \
    \ let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpdu5x5fzy.rs:119:3\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                                                   \
    \  - unclosed delimiter\n...\n104 |     for v in lst2 {\n    |               \
    \    - this delimiter might not be properly closed...\n105 | \n106 | }\n    |\
    \ - ...as it matches this but it has different indentation\n...\n119 | }\n   \
    \ |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdu5x5fzy.rs:15:57\n \
    \  |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |    -----------                                          ^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut res\
    \ = vec![];\n    for el1 in lst1 {\n        for el2 in lst2 {\n            if\
    \ el1.len() < el2.len() {\n                res.push(el1);\n                break;\n\
    \            }\n        }\n    }\n    return res;\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmplqc2ctyy.rs:21:20\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n21  |  \
    \       for el2 in lst2 {\n    |                    ^^^^\n    |              \
    \      |\n    |                    `lst2` moved due to this implicit call to `.into_iter()`,\
    \ in previous iteration of loop\n    |                    help: consider borrowing\
    \ to avoid moving into the for loop: `&lst2`\n    |\nnote: this function takes\
    \ ownership of the receiver `self`, which moves `lst2`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = vec![];\n    for s in lst1 {\n        for c in s.chars() {\n            total_chars.push(c);\n\
    \        }\n    }\n    for s in lst2 {\n        for c in s.chars() {\n       \
    \     total_chars.push(c);\n        }\n    }\n    total_chars.sort();\n    total_chars.dedup();\n\
    \    total_chars\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz8r0qtr8.rs:32:5\n   |\n\
    15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n \
    \  |                                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n32 |     total_chars\n   |     ^^^^^^^^^^^\
    \ expected struct `String`, found `char`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<char>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_len\
    \ = 0;\n    for x in lst1 {\n        total_len += x.len();\n    }\n    for x in\
    \ lst2 {\n        total_len += x.len();\n    }\n    if total_len == lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_len == lst2.len() {\n        return\
    \ lst2;\n    }\n    let mut total_len = 0;\n    for x in lst1 {\n        total_len\
    \ += x.len();\n    }\n    for x in lst2 {\n        total_len += x.len();\n   \
    \ }\n    if total_len == lst1.len() {\n        return lst1;\n    }\n    if total_len\
    \ == lst2.len() {\n        return lst2;\n    }\n    let mut total_len = 0;\n \
    \   for x in lst1 {\n        total_len += x.len();\n    }\n    for x in lst2 {\n\
    \        total_len += x.len();\n    }\n    if total_len == lst1.len() {\n    \
    \    return lst1;\n    }\n    if total_len == lst2.len() {\n        return lst2;\n\
    \    }\n    let mut total_len = 0;\n    for x in lst1 {\n        total_len +=\
    \ x.len();\n    }\n    for x in lst2 {\n        total_len += x.len();\n    }\n\
    \    if total_len == lst1.len() {\n        return lst1;\n    }\n    if total_len\
    \ == lst2.len() {\n        return lst2;\n    }\n    let mut total_len = 0;\n \
    \   for x in lst1 {\n        total_len += x.len();\n    }\n    for x in lst2 {\n\
    \        total_len += x.len();\n    }\n    if total_len == lst1.len() {\n    \
    \    return lst1;\n    }\n    if total_len == lst2.len() {\n        return lst2;\n\
    \    }\n    let mut total_len = 0;\n    for x in lst1 {\n        total_len +=\
    \ x.len();\n    }\n    for x in lst2 {\n        total_len += x.len();\n    }\n\
    \    if total_len == lst1.len() {\n        return lst1;\n    }\n    if total_len\
    \ == lst2.len() {\n        return lst2;\n    }\n    let mut total_len = 0;\n \
    \   for x in lst1 {\n        total_len += x.len();\n    }\n    for x in lst2 {\n\
    \        total_len += x.len();\n    }\n    if total_len == lst1.len() {\n    \
    \    return lst1;\n    }\n    if total_len == lst2.len() {\n        return lst2;\n\
    \    }\n    let mut total_len = 0;\n    for x in lst1 {\n        total_len +=\
    \ x.len();\n    }\n    for x in lst2 {\n        total_len += x.len();\n    }\n\
    \    if total_len == lst1.\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n   --> /tmp/tmpp3170m2v.rs:118:1\n    |\n\
    118 | }\n    | ^\n\nerror: expected `{`, found `}`\n   --> /tmp/tmpp3170m2v.rs:118:1\n\
    \    |\n117 |     if total_len == lst1.\n    |     -- this `if` expression has\
    \ a condition, but no block\n118 | }\n    | ^ expected `{`\n\nerror: aborting\
    \ due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659748969
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n    }\n\
    \    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let mut\
    \ total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n\n}\n\nfn main() {\n   \
    \ let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpk2jkmrwk.rs:119:3\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                                                   \
    \  - unclosed delimiter\n...\n104 |     for s in lst2 {\n    |               \
    \    - this delimiter might not be properly closed...\n105 | \n106 | }\n    |\
    \ - ...as it matches this but it has different indentation\n...\n119 | }\n   \
    \ |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk2jkmrwk.rs:15:57\n \
    \  |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |    -----------                                          ^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_len\
    \ = 0;\n    for el1 in lst1 {\n        for el2 in lst2 {\n            if el1.len()\
    \ < el2.len() {\n                total_len += el1.len();\n            }\n    \
    \    }\n    }\n    lst1.iter().filter(|&el| el1.len() < total_len).collect()\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `el1` in this scope\n  --> /tmp/tmp2r9l3vku.rs:27:30\n\
    \   |\n27 |     lst1.iter().filter(|&el| el1.len() < total_len).collect()\n  \
    \ |                              ^^^ help: a local variable with a similar name\
    \ exists: `el`\n\nerror[E0277]: a value of type `Vec<String>` cannot be built\
    \ from an iterator over elements of type `&String`\n  --> /tmp/tmp2r9l3vku.rs:27:53\n\
    \   |\n27 |     lst1.iter().filter(|&el| el1.len() < total_len).collect()\n  \
    \ |                                                     ^^^^^^^ value of type\
    \ `Vec<String>` cannot be built from `std::iter::Iterator<Item=&String>`\n   |\n\
    \   = help: the trait `FromIterator<&String>` is not implemented for `Vec<String>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_len\
    \ = 0;\n    for el1 in lst1 {\n        for el2 in lst2 {\n            if el1.len()\
    \ < el2.len() {\n                total_len += el1.len();\n            }\n    \
    \    }\n    }\n    total_len\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp45iika8c.rs:27:5\n   |\n\
    15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n \
    \  |                                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n27 |     total_len\n   |     ^^^^^^^^^\
    \ expected struct `Vec`, found `usize`\n   |\n   = note: expected struct `Vec<String>`\n\
    \                found type `usize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = vec![0; lst1.len()];\n    for x in lst1 {\n        for y in lst2 {\n     \
    \       if x.len() < y.len() {\n                total_chars[x.len()] += 1;\n \
    \           }\n        }\n    }\n    total_chars\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjxbpvttp.rs:27:5\n   |\n\
    15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n \
    \  |                                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n27 |     total_chars\n   |     ^^^^^^^^^^^\
    \ expected struct `String`, found integer\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<{integer}>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_len\
    \ = 0;\n    for s in lst1 {\n        total_len += s.len();\n    }\n    for s in\
    \ lst2 {\n        total_len += s.len();\n    }\n    if total_len == lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_len == lst2.len() {\n        return\
    \ lst2;\n    }\n    let mut total_len = 0;\n    for s in lst1 {\n        total_len\
    \ += s.len();\n    }\n    for s in lst2 {\n        total_len += s.len();\n   \
    \ }\n    if total_len < lst1.len() {\n        return lst1;\n    }\n    if total_len\
    \ < lst2.len() {\n        return lst2;\n    }\n    let mut total_len = 0;\n  \
    \  for s in lst1 {\n        total_len += s.len();\n    }\n    for s in lst2 {\n\
    \        total_len += s.len();\n    }\n    if total_len == lst1.len() {\n    \
    \    return lst1;\n    }\n    if total_len == lst2.len() {\n        return lst2;\n\
    \    }\n    let mut total_len = 0;\n    for s in lst1 {\n        total_len +=\
    \ s.len();\n    }\n    for s in lst2 {\n        total_len += s.len();\n    }\n\
    \    if total_len > lst1.len() {\n        return lst1;\n    }\n    if total_len\
    \ > lst2.len() {\n        return lst2;\n    }\n    vec![String::from(\"hi\"),\
    \ String::from(\"admin\")]\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `lst1`\n   --> /tmp/tmpg_s3aqep.rs:26:21\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n20  |     for s in lst1 {\n\
    \    |              ----\n    |              |\n    |              `lst1` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&lst1`\n...\n26  |     if total_len\
    \ == lst1.len() {\n    |                     ^^^^ value borrowed here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `lst1`\n\nerror[E0382]: borrow of moved value: `lst2`\n  --> /tmp/tmpg_s3aqep.rs:29:21\n\
    \   |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n23 |   \
    \  for s in lst2 {\n   |              ----\n   |              |\n   |        \
    \      `lst2` moved due to this implicit call to `.into_iter()`\n   |        \
    \      help: consider borrowing to avoid moving into the for loop: `&lst2`\n...\n\
    29 |     if total_len == lst2.len() {\n   |                     ^^^^ value borrowed\
    \ here after move\n\nerror[E0382]: borrow of moved value: `lst1`\n  --> /tmp/tmpg_s3aqep.rs:39:20\n\
    \   |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n33 |     for s in lst1 {\n \
    \  |              ----\n   |              |\n   |              `lst1` moved due\
    \ to this implicit call to `.into_iter()`\n   |              help: consider borrowing\
    \ to avoid moving into the for loop: `&lst1`\n...\n39 |     if total_len < lst1.len()\
    \ {\n   |                    ^^^^ value borrowed here after move\n\nerror[E0382]:\
    \ borrow of moved value: `lst2`\n  --> /tmp/tmpg_s3aqep.rs:42:20\n   |\n15 | fn\
    \ total_match(l"
  stdout: ''
  timestamp: 1659748970
- exit_code: 101
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut res = vec![];\n    for s in lst1 {\n        if lst2.iter().any(|s|\
    \ s.len() < s.len()) {\n            res.push(s);\n        }\n    }\n    if res.len()\
    \ == 0 {\n        res\n    } else {\n        res\n    }\n}\n\nfn main() {\n  \
    \  let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmp9cd7x5b5.rs:32:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = vec![];\n    for elem in lst1 {\n        let mut total_chars_elem = vec![];\n\
    \        for elem2 in lst2 {\n            if elem.len() < elem2.len() {\n    \
    \            total_chars_elem.push(elem);\n            }\n        }\n        total_chars.extend(total_chars_elem);\n\
    \    }\n    total_chars\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpj2taseyl.rs:22:22\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n22  |  \
    \       for elem2 in lst2 {\n    |                      ^^^^\n    |          \
    \            |\n    |                      `lst2` moved due to this implicit call\
    \ to `.into_iter()`, in previous iteration of loop\n    |                    \
    \  help: consider borrowing to avoid moving into the for loop: `&lst2`\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `lst2`\n\
    \nerror[E0382]: borrow of moved value: `elem`\n  --> /tmp/tmpj2taseyl.rs:23:16\n\
    \   |\n20 |     for elem in lst1 {\n   |         ----    ---- this reinitialization\
    \ might get skipped\n   |         |\n   |         move occurs because `elem` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n23 |        \
    \     if elem.len() < elem2.len() {\n   |                ^^^^ value borrowed here\
    \ after move\n24 |                 total_chars_elem.push(elem);\n   |        \
    \                               ---- value moved here, in previous iteration of\
    \ loop\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n    }\n\
    \    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let mut\
    \ total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n\n}\n\nfn main() {\n   \
    \ let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpdu5x5fzy.rs:119:3\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                                                   \
    \  - unclosed delimiter\n...\n104 |     for v in lst2 {\n    |               \
    \    - this delimiter might not be properly closed...\n105 | \n106 | }\n    |\
    \ - ...as it matches this but it has different indentation\n...\n119 | }\n   \
    \ |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdu5x5fzy.rs:15:57\n \
    \  |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |    -----------                                          ^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for s in lst2 {\n        if total_chars > s.len() {\n   \
    \         total_chars = s.len();\n        }\n    }\n    lst1\n}\n\nfn main() {\n\
    \    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmpyhu0xng1.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for v in lst2 {\n        if v.len() > total_chars {\n   \
    \         total_chars = v.len();\n        }\n    }\n    lst1.iter().filter(|&x|\
    \ x.len() <= total_chars).collect()\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&String`\n  --> /tmp/tmpmhs2p51b.rs:25:53\n   |\n25 |\
    \     lst1.iter().filter(|&x| x.len() <= total_chars).collect()\n   |        \
    \                                             ^^^^^^^ value of type `Vec<String>`\
    \ cannot be built from `std::iter::Iterator<Item=&String>`\n   |\n   = help: the\
    \ trait `FromIterator<&String>` is not implemented for `Vec<String>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = vec![];\n    for s in lst1 {\n        for s2 in lst2 {\n            if s.len()\
    \ < s2.len() {\n                break;\n            }\n            total_chars.push(s);\n\
    \        }\n    }\n    total_chars\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmp6y7zlwm5.rs:21:19\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n21  |  \
    \       for s2 in lst2 {\n    |                   ^^^^\n    |                \
    \   |\n    |                   `lst2` moved due to this implicit call to `.into_iter()`,\
    \ in previous iteration of loop\n    |                   help: consider borrowing\
    \ to avoid moving into the for loop: `&lst2`\n    |\nnote: this function takes\
    \ ownership of the receiver `self`, which moves `lst2`\n\nerror[E0382]: borrow\
    \ of moved value: `s`\n  --> /tmp/tmp6y7zlwm5.rs:22:16\n   |\n20 |     for s in\
    \ lst1 {\n   |         -    ---- this reinitialization might get skipped\n   |\
    \         |\n   |         move occurs because `s` has type `String`, which does\
    \ not implement the `Copy` trait\n21 |         for s2 in lst2 {\n22 |        \
    \     if s.len() < s2.len() {\n   |                ^ value borrowed here after\
    \ move\n...\n25 |             total_chars.push(s);\n   |                     \
    \         - value moved here, in previous iteration of loop\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for v in lst2 {\n        if v > total_chars {\n         \
    \   total_chars = v;\n        }\n    }\n    lst1.iter().filter(|&x| x < total_chars).collect()\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgdkxobfi.rs:21:16\n   |\n\
    21 |         if v > total_chars {\n   |                ^^^^^^^^^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                |\n   |     \
    \           expected struct `String`, found `usize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpgdkxobfi.rs:22:27\n   |\n22 |             total_chars =\
    \ v;\n   |                           ^ expected `usize`, found struct `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgdkxobfi.rs:25:33\n   |\n25 |\
    \     lst1.iter().filter(|&x| x < total_chars).collect()\n   |               \
    \                  ^^^^^^^^^^^ expected `&String`, found `usize`\n\nerror[E0277]:\
    \ a value of type `Vec<String>` cannot be built from an iterator over elements\
    \ of type `&String`\n  --> /tmp/tmpgdkxobfi.rs:25:46\n   |\n25 |     lst1.iter().filter(|&x|\
    \ x < total_chars).collect()\n   |                                           \
    \   ^^^^^^^ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&String>`\n\
    \   |\n   = help: the trait `FromIterator<&String>` is not implemented for `Vec<String>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_len\
    \ = 0;\n    for el1 in lst1 {\n        for el2 in lst2 {\n            if el1.len()\
    \ < el2.len() {\n                total_len += el1.len();\n            }\n    \
    \    }\n    }\n    return lst1.iter().take(total_len).collect();\n}\n\nfn main()\
    \ {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&String`\n  --> /tmp/tmp1wbj_e98.rs:27:40\n   |\n27 |\
    \     return lst1.iter().take(total_len).collect();\n   |                    \
    \                    ^^^^^^^ value of type `Vec<String>` cannot be built from\
    \ `std::iter::Iterator<Item=&String>`\n   |\n   = help: the trait `FromIterator<&String>`\
    \ is not implemented for `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_match:\
    \ Vec<String> = vec![];\n    for el1 in lst1 {\n        for el2 in lst2 {\n  \
    \          if el1.len() < el2.len() {\n                total_match.push(el1);\n\
    \                break;\n            }\n        }\n    }\n    total_match\n}\n\
    \nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmput5zrwfx.rs:21:20\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n21  |  \
    \       for el2 in lst2 {\n    |                    ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n21  |         for el2 in &lst2 {\n    |        \
    \            +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut res\
    \ = vec![];\n    for v in lst1 {\n        if lst2.iter().any(|s| v == s) {\n \
    \           res.push(v);\n        }\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmphbqxds1y.rs:21:34\n\
    \   |\n21 |         if lst2.iter().any(|s| v == s) {\n   |                   \
    \               ^^ no implementation for `String == &String`\n   |\n   = help:\
    \ the trait `PartialEq<&String>` is not implemented for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 101
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    if lst1.len()\
    \ < lst2.len() {\n        let mut result = vec![];\n        for element in lst1\
    \ {\n            if lst2.iter().any(|element2| element2.contains(&element)) {\n\
    \                result.push(element);\n            }\n        }\n        return\
    \ result;\n    }\n    let mut result = vec![];\n    for element in lst2 {\n  \
    \      if lst1.iter().any(|element2| element2.contains(&element)) {\n        \
    \    result.push(element);\n        }\n    }\n    return result;\n}\n\nfn main()\
    \ {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmpd_whxdmr.rs:40:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_len\
    \ = 0;\n    for s in lst1 {\n        total_len += s.len();\n    }\n    for s in\
    \ lst2 {\n        total_len += s.len();\n    }\n    if total_len == lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_len == lst2.len() {\n        return\
    \ lst2;\n    }\n    let mut total_len = 0;\n    for s in lst1 {\n        total_len\
    \ += s.len();\n    }\n    for s in lst2 {\n        total_len += s.len();\n   \
    \ }\n    if total_len == lst1.len() {\n        return lst1;\n    }\n    if total_len\
    \ == lst2.len() {\n        return lst2;\n    }\n    let mut total_len = 0;\n \
    \   for s in lst1 {\n        total_len += s.len();\n    }\n    for s in lst2 {\n\
    \        total_len += s.len();\n    }\n    if total_len == lst1.len() {\n    \
    \    return lst1;\n    }\n    if total_len == lst2.len() {\n        return lst2;\n\
    \    }\n    let mut total_len = 0;\n    for s in lst1 {\n        total_len +=\
    \ s.len();\n    }\n    for s in lst2 {\n        total_len += s.len();\n    }\n\
    \    if total_len == lst1.len() {\n        return lst1;\n    }\n    if total_len\
    \ == lst2.len() {\n        return lst2;\n    }\n    let mut total_len = 0;\n \
    \   for s in lst1 {\n        total_len += s.len();\n    }\n    for s in lst2 {\n\
    \        total_len += s.len();\n    }\n    if total_len == lst1.len() {\n    \
    \    return lst1;\n    }\n    if total_len == lst2.len() {\n        return lst2;\n\
    \    }\n    let mut total_len = 0;\n    for s in lst1 {\n        total_len +=\
    \ s.len();\n    }\n    for s in lst2 {\n        total_len += s.len();\n    }\n\
    \    if total_len == lst1.len() {\n        return lst1;\n    }\n    if total_len\
    \ == lst2.len() {\n        return lst2;\n    }\n    let mut total_len = 0;\n \
    \   for s in lst1 {\n        total_len += s.len();\n    }\n    for s in lst2 {\n\
    \        total_len += s.len();\n    }\n    if total_len == lst1.len() {\n    \
    \    return lst1;\n    }\n    if total_len == lst2.len() {\n        return lst2;\n\
    \    }\n    let mut total_len = 0;\n    for s in lst1 {\n        total_len +=\
    \ s.len();\n    }\n    for s in lst2 {\n        total_len += s.len();\n    }\n\
    \    if total_len == lst1.\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n   --> /tmp/tmpxi0yygmb.rs:118:1\n    |\n\
    118 | }\n    | ^\n\nerror: expected `{`, found `}`\n   --> /tmp/tmpxi0yygmb.rs:118:1\n\
    \    |\n117 |     if total_len == lst1.\n    |     -- this `if` expression has\
    \ a condition, but no block\n118 | }\n    | ^ expected `{`\n\nerror: aborting\
    \ due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_match:\
    \ Vec<String> = vec![];\n    for el1 in lst1 {\n        for el2 in lst2 {\n  \
    \          if el1.len() < el2.len() {\n                total_match.push(el1);\n\
    \                break;\n            }\n        }\n    }\n    total_match\n}\n\
    \nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmput5zrwfx.rs:21:20\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n21  |  \
    \       for el2 in lst2 {\n    |                    ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n21  |         for el2 in &lst2 {\n    |        \
    \            +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for elem in lst2 {\n        if elem.len() > total_chars {\n\
    \            total_chars = elem.len();\n        }\n    }\n    lst1.iter().filter(|x|\
    \ x.len() < total_chars).collect()\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&String`\n  --> /tmp/tmp4sxdrhvk.rs:25:51\n   |\n25 |\
    \     lst1.iter().filter(|x| x.len() < total_chars).collect()\n   |          \
    \                                         ^^^^^^^ value of type `Vec<String>`\
    \ cannot be built from `std::iter::Iterator<Item=&String>`\n   |\n   = help: the\
    \ trait `FromIterator<&String>` is not implemented for `Vec<String>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut total_match: Vec<String> = vec![];\n    for el1 in lst1 {\n     \
    \   for el2 in lst2 {\n            if el1.len() < el2.len() {\n              \
    \  total_match.push(el1);\n                break;\n            }\n        }\n\
    \    }\n    total_match\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpp_sfjfr0.rs:18:20\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n18  |  \
    \       for el2 in lst2 {\n    |                    ^^^^\n    |              \
    \      |\n    |                    `lst2` moved due to this implicit call to `.into_iter()`,\
    \ in previous iteration of loop\n    |                    help: consider borrowing\
    \ to avoid moving into the for loop: `&lst2`\n    |\nnote: this function takes\
    \ ownership of the receiver `self`, which moves `lst2`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_len\
    \ = 0;\n    for v in lst1 {\n        total_len += v.chars().filter(|c| c < 'a').count()\
    \ + 1;\n    }\n    for v in lst2 {\n        total_len += v.chars().filter(|c|\
    \ c < 'a').count() + 1;\n    }\n    if total_len == lst1.len() {\n        return\
    \ lst1;\n    }\n    if total_len == lst2.len() {\n        return lst2;\n    }\n\
    \    let mut total_len = 0;\n    for v in lst1 {\n        total_len += v.chars().filter(|c|\
    \ c < 'a').count() + 1;\n    }\n    for v in lst2 {\n        total_len += v.chars().filter(|c|\
    \ c < 'a').count() + 1;\n    }\n    if total_len == lst1.len() {\n        return\
    \ lst1;\n    }\n    if total_len == lst2.len() {\n        return lst2;\n    }\n\
    \    let mut total_len = 0;\n    for v in lst1 {\n        total_len += v.chars().filter(|c|\
    \ c < 'a').count() + 1;\n    }\n    for v in lst2 {\n        total_len += v.chars().filter(|c|\
    \ c < 'a').count() + 1;\n    }\n    if total_len == lst1.len() {\n        return\
    \ lst1;\n    }\n    if total_len == lst2.len() {\n        return lst2;\n    }\n\
    \    let mut total_len = 0;\n    for v in lst1 {\n        total_len += v.chars().filter(|c|\
    \ c < 'a').count() + 1;\n    }\n    for v in lst2 {\n        total_len += v.chars().filter(|c|\
    \ c < 'a').count() + 1;\n    }\n    if total_len == lst1.len() {\n        return\
    \ lst1;\n    }\n    if total_len == lst2.len() {\n        return lst2;\n    }\n\
    \    let mut total_len = 0;\n    for v in lst1 {\n        total_len += v.chars().filter(|c|\
    \ c < 'a').count() + 1;\n    }\n    for v in lst2 {\n        total_len += v.chars().filter(|c|\
    \ c < 'a').count() + 1;\n    }\n    if total_len == lst1.len() {\n        return\
    \ lst1;\n    }\n    if total_len == lst2.len() {\n        return lst2;\n    }\n\
    \    let mut total_len = 0;\n    for v in lst1 {\n        total_len += v.chars().filter(|c|\
    \ c < 'a').count() + 1;\n    }\n    for v in lst2 {\n        total_len += v.chars().filter(|c|\
    \ c < '\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpz54wbo0s.rs:89:47\n\
    \   |\n89 |         total_len += v.chars().filter(|c| c < '\n   |            \
    \                                   ^\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0762`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_match:\
    \ Vec<String> = vec![];\n    for i in 0..lst1.len() {\n        if lst1[i] < lst2[i]\
    \ {\n            total_match.push(lst1[i]);\n        }\n    }\n    total_match\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmp9jcy4wi6.rs:22:30\n\
    \   |\n22 |             total_match.push(lst1[i]);\n   |                     \
    \         ^^^^^^^ move occurs because value has type `String`, which does not\
    \ implement the `Copy` trait\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = vec![];\n    for s in lst1 {\n        let mut total_chars_in_s = vec![];\n\
    \        for c in s {\n            total_chars_in_s.push(total_chars.iter().filter(|&x|\
    \ x == c).count());\n        }\n        total_chars = total_chars_in_s;\n    }\n\
    \    for s in lst2 {\n        let mut total_chars_in_s = vec![];\n        for\
    \ c in s {\n            total_chars_in_s.push(total_chars.iter().filter(|&x| x\
    \ == c).count());\n        }\n        total_chars = total_chars_in_s;\n    }\n\
    \    total_chars\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n   --> /tmp/tmppprl3kar.rs:22:18\n\
    \    |\n22  |         for c in s {\n    |                  ^ `String` is not an\
    \ iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help: the trait\
    \ `Iterator` is not implemented for `String`\n    = note: required because of\
    \ the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror[E0277]: `String` is not an iterator\n   --> /tmp/tmppprl3kar.rs:29:18\n\
    \    |\n29  |         for c in s {\n    |                  ^ `String` is not an\
    \ iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help: the trait\
    \ `Iterator` is not implemented for `String`\n    = note: required because of\
    \ the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppprl3kar.rs:34:5\n\
    \   |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |                                                         -----------\
    \ expected `Vec<String>` because of return type\n...\n34 |     total_chars\n \
    \  |     ^^^^^^^^^^^ expected struct `String`, found `usize`\n   |\n   = note:\
    \ expected struct `Vec<String>`\n              found struct `Vec<usize>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 101
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for x in lst2 {\n        total_chars += x.len();\n    }\n\
    \    if total_chars < lst1.len() {\n        return lst1;\n    }\n    lst1\n}\n\
    \nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmpchidvg0u.rs:32:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748971
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = vec![];\n    for x in lst1 {\n        for y in lst2 {\n            if x.len()\
    \ < y.len() {\n                total_chars.push(y);\n                break;\n\
    \            }\n        }\n    }\n    total_chars\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpayyltm_r.rs:21:18\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n21  |  \
    \       for y in lst2 {\n    |                  ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n21  |         for y in &lst2 {\n    |          \
    \        +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_len\
    \ = 0;\n    for s in lst1 {\n        total_len += s.len();\n    }\n    let mut\
    \ total_len2 = total_len;\n    for s in lst2 {\n        total_len2 += s.len();\n\
    \    }\n    if total_len == total_len2 {\n        return lst1;\n    }\n    if\
    \ total_len2 < total_len {\n        return lst2;\n    }\n    lst1\n}\n\nfn main()\
    \ {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst1`\n   --> /tmp/tmpk9v3evy4.rs:28:16\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n20  |     for s in lst1 {\n\
    \    |              ----\n    |              |\n    |              `lst1` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&lst1`\n...\n28  |         return\
    \ lst1;\n    |                ^^^^ value used here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `lst1`\n\nerror[E0382]:\
    \ use of moved value: `lst2`\n  --> /tmp/tmpk9v3evy4.rs:31:16\n   |\n15 | fn total_match(lst1:\
    \ Vec<String>, lst2: Vec<String>) -> Vec<String> {\n   |                     \
    \              ---- move occurs because `lst2` has type `Vec<String>`, which does\
    \ not implement the `Copy` trait\n...\n24 |     for s in lst2 {\n   |        \
    \      ----\n   |              |\n   |              `lst2` moved due to this implicit\
    \ call to `.into_iter()`\n   |              help: consider borrowing to avoid\
    \ moving into the for loop: `&lst2`\n...\n31 |         return lst2;\n   |    \
    \            ^^^^ value used here after move\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_len\
    \ = 0;\n    for el1 in lst1 {\n        for el2 in lst2 {\n            if el1.len()\
    \ < el2.len() {\n                total_len += el1.len();\n            }\n    \
    \    }\n    }\n    total_len += lst2.len();\n    lst1.iter().filter(|el| el !=\
    \ \"\").take(total_len).collect()\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&String` with `str`\n  --> /tmp/tmpa439n1fz.rs:28:32\n\
    \   |\n28 |     lst1.iter().filter(|el| el != \"\").take(total_len).collect()\n\
    \   |                                ^^ no implementation for `&String == str`\n\
    \   |\n   = help: the trait `PartialEq<str>` is not implemented for `&String`\n\
    \   = note: required because of the requirements on the impl of `PartialEq<&str>`\
    \ for `&&String`\n\nerror[E0277]: a value of type `Vec<String>` cannot be built\
    \ from an iterator over elements of type `&String`\n  --> /tmp/tmpa439n1fz.rs:28:55\n\
    \   |\n28 |     lst1.iter().filter(|el| el != \"\").take(total_len).collect()\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<String>` cannot be built from `std::iter::Iterator<Item=&String>`\n   |\n\
    \   = help: the trait `FromIterator<&String>` is not implemented for `Vec<String>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_len\
    \ = 0;\n    for el1 in lst1 {\n        for el2 in lst2 {\n            if el1.len()\
    \ < el2.len() {\n                total_len += el1.len();\n            }\n    \
    \    }\n    }\n    total_len += lst2.len();\n    lst1.iter().filter(|el| el1.len()\
    \ < total_len).collect()\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `el1` in this scope\n  --> /tmp/tmp6_utdr30.rs:28:29\n\
    \   |\n28 |     lst1.iter().filter(|el| el1.len() < total_len).collect()\n   |\
    \                             ^^^ help: a local variable with a similar name exists:\
    \ `el`\n\nerror[E0277]: a value of type `Vec<String>` cannot be built from an\
    \ iterator over elements of type `&String`\n  --> /tmp/tmp6_utdr30.rs:28:52\n\
    \   |\n28 |     lst1.iter().filter(|el| el1.len() < total_len).collect()\n   |\
    \                                                    ^^^^^^^ value of type `Vec<String>`\
    \ cannot be built from `std::iter::Iterator<Item=&String>`\n   |\n   = help: the\
    \ trait `FromIterator<&String>` is not implemented for `Vec<String>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = vec![];\n    for s in lst1 {\n        for c in s.chars() {\n            total_chars.push(c);\n\
    \        }\n    }\n    for s in lst2 {\n        for c in s.chars() {\n       \
    \     total_chars.push(c);\n        }\n    }\n    total_chars.sort_unstable();\n\
    \    total_chars.dedup();\n    total_chars\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4l79ctkb.rs:32:5\n   |\n\
    15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n \
    \  |                                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n32 |     total_chars\n   |     ^^^^^^^^^^^\
    \ expected struct `String`, found `char`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<char>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut total_match: Vec<String> = vec![];\n    for el1 in lst1 {\n     \
    \   for el2 in lst2 {\n            if el1.len() < el2.len() {\n              \
    \  total_match.push(el1);\n                break;\n            }\n        }\n\
    \    }\n    if total_match.len() == lst1.len() {\n        total_match\n    } else\
    \ {\n        total_match\n    }\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmp4dtuxj5b.rs:18:20\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n18  |  \
    \       for el2 in lst2 {\n    |                    ^^^^\n    |              \
    \      |\n    |                    `lst2` moved due to this implicit call to `.into_iter()`,\
    \ in previous iteration of loop\n    |                    help: consider borrowing\
    \ to avoid moving into the for loop: `&lst2`\n    |\nnote: this function takes\
    \ ownership of the receiver `self`, which moves `lst2`\n\nerror[E0382]: borrow\
    \ of moved value: `lst1`\n  --> /tmp/tmp4dtuxj5b.rs:25:29\n   |\n15 | fn total_match(lst1:\
    \ Vec<String>, lst2: Vec<String>) -> Vec<String> {\n   |                ---- move\
    \ occurs because `lst1` has type `Vec<String>`, which does not implement the `Copy`\
    \ trait\n16 |     let mut total_match: Vec<String> = vec![];\n17 |     for el1\
    \ in lst1 {\n   |                ----\n   |                |\n   |           \
    \     `lst1` moved due to this implicit call to `.into_iter()`\n   |         \
    \       help: consider borrowing to avoid moving into the for loop: `&lst1`\n\
    ...\n25 |     if total_match.len() == lst1.len() {\n   |                     \
    \        ^^^^ value borrowed here after move\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut res\
    \ = vec![];\n    for el1 in lst1 {\n        for el2 in lst2 {\n            if\
    \ el1.len() < el2.len() {\n                res.push(el1);\n                break;\n\
    \            }\n        }\n    }\n    return res;\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmplqc2ctyy.rs:21:20\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n21  |  \
    \       for el2 in lst2 {\n    |                    ^^^^\n    |              \
    \      |\n    |                    `lst2` moved due to this implicit call to `.into_iter()`,\
    \ in previous iteration of loop\n    |                    help: consider borrowing\
    \ to avoid moving into the for loop: `&lst2`\n    |\nnote: this function takes\
    \ ownership of the receiver `self`, which moves `lst2`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for elem in lst2 {\n        if elem.len() > total_chars {\n\
    \            total_chars = elem.len();\n        }\n    }\n    lst1.iter().filter(|&x|\
    \ x.len() < total_chars).collect()\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&String`\n  --> /tmp/tmpjhrejsvf.rs:25:52\n   |\n25 |\
    \     lst1.iter().filter(|&x| x.len() < total_chars).collect()\n   |         \
    \                                           ^^^^^^^ value of type `Vec<String>`\
    \ cannot be built from `std::iter::Iterator<Item=&String>`\n   |\n   = help: the\
    \ trait `FromIterator<&String>` is not implemented for `Vec<String>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = vec![];\n    for el1 in lst1 {\n        for el2 in lst2 {\n            if\
    \ el1.len() < el2.len() {\n                total_chars.push(el1);\n          \
    \      break;\n            }\n        }\n    }\n    total_chars\n}\n\nfn main()\
    \ {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpp11fnkle.rs:21:20\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n21  |  \
    \       for el2 in lst2 {\n    |                    ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n21  |         for el2 in &lst2 {\n    |        \
    \            +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = vec![];\n    for x in lst1 {\n        for y in lst2 {\n            if x.len()\
    \ < y.len() {\n                total_chars.push(y);\n            }\n        }\n\
    \    }\n    return total_chars;\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpxo4jirzx.rs:21:18\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n21  |  \
    \       for y in lst2 {\n    |                  ^^^^\n    |                  |\n\
    \    |                  `lst2` moved due to this implicit call to `.into_iter()`,\
    \ in previous iteration of loop\n    |                  help: consider borrowing\
    \ to avoid moving into the for loop: `&lst2`\n    |\nnote: this function takes\
    \ ownership of the receiver `self`, which moves `lst2`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n    }\n\
    \    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let mut\
    \ total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n\n}\n\nfn main() {\n   \
    \ let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpdu5x5fzy.rs:119:3\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                                                   \
    \  - unclosed delimiter\n...\n104 |     for v in lst2 {\n    |               \
    \    - this delimiter might not be properly closed...\n105 | \n106 | }\n    |\
    \ - ...as it matches this but it has different indentation\n...\n119 | }\n   \
    \ |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdu5x5fzy.rs:15:57\n \
    \  |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |    -----------                                          ^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut total_match: Vec<String> = vec![];\n    for el1 in lst1 {\n     \
    \   for el2 in lst2 {\n            if el1.len() < el2.len() {\n              \
    \  total_match.push(el1);\n                break;\n            }\n        }\n\
    \    }\n    total_match\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpp_sfjfr0.rs:18:20\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n18  |  \
    \       for el2 in lst2 {\n    |                    ^^^^\n    |              \
    \      |\n    |                    `lst2` moved due to this implicit call to `.into_iter()`,\
    \ in previous iteration of loop\n    |                    help: consider borrowing\
    \ to avoid moving into the for loop: `&lst2`\n    |\nnote: this function takes\
    \ ownership of the receiver `self`, which moves `lst2`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n    }\n\
    \    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let mut\
    \ total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n\n}\n\nfn main() {\n   \
    \ let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpdu5x5fzy.rs:119:3\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                                                   \
    \  - unclosed delimiter\n...\n104 |     for v in lst2 {\n    |               \
    \    - this delimiter might not be properly closed...\n105 | \n106 | }\n    |\
    \ - ...as it matches this but it has different indentation\n...\n119 | }\n   \
    \ |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdu5x5fzy.rs:15:57\n \
    \  |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |    -----------                                          ^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for elem in lst2 {\n        total_chars += elem.len();\n\
    \    }\n    lst1.iter().filter(|&x| x < total_chars).collect()\n}\n\nfn main()\
    \ {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp27q6ibuw.rs:23:33\n   |\n\
    23 |     lst1.iter().filter(|&x| x < total_chars).collect()\n   |            \
    \                     ^^^^^^^^^^^ expected `&String`, found `usize`\n\nerror[E0277]:\
    \ a value of type `Vec<String>` cannot be built from an iterator over elements\
    \ of type `&String`\n  --> /tmp/tmp27q6ibuw.rs:23:46\n   |\n23 |     lst1.iter().filter(|&x|\
    \ x < total_chars).collect()\n   |                                           \
    \   ^^^^^^^ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&String>`\n\
    \   |\n   = help: the trait `FromIterator<&String>` is not implemented for `Vec<String>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut res\
    \ = vec![];\n    for i in 0..lst1.len() {\n        if lst1[i] < lst2[i] {\n  \
    \          res.push(lst1[i]);\n        }\n    }\n    return res;\n}\n\nfn main()\
    \ {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpxy0mr6hz.rs:22:22\n\
    \   |\n22 |             res.push(lst1[i]);\n   |                      ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_match:\
    \ Vec<String> = vec![];\n    for el1 in lst1 {\n        for el2 in lst2 {\n  \
    \          if el1.len() < el2.len() {\n                total_match.push(el1);\n\
    \                break;\n            }\n        }\n    }\n    total_match\n}\n\
    \nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmput5zrwfx.rs:21:20\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n21  |  \
    \       for el2 in lst2 {\n    |                    ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n21  |         for el2 in &lst2 {\n    |        \
    \            +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = vec![];\n    for x in lst1 {\n        if lst2.iter().any(|y| y.contains(&x))\
    \ {\n            total_chars.push(x);\n        }\n    }\n    total_chars\n}\n\n\
    fn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmpx18pm1_u.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748971
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n    }\n\
    \    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let mut\
    \ total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for s in lst2 {\n\n}\n\nfn main() {\n   \
    \ let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpk2jkmrwk.rs:119:3\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                                                   \
    \  - unclosed delimiter\n...\n104 |     for s in lst2 {\n    |               \
    \    - this delimiter might not be properly closed...\n105 | \n106 | }\n    |\
    \ - ...as it matches this but it has different indentation\n...\n119 | }\n   \
    \ |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk2jkmrwk.rs:15:57\n \
    \  |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |    -----------                                          ^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = vec![];\n    for v in lst1 {\n        total_chars.iter().filter(|&x| x <=\
    \ v).count();\n    }\n    for v in lst2 {\n        total_chars.iter().filter(|&x|\
    \ x <= v).count();\n    }\n    total_chars\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&str` with `String`\n  --> /tmp/tmp1i3ymfpp.rs:21:42\n\
    \   |\n21 |         total_chars.iter().filter(|&x| x <= v).count();\n   |    \
    \                                      ^^ no implementation for `&str < String`\
    \ and `&str > String`\n   |\n   = help: the trait `PartialOrd<String>` is not\
    \ implemented for `&str`\n\nerror[E0277]: the size for values of type `str` cannot\
    \ be known at compilation time\n  --> /tmp/tmp1i3ymfpp.rs:21:28\n   |\n21 |  \
    \       total_chars.iter().filter(|&x| x <= v).count();\n   |                \
    \            ^^^^^^ doesn't have a size known at compile-time\n   |\n   = help:\
    \ the trait `Sized` is not implemented for `str`\n   = note: required because\
    \ of the requirements on the impl of `Iterator` for `std::slice::Iter<'_, str>`\n\
    \nerror[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmp1i3ymfpp.rs:21:9\n   |\n21 |         total_chars.iter().filter(|&x|\
    \ x <= v).count();\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't\
    \ have a size known at compile-time\n   |\n   = help: the trait `Sized` is not\
    \ implemented for `str`\nnote: required by a bound in `std::slice::Iter`\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n  -->\
    \ /tmp/tmp1i3ymfpp.rs:21:21\n   |\n21 |         total_chars.iter().filter(|&x|\
    \ x <= v).count();\n   |                     ^^^^ doesn't have a size known at\
    \ compile-time\n   |\n   = help: the trait `Sized` is not implemented for `str`\n\
    \nerror[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n   --> /tmp/tmp1i3ymfpp.rs:19:27\n    |\n19  |     let mut total_chars\
    \ = vec![];\n    |                           ^^^^^^ doesn't have a size known\
    \ at compile-time\n    |\n    = help: the trait `Sized` is not implemented for\
    \ `str`\nnote: required by `Vec::<T>::new`\n    = note: this error originates\
    \ in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more\
    \ info)\n\nerror[E0277]: the size for values of type `str` cannot be known at\
    \ compilation time\n   --> /tmp/tmp1i3ymfpp.rs:19:27\n "
  stdout: ''
  timestamp: 1659748970
- exit_code: 101
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = vec![];\n    for elem in lst1 {\n        if elem.len() < lst2.len() {\n  \
    \          total_chars.push(elem);\n        }\n    }\n    for elem in lst2 {\n\
    \        if elem.len() < total_chars.len() {\n            total_chars.push(elem);\n\
    \        }\n    }\n    total_chars\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmp22a45a8n.rs:36:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748971
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut res\
    \ = vec![];\n    for i in 0..lst1.len() {\n        if lst1[i] < lst2[i] {\n  \
    \          res.push(lst1[i]);\n        }\n    }\n    return res;\n}\n\nfn main()\
    \ {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpxy0mr6hz.rs:22:22\n\
    \   |\n22 |             res.push(lst1[i]);\n   |                      ^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = vec![];\n    for x in lst1 {\n        if lst2.iter().any(|y| x.chars().any(|z|\
    \ z.cmp(y) < 0)) {\n            total_chars.push(x);\n        }\n    }\n    total_chars\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc8uf2ac0.rs:21:56\n   |\n\
    21 |         if lst2.iter().any(|y| x.chars().any(|z| z.cmp(y) < 0)) {\n   | \
    \                                                       ^ expected `char`, found\
    \ struct `String`\n   |\n   = note: expected reference `&char`\n             \
    \ found reference `&String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc8uf2ac0.rs:21:61\n\
    \   |\n21 |         if lst2.iter().any(|y| x.chars().any(|z| z.cmp(y) < 0)) {\n\
    \   |                                                             ^ expected enum\
    \ `std::cmp::Ordering`, found integer\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_len\
    \ = 0;\n    for v in lst1 {\n        total_len += v.len();\n    }\n    let mut\
    \ total_len2 = total_len;\n    for v in lst2 {\n        total_len2 += v.len();\n\
    \    }\n    if total_len2 > total_len {\n        return lst1;\n    }\n    return\
    \ lst2;\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst1`\n   --> /tmp/tmp0yvqaz9l.rs:28:16\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n20  |     for v in lst1 {\n\
    \    |              ----\n    |              |\n    |              `lst1` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&lst1`\n...\n28  |         return\
    \ lst1;\n    |                ^^^^ value used here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `lst1`\n\nerror[E0382]:\
    \ use of moved value: `lst2`\n  --> /tmp/tmp0yvqaz9l.rs:30:12\n   |\n15 | fn total_match(lst1:\
    \ Vec<String>, lst2: Vec<String>) -> Vec<String> {\n   |                     \
    \              ---- move occurs because `lst2` has type `Vec<String>`, which does\
    \ not implement the `Copy` trait\n...\n24 |     for v in lst2 {\n   |        \
    \      ----\n   |              |\n   |              `lst2` moved due to this implicit\
    \ call to `.into_iter()`\n   |              help: consider borrowing to avoid\
    \ moving into the for loop: `&lst2`\n...\n30 |     return lst2;\n   |        \
    \    ^^^^ value used here after move\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748969
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_len\
    \ = 0;\n    for el1 in lst1 {\n        for el2 in lst2 {\n            if el1.len()\
    \ < el2.len() {\n                total_len += el1.len();\n            }\n    \
    \    }\n    }\n    lst1.iter().filter(|el| el1.len() < total_len).collect()\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `el1` in this scope\n  --> /tmp/tmpwwshlfzp.rs:27:29\n\
    \   |\n27 |     lst1.iter().filter(|el| el1.len() < total_len).collect()\n   |\
    \                             ^^^ help: a local variable with a similar name exists:\
    \ `el`\n\nerror[E0277]: a value of type `Vec<String>` cannot be built from an\
    \ iterator over elements of type `&String`\n  --> /tmp/tmpwwshlfzp.rs:27:52\n\
    \   |\n27 |     lst1.iter().filter(|el| el1.len() < total_len).collect()\n   |\
    \                                                    ^^^^^^^ value of type `Vec<String>`\
    \ cannot be built from `std::iter::Iterator<Item=&String>`\n   |\n   = help: the\
    \ trait `FromIterator<&String>` is not implemented for `Vec<String>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = vec![];\n    for elem in lst1 {\n        let mut total_chars_in_elem = vec![];\n\
    \        for elem2 in lst2 {\n            if elem.chars().all(|c| elem2.chars().any(|c|\
    \ c == c)) {\n                total_chars_in_elem.push(elem2);\n            }\n\
    \        }\n        total_chars.push(total_chars_in_elem);\n    }\n    total_chars\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu5o3yj2q.rs:29:5\n   |\n\
    15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n \
    \  |                                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n29 |     total_chars\n   |     ^^^^^^^^^^^\
    \ expected struct `String`, found struct `Vec`\n   |\n   = note: expected struct\
    \ `Vec<String>`\n              found struct `Vec<Vec<String>>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n    }\n\
    \    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let mut\
    \ total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n\n}\n\nfn main() {\n   \
    \ let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpdu5x5fzy.rs:119:3\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                                                   \
    \  - unclosed delimiter\n...\n104 |     for v in lst2 {\n    |               \
    \    - this delimiter might not be properly closed...\n105 | \n106 | }\n    |\
    \ - ...as it matches this but it has different indentation\n...\n119 | }\n   \
    \ |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdu5x5fzy.rs:15:57\n \
    \  |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |    -----------                                          ^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_len\
    \ = lst1.len();\n    for i in 0..total_len {\n        if lst1[i] < lst2[i] {\n\
    \            total_len = i;\n            break;\n        }\n    }\n    lst1.iter().take(total_len).collect()\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&String`\n    --> /tmp/tmp3s_9_rrg.rs:26:33\n     |\n\
    26   |     lst1.iter().take(total_len).collect()\n     |                     \
    \            ^^^^^^^ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&String>`\n\
    \     |\n     = help: the trait `FromIterator<&String>` is not implemented for\
    \ `Vec<String>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = vec![0; lst1.len()];\n    for v in lst1 {\n        total_chars.iter_mut().for_each(|&i|\
    \ {\n            *i += (v.len() as i32);\n        });\n    }\n    for v in lst2\
    \ {\n        total_chars.iter_mut().for_each(|&i| {\n            *i += (v.len()\
    \ as i32);\n        });\n    }\n    total_chars.iter().cloned().collect()\n}\n\
    \nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around assigned value\n  --> /tmp/tmpu9yzixha.rs:22:19\n\
    \   |\n22 |             *i += (v.len() as i32);\n   |                   ^^^^^^^^^^^^^^^^\
    \ help: remove these parentheses\n   |\n   = note: `#[warn(unused_parens)]` on\
    \ by default\n\nwarning: unnecessary parentheses around assigned value\n  -->\
    \ /tmp/tmpu9yzixha.rs:27:19\n   |\n27 |             *i += (v.len() as i32);\n\
    \   |                   ^^^^^^^^^^^^^^^^ help: remove these parentheses\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpu9yzixha.rs:21:42\n   |\n21 |         total_chars.iter_mut().for_each(|&i|\
    \ {\n   |                                          ^--\n   |                 \
    \                         ||\n   |                                          |expected\
    \ due to this\n   |                                          types differ in mutability\n\
    \   |                                          help: did you mean `i`: `&&mut\
    \ {integer}`\n   |\n   = note: expected mutable reference `&mut {integer}`\n \
    \                     found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpu9yzixha.rs:26:42\n   |\n26 |         total_chars.iter_mut().for_each(|&i|\
    \ {\n   |                                          ^--\n   |                 \
    \                         ||\n   |                                          |expected\
    \ due to this\n   |                                          types differ in mutability\n\
    \   |                                          help: did you mean `i`: `&&mut\
    \ {integer}`\n   |\n   = note: expected mutable reference `&mut {integer}`\n \
    \                     found reference `&_`\n\nerror[E0277]: a value of type `Vec<String>`\
    \ cannot be built from an iterator over elements of type `{integer}`\n  --> /tmp/tmpu9yzixha.rs:30:33\n\
    \   |\n30 |     total_chars.iter().cloned().collect()\n   |                  \
    \               ^^^^^^^ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item={integer}>`\n\
    \   |\n   = help: the trait `FromIterator<{integer}>` is not implemented for `Vec<String>`\n\
    \nerror: aborting due to 3 previous errors; 2 warnings emitted\n\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = vec![];\n    for elem in lst1 {\n        let mut count = 0;\n        for elem2\
    \ in lst2 {\n            if elem.chars().all(|c| c == elem2.chars().first()) {\n\
    \                count += 1;\n            }\n        }\n        total_chars.push(String::from(elem.chars().filter(|c|\
    \ c < elem2.chars().first()).count()));\n    }\n    total_chars\n}\n\nfn main()\
    \ {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `elem2` in this scope\n  --> /tmp/tmpb76cne0u.rs:27:67\n\
    \   |\n27 |         total_chars.push(String::from(elem.chars().filter(|c| c <\
    \ elem2.chars().first()).count()));\n   |                                    \
    \                               ^^^^^ help: a local variable with a similar name\
    \ exists: `elem`\n\nerror[E0599]: no method named `first` found for struct `Chars`\
    \ in the current scope\n  --> /tmp/tmpb76cne0u.rs:23:56\n   |\n23 |          \
    \   if elem.chars().all(|c| c == elem2.chars().first()) {\n   |              \
    \                                          ^^^^^ method not found in `Chars<'_>`\n\
    \nerror[E0277]: the trait bound `String: From<usize>` is not satisfied\n   -->\
    \ /tmp/tmpb76cne0u.rs:27:26\n    |\n27  |         total_chars.push(String::from(elem.chars().filter(|c|\
    \ c < elem2.chars().first()).count()));\n    |                          ^^^^^^^^^^^^\
    \ the trait `From<usize>` is not implemented for `String`\n    |\n    = help:\
    \ the following implementations were found:\n              <String as From<&String>>\n\
    \              <String as From<&mut str>>\n              <String as From<&str>>\n\
    \              <String as From<Box<str>>>\n            and 2 others\nnote: required\
    \ by `from`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0425, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748971
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = vec![];\n    for el1 in lst1 {\n        for el2 in lst2 {\n            if\
    \ el1.len() < el2.len() {\n                total_chars.push(el1);\n          \
    \      break;\n            }\n        }\n    }\n    total_chars\n}\n\nfn main()\
    \ {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpp11fnkle.rs:21:20\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n21  |  \
    \       for el2 in lst2 {\n    |                    ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n21  |         for el2 in &lst2 {\n    |        \
    \            +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n    }\n\
    \    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let mut\
    \ total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n\n}\n\nfn main() {\n   \
    \ let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpdu5x5fzy.rs:119:3\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                                                   \
    \  - unclosed delimiter\n...\n104 |     for v in lst2 {\n    |               \
    \    - this delimiter might not be properly closed...\n105 | \n106 | }\n    |\
    \ - ...as it matches this but it has different indentation\n...\n119 | }\n   \
    \ |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdu5x5fzy.rs:15:57\n \
    \  |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |    -----------                                          ^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n    }\n\
    \    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let mut\
    \ total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n\n}\n\nfn main() {\n   \
    \ let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpdu5x5fzy.rs:119:3\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                                                   \
    \  - unclosed delimiter\n...\n104 |     for v in lst2 {\n    |               \
    \    - this delimiter might not be properly closed...\n105 | \n106 | }\n    |\
    \ - ...as it matches this but it has different indentation\n...\n119 | }\n   \
    \ |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdu5x5fzy.rs:15:57\n \
    \  |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |    -----------                                          ^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_match:\
    \ Vec<String> = vec![];\n    for el1 in lst1 {\n        for el2 in lst2 {\n  \
    \          if el1.len() < el2.len() {\n                total_match.push(el1);\n\
    \                break;\n            }\n        }\n    }\n    total_match\n}\n\
    \nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmput5zrwfx.rs:21:20\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n21  |  \
    \       for el2 in lst2 {\n    |                    ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n21  |         for el2 in &lst2 {\n    |        \
    \            +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n    }\n\
    \    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let mut\
    \ total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n\
    \    }\n    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let\
    \ mut total_chars = lst1.len();\n    for v in lst2 {\n\n}\n\nfn main() {\n   \
    \ let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpdu5x5fzy.rs:119:3\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                                                   \
    \  - unclosed delimiter\n...\n104 |     for v in lst2 {\n    |               \
    \    - this delimiter might not be properly closed...\n105 | \n106 | }\n    |\
    \ - ...as it matches this but it has different indentation\n...\n119 | }\n   \
    \ |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdu5x5fzy.rs:15:57\n \
    \  |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |    -----------                                          ^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = vec![];\n    for s in lst1 {\n        for s2 in lst2 {\n            if s.len()\
    \ < s2.len() {\n                break;\n            }\n            total_chars.push(s);\n\
    \        }\n    }\n    total_chars\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmp6y7zlwm5.rs:21:19\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n21  |  \
    \       for s2 in lst2 {\n    |                   ^^^^\n    |                \
    \   |\n    |                   `lst2` moved due to this implicit call to `.into_iter()`,\
    \ in previous iteration of loop\n    |                   help: consider borrowing\
    \ to avoid moving into the for loop: `&lst2`\n    |\nnote: this function takes\
    \ ownership of the receiver `self`, which moves `lst2`\n\nerror[E0382]: borrow\
    \ of moved value: `s`\n  --> /tmp/tmp6y7zlwm5.rs:22:16\n   |\n20 |     for s in\
    \ lst1 {\n   |         -    ---- this reinitialization might get skipped\n   |\
    \         |\n   |         move occurs because `s` has type `String`, which does\
    \ not implement the `Copy` trait\n21 |         for s2 in lst2 {\n22 |        \
    \     if s.len() < s2.len() {\n   |                ^ value borrowed here after\
    \ move\n...\n25 |             total_chars.push(s);\n   |                     \
    \         - value moved here, in previous iteration of loop\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut res\
    \ = vec![];\n    for el1 in lst1 {\n        for el2 in lst2 {\n            if\
    \ el1.len() < el2.len() {\n                res.push(el1);\n                break;\n\
    \            }\n        }\n    }\n    return res;\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmplqc2ctyy.rs:21:20\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n21  |  \
    \       for el2 in lst2 {\n    |                    ^^^^\n    |              \
    \      |\n    |                    `lst2` moved due to this implicit call to `.into_iter()`,\
    \ in previous iteration of loop\n    |                    help: consider borrowing\
    \ to avoid moving into the for loop: `&lst2`\n    |\nnote: this function takes\
    \ ownership of the receiver `self`, which moves `lst2`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut total_match: Vec<String> = vec![];\n    let mut total_match_len:\
    \ usize = 0;\n    for el1 in lst1 {\n        for el2 in lst2 {\n            if\
    \ el1.len() < el2.len() {\n                total_match_len += el1.len();\n   \
    \         } else {\n                total_match_len += el2.len();\n          \
    \  }\n        }\n    }\n    total_match_len = total_match_len.max(0);\n    for\
    \ el1 in lst1 {\n        for el2 in lst2 {\n            if el1.len() < el2.len()\
    \ {\n                if el1.len() == total_match_len {\n                    total_match.push(el1);\n\
    \                }\n            } else {\n                if el2.len() == total_match_len\
    \ {\n                    total_match.push(el2);\n                }\n         \
    \   }\n        }\n    }\n    total_match\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpg68oekg0.rs:19:20\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n19  |  \
    \       for el2 in lst2 {\n    |                    ^^^^\n    |              \
    \      |\n    |                    `lst2` moved due to this implicit call to `.into_iter()`,\
    \ in previous iteration of loop\n    |                    help: consider borrowing\
    \ to avoid moving into the for loop: `&lst2`\n    |\nnote: this function takes\
    \ ownership of the receiver `self`, which moves `lst2`\n\nerror[E0382]: use of\
    \ moved value: `lst1`\n  --> /tmp/tmpg68oekg0.rs:28:16\n   |\n15 | fn total_match(lst1:\
    \ Vec<String>, lst2: Vec<String>) -> Vec<String> {\n   |                ---- move\
    \ occurs because `lst1` has type `Vec<String>`, which does not implement the `Copy`\
    \ trait\n...\n18 |     for el1 in lst1 {\n   |                ----\n   |     \
    \           |\n   |                `lst1` moved due to this implicit call to `.into_iter()`\n\
    \   |                help: consider borrowing to avoid moving into the for loop:\
    \ `&lst1`\n...\n28 |     for el1 in lst1 {\n   |                ^^^^ value used\
    \ here after move\n\nerror[E0382]: use of moved value: `lst2`\n  --> /tmp/tmpg68oekg0.rs:29:20\n\
    \   |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n19 |   \
    \      for el2 in lst2 {\n   |                    ---- `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n...\n29 |  \
    \       for el2 in lst2 {\n   |                    ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n   |\nhelp:\
    \ consider borrowing to avoid moving into the for loop\n   |\n29 |         for\
    \ el2 in &lst2 {\n   |                    ~~~~~\nhelp: consider borrowing to avoid\
    \ moving into "
  stdout: ''
  timestamp: 1659748970
- exit_code: 101
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for v in lst2 {\n        total_chars += v.len();\n    }\n\
    \    if total_chars == lst1.len() {\n        return lst1;\n    }\n    let mut\
    \ result = vec![];\n    for v in lst1 {\n        if v.len() < total_chars {\n\
    \            result.push(v);\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmprnfzgpde.rs:38:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748971
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = vec![];\n    for el1 in lst1 {\n        for el2 in lst2 {\n            if\
    \ el1.len() < el2.len() {\n                total_chars.push(el1);\n          \
    \      break;\n            }\n        }\n    }\n    total_chars\n}\n\nfn main()\
    \ {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpp11fnkle.rs:21:20\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n21  |  \
    \       for el2 in lst2 {\n    |                    ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n21  |         for el2 in &lst2 {\n    |        \
    \            +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut total_match: Vec<String> = Vec::new();\n    for elem in lst1 {\n\
    \        if lst2.iter().any(|x| x == elem) {\n            total_match.push(elem);\n\
    \        }\n    }\n    total_match\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&String` with `String`\n  --> /tmp/tmpoow029ob.rs:18:34\n\
    \   |\n18 |         if lst2.iter().any(|x| x == elem) {\n   |                \
    \                  ^^ no implementation for `&String == String`\n   |\n   = help:\
    \ the trait `PartialEq<String>` is not implemented for `&String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659748971
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_len\
    \ = 0;\n    for el1 in lst1 {\n        for el2 in lst2 {\n            if el1.len()\
    \ < el2.len() {\n                total_len += el1.len();\n            }\n    \
    \    }\n    }\n    total_len += lst2.len();\n    lst1.iter().filter(|el| el !=\
    \ \"\").take(total_len).collect()\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&String` with `str`\n  --> /tmp/tmpa439n1fz.rs:28:32\n\
    \   |\n28 |     lst1.iter().filter(|el| el != \"\").take(total_len).collect()\n\
    \   |                                ^^ no implementation for `&String == str`\n\
    \   |\n   = help: the trait `PartialEq<str>` is not implemented for `&String`\n\
    \   = note: required because of the requirements on the impl of `PartialEq<&str>`\
    \ for `&&String`\n\nerror[E0277]: a value of type `Vec<String>` cannot be built\
    \ from an iterator over elements of type `&String`\n  --> /tmp/tmpa439n1fz.rs:28:55\n\
    \   |\n28 |     lst1.iter().filter(|el| el != \"\").take(total_len).collect()\n\
    \   |                                                       ^^^^^^^ value of type\
    \ `Vec<String>` cannot be built from `std::iter::Iterator<Item=&String>`\n   |\n\
    \   = help: the trait `FromIterator<&String>` is not implemented for `Vec<String>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_len\
    \ = 0;\n    for s in lst1 {\n        total_len += s.len();\n    }\n    for s in\
    \ lst2 {\n        total_len += s.len();\n    }\n    if total_len == lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_len == lst2.len() {\n        return\
    \ lst2;\n    }\n    let mut total_len = 0;\n    for s in lst1 {\n        total_len\
    \ += s.len();\n    }\n    for s in lst2 {\n        total_len += s.len();\n   \
    \ }\n    if total_len == lst1.len() {\n        return lst1;\n    }\n    if total_len\
    \ == lst2.len() {\n        return lst2;\n    }\n    let mut total_len = 0;\n \
    \   for s in lst1 {\n        total_len += s.len();\n    }\n    for s in lst2 {\n\
    \        total_len += s.len();\n    }\n    if total_len == lst1.len() {\n    \
    \    return lst1;\n    }\n    if total_len == lst2.len() {\n        return lst2;\n\
    \    }\n    let mut total_len = 0;\n    for s in lst1 {\n        total_len +=\
    \ s.len();\n    }\n    for s in lst2 {\n        total_len += s.len();\n    }\n\
    \    if total_len == lst1.len() {\n        return lst1;\n    }\n    if total_len\
    \ == lst2.len() {\n        return lst2;\n    }\n    let mut total_len = 0;\n \
    \   for s in lst1 {\n        total_len += s.len();\n    }\n    for s in lst2 {\n\
    \        total_len += s.len();\n    }\n    if total_len == lst1.len() {\n    \
    \    return lst1;\n    }\n    if total_len == lst2.len() {\n        return lst2;\n\
    \    }\n    let mut total_len = 0;\n    for s in lst1 {\n        total_len +=\
    \ s.len();\n    }\n    for s in lst2 {\n        total_len += s.len();\n    }\n\
    \    if total_len == lst1.len() {\n        return lst1;\n    }\n    if total_len\
    \ == lst2.len() {\n        return lst2;\n    }\n    let mut total_len = 0;\n \
    \   for s in lst1 {\n        total_len += s.len();\n    }\n    for s in lst2 {\n\
    \        total_len += s.len();\n    }\n    if total_len == lst1.len() {\n    \
    \    return lst1;\n    }\n    if total_len == lst2.len() {\n        return lst2;\n\
    \    }\n    let mut total_len = 0;\n    for s in lst1 {\n        total_len +=\
    \ s.len();\n    }\n    for s in lst2 {\n        total_len += s.len();\n    }\n\
    \    if total_len == lst1.\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n   --> /tmp/tmpxi0yygmb.rs:118:1\n    |\n\
    118 | }\n    | ^\n\nerror: expected `{`, found `}`\n   --> /tmp/tmpxi0yygmb.rs:118:1\n\
    \    |\n117 |     if total_len == lst1.\n    |     -- this `if` expression has\
    \ a condition, but no block\n118 | }\n    | ^ expected `{`\n\nerror: aborting\
    \ due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_len\
    \ = 0;\n    for s in lst1 {\n        total_len += s.len();\n    }\n    let mut\
    \ total_len2 = total_len;\n    for s in lst2 {\n        total_len2 += s.len();\n\
    \    }\n    if total_len2 > total_len {\n        return lst1;\n    }\n    return\
    \ lst2;\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst1`\n   --> /tmp/tmp2nfp_576.rs:28:16\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n20  |     for s in lst1 {\n\
    \    |              ----\n    |              |\n    |              `lst1` moved\
    \ due to this implicit call to `.into_iter()`\n    |              help: consider\
    \ borrowing to avoid moving into the for loop: `&lst1`\n...\n28  |         return\
    \ lst1;\n    |                ^^^^ value used here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `lst1`\n\nerror[E0382]:\
    \ use of moved value: `lst2`\n  --> /tmp/tmp2nfp_576.rs:30:12\n   |\n15 | fn total_match(lst1:\
    \ Vec<String>, lst2: Vec<String>) -> Vec<String> {\n   |                     \
    \              ---- move occurs because `lst2` has type `Vec<String>`, which does\
    \ not implement the `Copy` trait\n...\n24 |     for s in lst2 {\n   |        \
    \      ----\n   |              |\n   |              `lst2` moved due to this implicit\
    \ call to `.into_iter()`\n   |              help: consider borrowing to avoid\
    \ moving into the for loop: `&lst2`\n...\n30 |     return lst2;\n   |        \
    \    ^^^^ value used here after move\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748969
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut total_len = 0;\n    for elem in lst1 {\n        total_len += elem.len();\n\
    \    }\n    for elem in lst2 {\n        total_len += elem.len();\n    }\n    if\
    \ total_len == 0 {\n        return lst1;\n    }\n    if total_len == lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_len == lst2.len() {\n        return\
    \ lst2;\n    }\n    let mut total_len = 0;\n    for elem in lst1 {\n        total_len\
    \ += elem.len();\n    }\n    for elem in lst2 {\n        total_len += elem.len();\n\
    \    }\n    if total_len == 0 {\n        return lst1;\n    }\n    if total_len\
    \ == lst1.len() {\n        return lst1;\n    }\n    if total_len == lst2.len()\
    \ {\n        return lst2;\n    }\n    let mut total_len = 0;\n    for elem in\
    \ lst1 {\n        total_len += elem.len();\n    }\n    for elem in lst2 {\n  \
    \      total_len += elem.len();\n    }\n    if total_len == 0 {\n        return\
    \ lst1;\n    }\n    if total_len == lst1.len() {\n        return lst1;\n    }\n\
    \    if total_len == lst2.len() {\n        return lst2;\n    }\n    let mut total_len\
    \ = 0;\n    for elem in lst1 {\n        total_len += elem.len();\n    }\n    for\
    \ elem in lst2 {\n        total_len += elem.len();\n    }\n    if total_len ==\
    \ 0 {\n        return lst1;\n    }\n    if total_len == lst1.len() {\n       \
    \ return lst1;\n    }\n    if total_len == lst2.len() {\n        return lst2;\n\
    \    }\n    let mut total_len = 0;\n    for elem in lst1 {\n        total_len\
    \ += elem.len();\n    }\n    for elem in lst2 {\n        total_len += elem.len();\n\
    \    }\n    if total_len == 0 {\n        return lst1;\n    }\n    if total_len\
    \ == lst1.len() {\n        return lst1;\n    }\n    if total_len == lst2.len()\
    \ {\n        return lst2;\n    }\n    let mut total_len = 0;\n    for elem in\
    \ lst1 {\n        total_len += elem.len();\n    }\n    for elem in lst2 {\n  \
    \      total_len += elem.len();\n    }\n    if total_len == 0 {\n        return\
    \ lst1;\n    }\n    if total_len == lst1.len() {\n        return lst1;\n    }\n\
    \    if total_len == lst2.len() {\n        return lst2;\n    }\n    let mut total_len\
    \ = 0;\n    for elem in lst1 {\n        total_len += elem.len();\n    }\n    for\
    \ elem in lst2 {\n        total_len += elem.len();\n    }\n    if \n}\n\nfn main()\
    \ {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n   --> /tmp/tmpown_bo0c.rs:120:1\n\
    \    |\n120 | }\n    | ^ expected expression\n\nerror: aborting due to previous\
    \ error\n\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_len\
    \ = 0;\n    for el1 in lst1 {\n        for el2 in lst2 {\n            if el1.len()\
    \ < el2.len() {\n                total_len += el1.len();\n            }\n    \
    \    }\n    }\n    lst1.iter().filter(|&x| x.len() == total_len).collect()\n}\n\
    \nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&String`\n  --> /tmp/tmp0ft2bc6w.rs:27:51\n   |\n27 |\
    \     lst1.iter().filter(|&x| x.len() == total_len).collect()\n   |          \
    \                                         ^^^^^^^ value of type `Vec<String>`\
    \ cannot be built from `std::iter::Iterator<Item=&String>`\n   |\n   = help: the\
    \ trait `FromIterator<&String>` is not implemented for `Vec<String>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748971
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = vec![];\n    for x in lst1 {\n        for y in lst2 {\n            if x.len()\
    \ < y.len() {\n                total_chars.push(y);\n                break;\n\
    \            }\n        }\n    }\n    total_chars\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpayyltm_r.rs:21:18\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n21  |  \
    \       for y in lst2 {\n    |                  ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n21  |         for y in &lst2 {\n    |          \
    \        +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut total_len = 0;\n    for el1 in lst1 {\n        for el2 in lst2 {\n\
    \            if el1.len() < el2.len() {\n                total_len += el1.len();\n\
    \            }\n        }\n    }\n    if total_len == 0 {\n        lst1\n    }\
    \ else {\n        lst1\n    }\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmphi2n5r36.rs:18:20\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n18  |  \
    \       for el2 in lst2 {\n    |                    ^^^^\n    |              \
    \      |\n    |                    `lst2` moved due to this implicit call to `.into_iter()`,\
    \ in previous iteration of loop\n    |                    help: consider borrowing\
    \ to avoid moving into the for loop: `&lst2`\n    |\nnote: this function takes\
    \ ownership of the receiver `self`, which moves `lst2`\n\nerror[E0382]: use of\
    \ moved value: `lst1`\n  --> /tmp/tmphi2n5r36.rs:25:9\n   |\n15 | fn total_match(lst1:\
    \ Vec<String>, lst2: Vec<String>) -> Vec<String> {\n   |                ---- move\
    \ occurs because `lst1` has type `Vec<String>`, which does not implement the `Copy`\
    \ trait\n16 |     let mut total_len = 0;\n17 |     for el1 in lst1 {\n   |   \
    \             ----\n   |                |\n   |                `lst1` moved due\
    \ to this implicit call to `.into_iter()`\n   |                help: consider\
    \ borrowing to avoid moving into the for loop: `&lst1`\n...\n25 |         lst1\n\
    \   |         ^^^^ value used here after move\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748971
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = vec![];\n    for x in lst1 {\n        for y in lst2 {\n            if x.len()\
    \ < y.len() {\n                total_chars.push(y);\n                break;\n\
    \            }\n        }\n    }\n    total_chars\n}\n\nfn main() {\n    let candidate\
    \ = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpayyltm_r.rs:21:18\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n21  |  \
    \       for y in lst2 {\n    |                  ^^^^ `lst2` moved due to this\
    \ implicit call to `.into_iter()`, in previous iteration of loop\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst2`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n21  |         for y in &lst2 {\n    |          \
    \        +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = vec![0; lst1.len()];\n    for s in lst1 {\n        for c in s.chars() {\n\
    \            total_chars[c] += 1;\n        }\n    }\n    for s in lst2 {\n   \
    \     for c in s.chars() {\n            total_chars[c] += 1;\n        }\n    }\n\
    \    for i in 0..total_chars.len() {\n        if total_chars[i] < lst2.len() {\n\
    \            return lst1;\n        }\n    }\n    lst1\n}\n\nfn main() {\n    let\
    \ candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[{integer}]` cannot be indexed by `char`\n  -->\
    \ /tmp/tmpqkgjnq7w.rs:22:13\n   |\n22 |             total_chars[c] += 1;\n   |\
    \             ^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented for `char`\n\
    \   = note: required because of the requirements on the impl of `Index<char>`\
    \ for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]` cannot be indexed\
    \ by `char`\n  --> /tmp/tmpqkgjnq7w.rs:27:13\n   |\n27 |             total_chars[c]\
    \ += 1;\n   |             ^^^^^^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not\
    \ implemented for `char`\n   = note: required because of the requirements on the\
    \ impl of `Index<char>` for `Vec<{integer}>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748971
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = vec![];\n    for v in lst1 {\n        if lst2.iter().any(|s| v == s) {\n \
    \           total_chars.push(v);\n        }\n    }\n    total_chars\n}\n\nfn main()\
    \ {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmp5ek_klg0.rs:21:34\n\
    \   |\n21 |         if lst2.iter().any(|s| v == s) {\n   |                   \
    \               ^^ no implementation for `String == &String`\n   |\n   = help:\
    \ the trait `PartialEq<&String>` is not implemented for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659748971
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = vec![0; lst1.len()];\n    for v in lst1 {\n        total_chars.iter_mut().for_each(|&i|\
    \ {\n            *i += (v.len() as i64);\n        });\n    }\n    for v in lst2\
    \ {\n        total_chars.iter_mut().for_each(|&i| {\n            *i += (v.len()\
    \ as i64);\n        });\n    }\n    total_chars.iter().cloned().collect()\n}\n\
    \nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around assigned value\n  --> /tmp/tmp0czecid0.rs:22:19\n\
    \   |\n22 |             *i += (v.len() as i64);\n   |                   ^^^^^^^^^^^^^^^^\
    \ help: remove these parentheses\n   |\n   = note: `#[warn(unused_parens)]` on\
    \ by default\n\nwarning: unnecessary parentheses around assigned value\n  -->\
    \ /tmp/tmp0czecid0.rs:27:19\n   |\n27 |             *i += (v.len() as i64);\n\
    \   |                   ^^^^^^^^^^^^^^^^ help: remove these parentheses\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0czecid0.rs:21:42\n   |\n21 |         total_chars.iter_mut().for_each(|&i|\
    \ {\n   |                                          ^--\n   |                 \
    \                         ||\n   |                                          |expected\
    \ due to this\n   |                                          types differ in mutability\n\
    \   |                                          help: did you mean `i`: `&&mut\
    \ {integer}`\n   |\n   = note: expected mutable reference `&mut {integer}`\n \
    \                     found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0czecid0.rs:26:42\n   |\n26 |         total_chars.iter_mut().for_each(|&i|\
    \ {\n   |                                          ^--\n   |                 \
    \                         ||\n   |                                          |expected\
    \ due to this\n   |                                          types differ in mutability\n\
    \   |                                          help: did you mean `i`: `&&mut\
    \ {integer}`\n   |\n   = note: expected mutable reference `&mut {integer}`\n \
    \                     found reference `&_`\n\nerror[E0277]: a value of type `Vec<String>`\
    \ cannot be built from an iterator over elements of type `{integer}`\n  --> /tmp/tmp0czecid0.rs:30:33\n\
    \   |\n30 |     total_chars.iter().cloned().collect()\n   |                  \
    \               ^^^^^^^ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item={integer}>`\n\
    \   |\n   = help: the trait `FromIterator<{integer}>` is not implemented for `Vec<String>`\n\
    \nerror: aborting due to 3 previous errors; 2 warnings emitted\n\n"
  stdout: ''
  timestamp: 1659748971
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = vec![];\n    for v in lst1 {\n        let mut count = 0;\n        for w in\
    \ lst2 {\n            if v == w {\n                count += 1;\n            }\n\
    \        }\n        total_chars.push(count);\n    }\n    total_chars\n}\n\nfn\
    \ main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoaa4i5z4.rs:29:5\n   |\n\
    15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n \
    \  |                                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n29 |     total_chars\n   |     ^^^^^^^^^^^\
    \ expected struct `String`, found integer\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<{integer}>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748971
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = vec![];\n    for s in lst1 {\n        if lst2.iter().any(|s| s.contains(&s))\
    \ {\n            total_chars.push(s);\n        }\n    }\n    total_chars\n}\n\n\
    fn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `String`\n  --> /tmp/tmplgn_j_zj.rs:21:43\n\
    \   |\n21 |         if lst2.iter().any(|s| s.contains(&s)) {\n   |           \
    \                                ^^ expected an `Fn<(char,)>` closure, found `String`\n\
    \   |\n   = help: the trait `Fn<(char,)>` is not implemented for `String`\n  \
    \ = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&String`\n   = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&&String`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748971
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = vec![];\n    for v in lst1 {\n        total_chars.iter().filter(|&x| x < v).count();\n\
    \    }\n    for v in lst2 {\n        total_chars.iter().filter(|&x| x < v).count();\n\
    \    }\n    total_chars\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&str` with `String`\n  --> /tmp/tmpv_j4q90a.rs:21:42\n\
    \   |\n21 |         total_chars.iter().filter(|&x| x < v).count();\n   |     \
    \                                     ^ no implementation for `&str < String`\
    \ and `&str > String`\n   |\n   = help: the trait `PartialOrd<String>` is not\
    \ implemented for `&str`\n   = help: the following other types implement trait\
    \ `PartialOrd<Rhs>`:\n             String\n             str\n\nerror[E0277]: the\
    \ size for values of type `str` cannot be known at compilation time\n  --> /tmp/tmpv_j4q90a.rs:21:28\n\
    \   |\n21 |         total_chars.iter().filter(|&x| x < v).count();\n   |     \
    \                       ^^^^^^ doesn't have a size known at compile-time\n   |\n\
    \   = help: the trait `Sized` is not implemented for `str`\n   = help: the trait\
    \ `Iterator` is implemented for `std::slice::Iter<'a, T>`\n   = note: required\
    \ because of the requirements on the impl of `Iterator` for `std::slice::Iter<'_,\
    \ str>`\n\nerror[E0277]: the size for values of type `str` cannot be known at\
    \ compilation time\n  --> /tmp/tmpv_j4q90a.rs:21:9\n   |\n21 |         total_chars.iter().filter(|&x|\
    \ x < v).count();\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't\
    \ have a size known at compile-time\n   |\n   = help: the trait `Sized` is not\
    \ implemented for `str`\nnote: required by a bound in `std::slice::Iter`\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n   -->\
    \ /tmp/tmpv_j4q90a.rs:21:21\n    |\n21  |         total_chars.iter().filter(|&x|\
    \ x < v).count();\n    |                     ^^^^ doesn't have a size known at\
    \ compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\n\
    note: required by a bound in `core::slice::<impl [T]>::iter`\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n   -->\
    \ /tmp/tmpv_j4q90a.rs:19:27\n    |\n19  |     let mut total_chars = vec![];\n\
    \    |                           ^^^^^^ doesn't have a size known at compile-time\n\
    \    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required\
    \ by a bo"
  stdout: ''
- exit_code: 101
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = lst1.len();\n    for s in lst2 {\n        total_chars += s.len();\n    }\n\
    \    if total_chars == lst1.len() {\n        return lst1;\n    }\n    lst1\n}\n\
    \nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"hi\", \"admin\"]`,\n right: `[\"hi\", \"hi\"]`', /tmp/tmp44lbv1if.rs:32:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748971
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_match:\
    \ Vec<String> = vec![];\n    for elem in lst1 {\n        if lst2.iter().any(|x|\
    \ x.contains(elem)) {\n            total_match.push(elem);\n        }\n    }\n\
    \    total_match\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n  -->\
    \ /tmp/tmp20flqpyl.rs:21:43\n   |\n21 |         if lst2.iter().any(|x| x.contains(elem))\
    \ {\n   |                                           ^^^^\n   |               \
    \                            |\n   |                                         \
    \  expected an implementor of trait `Pattern<'_>`\n   |                      \
    \                     help: consider borrowing here: `&elem`\n   |\n   = note:\
    \ the trait bound `String: Pattern<'_>` is not satisfied\n   = note: required\
    \ because of the requirements on the impl of `Pattern<'_>` for `String`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748971
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut total_match: Vec<String> = vec![];\n    for el1 in lst1 {\n     \
    \   for el2 in lst2 {\n            if el1.len() < el2.len() {\n              \
    \  total_match.push(el1);\n                break;\n            }\n        }\n\
    \    }\n    total_match\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst2`\n   --> /tmp/tmpp_sfjfr0.rs:18:20\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n18  |  \
    \       for el2 in lst2 {\n    |                    ^^^^\n    |              \
    \      |\n    |                    `lst2` moved due to this implicit call to `.into_iter()`,\
    \ in previous iteration of loop\n    |                    help: consider borrowing\
    \ to avoid moving into the for loop: `&lst2`\n    |\nnote: this function takes\
    \ ownership of the receiver `self`, which moves `lst2`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = vec![];\n    for s in lst1 {\n        if lst2.iter().any(|s| s.contains(&s))\
    \ {\n            total_chars.push(s);\n        }\n    }\n    total_chars\n}\n\n\
    fn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `String`\n  --> /tmp/tmplgn_j_zj.rs:21:43\n\
    \   |\n21 |         if lst2.iter().any(|s| s.contains(&s)) {\n   |           \
    \                                ^^ expected an `Fn<(char,)>` closure, found `String`\n\
    \   |\n   = help: the trait `Fn<(char,)>` is not implemented for `String`\n  \
    \ = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&String`\n   = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&&String`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748971
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut total_len = 0;\n    for s in lst1 {\n        total_len += s.len();\n\
    \    }\n    for s in lst2 {\n        total_len += s.len();\n    }\n    if total_len\
    \ == 0 {\n        lst1\n    } else {\n        let mut total_len = 0;\n       \
    \ for s in lst1 {\n            total_len += s.len();\n        }\n        for s\
    \ in lst2 {\n            total_len += s.len();\n        }\n        if total_len\
    \ == 0 {\n            lst1\n        } else {\n            lst1\n        }\n  \
    \  }\n}\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst1`\n   --> /tmp/tmp4j2rjj4f.rs:24:9\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n16  |     let mut total_len = 0;\n\
    17  |     for s in lst1 {\n    |              ----\n    |              |\n   \
    \ |              `lst1` moved due to this implicit call to `.into_iter()`\n  \
    \  |              help: consider borrowing to avoid moving into the for loop:\
    \ `&lst1`\n...\n24  |         lst1\n    |         ^^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `lst1`\n\nerror[E0382]: use of moved value: `lst2`\n  --> /tmp/tmp4j2rjj4f.rs:30:18\n\
    \   |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |                                   ---- move occurs because `lst2` has\
    \ type `Vec<String>`, which does not implement the `Copy` trait\n...\n20 |   \
    \  for s in lst2 {\n   |              ----\n   |              |\n   |        \
    \      `lst2` moved due to this implicit call to `.into_iter()`\n   |        \
    \      help: consider borrowing to avoid moving into the for loop: `&lst2`\n...\n\
    30 |         for s in lst2 {\n   |                  ^^^^ value used here after\
    \ move\n\nerror[E0382]: use of moved value: `lst1`\n  --> /tmp/tmp4j2rjj4f.rs:34:13\n\
    \   |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |                ---- move occurs because `lst1` has type `Vec<String>`,\
    \ which does not implement the `Copy` trait\n...\n27 |         for s in lst1 {\n\
    \   |                  ----\n   |                  |\n   |                  `lst1`\
    \ moved due to this implicit call to `.into_iter()`\n   |                  help:\
    \ consider borrowing to avoid moving into the for loop: `&lst1`\n...\n34 |   \
    \          lst1\n   |             ^^^^ value used here after move\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0382`.\n"
  stdout: ''
  timestamp: 1659748971
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_len\
    \ = 0;\n    for s in lst1 {\n        total_len += s.len();\n    }\n    for s in\
    \ lst2 {\n        total_len += s.len();\n    }\n    if total_len == lst1.len()\
    \ {\n        return lst1;\n    }\n    if total_len == lst2.len() {\n        return\
    \ lst2;\n    }\n    let mut total_len = 0;\n    for s in lst1 {\n        total_len\
    \ += s.len();\n    }\n    for s in lst2 {\n        total_len += s.len();\n   \
    \ }\n    if total_len == lst1.len() {\n        return lst1;\n    }\n    if total_len\
    \ == lst2.len() {\n        return lst2;\n    }\n    let mut total_len = 0;\n \
    \   for s in lst1 {\n        total_len += s.len();\n    }\n    for s in lst2 {\n\
    \        total_len += s.len();\n    }\n    if total_len == lst1.len() {\n    \
    \    return lst1;\n    }\n    if total_len == lst2.len() {\n        return lst2;\n\
    \    }\n    let mut total_len = 0;\n    for s in lst1 {\n        total_len +=\
    \ s.len();\n    }\n    for s in lst2 {\n        total_len += s.len();\n    }\n\
    \    if total_len == lst1.len() {\n        return lst1;\n    }\n    if total_len\
    \ == lst2.len() {\n        return lst2;\n    }\n    let mut total_len = 0;\n \
    \   for s in lst1 {\n        total_len += s.len();\n    }\n    for s in lst2 {\n\
    \        total_len += s.len();\n    }\n    if total_len == lst1.len() {\n    \
    \    return lst1;\n    }\n    if total_len == lst2.len() {\n        return lst2;\n\
    \    }\n    let mut total_len = 0;\n    for s in lst1 {\n        total_len +=\
    \ s.len();\n    }\n    for s in lst2 {\n        total_len += s.len();\n    }\n\
    \    if total_len == lst1.len() {\n        return lst1;\n    }\n    if total_len\
    \ == lst2.len() {\n        return lst2;\n    }\n    let mut total_len = 0;\n \
    \   for s in lst1 {\n        total_len += s.len();\n    }\n    for s in lst2 {\n\
    \        total_len += s.len();\n    }\n    if total_len == lst1.len() {\n    \
    \    return lst1;\n    }\n    if total_len == lst2.len() {\n        return lst2;\n\
    \    }\n    let mut total_len = 0;\n    for s in lst1 {\n        total_len +=\
    \ s.len();\n    }\n    for s in lst2 {\n        total_len += s.len();\n    }\n\
    \    if total_len == lst1.\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n   --> /tmp/tmpxi0yygmb.rs:118:1\n    |\n\
    118 | }\n    | ^\n\nerror: expected `{`, found `}`\n   --> /tmp/tmpxi0yygmb.rs:118:1\n\
    \    |\n117 |     if total_len == lst1.\n    |     -- this `if` expression has\
    \ a condition, but no block\n118 | }\n    | ^ expected `{`\n\nerror: aborting\
    \ due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_chars\
    \ = vec![];\n    for elem in lst1 {\n        let mut count = 0;\n        for elem2\
    \ in lst2 {\n            if elem.chars().all(|c| c == elem2.chars().first()) {\n\
    \                count += 1;\n            }\n        }\n        if count > total_chars.len()\
    \ {\n            total_chars = vec![elem];\n        }\n    }\n    total_chars\n\
    }\n\nfn main() {\n    let candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ Vec::<String>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    )]), vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `first` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmpwtrkqg5l.rs:23:56\n   |\n23 |             if elem.chars().all(|c|\
    \ c == elem2.chars().first()) {\n   |                                        \
    \                ^^^^^ method not found in `Chars<'_>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659748971
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    let mut total_match: Vec<String> = vec![];\n    for elem in lst1 {\n    \
    \    if lst2.iter().any(|x| x.contains(elem)) {\n            total_match.push(elem);\n\
    \        }\n    }\n    total_match\n}\n\nfn main() {\n    let candidate = total_match;\n\
    \    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"admin\")],\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]), vec![String::from(\"hi\"\
    ), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"\
    ), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"),\
    \ String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"hi\"\
    ), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"4\"\
    )], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n  -->\
    \ /tmp/tmpiv_yzotp.rs:18:43\n   |\n18 |         if lst2.iter().any(|x| x.contains(elem))\
    \ {\n   |                                           ^^^^\n   |               \
    \                            |\n   |                                         \
    \  expected an implementor of trait `Pattern<'_>`\n   |                      \
    \                     help: consider borrowing here: `&elem`\n   |\n   = note:\
    \ the trait bound `String: Pattern<'_>` is not satisfied\n   = note: required\
    \ because of the requirements on the impl of `Pattern<'_>` for `String`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748970
- exit_code: 1
  program: "/// Write a function that accepts two vectors of strings and returns the\
    \ vector that has \n/// total number of chars in the all strings of the vector\
    \ less than the other vector.\n/// if the two vectors have the same number of\
    \ chars, return the first vector.\n/// Examples\n/// >>> total_match(vec![], vec![])\n\
    /// vec![]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"Hi\")])\n/// vec![String::from(\"\
    hI\"), String::from(\"Hi\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hi\"), String::from(\"hi\"), String::from(\"admin\"\
    ), String::from(\"project\")])\n/// vec![String::from(\"hi\"), String::from(\"\
    admin\")]\n/// >>> total_match(vec![String::from(\"hi\"), String::from(\"admin\"\
    )], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")])\n\
    /// vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hi\")]\n///\
    \ >>> total_match(vec![String::from(\"4\")], vec![String::from(\"1\"), String::from(\"\
    2\"), String::from(\"3\"), String::from(\"4\"), String::from(\"5\")])\n/// vec![String::from(\"\
    4\")]\nfn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String> {\n\
    \    if lst1.len() == lst2.len() {\n        return lst1;\n    }\n    let mut total_len\
    \ = 0;\n    for s in lst1 {\n        total_len += s.len();\n    }\n    let mut\
    \ total_len2 = total_len;\n    for s in lst2 {\n        total_len2 += s.len();\n\
    \    }\n    if total_len == total_len2 {\n        return lst1;\n    }\n    let\
    \ mut total_len3 = total_len;\n    for s in lst2 {\n        total_len3 -= s.len();\n\
    \    }\n    if total_len3 == 0 {\n        return lst1;\n    }\n    let mut total_len4\
    \ = total_len;\n    for s in lst2 {\n        total_len4 += s.len();\n    }\n \
    \   if total_len4 < total_len3 {\n        return lst1;\n    }\n    let mut total_len5\
    \ = total_len;\n    for s in lst2 {\n        total_len5 -= s.len();\n    }\n \
    \   if total_len5 == 0 {\n        return lst1;\n    }\n    let mut total_len6\
    \ = total_len;\n    for s in lst2 {\n        total_len6 += s.len();\n    }\n \
    \   if total_len6 < total_len5 {\n        return lst1;\n    }\n    let mut total_len7\
    \ = total_len;\n    for s in lst2 {\n        total_len7 -= s.len();\n    }\n \
    \   if total_len7 == 0 {\n        return lst1;\n    }\n    let mut total_len8\
    \ = total_len;\n    for s in lst2 {\n        total_len8 += s.len();\n    }\n \
    \   if total_len8 < total_len7 {\n        return lst1;\n    }\n    let mut total_len9\
    \ = total_len;\n    for s in lst2 {\n        total_len9 -= s.len();\n    }\n \
    \   if total_len9 == 0 {\n        return lst1;\n    }\n    let mut total_len10\
    \ = total_len;\n    for s in lst2 {\n        total_len10 += s.len();\n    }\n\
    \    if total_len10 < total_len9 {\n        return lst1;\n    }\n    let mut total_len11\
    \ = total_len;\n    for s in lst2 {\n        total_len11 -= s.len();\n    }\n\
    \    if total_len11 == 0 {\n        return lst1;\n    }\n    let mut total_len12\
    \ = total_len;\n    for s in lst2 {\n        total_len12 += s.len();\n    }\n\
    \    if total_len12 < total_len11 {\n        return lst1;\n    }\n    let mut\
    \ total_len13 = total_len;\n    for s in lst2 {\n        total_len13 -= s.len();\n\
    \    }\n    if total_len13 == 0 {\n        return lst1;\n    }\n    let mut total_len14\
    \ = total_len;\n    for s in lst2 {\n        total_\n}\n\nfn main() {\n    let\
    \ candidate = total_match;\n    assert_eq!(candidate(Vec::<String>::new(), Vec::<String>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"hi\"),\
    \ String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\")]),\
    \ vec![String::from(\"hi\"), String::from(\"hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hi\"), String::from(\"hi\"\
    ), String::from(\"admin\"), String::from(\"project\")]), vec![String::from(\"\
    hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    4\")], vec![String::from(\"1\"), String::from(\"2\"), String::from(\"3\"), String::from(\"\
    4\"), String::from(\"5\")]), vec![String::from(\"4\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"Hi\"\
    )]), vec![String::from(\"hI\"), String::from(\"Hi\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    hi\"), String::from(\"admin\")], vec![String::from(\"hI\"), String::from(\"hi\"\
    ), String::from(\"hi\")]), vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"\
    hi\")]);\n    assert_eq!(candidate(vec![String::from(\"hi\"), String::from(\"\
    admin\")], vec![String::from(\"hI\"), String::from(\"hi\"), String::from(\"hii\"\
    )]), vec![String::from(\"hi\"), String::from(\"admin\")]);\n    assert_eq!(candidate(Vec::<String>::new(),\
    \ vec![String::from(\"this\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    this\")], Vec::<String>::new()), Vec::<String>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp0rfsvil0.rs:123:3\n\
    \    |\n15  | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n    |                                                                   \
    \  - unclosed delimiter\n...\n108 |     for s in lst2 {\n    |               \
    \    - this delimiter might not be properly closed...\n109 |         total_\n\
    110 | }\n    | - ...as it matches this but it has different indentation\n...\n\
    123 | }\n    |   ^\n\nerror[E0425]: cannot find value `total_` in this scope\n\
    \   --> /tmp/tmp0rfsvil0.rs:109:9\n    |\n109 |         total_\n    |        \
    \ ^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0rfsvil0.rs:15:57\n\
    \   |\n15 | fn total_match(lst1: Vec<String>, lst2: Vec<String>) -> Vec<String>\
    \ {\n   |    -----------                                          ^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748971
