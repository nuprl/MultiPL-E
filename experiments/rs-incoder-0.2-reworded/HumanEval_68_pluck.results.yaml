language: rs
name: HumanEval_68_pluck
results:
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 0;\n    let mut min_idx2 = 0;\n    let mut min_idx3 = 0;\n\
    \    let mut min_idx4 = 0;\n    let mut min_idx5 = 0;\n    let mut min_idx6 =\
    \ 0;\n    let mut min_idx7 = 0;\n    let mut min_idx8 = 0;\n    let mut min_idx9\
    \ = 0;\n    let mut min_idx10 = 0;\n    let mut min_idx11 = 0;\n    let mut min_idx12\
    \ = 0;\n    let mut min_idx13 = 0;\n    let mut min_idx14 = 0;\n    let mut min_idx15\
    \ = 0;\n    let mut min_idx16 = 0;\n    let mut min_idx17 = 0;\n    let mut min_idx18\
    \ = 0;\n    let mut min_idx19 = 0;\n    let mut min_idx20 = 0;\n    let mut min_idx21\
    \ = 0;\n    let mut min_idx22 = 0;\n    let mut min_idx23 = 0;\n    let mut min_idx24\
    \ = 0;\n    let mut min_idx25 = 0;\n    let mut min_idx26 = 0;\n    let mut min_idx27\
    \ = 0;\n    let mut min_idx28 = 0;\n    let mut min_idx29 = 0;\n    let mut min_idx30\
    \ = 0;\n    let mut min_idx31 = 0;\n    let mut min_idx32 = 0;\n    let mut min_idx33\
    \ = 0;\n    let mut min_idx34 = 0;\n    let mut min_idx35 = 0;\n    let mut min_idx36\
    \ = 0;\n    let mut min_idx37 = 0;\n    let mut min_idx38 = 0;\n    let mut min_idx39\
    \ = 0;\n    let mut min_idx40 = 0;\n    let mut min_idx41 = 0;\n    let mut min_idx42\
    \ = 0;\n    let mut min_idx43 = 0;\n    let mut min_idx44 = 0;\n    let mut min_idx45\
    \ = 0;\n    let mut min_idx46 = 0;\n    let mut min_idx47 = 0;\n    let mut min_idx48\
    \ = 0;\n    let mut min_idx49 = 0;\n    let mut min_idx50 = 0;\n    let mut min_idx51\
    \ = 0;\n    let mut min_idx52 = 0;\n    let mut min_idx53 = 0;\n    let mut min_idx54\
    \ = 0;\n    let mut min_idx55 = 0;\n    let mut min_idx56 = 0;\n    let mut min_idx57\
    \ = 0;\n    let mut min_idx58 = 0;\n    let mut min_idx59 = 0;\n    let mut min_idx60\
    \ = 0;\n    let mut min_idx61 = 0;\n    let mut min_idx62 = 0;\n    let mut min_idx63\
    \ = 0;\n    let mut min_idx\n}\n\nfn main() {\n    let candidate = pluck;\n  \
    \  assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_84wucx7.rs:91:20\n   |\n\
    91 |     let mut min_idx\n   |                    ^ help: add `;` here\n92 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_84wucx7.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 0;\n    for i in arr.iter().rev() {\n        if i % 2 ==\
    \ 0 {\n            if min_value == i {\n                min_idx = i;\n       \
    \     }\n            min_value = i;\n        }\n    }\n    vec![min_value, min_idx]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd4dolmfn.rs:31:29\n   |\n\
    31 |             if min_value == i {\n   |                             ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    31 |             if min_value == *i {\n   |                             +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpd4dolmfn.rs:32:27\n   |\n28 |  \
    \   let mut min_idx = 0;\n   |                       - expected due to this value\n\
    ...\n32 |                 min_idx = i;\n   |                           ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    32 |                 min_idx = *i;\n   |                           +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpd4dolmfn.rs:34:25\n   |\n27 |     let mut min_value\
    \ = arr[0];\n   |                         ------ expected due to this value\n\
    ...\n34 |             min_value = i;\n   |                         ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    34 |             min_value = *i;\n   |                         +\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value: isize =\
    \ 0;\n    let mut smallest_index: usize = 0;\n    let mut mut_smallest_value:\
    \ isize = 0;\n    let mut mut_smallest_index: usize = 0;\n    let mut mut_mut_smallest_value:\
    \ isize = 0;\n    let mut mut_mut_smallest_index: usize = 0;\n    let mut mut_mut_mut_smallest_value:\
    \ isize = 0;\n    let mut mut_mut_mut_smallest_index: usize = 0;\n    let mut\
    \ mut_mut_mut_mut_smallest_value: isize = 0;\n    let mut mut_mut_mut_mut_smallest_index:\
    \ usize = 0;\n    let mut mut_mut_mut_mut_mut_smallest_value: isize = 0;\n   \
    \ let mut mut_mut_mut_mut_mut_smallest_index: usize = 0;\n    let mut mut_mut_mut_mut_mut_mut_smallest_value:\
    \ isize = 0;\n    let mut mut_mut_mut_mut_mut_mut_smallest_index: usize = 0;\n\
    \    let mut mut_mut_mut_mut_mut_mut_mut_smallest_value: isize = 0;\n    let mut\
    \ mut_mut_mut_mut_mut_mut_mut_mut_smallest_index: usize = 0;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_value:\
    \ isize = 0;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_index:\
    \ usize = 0;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_value:\
    \ isize = 0;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_index:\
    \ usize = 0;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_value:\
    \ isize = 0;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_index:\
    \ usize = 0;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mu\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp15mqgvah.rs:49:71\n   |\n\
    49 |     let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mu\n\
    \   |                                                                       ^\
    \ help: add `;` here\n50 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp15mqgvah.rs:26:30\n   |\n26 | fn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |    -----                     ^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 0;\n    for i in arr.iter().rev() {\n        if i % 2 ==\
    \ 0 {\n            if min_value >= i {\n                min_value = i;\n     \
    \           min_idx = i;\n            }\n        }\n    }\n    vec![min_value,\
    \ min_idx]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3s4aecb_.rs:31:29\n   |\n\
    31 |             if min_value >= i {\n   |                             ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    31 |             if min_value >= *i {\n   |                             +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp3s4aecb_.rs:32:29\n   |\n27 |  \
    \   let mut min_value = arr[0];\n   |                         ------ expected\
    \ due to this value\n...\n32 |                 min_value = i;\n   |          \
    \                   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n32 |                 min_value = *i;\n   |               \
    \              +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3s4aecb_.rs:33:27\n\
    \   |\n28 |     let mut min_idx = 0;\n   |                       - expected due\
    \ to this value\n...\n33 |                 min_idx = i;\n   |                \
    \           ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n33 |                 min_idx = *i;\n   |                 \
    \          +\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = i32::MAX;\n\
    \    let mut min_idx = -1;\n    for i in arr.iter() {\n        if i % 2 == 0 {\n\
    \            if min_value < i {\n                min_value = i;\n            \
    \    min_idx = i;\n            }\n        }\n    }\n    if min_idx == -1 {\n \
    \       return vec![];\n    }\n    vec![min_value, min_idx]\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvczbidx1.rs:31:28\n   |\n\
    31 |             if min_value < i {\n   |                            ^ expected\
    \ `i32`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvczbidx1.rs:32:29\n\
    \   |\n27 |     let mut min_value = i32::MAX;\n   |                         --------\
    \ expected due to this value\n...\n32 |                 min_value = i;\n   | \
    \                            ^ expected `i32`, found `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvczbidx1.rs:33:27\n   |\n28 |     let mut min_idx\
    \ = -1;\n   |                       -- expected due to this value\n...\n33 | \
    \                min_idx = i;\n   |                           ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n33 |  \
    \               min_idx = *i;\n   |                           +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvczbidx1.rs:40:10\n   |\n40 |     vec![min_value,\
    \ min_idx]\n   |          ^^^^^^^^^ expected `isize`, found `i32`\n   |\nhelp:\
    \ you can convert an `i32` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n40 |     vec![min_value.try_into().unwrap(), min_idx]\n   |     \
    \              ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    for i in arr.iter().rev() {\n        if\
    \ i % 2 == 0 {\n            if smallest_value < i {\n                smallest_value\
    \ = i;\n                smallest_index = i;\n            }\n        }\n    }\n\
    \    vec![smallest_value, smallest_index]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpytbrv3ym.rs:31:33\n   |\n\
    31 |             if smallest_value < i {\n   |                               \
    \  ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n31 |             if smallest_value < *i {\n   |              \
    \                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpytbrv3ym.rs:32:34\n\
    \   |\n27 |     let mut smallest_value = arr[0];\n   |                       \
    \       ------ expected due to this value\n...\n32 |                 smallest_value\
    \ = i;\n   |                                  ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n32 |                 smallest_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpytbrv3ym.rs:33:34\n   |\n28 |     let mut smallest_index = 0;\n\
    \   |                              - expected due to this value\n...\n33 |   \
    \              smallest_index = i;\n   |                                  ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    33 |                 smallest_index = *i;\n   |                              \
    \    +\n\nerror: aborting due to 3 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = i32::MAX;\n\
    \    let mut min_idx = -1;\n    let mut min_idx2 = -1;\n    for i in arr.iter()\
    \ {\n        if i % 2 == 0 {\n            if min_value < i {\n               \
    \ min_value = i;\n                min_idx = i;\n            }\n        } else\
    \ {\n            if min_idx2 < i {\n                min_idx2 = i;\n          \
    \  }\n        }\n    }\n    if min_idx2 == min_idx {\n        return vec![];\n\
    \    }\n    return vec![min_value, min_idx];\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxf2_xml7.rs:32:28\n   |\n\
    32 |             if min_value < i {\n   |                            ^ expected\
    \ `i32`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxf2_xml7.rs:33:29\n\
    \   |\n27 |     let mut min_value = i32::MAX;\n   |                         --------\
    \ expected due to this value\n...\n33 |                 min_value = i;\n   | \
    \                            ^ expected `i32`, found `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxf2_xml7.rs:34:27\n   |\n28 |     let mut min_idx\
    \ = -1;\n   |                       -- expected due to this value\n...\n34 | \
    \                min_idx = i;\n   |                           ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n34 |  \
    \               min_idx = *i;\n   |                           +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxf2_xml7.rs:38:28\n   |\n29 |     let mut min_idx2\
    \ = -1;\n   |                        -- expected due to this value\n...\n38 |\
    \                 min_idx2 = i;\n   |                            ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n38 |  \
    \               min_idx2 = *i;\n   |                            +\n\nerror[E0277]:\
    \ can't compare `isize` with `&isize`\n  --> /tmp/tmpxf2_xml7.rs:37:25\n   |\n\
    37 |             if min_idx2 < i {\n   |                         ^ no implementation\
    \ for `isize < &isize` and `isize > &isize`\n   |\n   = help: the trait `PartialOrd<&isize>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpxf2_xml7.rs:45:17\n   |\n45 |     return vec![min_value, min_idx];\n\
    \   |                 ^^^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you\
    \ can convert an `i32` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n45 |     return vec![min_value.try_int"
  stdout: ''
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value: isize =\
    \ 0;\n    let mut smallest_index: isize = 0;\n    let mut even_values: Vec<isize>\
    \ = Vec::new();\n    for value in arr {\n        if value % 2 == 0 {\n       \
    \     even_values.push(value);\n        }\n        if value == smallest_value\
    \ {\n            smallest_index = arr.iter().position(|&x| x == value).unwrap();\n\
    \        }\n        if value < smallest_value {\n            smallest_value =\
    \ value;\n        }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n\
    \    }\n    if even_values.len() == 1 {\n        return vec![even_values[0]];\n\
    \    }\n    let mut smallest_even_value = even_values[0];\n    let mut smallest_even_index\
    \ = smallest_index;\n    for value in even_values {\n        if value < smallest_even_value\
    \ {\n            smallest_even_value = value;\n            smallest_even_index\
    \ = arr.iter().position(|&x| x == value).unwrap();\n        }\n    }\n    vec![smallest_even_value,\n\
    \         smallest_even_index]\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw3ndoh9v.rs:35:30\n   |\n\
    28 |     let mut smallest_index: isize = 0;\n   |                            \
    \ ----- expected due to this type\n...\n35 |             smallest_index = arr.iter().position(|&x|\
    \ x == value).unwrap();\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw3ndoh9v.rs:52:35\n\
    \   |\n48 |     let mut smallest_even_index = smallest_index;\n   |          \
    \                         -------------- expected due to this value\n...\n52 |\
    \             smallest_even_index = arr.iter().position(|&x| x == value).unwrap();\n\
    \   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut even_values = vec![];\n\
    \    let mut smallest_value = vec![];\n    let mut smallest_index = vec![];\n\
    \    for i in arr.iter() {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \            if i < smallest_value.len() {\n                smallest_value[i]\
    \ = i;\n                smallest_index[i] = i;\n            }\n        } else\
    \ {\n            if i < smallest_value.len() {\n                smallest_value[i]\
    \ = i;\n                smallest_index[i] = i;\n            }\n        }\n   \
    \ }\n    if even_values.len() == 0 {\n        return vec![];\n    }\n    if even_values.len()\
    \ == 1 {\n        return vec![even_values[0]];\n    }\n    if even_values.len()\
    \ > 1 {\n        let mut smallest_value_iter = even_values.iter().cloned().collect::<Vec<_>>();\n\
    \        let mut smallest_index_iter = smallest_index.iter().cloned().collect::<Vec<_>>();\n\
    \        let mut smallest_value = vec![];\n        let mut smallest_index = vec![];\n\
    \        for i in even_values.iter() {\n            if i < smallest_value.len()\
    \ {\n                smallest_value[i] = i;\n                smallest_index[i]\
    \ = i;\n            }\n        }\n        for i in even_values.iter() {\n    \
    \        if i < smallest_value.len() {\n                smallest_value[i] = i;\n\
    \                smallest_index[i] = i;\n            }\n        }\n        for\
    \ i in even_values.iter() {\n            if i < smallest_value.len() {\n     \
    \           smallest_value[i] = i;\n                smallest_index[i] = i;\n \
    \           }\n        }\n        for i in even_values.iter() {\n            if\
    \ i < smallest_value.len() {\n                smallest_value[i] = i;\n       \
    \         smallest_index[i] = i;\n            }\n        }\n        for i in even_values.iter()\
    \ {\n            if i < smallest_value.len() {\n                smallest_value[i]\
    \ = i;\n                smallest_index[i] = i;\n            }\n        }\n   \
    \     for i in even_values.iter() {\n            if i < smallest_value.len() {\n\
    \                smallest_value[i] = i;\n                smallest_index[i] = i;\n\
    \            }\n        }\n        for i in even_values.iter() {\n           \
    \ if i < smallest_value.len() {\n                smallest_value[i] = i;\n    \
    \            smallest_index[i] = i;\n            }\n        }\n        for i in\
    \ even_values.iter() {\n            if i < smallest_value.len() {\n          \
    \      smallest_value[i] = i;\n                smallest_index[i] = i;\n      \
    \      }\n        }\n        for i in even_values.iter() {\n            if i <\
    \ smallest_value.len() {\n                smallest_value[i] = i;\n           \
    \     smallest_index[i] = i;\n            }\n        }\n        for i in even_values.iter()\
    \ {\n            if \n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp57s0k_bm.rs:123:3\n\
    \    |\n26  | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    |               \
    \                          - unclosed delimiter\n...\n50  |     if even_values.len()\
    \ > 1 {\n    |                              - unclosed delimiter\n...\n109 | \
    \        for i in even_values.iter() {\n    |                                \
    \     - this delimiter might not be properly closed...\n110 |             if \n\
    111 | }\n    | - ...as it matches this but it has different indentation\n...\n\
    123 | }\n    |   ^\n\nerror: expected expression, found `}`\n   --> /tmp/tmp57s0k_bm.rs:111:1\n\
    \    |\n111 | }\n    | ^ expected expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp57s0k_bm.rs:33:20\n   |\n33 |             if i < smallest_value.len()\
    \ {\n   |                    ^^^^^^^^^^^^^^^^^^^^ expected `&isize`, found `usize`\n\
    \nerror[E0277]: the type `[_]` cannot be indexed by `&isize`\n  --> /tmp/tmp57s0k_bm.rs:34:17\n\
    \   |\n34 |                 smallest_value[i] = i;\n   |                 ^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[_]>` is not implemented for `&isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<&isize>` for `Vec<_>`\n\nerror[E0277]:\
    \ the type `[_]` cannot be indexed by `&isize`\n  --> /tmp/tmp57s0k_bm.rs:35:17\n\
    \   |\n35 |                 smallest_index[i] = i;\n   |                 ^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[_]>` is not implemented for `&isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<&isize>` for `Vec<_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp57s0k_bm.rs:38:20\n   |\n38 |             if\
    \ i < smallest_value.len() {\n   |                    ^^^^^^^^^^^^^^^^^^^^ expected\
    \ `&isize`, found `usize`\n\nerror[E0277]: the type `[_]` cannot be indexed by\
    \ `&is"
  stdout: ''
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value: isize =\
    \ 0;\n    let mut smallest_index: usize = 0;\n    let mut smallest_even_value:\
    \ isize = 0;\n    let mut mut_even_value: isize = 0;\n    let mut mut_index: usize\
    \ = 0;\n    let mut mut_index: usize = 0;\n    let mut mut_index: usize = 0;\n\
    \    let mut mut_index: usize = 0;\n    let mut mut_index: usize = 0;\n    let\
    \ mut mut_index: usize = 0;\n    let mut mut_index: usize = 0;\n    let mut mut_index:\
    \ usize = 0;\n    let mut mut_index: usize = 0;\n    let mut mut_index: usize\
    \ = 0;\n    let mut mut_index: usize = 0;\n    let mut mut_index: usize = 0;\n\
    \    let mut mut_index: usize = 0;\n    let mut mut_index: usize = 0;\n    let\
    \ mut mut_index: usize = 0;\n    let mut mut_index: usize = 0;\n    let mut mut_index:\
    \ usize = 0;\n    let mut mut_index: usize = 0;\n    let mut mut_index: usize\
    \ = 0;\n    let mut mut_index: usize = 0;\n    let mut mut_index: usize = 0;\n\
    \    let mut mut_index: usize = 0;\n    let mut mut_index: usize = 0;\n    let\
    \ mut mut_index: usize = 0;\n    let mut mut_index: usize = 0;\n    let mut mut_index:\
    \ usize = 0;\n    let mut mut_index: usize = 0;\n    let mut mut_index: usize\
    \ = 0;\n    let mut mut_index: usize = 0;\n    let mut mut_index: usize = 0;\n\
    \    let mut mut_index: usize = 0;\n    let mut mut_index: usize = 0;\n    let\
    \ mut mut_index: usize = 0;\n    let mut mut_index: usize = 0;\n    let mut mut_index:\
    \ usize = 0;\n    let mut mut_index: usize = 0;\n    let mut mut_index: usize\
    \ = 0;\n    let mut mut_index: usize = 0;\n    let mut mut_index: usize = 0;\n\
    \    let mut mut_index: usize = 0;\n    let mut mut_index: usize = 0;\n    let\
    \ mut mut_index: usize = 0;\n    let mut mut_index: usize = 0;\n    let mut mut_index:\
    \ usize = 0;\n    let mut mut_index: usize = 0;\n    let mut mut_index: usize\
    \ = 0;\n    let mut mut_index: usize\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp2l1g2whj.rs:77:29\n   |\n\
    77 |     let mut mut_index: usize\n   |                             ^ help: add\
    \ `;` here\n78 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2l1g2whj.rs:26:30\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |    -----                     ^^^^^^^^^^ expected struct `Vec`, found\
    \ `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or\
    \ `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n       \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut even_values = vec![];\n\
    \    let mut smallest_value = vec![];\n    let mut smallest_index = vec![];\n\
    \    for i in arr.iter() {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \            if i < smallest_value.len() {\n                smallest_value[i]\
    \ = i;\n                smallest_index[i] = i;\n            }\n        } else\
    \ {\n            if i < smallest_value.len() {\n                smallest_value[i]\
    \ = i;\n                smallest_index[i] = i;\n            }\n        }\n   \
    \ }\n    if even_values.len() == 0 {\n        return vec![];\n    }\n    if even_values.len()\
    \ == 1 {\n        return vec![even_values[0]];\n    }\n    if even_values.len()\
    \ > 1 {\n        let mut smallest_even_value = even_values[0];\n        let mut\
    \ smallest_even_index = even_values[0];\n        for i in even_values.iter().rev()\
    \ {\n            if i % 2 == 0 {\n                if i < smallest_even_value.len()\
    \ {\n                    smallest_even_value = i;\n                    smallest_even_index\
    \ = i;\n                }\n            } else {\n                if i < smallest_even_value.len()\
    \ {\n                    smallest_even_value = i;\n                    smallest_even_index\
    \ = i;\n                }\n            }\n        }\n        return vec![smallest_even_value];\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbj86inof.rs:33:20\n   |\n\
    33 |             if i < smallest_value.len() {\n   |                    ^^^^^^^^^^^^^^^^^^^^\
    \ expected `&isize`, found `usize`\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `&isize`\n  --> /tmp/tmpbj86inof.rs:34:17\n   |\n34 |                 smallest_value[i]\
    \ = i;\n   |                 ^^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>` is not implemented\
    \ for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<&isize>`\
    \ for `Vec<_>`\n\nerror[E0277]: the type `[_]` cannot be indexed by `&isize`\n\
    \  --> /tmp/tmpbj86inof.rs:35:17\n   |\n35 |                 smallest_index[i]\
    \ = i;\n   |                 ^^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>` is not implemented\
    \ for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<&isize>`\
    \ for `Vec<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbj86inof.rs:38:20\n\
    \   |\n38 |             if i < smallest_value.len() {\n   |                  \
    \  ^^^^^^^^^^^^^^^^^^^^ expected `&isize`, found `usize`\n\nerror[E0277]: the\
    \ type `[_]` cannot be indexed by `&isize`\n  --> /tmp/tmpbj86inof.rs:39:17\n\
    \   |\n39 |                 smallest_value[i] = i;\n   |                 ^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[_]>` is not implemented for `&isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<&isize>` for `Vec<_>`\n\nerror[E0277]:\
    \ the type `[_]` cannot be indexed by `&isize`\n  --> /tmp/tmpbj86inof.rs:40:17\n\
    \   |\n40 |                 smallest_index[i] = i;\n   |                 ^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the"
  stdout: ''
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value: isize =\
    \ 0;\n    let mut smallest_index: usize = 0;\n    let mut even_values = Vec::new();\n\
    \    let mut even_values_index: Vec<usize> = Vec::new();\n    for &node in arr\
    \ {\n        if node.value % 2 == 0 {\n            even_values.push(node.value);\n\
    \            even_values_index.push(node.index);\n        }\n        if node.value\
    \ < smallest_value {\n            smallest_value = node.value;\n            smallest_index\
    \ = node.index;\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut smallest_even_value = even_values[0];\n    let mut\
    \ smallest_even_index = even_values_index[0];\n    for &node in even_values.iter().rev()\
    \ {\n        if node < smallest_even_value {\n            smallest_even_value\
    \ = node;\n            smallest_even_index = even_values_index[even_values.iter().rev().position(|&x|\
    \ x == node).unwrap()];\n        }\n    }\n    even_values.clear();\n    even_values_index.clear();\n\
    \    even_values.push(smallest_even_value);\n    even_values_index.push(smallest_even_index);\n\
    \    even_values.sort_unstable();\n    even_values_index.sort_unstable();\n  \
    \  even_values.iter().cloned().collect()\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc2pr4blz.rs:31:9\n   |\n\
    31 |     for &node in arr {\n   |         ^^^^^    --- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `node`\n   |\n\
    \   = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut even_values = vec![];\n\
    \    let mut smallest_value = vec![];\n    let mut smallest_index = vec![];\n\
    \    for i in arr.iter() {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \            if i < smallest_value.len() {\n                smallest_value.push(smallest_value[i]);\n\
    \                smallest_index.push(smallest_index[i]);\n            }\n    \
    \    }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n    }\n\
    \    if even_values.len() == 1 {\n        return vec![even_values[0]];\n    }\n\
    \    if even_values.len() == 2 {\n        if even_values[0] < even_values[1] {\n\
    \            return vec![even_values[0], even_values[1]];\n        } else {\n\
    \            return vec![even_values[1], even_values[0]];\n        }\n    }\n\
    \    if even_values.len() == 3 {\n        if even_values[0] < even_values[1] &&\
    \ even_values[0] < even_values[2] {\n            return vec![even_values[0], even_values[1]];\n\
    \        }\n        if even_values[1] < even_values[2] {\n            return vec![even_values[1],\
    \ even_values[2]];\n        }\n        if even_values[0] < even_values[1] && even_values[1]\
    \ < even_values[2] {\n            return vec![even_values[0], even_values[2]];\n\
    \        }\n        if even_values[0] < even_values[1] && even_values[2] < even_values[2]\
    \ {\n            return vec![even_values[1], even_values[2]];\n        }\n   \
    \ }\n    if even_values.len() == 4 {\n        if even_values[0] < even_values[1]\
    \ && even_values[0] < even_values[2] && even_values[0] < even_values[3] {\n  \
    \          return vec![even_values[0], even_values[1]];\n        }\n        if\
    \ even_values[1] < even_values[2] && even_values[1] < even_values[3] {\n     \
    \       return vec![even_values[1], even_values[2]];\n        }\n        if even_values[2]\
    \ < even_values[3] {\n            return vec![even_values[2], even_values[3]];\n\
    \        }\n    }\n    if even_values.len() == 5 {\n        if even_values[0]\
    \ < even_values[1] && even_values[0] < even_values[2] && even_values[0] < even_values[3]\
    \ && even_values[0] < even_values[4] {\n            return vec![even_values[0],\
    \ even_values[1]];\n        }\n        if even_values[1] < even_values[2] && even_values[1]\
    \ < even_values[3] && even_values[1] < even_values[4] {\n            return vec![even_values[1],\
    \ even_values[2]];\n        }\n        if even_values[2] < even_values[3] && even_values[2]\
    \ < even_value\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpac6pgl48.rs:97:3\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \                       - unclosed delimiter\n...\n77 |     if even_values.len()\
    \ == 5 {\n   |                               - this delimiter might not be properly\
    \ closed...\n...\n85 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n97 | }\n   |   ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmpac6pgl48.rs:85:1\n\
    \   |\n84 |         if even_values[2] < even_values[3] && even_values[2] < even_value\n\
    \   |         -- this `if` expression has a condition, but no block\n85 | }\n\
    \   | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpac6pgl48.rs:33:20\n\
    \   |\n33 |             if i < smallest_value.len() {\n   |                  \
    \  ^^^^^^^^^^^^^^^^^^^^ expected `&isize`, found `usize`\n\nerror[E0277]: the\
    \ type `[_]` cannot be indexed by `&isize`\n  --> /tmp/tmpac6pgl48.rs:34:37\n\
    \   |\n34 |                 smallest_value.push(smallest_value[i]);\n   |    \
    \                                 ^^^^^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>` is\
    \ not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<_>`\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `&isize`\n  --> /tmp/tmpac6pgl48.rs:35:37\n   |\n35 |                 smallest_index.push(smallest_index[i]);\n\
    \   |                                     ^^^^^^^^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>`\
    \ is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpac6pgl48.rs:43:21\n\
    \   |\n43 |         return vec![even_values[0]];\n   |                     ^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n  "
  stdout: ''
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = -1;\n    for i in arr.iter().rev() {\n        if i % 2 ==\
    \ 0 {\n            if min_value < i {\n                min_value = i;\n      \
    \          min_idx = i;\n            }\n        }\n    }\n    if min_idx == -1\
    \ {\n        return vec![];\n    }\n    vec![min_value, min_idx]\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp810vwvta.rs:31:28\n   |\n\
    31 |             if min_value < i {\n   |                            ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    31 |             if min_value < *i {\n   |                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp810vwvta.rs:32:29\n   |\n27 |     let mut min_value\
    \ = arr[0];\n   |                         ------ expected due to this value\n\
    ...\n32 |                 min_value = i;\n   |                             ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    32 |                 min_value = *i;\n   |                             +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp810vwvta.rs:33:27\n   |\n28 |     let mut min_idx\
    \ = -1;\n   |                       -- expected due to this value\n...\n33 | \
    \                min_idx = i;\n   |                           ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n33 |  \
    \               min_idx = *i;\n   |                           +\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_val = arr[0];\n   \
    \ let mut min_idx = 0;\n    let mut min_idx2 = 0;\n    let mut min_idx3 = 0;\n\
    \    let mut min_idx4 = 0;\n    let mut min_idx5 = 0;\n    let mut min_idx6 =\
    \ 0;\n    let mut min_idx7 = 0;\n    let mut min_idx8 = 0;\n    let mut min_idx9\
    \ = 0;\n    let mut min_idx10 = 0;\n    let mut min_idx11 = 0;\n    let mut min_idx12\
    \ = 0;\n    let mut min_idx13 = 0;\n    let mut min_idx14 = 0;\n    let mut min_idx15\
    \ = 0;\n    let mut min_idx16 = 0;\n    let mut min_idx17 = 0;\n    let mut min_idx18\
    \ = 0;\n    let mut min_idx19 = 0;\n    let mut min_idx20 = 0;\n    let mut min_idx21\
    \ = 0;\n    let mut min_idx22 = 0;\n    let mut min_idx23 = 0;\n    let mut min_idx24\
    \ = 0;\n    let mut min_idx25 = 0;\n    let mut min_idx26 = 0;\n    let mut min_idx27\
    \ = 0;\n    let mut min_idx28 = 0;\n    let mut min_idx29 = 0;\n    let mut min_idx30\
    \ = 0;\n    let mut min_idx31 = 0;\n    let mut min_idx32 = 0;\n    let mut min_idx33\
    \ = 0;\n    let mut min_idx34 = 0;\n    let mut min_idx35 = 0;\n    let mut min_idx36\
    \ = 0;\n    let mut min_idx37 = 0;\n    let mut min_idx38 = 0;\n    let mut min_idx39\
    \ = 0;\n    let mut min_idx40 = 0;\n    let mut min_idx41 = 0;\n    let mut min_idx42\
    \ = 0;\n    let mut min_idx43 = 0;\n    let mut min_idx44 = 0;\n    let mut min_idx45\
    \ = 0;\n    let mut min_idx46 = 0;\n    let mut min_idx47 = 0;\n    let mut min_idx48\
    \ = 0;\n    let mut min_idx49 = 0;\n    let mut min_idx50 = 0;\n    let mut min_idx51\
    \ = 0;\n    let mut min_idx52 = 0;\n    let mut min_idx53 = 0;\n    let mut min_idx54\
    \ = 0;\n    let mut min_idx55 = 0;\n    let mut min_idx56 = 0;\n    let mut min_idx57\
    \ = 0;\n    let mut min_idx58 = 0;\n    let mut min_idx59 = 0;\n    let mut min_idx60\
    \ = 0;\n    let mut min_idx61 = 0;\n    let mut min_idx62 = 0;\n    let mut min_idx63\
    \ = 0;\n    let mut min_idx\n}\n\nfn main() {\n    let candidate = pluck;\n  \
    \  assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5rse7rbo.rs:91:20\n   |\n\
    91 |     let mut min_idx\n   |                    ^ help: add `;` here\n92 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5rse7rbo.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 0;\n    let mut min_idx2 = 0;\n    for i in arr.iter().rev()\
    \ {\n        if i % 2 == 0 {\n            if min_value >= i {\n              \
    \  min_value = i;\n                min_idx = i;\n            }\n        } else\
    \ {\n            if min_value >= i {\n                min_value = i;\n       \
    \         min_idx2 = i;\n            }\n        }\n    }\n    if min_idx2 == min_idx\
    \ {\n        min_idx2\n    } else {\n        min_idx\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuilok3yq.rs:32:29\n   |\n\
    32 |             if min_value >= i {\n   |                             ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    32 |             if min_value >= *i {\n   |                             +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpuilok3yq.rs:33:29\n   |\n27 |  \
    \   let mut min_value = arr[0];\n   |                         ------ expected\
    \ due to this value\n...\n33 |                 min_value = i;\n   |          \
    \                   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n33 |                 min_value = *i;\n   |               \
    \              +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuilok3yq.rs:34:27\n\
    \   |\n28 |     let mut min_idx = 0;\n   |                       - expected due\
    \ to this value\n...\n34 |                 min_idx = i;\n   |                \
    \           ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n34 |                 min_idx = *i;\n   |                 \
    \          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuilok3yq.rs:37:29\n\
    \   |\n37 |             if min_value >= i {\n   |                            \
    \ ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n37 |             if min_value >= *i {\n   |                           \
    \  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuilok3yq.rs:38:29\n   |\n\
    27 |     let mut min_value = arr[0];\n   |                         ------ expected\
    \ due to this value\n...\n38 |                 min_value = i;\n   |          \
    \                   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n38 |                 min_value = *i;\n   |               \
    \              +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuilok3yq.rs:39:28\n\
    \   |\n29 |     let mut min_idx2 = 0;\n   |                        - expected\
    \ due to this value\n...\n39 |                 min_idx2 = i;\n   |           \
    \                 ^ expected integer, found `&isize`\n   |\nhelp: consid"
  stdout: ''
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut even_values = vec![];\n\
    \    let mut smallest_value = vec![];\n    let mut smallest_index = vec![];\n\
    \    for i in arr.iter() {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \            if i < smallest_value.len() {\n                smallest_value[i]\
    \ = i;\n                smallest_index[i] = i;\n            }\n        }\n   \
    \ }\n    if even_values.len() == 0 {\n        return vec![];\n    }\n    let mut\
    \ smallest_value_len = even_values.len();\n    for i in even_values.iter() {\n\
    \        if smallest_value[smallest_value_len - 1] == i {\n            smallest_value_len--;\n\
    \        }\n    }\n    for i in 0..smallest_value_len {\n        if even_values[i]\
    \ == smallest_value[i] {\n            smallest_index[i] = even_values[i];\n  \
    \      }\n    }\n    smallest_value\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpop6jvppo.rs:45:33\n\
    \   |\n45 |             smallest_value_len--;\n   |                          \
    \       ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpop6jvppo.rs:33:20\n\
    \   |\n33 |             if i < smallest_value.len() {\n   |                  \
    \  ^^^^^^^^^^^^^^^^^^^^ expected `&isize`, found `usize`\n\nerror[E0277]: the\
    \ type `[_]` cannot be indexed by `&isize`\n  --> /tmp/tmpop6jvppo.rs:34:17\n\
    \   |\n34 |                 smallest_value[i] = i;\n   |                 ^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[_]>` is not implemented for `&isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<&isize>` for `Vec<_>`\n\nerror[E0277]:\
    \ the type `[_]` cannot be indexed by `&isize`\n  --> /tmp/tmpop6jvppo.rs:35:17\n\
    \   |\n35 |                 smallest_index[i] = i;\n   |                 ^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[_]>` is not implemented for `&isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<&isize>` for `Vec<_>`\n\nerror[E0277]:\
    \ can't compare `isize` with `&&isize`\n  --> /tmp/tmpop6jvppo.rs:44:51\n   |\n\
    44 |         if smallest_value[smallest_value_len - 1] == i {\n   |          \
    \                                         ^^ no implementation for `isize == &&isize`\n\
    \   |\n   = help: the trait `PartialEq<&&isize>` is not implemented for `isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpop6jvppo.rs:49:27\n\
    \   |\n49 |         if even_values[i] == smallest_value[i] {\n   |           \
    \                ^^ no imp"
  stdout: ''
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    for i in arr.iter().rev() {\n        if\
    \ i % 2 == 0 {\n            if smallest_value < i {\n                smallest_value\
    \ = i;\n                smallest_index = i;\n            }\n        }\n    }\n\
    \    vec![smallest_value, smallest_index]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmtadrjsg.rs:31:33\n   |\n\
    31 |             if smallest_value < i {\n   |                               \
    \  ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n31 |             if smallest_value < *i {\n   |              \
    \                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmtadrjsg.rs:32:34\n\
    \   |\n27 |     let mut smallest_value = arr[0];\n   |                       \
    \       ------ expected due to this value\n...\n32 |                 smallest_value\
    \ = i;\n   |                                  ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n32 |                 smallest_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmtadrjsg.rs:33:34\n   |\n28 |     let mut smallest_index = 0;\n\
    \   |                              - expected due to this value\n...\n33 |   \
    \              smallest_index = i;\n   |                                  ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    33 |                 smallest_index = *i;\n   |                              \
    \    +\n\nerror: aborting due to 3 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value: isize =\
    \ 0;\n    let mut smallest_index: usize = 0;\n    let mut smallest_even_value:\
    \ isize = 0;\n    for &i in arr {\n        if i % 2 == 0 {\n            smallest_even_value\
    \ = i;\n        }\n        if i == smallest_value {\n            smallest_index\
    \ = i;\n        }\n        if i == smallest_even_value {\n            smallest_value\
    \ = i;\n        }\n    }\n    smallest_value\n        .clone()\n        .to_vec()\n\
    \        .iter()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n   --> /tmp/tmpdnplgl2q.rs:148:1\n    |\n\
    148 | }\n    | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdnplgl2q.rs:30:9\n\
    \   |\n30 |     for &i in arr {\n   |         ^^    --- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `i`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdnplgl2q.rs:35:30\n   |\n28 |     let mut smallest_index:\
    \ usize = 0;\n   |                             ----- expected due to this type\n\
    ...\n35 |             smallest_index = i;\n   |                              ^\
    \ expected `usize`, found `isize`\n\nerror[E0599]: no method named `to_vec` found\
    \ for type `isize` in the current scope\n  --> /tmp/tmpdnplgl2q.rs:43:10\n   |\n\
    43 |         .to_vec()\n   |          ^^^^^^ help: there is an associated function\
    \ with a similar name: `to_be`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    let mut even_value = false;\n    for i in\
    \ arr.iter() {\n        if i % 2 == 0 {\n            even_value = true;\n    \
    \    }\n        if i == smallest_value {\n            smallest_index = i;\n  \
    \      }\n        if even_value\n            && smallest_value == i\n        \
    \    && smallest_index == i\n        {\n            smallest_value = i;\n    \
    \        smallest_index = i;\n            even_value = false;\n        }\n   \
    \ }\n    if even_value\n        && smallest_value == smallest_index\n        &&\
    \ smallest_index == arr.len() - 1\n    {\n        smallest_value = smallest_index;\n\
    \        smallest_index = arr.len() - 1;\n    }\n    vec![smallest_value, smallest_index]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpjcq4nko1.rs:34:14\n\
    \   |\n34 |         if i == smallest_value {\n   |              ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpjcq4nko1.rs:35:30\n   |\n28 |     let mut smallest_index = 0;\n   |\
    \                              - expected due to this value\n...\n35 |       \
    \      smallest_index = i;\n   |                              ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n35 |  \
    \           smallest_index = *i;\n   |                              +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjcq4nko1.rs:38:34\n   |\n38 |             &&\
    \ smallest_value == i\n   |                                  ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n38 |  \
    \           && smallest_value == *i\n   |                                  +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpjcq4nko1.rs:41:30\n   |\n27 |\
    \     let mut smallest_value = arr[0];\n   |                              ------\
    \ expected due to this value\n...\n41 |             smallest_value = i;\n   |\
    \                              ^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n41 |             smallest_value = *i;\n\
    \   |                              +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpjcq4nko1.rs:42:30\n   |\n28 |     let mut smallest_index = 0;\n   |\
    \                              - expected due to this value\n...\n42 |       \
    \      smallest_index = i;\n   |                              ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n42 |  \
    \           smallest_index = *i;\n   |                              +\n\nerror[E0277]:\
    \ can't"
  stdout: ''
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 0;\n    for idx in 0..arr.len() {\n        if arr[idx] %\
    \ 2 == 0 {\n            if min_value < arr[idx] {\n                min_value =\
    \ arr[idx];\n                min_idx = idx;\n            }\n        }\n    }\n\
    \    vec![min_value, min_idx]\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt_s4re56.rs:37:21\n   |\n\
    37 |     vec![min_value, min_idx]\n   |                     ^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n37 |     vec![min_value, min_idx.try_into().unwrap()]\n\
    \   |                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smalest_value = arr[0];\n\
    \    let mut smalest_index = 0;\n    let mut even_values = Vec::new();\n    for\
    \ i in arr.iter().rev() {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \        }\n        if i == smalest_value {\n            smalest_index = even_values.len();\n\
    \        }\n        if i == smalest_value {\n            smalest_value = i;\n\
    \        }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n \
    \   }\n    even_values.sort_unstable_by_key(|x| x);\n    even_values.reverse();\n\
    \    even_values.first().unwrap()\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp7qlvo78w.rs:34:14\n\
    \   |\n34 |         if i == smalest_value {\n   |              ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7qlvo78w.rs:38:29\n\
    \   |\n38 |             smalest_value = i;\n   |                             ^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n38 |             smalest_value = *i;\n   |                            \
    \ +\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp7qlvo78w.rs:37:14\n\
    \   |\n37 |         if i == smalest_value {\n   |              ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7qlvo78w.rs:46:5\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \            ---------- expected `Vec<isize>` because of return type\n...\n46\
    \ |     even_values.first().unwrap()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `&&isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found reference `&&isize`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = i32::MAX;\n\
    \    let mut min_idx = -1;\n    for i in arr.iter() {\n        if min_value <\
    \ i {\n            min_value = i;\n            min_idx = i;\n        }\n    }\n\
    \    if min_value == i32::MAX {\n        return vec![];\n    }\n    let mut mut_arr\
    \ = arr.to_vec();\n    mut_arr[min_idx] = i32::MAX;\n    return mut_arr;\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1i_l2g20.rs:30:24\n   |\n\
    30 |         if min_value < i {\n   |                        ^ expected `i32`,\
    \ found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1i_l2g20.rs:31:25\n\
    \   |\n31 |             min_value = i;\n   |                         ^ expected\
    \ `i32`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1i_l2g20.rs:32:23\n\
    \   |\n32 |             min_idx = i;\n   |                       ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n32 |  \
    \           min_idx = *i;\n   |                       +\n\nerror[E0277]: the trait\
    \ bound `usize: Neg` is not satisfied\n  --> /tmp/tmp1i_l2g20.rs:28:23\n   |\n\
    28 |     let mut min_idx = -1;\n   |                       ^^ the trait `Neg`\
    \ is not implemented for `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1i_l2g20.rs:39:24\n\
    \   |\n39 |     mut_arr[min_idx] = i32::MAX;\n   |                        ^^^^^^^^\
    \ expected `isize`, found `i32`\n\nerror: aborting due to 5 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value: isize =\
    \ 0;\n    let mut smallest_index: usize = 0;\n    let mut even_value: isize =\
    \ 0;\n    let mut even_index: usize = 0;\n    let mut index: usize = 0;\n    let\
    \ mut value: isize = 0;\n    for &i in arr {\n        if i % 2 == 0 {\n      \
    \      even_value = i;\n            even_index = index;\n        }\n        if\
    \ i < smallest_value {\n            smallest_value = i;\n            smallest_index\
    \ = index;\n        }\n        if i == smallest_value {\n            index = smallest_index;\n\
    \        }\n        index += 1;\n    }\n    if even_index == 0 {\n        return\
    \ vec![];\n    }\n    return vec![even_index, even_value];\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbmi0bmu8.rs:33:9\n   |\n\
    33 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbmi0bmu8.rs:50:17\n   |\n50 |     return vec![even_index,\
    \ even_value];\n   |                 ^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n50 |     return vec![even_index.try_into().unwrap(),\
    \ even_value];\n   |                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value: isize =\
    \ 0;\n    let mut smallest_index: usize = 0;\n    let mut even_values = false;\n\
    \    for &i in arr {\n        if i % 2 == 0 {\n            even_values = true;\n\
    \        }\n        if even_values {\n            if smallest_value < i {\n  \
    \              smallest_value = i;\n                smallest_index = i;\n    \
    \        }\n        } else {\n            if smallest_value < i {\n          \
    \      smallest_value = i;\n                smallest_index = i;\n            }\n\
    \        }\n    }\n    if even_values {\n        vec![smallest_value, smallest_index]\n\
    \    } else {\n        vec![]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyoaij96q.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpyoaij96q.rs:37:34\n   |\n37 |                 smallest_index\
    \ = i;\n   |                                  ^ expected `usize`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyoaij96q.rs:42:34\n   |\n42 |\
    \                 smallest_index = i;\n   |                                  ^\
    \ expected `usize`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyoaij96q.rs:47:30\n\
    \   |\n47 |         vec![smallest_value, smallest_index]\n   |               \
    \               ^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you\
    \ can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n47 |         vec![smallest_value, smallest_index.try_into().unwrap()]\n\
    \   |                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = -1;\n    for i in arr.iter().rev() {\n        if i % 2 ==\
    \ 0 {\n            if min_value == i {\n                min_idx = i;\n       \
    \     } else {\n                min_value = i;\n                min_idx = i;\n\
    \            }\n        }\n    }\n    if min_idx == -1 || min_value == arr[0]\
    \ {\n        return vec![];\n    }\n    vec![min_value, min_idx]\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr3y0g4ty.rs:31:29\n   |\n\
    31 |             if min_value == i {\n   |                             ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    31 |             if min_value == *i {\n   |                             +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpr3y0g4ty.rs:32:27\n   |\n32 |  \
    \               min_idx = i;\n   |                           ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n32 |  \
    \               min_idx = *i;\n   |                           +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpr3y0g4ty.rs:34:29\n   |\n34 |              \
    \   min_value = i;\n   |                             ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n34 |        \
    \         min_value = *i;\n   |                             +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpr3y0g4ty.rs:35:27\n   |\n35 |              \
    \   min_idx = i;\n   |                           ^ expected integer, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n35 |                 min_idx\
    \ = *i;\n   |                           +\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value: isize =\
    \ 0;\n    let mut smallest_index: isize = 0;\n    let mut even_values = Vec::new();\n\
    \    for &i in arr {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \        }\n        if i == smallest_value {\n            smallest_index = i;\n\
    \        }\n        if i == smallest_value {\n            smallest_value = i;\n\
    \        }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n \
    \   }\n    let mut smallest_even_value = even_values[0];\n    let mut smallest_even_index\
    \ = even_values[0];\n    for &i in even_values {\n        if i < smallest_even_value\
    \ {\n            smallest_even_value = i;\n            smallest_even_index = i;\n\
    \        }\n    }\n    vec![smallest_even_index, smallest_even_value]\n}\n\nfn\
    \ main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptqgzp7k5.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmptqgzp7k5.rs:46:9\n   |\n46 |     for &i in even_values\
    \ {\n   |         ^^    ----------- this expression has type `isize`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even_value = arr[0];\n\
    \    let mut min_even_index = -1;\n    let mut min_even_index_in_vec = 0;\n  \
    \  let mut min_even_index_in_vec_prev = 0;\n    let mut min_even_index_in_vec_next\
    \ = 0;\n    let mut min_even_index_in_vec_next2 = 0;\n    let mut min_even_index_in_vec_next3\
    \ = 0;\n    let mut min_even_index_in_vec_next4 = 0;\n    let mut min_even_index_in_vec_next5\
    \ = 0;\n    let mut min_even_index_in_vec_next6 = 0;\n    let mut min_even_index_in_vec_next7\
    \ = 0;\n    let mut min_even_index_in_vec_next8 = 0;\n    let mut min_even_index_in_vec_next9\
    \ = 0;\n    let mut min_even_index_in_vec_next10 = 0;\n    let mut min_even_index_in_vec_next11\
    \ = 0;\n    let mut min_even_index_in_vec_next12 = 0;\n    let mut min_even_index_in_vec_next13\
    \ = 0;\n    let mut min_even_index_in_vec_next14 = 0;\n    let mut min_even_index_in_vec_next15\
    \ = 0;\n    let mut min_even_index_in_vec_next16 = 0;\n    let mut min_even_index_in_vec_next17\
    \ = 0;\n    let mut min_even_index_in_vec_next18 = 0;\n    let mut min_even_index_in_vec_next19\
    \ = 0;\n    let mut min_even_index_in_vec_next20 = 0;\n    let mut min_even_index_in_vec_next21\
    \ = 0;\n    let mut min_even_index_in_vec_next22 = 0;\n    let mut min_even_index_in_vec_next23\
    \ = 0;\n    let mut min_even_index_in_vec_next24 = 0;\n    let mut min_even_index_in_vec_next25\
    \ = 0;\n    let mut min_even_index_in_vec_next26 = 0;\n    let mut min_even_index_in_vec_next27\
    \ = 0;\n    let mut min_even_index_in_vec_next28 = 0;\n    let mut min_even_index_in_vec_next29\
    \ = 0;\n    let mut min_even_index_in_vec_next30 = 0;\n    let mut min_even_index_in_vec_next31\
    \ = 0;\n    let mut min_even_index_in_vec_next32 = 0;\n    let mut min_even_index_in_vec_next33\
    \ = 0;\n    let mut min_even_index_in_vec_next34 = 0;\n    let mut min_even_index_in_vec_next35\
    \ = 0;\n    let mut min_even_index_in_vec_next36 = 0;\n    let mut min_even_index_in_vec_next37\
    \ = 0;\n    let mut min_even_index_in_vec_next38 = 0;\n    let mut min_even_index_in_vec_next39\
    \ = 0;\n    let mut min_even_index_in_vec_next40 = 0;\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpeouxg2cq.rs:26:30\n   |\n\
    26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----                \
    \     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_val = arr[0];\n   \
    \ let mut min_idx = 1;\n    let mut min_idx2 = 0;\n    let mut min_idx3 = 0;\n\
    \    let mut min_idx4 = 0;\n    let mut min_idx5 = 0;\n    let mut min_idx6 =\
    \ 0;\n    let mut min_idx7 = 0;\n    let mut min_idx8 = 0;\n    let mut min_idx9\
    \ = 0;\n    let mut min_idx10 = 0;\n    let mut min_idx11 = 0;\n    let mut min_idx12\
    \ = 0;\n    let mut min_idx13 = 0;\n    let mut min_idx14 = 0;\n    let mut min_idx15\
    \ = 0;\n    let mut min_idx16 = 0;\n    let mut min_idx17 = 0;\n    let mut min_idx18\
    \ = 0;\n    let mut min_idx19 = 0;\n    let mut min_idx20 = 0;\n    let mut min_idx21\
    \ = 0;\n    let mut min_idx22 = 0;\n    let mut min_idx23 = 0;\n    let mut min_idx24\
    \ = 0;\n    let mut min_idx25 = 0;\n    let mut min_idx26 = 0;\n    let mut min_idx27\
    \ = 0;\n    let mut min_idx28 = 0;\n    let mut min_idx29 = 0;\n    let mut min_idx30\
    \ = 0;\n    let mut min_idx31 = 0;\n    let mut min_idx32 = 0;\n    let mut min_idx33\
    \ = 0;\n    let mut min_idx34 = 0;\n    let mut min_idx35 = 0;\n    let mut min_idx36\
    \ = 0;\n    let mut min_idx37 = 0;\n    let mut min_idx38 = 0;\n    let mut min_idx39\
    \ = 0;\n    let mut min_idx40 = 0;\n    let mut min_idx41 = 0;\n    let mut min_idx42\
    \ = 0;\n    let mut min_idx43 = 0;\n    let mut min_idx44 = 0;\n    let mut min_idx45\
    \ = 0;\n    let mut min_idx46 = 0;\n    let mut min_idx47 = 0;\n    let mut min_idx48\
    \ = 0;\n    let mut min_idx49 = 0;\n    let mut min_idx50 = 0;\n    let mut min_idx51\
    \ = 0;\n    let mut min_idx52 = 0;\n    let mut min_idx53 = 0;\n    let mut min_idx54\
    \ = 0;\n    let mut min_idx55 = 0;\n    let mut min_idx56 = 0;\n    let mut min_idx57\
    \ = 0;\n    let mut min_idx58 = 0;\n    let mut min_idx59 = 0;\n    let mut min_idx60\
    \ = 0;\n    let mut min_idx61 = 0;\n    let mut min_idx62 = 0;\n    let mut min_idx63\
    \ = 0;\n    let mut min_idx\n}\n\nfn main() {\n    let candidate = pluck;\n  \
    \  assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpqiwbapwi.rs:91:20\n   |\n\
    91 |     let mut min_idx\n   |                    ^ help: add `;` here\n92 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqiwbapwi.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 0;\n    let mut min_idx2 = 0;\n    let mut min_idx3 = 0;\n\
    \    let mut min_idx4 = 0;\n    let mut min_idx5 = 0;\n    let mut min_idx6 =\
    \ 0;\n    let mut min_idx7 = 0;\n    let mut min_idx8 = 0;\n    let mut min_idx9\
    \ = 0;\n    let mut min_idx10 = 0;\n    let mut min_idx11 = 0;\n    let mut min_idx12\
    \ = 0;\n    let mut min_idx13 = 0;\n    let mut min_idx14 = 0;\n    let mut min_idx15\
    \ = 0;\n    let mut min_idx16 = 0;\n    let mut min_idx17 = 0;\n    let mut min_idx18\
    \ = 0;\n    let mut min_idx19 = 0;\n    let mut min_idx20 = 0;\n    let mut min_idx21\
    \ = 0;\n    let mut min_idx22 = 0;\n    let mut min_idx23 = 0;\n    let mut min_idx24\
    \ = 0;\n    let mut min_idx25 = 0;\n    let mut min_idx26 = 0;\n    let mut min_idx27\
    \ = 0;\n    let mut min_idx28 = 0;\n    let mut min_idx29 = 0;\n    let mut min_idx30\
    \ = 0;\n    let mut min_idx31 = 0;\n    let mut min_idx32 = 0;\n    let mut min_idx33\
    \ = 0;\n    let mut min_idx34 = 0;\n    let mut min_idx35 = 0;\n    let mut min_idx36\
    \ = 0;\n    let mut min_idx37 = 0;\n    let mut min_idx38 = 0;\n    let mut min_idx39\
    \ = 0;\n    let mut min_idx40 = 0;\n    let mut min_idx41 = 0;\n    let mut min_idx42\
    \ = 0;\n    let mut min_idx43 = 0;\n    let mut min_idx44 = 0;\n    let mut min_idx45\
    \ = 0;\n    let mut min_idx46 = 0;\n    let mut min_idx47 = 0;\n    let mut min_idx48\
    \ = 0;\n    let mut min_idx49 = 0;\n    let mut min_idx50 = 0;\n    let mut min_idx51\
    \ = 0;\n    let mut min_idx52 = 0;\n    let mut min_idx53 = 0;\n    let mut min_idx54\
    \ = 0;\n    let mut min_idx55 = 0;\n    let mut min_idx56 = 0;\n    let mut min_idx57\
    \ = 0;\n    let mut min_idx58 = 0;\n    let mut min_idx59 = 0;\n    let mut min_idx60\
    \ = 0;\n    let mut min_idx61 = 0;\n    let mut min_idx62 = 0;\n    let mut min_idx63\
    \ = 0;\n    let mut min_idx\n}\n\nfn main() {\n    let candidate = pluck;\n  \
    \  assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_84wucx7.rs:91:20\n   |\n\
    91 |     let mut min_idx\n   |                    ^ help: add `;` here\n92 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_84wucx7.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value: isize =\
    \ 0;\n    let mut smallest_index: usize = 0;\n    let mut even_values = Vec::new();\n\
    \    for &i in arr {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \        }\n        if i == smallest_value {\n            smallest_index = arr.iter().position(|&i|\
    \ i == smallest_value).unwrap();\n        }\n        if i == smallest_value {\n\
    \            smallest_value = i;\n        }\n    }\n    if even_values.len() ==\
    \ 0 {\n        return vec![];\n    }\n    let mut smallest_even_value = even_values[0];\n\
    \    let mut smallest_even_index = smallest_index;\n    for &i in even_values\
    \ {\n        if i < smallest_even_value {\n            smallest_even_value = i;\n\
    \            smallest_even_index = arr.iter().position(|&i| i == smallest_even_value).unwrap();\n\
    \        }\n    }\n    vec![smallest_even_value,smallest_even_index]\n}\n\nfn\
    \ main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4r6pmo8e.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4r6pmo8e.rs:46:9\n   |\n46 |     for &i in even_values\
    \ {\n   |         ^^    ----------- this expression has type `isize`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp4r6pmo8e.rs:52:30\n   |\n52 |     vec![smallest_even_value,smallest_even_index]\n\
    \   |                              ^^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n52 |     vec![smallest_even_value,smallest_even_index.try_into().unwrap()]\n\
    \   |                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 1;\n    let mut min_even_val = 0;\n    for &i in arr {\n\
    \        if i % 2 == 0 {\n            min_even_val = i;\n        }\n        if\
    \ min_even_val < i {\n            min_value = i;\n            min_idx = i;\n \
    \           min_even_val = i;\n        }\n    }\n    if min_even_val == 0 {\n\
    \        return vec![];\n    }\n    let mut min_even_val_idx = 1;\n    let mut\
    \ min_even_val_idx = 1;\n    for &i in arr {\n        if i % 2 == 0 {\n      \
    \      if min_even_val_idx == min_even_val {\n                min_even_val_idx\
    \ = i;\n            }\n        } else {\n            if min_even_val_idx == min_even_val\
    \ {\n                min_even_val_idx = i;\n            }\n        }\n    }\n\
    \    let mut min_even_val_idx = 1;\n    let mut min_even_val_idx = 1;\n    for\
    \ &i in arr {\n        if i % 2 == 0 {\n            if min_even_val_idx == min_even_val\
    \ {\n                min_even_val_idx = i;\n            }\n        } else {\n\
    \            if min_even_val_idx == min_even_val {\n                min_even_val_idx\
    \ = i;\n            }\n        }\n    }\n    if min_even_val_idx == min_even_val\
    \ {\n        return vec![min_even_val, min_even_val_idx];\n    }\n    return vec![];\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfpism30h.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfpism30h.rs:45:9\n   |\n45 |     for &i in arr {\n   |\
    \         ^^    --- this expression has type `isize`\n   |         |\n   |   \
    \      expected `isize`, found reference\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfpism30h.rs:58:9\n\
    \   |\n58 |     for &i in arr {\n   |         ^^    --- this expression has type\
    \ `isize`\n   |         |\n   |         expected `isize`, found reference\n  \
    \ |\n   = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 0;\n    for i in arr.iter().rev() {\n        if i % 2 ==\
    \ 0 {\n            if min_value > i {\n                min_value = i;\n      \
    \          min_idx = i;\n            }\n        }\n    }\n    vec![min_value,\
    \ min_idx]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjzjh771y.rs:31:28\n   |\n\
    31 |             if min_value > i {\n   |                            ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    31 |             if min_value > *i {\n   |                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjzjh771y.rs:32:29\n   |\n32 |              \
    \   min_value = i;\n   |                             ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n32 |        \
    \         min_value = *i;\n   |                             +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjzjh771y.rs:33:27\n   |\n33 |              \
    \   min_idx = i;\n   |                           ^ expected integer, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n33 |                 min_idx\
    \ = *i;\n   |                           +\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut even_values = vec![];\n\
    \    let mut smallest_value = vec![];\n    let mut smallest_index = vec![];\n\
    \    for i in arr {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \            if i < smallest_value.len() {\n                smallest_value[i]\
    \ = i;\n                smallest_index[i] = i;\n            }\n        }\n   \
    \ }\n    if even_values.len() == 0 {\n        return vec![];\n    }\n    for i\
    \ in even_values {\n        if smallest_value[i] == i {\n            smallest_index[i]\
    \ = i;\n        }\n    }\n    for i in even_values {\n        if smallest_value[i]\
    \ == i {\n            smallest_index[i] = i;\n        }\n    }\n    for i in even_values\
    \ {\n        if smallest_value[i] == i {\n            smallest_index[i] = i;\n\
    \        }\n    }\n    for i in even_values {\n        if smallest_value[i] ==\
    \ i {\n            smallest_index[i] = i;\n        }\n    }\n    for i in even_values\
    \ {\n        if smallest_value[i] == i {\n            smallest_index[i] = i;\n\
    \        }\n    }\n    for i in even_values {\n        if smallest_value[i] ==\
    \ i {\n            smallest_index[i] = i;\n        }\n    }\n    for i in even_values\
    \ {\n        if smallest_value[i] == i {\n            smallest_index[i] = i;\n\
    \        }\n    }\n    for i in even_values {\n        if smallest_value[i] ==\
    \ i {\n            smallest_index[i] = i;\n        }\n    }\n    for i in even_values\
    \ {\n        if smallest_value[i] == i {\n            smallest_index[i] = i;\n\
    \        }\n    }\n    for i in even_values {\n        if smallest_value[i] ==\
    \ i {\n            smallest_index[i] = i;\n        }\n    }\n    for i in even_values\
    \ {\n        if smallest_value[i] == i {\n            smallest_index[i] = i;\n\
    \        }\n    }\n    for i in even_values {\n        if smallest_value[i] ==\
    \ i {\n            smallest_index[i] = i;\n        }\n    }\n    for i in even_values\
    \ {\n        if smallest_value[i] == i {\n            smallest_index[i] = i;\n\
    \        }\n    }\n    for i in even_values {\n        if smallest_value[i] ==\
    \ i {\n            smallest_index[i] = i;\n        }\n    }\n    for i in even_values\
    \ {\n        if smallest_value[i] == i {\n            smallest_index[i] = i;\n\
    \        }\n    }\n    for i in even_values {\n        if smallest_value[i] ==\
    \ i {\n            smallest_index[i] = i;\n        }\n    }\n    for i in even_values\
    \ {\n        if smallest_value[i] == i {\n            smallest_index[i] = i;\n\
    \        }\n    }\n    for i in even_values {\n        if smallest_value[i] ==\
    \ i {\n            smallest_\n}\n\nfn main() {\n    let candidate = pluck;\n \
    \   assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpg48qgby3.rs:142:3\n\
    \    |\n26  | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    |               \
    \                          - unclosed delimiter\n...\n127 |     for i in even_values\
    \ {\n    |                          - unclosed delimiter\n128 |         if smallest_value[i]\
    \ == i {\n    |                                   - this delimiter might not be\
    \ properly closed...\n129 |             smallest_\n130 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n142 | }\n    |   ^\n\nerror[E0425]:\
    \ cannot find value `smallest_` in this scope\n   --> /tmp/tmpg48qgby3.rs:129:13\n\
    \    |\n129 |             smallest_\n    |             ^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg48qgby3.rs:33:20\n\
    \   |\n33 |             if i < smallest_value.len() {\n   |                  \
    \  ^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    33 |             if i < smallest_value.len().try_into().unwrap() {\n   |     \
    \               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the\
    \ type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmpg48qgby3.rs:34:17\n \
    \  |\n34 |                 smallest_value[i] = i;\n   |                 ^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[_]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<_>`\n\nerror[E0277]:\
    \ the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmpg48qgby3.rs:35:17\n\
    \   |\n35 |                 smallest_index[i] = i;\n   |                 ^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[_]>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<_>`\n\nerror[E0277]:\
    \ the type `[_]` cannot be indexed by `isize`\n  --> /tmp/tmpg48qgby3.rs:43:12\n\
    \   |\n43 |"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut min_idx = -1;\n    for i in arr.iter() {\n        if i % 2 == 0 {\n\
    \            if min_val < i {\n                min_val = i;\n                min_idx\
    \ = i;\n            }\n        }\n    }\n    if min_val == std::i32::MAX {\n \
    \       return vec![];\n    }\n    let mut result = vec![];\n    for i in arr.iter()\
    \ {\n        if i % 2 == 0 {\n            result.push(min_val);\n            break;\n\
    \        }\n    }\n    if result.len() == 0 {\n        return vec![];\n    }\n\
    \    let mut min_val = std::i32::MAX;\n    let mut min_idx = -1;\n    for i in\
    \ result.iter() {\n        if i < min_val {\n            min_val = i;\n      \
    \      min_idx = i;\n        }\n    }\n    vec![min_val, min_idx]\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpegwjyt0r.rs:31:26\n   |\n\
    31 |             if min_val < i {\n   |                          ^ expected `i32`,\
    \ found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpegwjyt0r.rs:32:27\n\
    \   |\n32 |                 min_val = i;\n   |                           ^ expected\
    \ `i32`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpegwjyt0r.rs:33:27\n\
    \   |\n33 |                 min_idx = i;\n   |                           ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    33 |                 min_idx = *i;\n   |                           +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpegwjyt0r.rs:53:16\n   |\n53 |         if i <\
    \ min_val {\n   |                ^^^^^^^\n   |                |\n   |        \
    \        expected `&i32`, found `i32`\n   |                help: consider borrowing\
    \ here: `&min_val`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpegwjyt0r.rs:54:23\n\
    \   |\n54 |             min_val = i;\n   |                       ^ expected `i32`,\
    \ found `&i32`\n   |\nhelp: consider dereferencing the borrow\n   |\n54 |    \
    \         min_val = *i;\n   |                       +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpegwjyt0r.rs:55:23\n   |\n55 |             min_idx = i;\n\
    \   |                       ^ expected integer, found `&i32`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n55 |             min_idx = *i;\n   |       \
    \                +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpegwjyt0r.rs:58:10\n\
    \   |\n58 |     vec![min_val, min_idx]\n   |          ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n58 |     vec![min_val.try_into().unwrap(),\
    \ min_idx]\n   |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to\
    \ 7 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    let mut smallest_even_value = false;\n \
    \   for &i in arr {\n        if i % 2 == 0 {\n            if smallest_even_value\n\
    \                || (smallest_value >= i && smallest_index == 0)\n           \
    \ {\n                smallest_even_value = true;\n                smallest_value\
    \ = i;\n                smallest_index = i;\n            }\n        } else {\n\
    \            smallest_even_value = false;\n        }\n    }\n    smallest_index\n\
    \        .iter()\n        .map(|i| arr[i])\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9_7uvtbz.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0599]: no\
    \ method named `iter` found for type `isize` in the current scope\n  --> /tmp/tmp9_7uvtbz.rs:44:10\n\
    \   |\n44 |         .iter()\n   |          ^^^^ method not found in `isize`\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value: isize =\
    \ 0;\n    let mut smallest_index: usize = 0;\n    let mut even_values: Vec<isize>\
    \ = Vec::new();\n    for i in arr {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \        }\n        if i == smallest_value {\n            smallest_index = i;\n\
    \        }\n        if i == smallest_value {\n            smallest_value = i;\n\
    \        }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n \
    \   }\n    if even_values.len() == 1 {\n        return vec![even_values[0]];\n\
    \    }\n    if even_values.len() == 2 {\n        return vec![even_values[0], even_values[1]];\n\
    \    }\n    if even_values.len() == 3 {\n        return vec![even_values[0], even_values[1],\
    \ even_values[2]];\n    }\n    if even_values.len() == 4 {\n        return vec![even_values[0],\
    \ even_values[1], even_values[2], even_values[3]];\n    }\n    if even_values.len()\
    \ == 5 {\n        return vec![even_values[0], even_values[1], even_values[2],\
    \ even_values[3], even_values[4]];\n    }\n    if even_values.len() == 6 {\n \
    \       return vec![even_values[0], even_values[1], even_values[2], even_values[3],\
    \ even_values[4], even_values[5]];\n    }\n    if even_values.len() == 7 {\n \
    \       return vec![even_values[0], even_values[1], even_values[2], even_values[3],\
    \ even_values[4], even_values[5], even_values[6]];\n    }\n    if even_values.len()\
    \ == 8 {\n        return vec![even_values[0], even_values[1], even_values[2],\
    \ even_values[3], even_values[4], even_values[5], even_values[6], even_values[7]];\n\
    \    }\n    if even_values.len() == 9 {\n        return vec![even_values[0], even_values[1],\
    \ even_values[2], even_values[3], even_values[4], even_values[5], even_values[6],\
    \ even_values[7], even_values[8]];\n    }\n    if even_values.len() == 10 {\n\
    \        return vec![even_values[0], even_values[1], even_values[2], even_values[3],\
    \ even_values[4], even_values[5], even_values[6], even_values[7], even_values[8],\
    \ even_values[9]];\n    }\n    if even_values.len() == 11 {\n        return vec![even_values[0],\
    \ even_values[1], even_values[2], even_values[3], even_values[4], even_values[5],\
    \ even_values[6], even_values[7], even_values[8], even_values[9], even_values[10]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp51r6m0py.rs:88:3\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \                       - unclosed delimiter\n...\n74 |     if even_values.len()\
    \ == 11 {\n   |                                - this delimiter might not be properly\
    \ closed...\n75 |         return vec![even_values[0], ev...\n76 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n88 | }\n   |   ^\n\n\
    error: mismatched closing delimiter: `}`\n  --> /tmp/tmp51r6m0py.rs:75:20\n  \
    \ |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                    \
    \                     - closing delimiter possibly meant for this\n...\n75 | \
    \        return vec![even_values[0], even_values[1], even_values[2], even_values[3],\
    \ even_values[4], even_values[5], even_values[6], even_...\n   |             \
    \       ^ unclosed delimiter\n76 | }\n   | ^ mismatched closing delimiter\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp51r6m0py.rs:35:30\n   |\n35 |  \
    \           smallest_index = i;\n   |                              ^ expected\
    \ `usize`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp51r6m0py.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 1;\n    for i in 1..arr.len() {\n        if arr[i] < min_value\
    \ {\n            min_value = arr[i];\n            min_idx = i;\n        }\n  \
    \  }\n    vec![min_value, min_idx]\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwp16ng3r.rs:35:21\n   |\n\
    35 |     vec![min_value, min_idx]\n   |                     ^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n35 |     vec![min_value, min_idx.try_into().unwrap()]\n\
    \   |                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 101
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_even_value = arr[0];\n\
    \    let mut smallest_even_index = -1;\n    let mut smallest_even_index_in_vec\
    \ = -1;\n    for i in arr.iter().cloned() {\n        if i % 2 == 0 {\n       \
    \     if smallest_even_index == -1 || smallest_even_value < i {\n            \
    \    smallest_even_value = i;\n                smallest_even_index = i;\n    \
    \            smallest_even_index_in_vec = i;\n            } else {\n         \
    \       if smallest_even_index_in_vec < i {\n                    smallest_even_index_in_vec\
    \ = i;\n                }\n            }\n        }\n    }\n    if smallest_even_index\
    \ == -1 {\n        return vec![];\n    }\n    let mut result = vec![smallest_even_value];\n\
    \    for i in 0..smallest_even_index_in_vec {\n        result.push(i);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 0, 1, 2, 3]`,\n right: `[2, 1]`', /tmp/tmpw4jlvejo.rs:55:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    for &i in arr {\n        if i % 2 == 0 {\n\
    \            if smallest_value < i {\n                smallest_value = i;\n  \
    \              smallest_index = i;\n            }\n        }\n    }\n    vec![smallest_value,\
    \ smallest_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdwakmk9z.rs:29:9\n   |\n\
    29 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_even_value = arr[0];\n\
    \    let mut smallest_even_index = -1;\n    let mut smallest_index = -1;\n   \
    \ let mut even_value_count = 0;\n    for &i in arr {\n        if i % 2 == 0 {\n\
    \            even_value_count += 1;\n            if even_value_count == 1 {\n\
    \                smallest_even_value = i;\n                smallest_even_index\
    \ = i;\n                smallest_index = i;\n            }\n        } else {\n\
    \            even_value_count -= 1;\n        }\n    }\n    if even_value_count\
    \ == 0 {\n        return vec![];\n    }\n    let mut even_values = vec![];\n \
    \   for i in 0..even_value_count {\n        even_values.push(smallest_even_index);\n\
    \    }\n    even_values.push(smallest_index);\n    return even_values;\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3efvre8c.rs:31:9\n   |\n\
    31 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_val = arr[0];\n   \
    \ let mut min_idx = 0;\n    let mut min_idx = arr.iter().enumerate().min_by_key(|(_,\
    \ v)| {\n        if v < min_val {\n            min_val = v;\n            min_idx\
    \ = *;\n        }\n    });\n    min_idx\n}\n\nfn main() {\n    let candidate =\
    \ pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp022hhui5.rs:32:24\n\
    \   |\n32 |             min_idx = *;\n   |                        ^ expected expression\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp022hhui5.rs:30:16\n   |\n30 |\
    \         if v < min_val {\n   |                ^^^^^^^ expected `&&isize`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp022hhui5.rs:31:23\n\
    \   |\n31 |             min_val = v;\n   |                       ^ expected `isize`,\
    \ found `&&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp022hhui5.rs:35:5\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \            ---------- expected `Vec<isize>` because of return type\n...\n35\
    \ |     min_idx\n   |     ^^^^^^^ expected struct `Vec`, found enum `Option`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n                found enum `Option<(usize,\
    \ &isize)>`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 101
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_index = 0;\n    for i in arr.iter().cloned() {\n        if i %\
    \ 2 == 0 {\n            if min_value < i {\n                min_value = i;\n \
    \               min_index = i;\n            }\n        }\n    }\n    vec![min_value,\
    \ min_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 0]`,\n right: `[2, 1]`', /tmp/tmp6pkmw8pd.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_even_value = arr[0];\n\
    \    let mut smallest_even_index = -1;\n    let mut smallest_index = -1;\n   \
    \ for &i in arr {\n        if i % 2 == 0 {\n            if smallest_even_value\
    \ < i {\n                smallest_even_value = i;\n                smallest_even_index\
    \ = i;\n            }\n        }\n        if smallest_even_value == i {\n    \
    \        if smallest_index < i {\n                smallest_index = i;\n      \
    \      }\n        }\n    }\n    if smallest_even_value == 0 {\n        vec![]\n\
    \    } else {\n        vec![smallest_even_index, smallest_index]\n    }\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3t8mh4z1.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_even_value = arr[0];\n\
    \    let mut smallest_even_index = -1;\n    let mut smallest_even_value_found\
    \ = false;\n    for &mut value in arr.iter_mut() {\n        if value % 2 == 0\
    \ {\n            if smallest_even_value_found {\n                smallest_even_index\
    \ = arr.iter().position(|&x| x == smallest_even_value).unwrap();\n           \
    \     break;\n            }\n            smallest_even_value = value;\n      \
    \      smallest_even_value_found = true;\n        }\n    }\n    if smallest_even_value_found\
    \ {\n        arr.iter_mut().enumerate().filter(|&(i, &v)| v == smallest_even_value).map(|&(i,\
    \ &v)| i).collect()\n    } else {\n        vec![]\n    }\n}\n\nfn main() {\n \
    \   let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpg8wv_usc.rs:28:35\n\
    \   |\n28 |     let mut smallest_even_index = -1;\n   |                      \
    \             ^^ the trait `Neg` is not implemented for `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpg8wv_usc.rs:41:49\n   |\n41 |         arr.iter_mut().enumerate().filter(|&(i,\
    \ &v)| v == smallest_even_value).map(|&(i, &v)| i).collect()\n   |           \
    \                                      ^^- expected due to this\n   |        \
    \                                         |\n   |                            \
    \                     types differ in mutability\n   |                       \
    \                          help: you can probably remove the explicit borrow:\
    \ `v`\n   |\n   = note: expected mutable reference `&mut isize`\n            \
    \          found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg8wv_usc.rs:41:85\n\
    \   |\n41 |         arr.iter_mut().enumerate().filter(|&(i, &v)| v == smallest_even_value).map(|&(i,\
    \ &v)| i).collect()\n   |                                                    \
    \                                 ^^^^^^^-\n   |                             \
    \                                                        |      |\n   |      \
    \                                                                            \
    \   |      expected due to this\n   |                                        \
    \                                             expected tuple, found reference\n\
    \   |\n   = note:  expected tuple `(usize, &mut isize)`\n           found reference\
    \ `&_`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 1;\n    for i in 1..arr.len() {\n        if arr[i] < min_value\
    \ {\n            min_value = arr[i];\n            min_idx = i;\n        }\n  \
    \  }\n    vec![min_value, min_idx]\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwp16ng3r.rs:35:21\n   |\n\
    35 |     vec![min_value, min_idx]\n   |                     ^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n35 |     vec![min_value, min_idx.try_into().unwrap()]\n\
    \   |                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even_value = arr[0];\n\
    \    let mut min_even_index = -1;\n    let mut min_even_index_in_arr = -1;\n \
    \   let mut min_even_index_in_arr_with_min_even_value = -1;\n    let mut min_even_index_in_arr_with_min_even_value_in_arr\
    \ = -1;\n    let mut min_even_index_in_arr_with_min_even_value_in_arr_with_min_even_value\
    \ = -1;\n    let mut min_even_index_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr\
    \ = -1;\n    let mut min_even_index_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value\
    \ = -1;\n    let mut min_even_index_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr\
    \ = -1;\n    let mut min_even_index_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value\
    \ = -1;\n    let mut min_even_index_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr\
    \ = -1;\n    let mut min_even_index_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value\
    \ = -1;\n    let mut min_even_index_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr\
    \ = -1;\n    let mut min_even_index_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value\
    \ = -1;\n    let mut min_even_index_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value\
    \ = -1;\n    let mut min_even_index_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value\
    \ = -1;\n    let mut min_even_index_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value\
    \ = -1;\n    let mut \n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmphm74m018.rs:45:1\n\
    \   |\n45 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut even_values = vec![];\n\
    \    let mut smallest_value = vec![];\n    let mut smallest_index = vec![];\n\
    \    for i in arr.iter() {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \            if i < smallest_value.len() {\n                smallest_value[i]\
    \ = i;\n                smallest_index[i] = i;\n            }\n        }\n   \
    \ }\n    if even_values.len() == 0 {\n        return vec![];\n    }\n    if even_values.len()\
    \ == 1 {\n        return vec![even_values[0]];\n    }\n    if even_values.len()\
    \ > 1 {\n        let mut smallest_value = vec![];\n        let mut smallest_index\
    \ = vec![];\n        for i in even_values.iter() {\n            if i < smallest_value.len()\
    \ {\n                smallest_value[i] = i;\n                smallest_index[i]\
    \ = i;\n            }\n        }\n        let mut smallest_value_iter = smallest_value.iter();\n\
    \        let mut smallest_index_iter = smallest_index.iter();\n        let mut\
    \ smallest_value = vec![];\n        let mut smallest_index = vec![];\n       \
    \ for i in even_values.iter() {\n            if i < smallest_value.len() {\n \
    \               smallest_value.push(smallest_value_iter.next().unwrap());\n  \
    \              smallest_index.push(smallest_index_iter.next().unwrap());\n   \
    \         }\n        }\n        return vec![smallest_value[smallest_value.len()\
    \ - 1], smallest_index[smallest_index.len() - 1]];\n    }\n    return vec![];\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4uo_sj_0.rs:33:20\n   |\n\
    33 |             if i < smallest_value.len() {\n   |                    ^^^^^^^^^^^^^^^^^^^^\
    \ expected `&isize`, found `usize`\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `&isize`\n  --> /tmp/tmp4uo_sj_0.rs:34:17\n   |\n34 |                 smallest_value[i]\
    \ = i;\n   |                 ^^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>` is not implemented\
    \ for `&isize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<_>`\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `&isize`\n  --> /tmp/tmp4uo_sj_0.rs:35:17\n   |\n35 |                 smallest_index[i]\
    \ = i;\n   |                 ^^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>` is not implemented\
    \ for `&isize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4uo_sj_0.rs:43:21\n\
    \   |\n43 |         return vec![even_values[0]];\n   |                     ^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the type\n\
    \   |\n43 |         return vec![*even_values[0]];\n   |                     +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp4uo_sj_0.rs:49:20\n   |\n49 |\
    \             if i < smallest_value.len() {\n   |                    ^^^^^^^^^^^^^^^^^^^^\
    \ expected `&&isize`, found `usize`\n\nerror[E0277]: the type `[_]` cannot be\
    \ indexed by `&&isize`\n  --> /tmp/tmp4uo_sj_0.rs:50:17\n   |\n50 |          \
    \       smallest_value[i] = i;\n   |                 ^^^^^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>`\
    \ is not implemented for `&&isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<&&isize>` for `Vec<_>`\n\nerror[E0277]: the type `[_]`\
    \ cannot be indexed by `&&isize`\n  --> /tmp/tmp4uo_sj_0.rs:51:17\n   |\n51 |\
    \                 smallest_index[i] = i;\n   |"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = -1;\n    for i in arr.iter().rev() {\n        if i % 2 ==\
    \ 0 {\n            if min_value < i {\n                min_value = i;\n      \
    \          min_idx = i;\n            }\n        }\n    }\n    if min_idx == -1\
    \ {\n        return vec![];\n    }\n    vec![min_value, min_idx]\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp810vwvta.rs:31:28\n   |\n\
    31 |             if min_value < i {\n   |                            ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    31 |             if min_value < *i {\n   |                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp810vwvta.rs:32:29\n   |\n27 |     let mut min_value\
    \ = arr[0];\n   |                         ------ expected due to this value\n\
    ...\n32 |                 min_value = i;\n   |                             ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    32 |                 min_value = *i;\n   |                             +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp810vwvta.rs:33:27\n   |\n28 |     let mut min_idx\
    \ = -1;\n   |                       -- expected due to this value\n...\n33 | \
    \                min_idx = i;\n   |                           ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n33 |  \
    \               min_idx = *i;\n   |                           +\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    let mut mut_smallest_value = smallest_value;\n\
    \    let mut mut_smallest_index = smallest_index;\n    let mut mut_mut_smallest_value\
    \ = mut_smallest_value;\n    let mut mut_mut_smallest_index = mut_smallest_index;\n\
    \    let mut mut_mut_mut_smallest_value = mut_mut_smallest_value;\n    let mut\
    \ mut_mut_mut_smallest_index = mut_mut_smallest_index;\n    let mut mut_mut_mut_mut_smallest_value\
    \ = mut_mut_mut_smallest_value;\n    let mut mut_mut_mut_mut_smallest_index =\
    \ mut_mut_mut_smallest_index;\n    let mut mut_mut_mut_mut_mut_smallest_value\
    \ = mut_mut_mut_mut_smallest_value;\n    let mut mut_mut_mut_mut_mut_smallest_index\
    \ = mut_mut_mut_mut_smallest_index;\n    let mut mut_mut_mut_mut_mut_mut_smallest_value\
    \ = mut_mut_mut_mut_smallest_value;\n    let mut mut_mut_mut_mut_mut_mut_smallest_index\
    \ = mut_mut_mut_mut_mut_smallest_index;\n    let mut mut_mut_mut_mut_mut_mut_mut_smallest_value\
    \ = mut_mut_mut_mut_mut_smallest_value;\n    let mut mut_mut_mut_mut_mut_mut_mut_smallest_index\
    \ = mut_mut_mut_mut_mut_mut_smallest_index;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_smallest_value\
    \ = mut_mut_mut_mut_mut_mut_smallest_value;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_index\
    \ = mut_mut_mut_mut_mut_mut_mut_smallest_index;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_value\
    \ = mut_mut_mut_mut_mut_mut_mut_mut_smallest_value;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_index\
    \ = mut_mut_mut_mut_mu\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpn_1i0_zi.rs:46:92\n   |\n\
    46 |     let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_index =\
    \ mut_mut_mut_mut_mu\n   |                                                   \
    \                                         ^ help: add `;` here\n47 | }\n   | -\
    \ unexpected token\n\nerror[E0425]: cannot find value `mut_mut_mut_mut_mu` in\
    \ this scope\n  --> /tmp/tmpn_1i0_zi.rs:46:74\n   |\n46 |     let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_index\
    \ = mut_mut_mut_mut_mu\n   |                                                 \
    \                         ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpn_1i0_zi.rs:26:30\n   |\n26 | fn pluck(arr:\
    \ Vec<isize>) -> Vec<isize> {\n   |    -----                     ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut even_values = vec![];\n\
    \    let mut smallest_value = vec![];\n    let mut smallest_index = vec![];\n\
    \    for i in arr.iter() {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \            if smallest_value.len() == 0 || i < smallest_value[0] {\n       \
    \         smallest_value.push(i);\n                smallest_index.push(i);\n \
    \           }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ vec![];\n    }\n    if smallest_value.len() == 0 {\n        return vec![];\n\
    \    }\n    if even_values.len() == 1 {\n        return vec![smallest_value[0],\
    \ smallest_index[0]];\n    }\n    if even_values.len() == smallest_value.len()\
    \ {\n        return vec![smallest_value[0], smallest_index[0]];\n    }\n    if\
    \ even_values.len() == smallest_value.len() + 1 {\n        return vec![smallest_value[even_values.len()\
    \ - 1], smallest_index[even_values.len() - 1]];\n    }\n    if even_values.len()\
    \ == smallest_value.len() + 2 {\n        return vec![smallest_value[even_values.len()\
    \ - 2], smallest_index[even_values.len() - 2]];\n    }\n    if even_values.len()\
    \ == smallest_value.len() + 3 {\n        return vec![smallest_value[even_values.len()\
    \ - 3], smallest_index[even_values.len() - 3]];\n    }\n    if even_values.len()\
    \ == smallest_value.len() + 4 {\n        return vec![smallest_value[even_values.len()\
    \ - 4], smallest_index[even_values.len() - 4]];\n    }\n    if even_values.len()\
    \ == smallest_value.len() + 5 {\n        return vec![smallest_value[even_values.len()\
    \ - 5], smallest_index[even_values.len() - 5]];\n    }\n    if even_values.len()\
    \ == smallest_value.len() + 6 {\n        return vec![smallest_value[even_values.len()\
    \ - 6], smallest_index[even_values.len() - 6]];\n    }\n    if even_values.len()\
    \ == smallest_value.len() + 7 {\n        return vec![smallest_value[even_values.len()\
    \ - 7], smallest_index[even_values.len() - 7]];\n    }\n    if even_values.len()\
    \ == smallest_value.len() + 8 {\n        return vec![smallest_value[even_values.len()\
    \ - 8], smallest_index[even_values.len() - 8]];\n    }\n    if even_values.len()\
    \ == smallest_value.len() + 9 {\n        return vec![smallest_value[even_values.len(\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp44yzdsm_.rs:89:3\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \                       - unclosed delimiter\n...\n75 |     if even_values.len()\
    \ == smallest_value.len() + 9 {\n   |                                        \
    \              - this delimiter might not be properly closed...\n76 |        \
    \ return vec![smallest_value[even_values.len(\n77 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n89 | }\n   |   ^\n\nerror: mismatched\
    \ closing delimiter: `}`\n  --> /tmp/tmp44yzdsm_.rs:76:51\n   |\n26 | fn pluck(arr:\
    \ Vec<isize>) -> Vec<isize> {\n   |                                         -\
    \ closing delimiter possibly meant for this\n...\n76 |         return vec![smallest_value[even_values.len(\n\
    \   |                                                   ^ unclosed delimiter\n\
    77 | }\n   | ^ mismatched closing delimiter\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp44yzdsm_.rs:46:21\n   |\n46 |         return vec![smallest_value[0],\
    \ smallest_index[0]];\n   |                     ^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the type\n   |\n46 |    \
    \     return vec![*smallest_value[0], smallest_index[0]];\n   |              \
    \       +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp44yzdsm_.rs:49:21\n\
    \   |\n49 |         return vec![smallest_value[0], smallest_index[0]];\n   | \
    \                    ^^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\n\
    help: consider dereferencing the type\n   |\n49 |         return vec![*smallest_value[0],\
    \ smallest_index[0]];\n   |                     +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp44yzdsm_.rs:52:21\n   |\n52 |         return vec![smallest_value[even_values.len()\
    \ - 1], smallest_index[even_values.len() - 1]];\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the type\n\
    \   |\n52 |         return vec![*smallest_value[even_values.len() - 1], smallest_index[even_values.len()\
    \ - 1]];\n   |               "
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 0;\n    for i in arr.iter().rev() {\n        if i % 2 ==\
    \ 0 {\n            min_value = i;\n            min_idx = i;\n        }\n    }\n\
    \    vec![min_value, min_idx]\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvm2upu9t.rs:31:25\n   |\n\
    31 |             min_value = i;\n   |                         ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n31 |  \
    \           min_value = *i;\n   |                         +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvm2upu9t.rs:32:23\n   |\n32 |             min_idx = i;\n\
    \   |                       ^ expected integer, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n32 |             min_idx = *i;\n   |       \
    \                +\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut even_values = vec![];\n\
    \    let mut smallest_value = vec![];\n    let mut smallest_index = vec![];\n\
    \    for i in arr.iter() {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \            if i < smallest_value.len() {\n                smallest_value[i]\
    \ = i;\n                smallest_index[i] = i;\n            } else {\n       \
    \         smallest_value[i] = i;\n                smallest_index[i] = i;\n   \
    \         }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ vec![];\n    }\n    if even_values.len() == 1 {\n        return vec![even_values[0]];\n\
    \    }\n    let mut smallest_value_pos = 0;\n    for i in even_values.iter() {\n\
    \        if smallest_value[smallest_value_pos] < i {\n            smallest_value_pos\
    \ = i;\n        }\n    }\n    for i in even_values.iter() {\n        if i == smallest_value_pos\
    \ {\n            smallest_value.push(smallest_value_pos);\n            smallest_index.push(smallest_value_pos);\n\
    \        }\n    }\n    for i in even_values.iter() {\n        if i == smallest_value_pos\
    \ {\n            smallest_value.push(smallest_value_pos);\n            smallest_index.push(smallest_value_pos);\n\
    \        }\n    }\n    for i in even_values.iter() {\n        if i == smallest_value_pos\
    \ {\n            smallest_value.push(smallest_value_pos);\n            smallest_index.push(smallest_value_pos);\n\
    \        }\n    }\n    for i in even_values.iter() {\n        if i == smallest_value_pos\
    \ {\n            smallest_value.push(smallest_value_pos);\n            smallest_index.push(smallest_value_pos);\n\
    \        }\n    }\n    for i in even_values.iter() {\n        if i == smallest_value_pos\
    \ {\n            smallest_value.push(smallest_value_pos);\n            smallest_index.push(smallest_value_pos);\n\
    \        }\n    }\n    for i in even_values.iter() {\n        if i == smallest_value_pos\
    \ {\n            smallest_value.push(smallest_value_pos);\n            smallest_index.push(smallest_value_pos);\n\
    \        }\n    }\n    for i in even_values.iter() {\n        if i == smallest_value_pos\
    \ {\n            smallest_value.push(smallest_value_pos);\n            smallest_index.push(smallest_value_pos);\n\
    \        }\n    }\n    for i in even_values.iter() {\n        if i == smallest_value_pos\
    \ {\n            smallest_value.push(smallest_value_pos);\n            smallest_index.push(smallest_value_pos);\n\
    \        }\n    }\n    for i in even_values.iter() {\n        if i == smallest_value_pos\
    \ {\n            smallest_value.push(smalle\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpbg34sq0t.rs:117:3\n\
    \    |\n26  | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    |               \
    \                          - unclosed delimiter\n...\n102 |     for i in even_values.iter()\
    \ {\n    |                                 - unclosed delimiter\n103 |       \
    \  if i == smallest_value_pos {\n    |                                    - this\
    \ delimiter might not be properly closed...\n104 |             smallest_value.push(smalle\n\
    105 | }\n    | - ...as it matches this but it has different indentation\n...\n\
    117 | }\n    |   ^\n\nerror: mismatched closing delimiter: `}`\n   --> /tmp/tmpbg34sq0t.rs:104:32\n\
    \    |\n26  | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    |               \
    \                          - closing delimiter possibly meant for this\n...\n\
    104 |             smallest_value.push(smalle\n    |                          \
    \      ^ unclosed delimiter\n105 | }\n    | ^ mismatched closing delimiter\n\n\
    error[E0425]: cannot find value `smalle` in this scope\n   --> /tmp/tmpbg34sq0t.rs:104:33\n\
    \    |\n104 |             smallest_value.push(smalle\n    |                  \
    \               ^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbg34sq0t.rs:33:20\n   |\n33 |             if i < smallest_value.len()\
    \ {\n   |                    ^^^^^^^^^^^^^^^^^^^^ expected `&isize`, found `usize`\n\
    \nerror[E0277]: the type `[_]` cannot be indexed by `&isize`\n  --> /tmp/tmpbg34sq0t.rs:34:17\n\
    \   |\n34 |                 smallest_value[i] = i;\n   |                 ^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[_]>` is not implemented for `&isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<&isize>` for `Vec<_>`\n\n\
    error[E0277]: the type `[_]` cannot be indexed by `&isize`\n  --> /tmp/tmpbg34sq0t.rs:35:17\n\
    \   |\n35 |                 smallest_index[i] = i;\n   |                 ^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[_]>` is not impleme"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_index = 0;\n    let mut min_even_value = false;\n    for &i in\
    \ arr {\n        if i % 2 == 0 {\n            min_even_value = true;\n       \
    \     min_value = i;\n            min_index = i;\n        }\n    }\n    if min_even_value\n\
    \        && min_value > 0\n        && min_index > 0\n        && min_value < arr.len()\
    \ {\n        vec![min_value, min_index]\n    } else {\n        vec![]\n    }\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplonsttjg.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmplonsttjg.rs:40:24\n   |\n40 |         && min_value < arr.len()\
    \ {\n   |                        ^^^^^^^^^ expected `isize`, found `usize`\n \
    \  |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n40 |         && min_value < arr.len().try_into().unwrap()\
    \ {\n   |                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 0;\n    for &i in arr {\n        if i % 2 == 0 {\n     \
    \       if min_value > i {\n                min_value = i;\n                min_idx\
    \ = i;\n            }\n        }\n    }\n    vec![min_value, min_idx]\n}\n\nfn\
    \ main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprit4c3re.rs:29:9\n   |\n\
    29 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even_value = arr[0];\n\
    \    let mut min_even_index = 0;\n    let mut min_even_index_in_arr = 0;\n   \
    \ let mut min_even_index_in_arr2 = 0;\n    let mut min_even_index_in_arr3 = 0;\n\
    \    let mut min_even_index_in_arr4 = 0;\n    let mut min_even_index_in_arr5 =\
    \ 0;\n    let mut min_even_index_in_arr6 = 0;\n    let mut min_even_index_in_arr7\
    \ = 0;\n    let mut min_even_index_in_arr8 = 0;\n    let mut min_even_index_in_arr9\
    \ = 0;\n    let mut min_even_index_in_arr10 = 0;\n    let mut min_even_index_in_arr11\
    \ = 0;\n    let mut min_even_index_in_arr12 = 0;\n    let mut min_even_index_in_arr13\
    \ = 0;\n    let mut min_even_index_in_arr14 = 0;\n    let mut min_even_index_in_arr15\
    \ = 0;\n    let mut min_even_index_in_arr16 = 0;\n    let mut min_even_index_in_arr17\
    \ = 0;\n    let mut min_even_index_in_arr18 = 0;\n    let mut min_even_index_in_arr19\
    \ = 0;\n    let mut min_even_index_in_arr20 = 0;\n    let mut min_even_index_in_arr21\
    \ = 0;\n    let mut min_even_index_in_arr22 = 0;\n    let mut min_even_index_in_arr23\
    \ = 0;\n    let mut min_even_index_in_arr24 = 0;\n    let mut min_even_index_in_arr25\
    \ = 0;\n    let mut min_even_index_in_arr26 = 0;\n    let mut min_even_index_in_arr27\
    \ = 0;\n    let mut min_even_index_in_arr28 = 0;\n    let mut min_even_index_in_arr29\
    \ = 0;\n    let mut min_even_index_in_arr30 = 0;\n    let mut min_even_index_in_arr31\
    \ = 0;\n    let mut min_even_index_in_arr32 = 0;\n    let mut min_even_index_in_arr33\
    \ = 0;\n    let mut min_even_index_in_arr34 = 0;\n    let mut min_even_index_in_arr35\
    \ = 0;\n    let mut min_even_index_in_arr36 = 0;\n    let mut min_even_index_in_arr37\
    \ = 0;\n    let mut min_even_index_in_arr38 = 0;\n    let mut min_even_index_in_arr39\
    \ = 0;\n    let mut min_even_index_in_arr40 = 0;\n    let mut min_even_index_in_arr41\
    \ = 0;\n    let mut min_even_index_in_arr42 = 0;\n    let mut min_even_index_in_arr43\
    \ = 0;\n    let mut min_even_index_in_arr44 = 0;\n    let mut min_even_index_in_arr45\
    \ = 0;\n    let mut min_even\n}\n\nfn main() {\n    let candidate = pluck;\n \
    \   assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpi94ao66w.rs:74:21\n   |\n\
    74 |     let mut min_even\n   |                     ^ help: add `;` here\n75 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi94ao66w.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 0;\n    let mut min_idx2 = 0;\n    let mut min_idx3 = 0;\n\
    \    let mut min_idx4 = 0;\n    let mut min_idx5 = 0;\n    let mut min_idx6 =\
    \ 0;\n    let mut min_idx7 = 0;\n    let mut min_idx8 = 0;\n    let mut min_idx9\
    \ = 0;\n    let mut min_idx10 = 0;\n    let mut min_idx11 = 0;\n    let mut min_idx12\
    \ = 0;\n    let mut min_idx13 = 0;\n    let mut min_idx14 = 0;\n    let mut min_idx15\
    \ = 0;\n    let mut min_idx16 = 0;\n    let mut min_idx17 = 0;\n    let mut min_idx18\
    \ = 0;\n    let mut min_idx19 = 0;\n    let mut min_idx20 = 0;\n    let mut min_idx21\
    \ = 0;\n    let mut min_idx22 = 0;\n    let mut min_idx23 = 0;\n    let mut min_idx24\
    \ = 0;\n    let mut min_idx25 = 0;\n    let mut min_idx26 = 0;\n    let mut min_idx27\
    \ = 0;\n    let mut min_idx28 = 0;\n    let mut min_idx29 = 0;\n    let mut min_idx30\
    \ = 0;\n    let mut min_idx31 = 0;\n    let mut min_idx32 = 0;\n    let mut min_idx33\
    \ = 0;\n    let mut min_idx34 = 0;\n    let mut min_idx35 = 0;\n    let mut min_idx36\
    \ = 0;\n    let mut min_idx37 = 0;\n    let mut min_idx38 = 0;\n    let mut min_idx39\
    \ = 0;\n    let mut min_idx40 = 0;\n    let mut min_idx41 = 0;\n    let mut min_idx42\
    \ = 0;\n    let mut min_idx43 = 0;\n    let mut min_idx44 = 0;\n    let mut min_idx45\
    \ = 0;\n    let mut min_idx46 = 0;\n    let mut min_idx47 = 0;\n    let mut min_idx48\
    \ = 0;\n    let mut min_idx49 = 0;\n    let mut min_idx50 = 0;\n    let mut min_idx51\
    \ = 0;\n    let mut min_idx52 = 0;\n    let mut min_idx53 = 0;\n    let mut min_idx54\
    \ = 0;\n    let mut min_idx55 = 0;\n    let mut min_idx56 = 0;\n    let mut min_idx57\
    \ = 0;\n    let mut min_idx58 = 0;\n    let mut min_idx59 = 0;\n    let mut min_idx60\
    \ = 0;\n    let mut min_idx61 = 0;\n    let mut min_idx62 = 0;\n    let mut min_idx63\
    \ = 0;\n    let mut min_idx\n}\n\nfn main() {\n    let candidate = pluck;\n  \
    \  assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_84wucx7.rs:91:20\n   |\n\
    91 |     let mut min_idx\n   |                    ^ help: add `;` here\n92 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_84wucx7.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even_value = arr[0];\n\
    \    let mut min_even_index = -1;\n    let mut min_even_index_count = 0;\n   \
    \ for &i in arr {\n        if i % 2 == 0 {\n            if min_even_index == -1\
    \ || min_even_index > i {\n                min_even_index = i;\n             \
    \   min_even_index_count = 1;\n            } else {\n                min_even_index_count\
    \ += 1;\n            }\n        }\n    }\n    if min_even_index_count == 0 {\n\
    \        return vec![];\n    }\n    if min_even_index == min_even_value {\n  \
    \      return vec![];\n    }\n    let mut min_even_index_value = min_even_index;\n\
    \    let mut min_even_index_value_count = 0;\n    for &i in arr {\n        if\
    \ i == min_even_index_value {\n            if min_even_index_value_count == 0\
    \ {\n                return vec![];\n            }\n            min_even_index_value_count\
    \ += 1;\n        } else {\n            min_even_index_value = i;\n           \
    \ min_even_index_value_count = 1;\n        }\n    }\n    if min_even_index_value_count\
    \ == 0 {\n        return vec![];\n    }\n    let mut min_even_index_value = min_even_index;\n\
    \    let mut min_even_index_value_count = 0;\n    for &i in arr {\n        if\
    \ i == min_even_index_value {\n            if min_even_index_value_count == 0\
    \ {\n                return vec![];\n            }\n            min_even_index_value_count\
    \ += 1;\n        } else {\n            min_even_index_value = i;\n           \
    \ min_even_index_value_count = 1;\n        }\n    }\n    if min_even_index_value_count\
    \ == 0 {\n        return vec![];\n    }\n    let mut min_even_index_value = min_even_index;\n\
    \    let mut min_even_index_value_count = 0;\n    for &i in arr {\n        if\
    \ i == min_even_index_value {\n            if min_even_index_value_count == 0\
    \ {\n                return vec![];\n            }\n            min_even_index_value_count\
    \ += 1;\n        } else {\n            min_even_index_value = i;\n           \
    \ min_even_index_value_count = 1;\n        }\n    }\n    if min_even_index_value_count\
    \ == 0 {\n        return vec![];\n    }\n    let mut min_even_index_value = min_even_index;\n\
    \    let mut min_even_index_value_count = 0;\n    for &i in arr {\n        if\
    \ i == min_even_index_value {\n            if min_even_index_value_count == 0\
    \ {\n                return vec![];\n            }\n            min_even_index_value_count\
    \ += 1;\n        } else {\n            min_even_index_value = i;\n           \
    \ min_even_index_value_count = 1;\n        }\n    }\n    if min_even_index_value_count\
    \ == 0 {\n        return vec![];\n    }\n    let mut min_even_index_value = min_even_index;\n\
    \    let mut min_even_index_value_count = 0;\n    for &i in arr {\n        if\
    \ i == min_even_index_value \n}\n\nfn main() {\n    let candidate = pluck;\n \
    \   assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp5okkbhd2.rs:126:3\n\
    \    |\n26  | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    |               \
    \                          - unclosed delimiter\n...\n112 |     for &i in arr\
    \ {\n    |                   - this delimiter might not be properly closed...\n\
    113 |         if i == min_even_index_value \n114 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n126 | }\n    |   ^\n\nerror: expected\
    \ `{`, found `}`\n   --> /tmp/tmp5okkbhd2.rs:114:1\n    |\n113 |         if i\
    \ == min_even_index_value \n    |         -- this `if` expression has a condition,\
    \ but no block\n114 | }\n    | ^ expected `{`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5okkbhd2.rs:30:9\n   |\n30 |     for &i in arr {\n   |        \
    \ ^^    --- this expression has type `isize`\n   |         |\n   |         expected\
    \ `isize`, found reference\n   |\n   = note:   expected type `isize`\n       \
    \    found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5okkbhd2.rs:48:9\n\
    \   |\n48 |     for &i in arr {\n   |         ^^    --- this expression has type\
    \ `isize`\n   |         |\n   |         expected `isize`, found reference\n  \
    \ |\n   = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5okkbhd2.rs:64:9\n   |\n64 |     for &i in arr\
    \ {\n   |         ^^    --- this expression has type `isize`\n   |         |\n\
    \   |         expected `isize`, found reference\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5okkbhd2.rs:80:9\n   |\n80 |     for &i in arr {\n   |        \
    \ ^^    --- this expression has type `isize`\n   |         |\n   |         expected\
    \ `isize`, found reference\n   |\n   = note:   expected type `isize`\n       \
    \    found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5okkbhd2.rs:96:9\n\
    \   |\n96 |     for &i in arr {\n   |         ^^    --- this expression has type\
    \ `isize`\n   |         |\n   |         expected `isize`, found reference\n  \
    \ |\n   = note:   expected type `isize`\n           "
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even_value = arr[0];\n\
    \    let mut min_even_index = -1;\n    let mut min_even_index_in_arr = 0;\n  \
    \  let mut min_even_index_in_arr2 = 0;\n    let mut min_even_index_in_arr3 = 0;\n\
    \    let mut min_even_index_in_arr4 = 0;\n    let mut min_even_index_in_arr5 =\
    \ 0;\n    let mut min_even_index_in_arr6 = 0;\n    let mut min_even_index_in_arr7\
    \ = 0;\n    let mut min_even_index_in_arr8 = 0;\n    let mut min_even_index_in_arr9\
    \ = 0;\n    let mut min_even_index_in_arr10 = 0;\n    let mut min_even_index_in_arr11\
    \ = 0;\n    let mut min_even_index_in_arr12 = 0;\n    let mut min_even_index_in_arr13\
    \ = 0;\n    let mut min_even_index_in_arr14 = 0;\n    let mut min_even_index_in_arr15\
    \ = 0;\n    let mut min_even_index_in_arr16 = 0;\n    let mut min_even_index_in_arr17\
    \ = 0;\n    let mut min_even_index_in_arr18 = 0;\n    let mut min_even_index_in_arr19\
    \ = 0;\n    let mut min_even_index_in_arr20 = 0;\n    let mut min_even_index_in_arr21\
    \ = 0;\n    let mut min_even_index_in_arr22 = 0;\n    let mut min_even_index_in_arr23\
    \ = 0;\n    let mut min_even_index_in_arr24 = 0;\n    let mut min_even_index_in_arr25\
    \ = 0;\n    let mut min_even_index_in_arr26 = 0;\n    let mut min_even_index_in_arr27\
    \ = 0;\n    let mut min_even_index_in_arr28 = 0;\n    let mut min_even_index_in_arr29\
    \ = 0;\n    let mut min_even_index_in_arr30 = 0;\n    let mut min_even_index_in_arr31\
    \ = 0;\n    let mut min_even_index_in_arr32 = 0;\n    let mut min_even_index_in_arr33\
    \ = 0;\n    let mut min_even_index_in_arr34 = 0;\n    let mut min_even_index_in_arr35\
    \ = 0;\n    let mut min_even_index_in_arr36 = 0;\n    let mut min_even_index_in_arr37\
    \ = 0;\n    let mut min_even_index_in_arr38 = 0;\n    let mut min_even_index_in_arr39\
    \ = 0;\n    let mut min_even_index_in_arr40 = 0;\n    let mut min_even_index_in_arr41\
    \ = 0;\n    let mut min_even_index_in_arr42 = 0;\n    let mut min_even_index_in_arr43\
    \ = 0;\n    let mut min_even_index_in_arr44 = 0;\n    let mut min_even_index_in_arr45\
    \ = 0;\n    let mut min_even\n}\n\nfn main() {\n    let candidate = pluck;\n \
    \   assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp6lqci4lh.rs:74:21\n   |\n\
    74 |     let mut min_even\n   |                     ^ help: add `;` here\n75 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6lqci4lh.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    let mut mut_smallest_value = smallest_value;\n\
    \    let mut mut_smallest_index = smallest_index;\n    let mut mut_mut_smallest_value\
    \ = mut_smallest_value;\n    let mut mut_mut_smallest_index = mut_smallest_index;\n\
    \    let mut mut_mut_mut_smallest_value = mut_mut_smallest_value;\n    let mut\
    \ mut_mut_mut_smallest_index = mut_mut_smallest_index;\n    let mut mut_mut_mut_mut_smallest_value\
    \ = mut_mut_mut_smallest_value;\n    let mut mut_mut_mut_mut_smallest_index =\
    \ mut_mut_mut_smallest_index;\n    let mut mut_mut_mut_mut_mut_smallest_value\
    \ = mut_mut_mut_mut_smallest_value;\n    let mut mut_mut_mut_mut_mut_smallest_index\
    \ = mut_mut_mut_mut_smallest_index;\n    let mut mut_mut_mut_mut_mut_mut_smallest_value\
    \ = mut_mut_mut_mut_mut_smallest_value;\n    let mut mut_mut_mut_mut_mut_mut_smallest_index\
    \ = mut_mut_mut_mut_mut_smallest_index;\n    let mut mut_mut_mut_mut_mut_mut_mut_smallest_value\
    \ = mut_mut_mut_mut_mut_mut_smallest_value;\n    let mut mut_mut_mut_mut_mut_mut_mut_smallest_index\
    \ = mut_mut_mut_mut_mut_mut_smallest_index;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_smallest_value\
    \ = mut_mut_mut_mut_mut_mut_mut_smallest_value;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_index\
    \ = mut_mut_mut_mut_mut_mut_mut_smallest_index;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_value\
    \ = mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_value;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_index\
    \ = mu\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmplwubrlb1.rs:46:76\n   |\n\
    46 |     let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_index =\
    \ mu\n   |                                                                   \
    \         ^ help: add `;` here\n47 | }\n   | - unexpected token\n\nerror[E0425]:\
    \ cannot find value `mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_value` in this\
    \ scope\n  --> /tmp/tmplwubrlb1.rs:45:70\n   |\n45 |     let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_value\
    \ = mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_value;\n   |                \
    \                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `mut_mut_mut_mut_mut_mut_mut_mut_smallest_value`\n\
    \nerror[E0425]: cannot find value `mu` in this scope\n  --> /tmp/tmplwubrlb1.rs:46:74\n\
    \   |\n46 |     let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_index\
    \ = mu\n   |                                                                 \
    \         ^^ not found in this scope\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmplwubrlb1.rs:26:30\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |    -----                     ^^^^^^^^^^ expected struct `Vec`, found\
    \ `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or\
    \ `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n       \
    \    found unit type `()`\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even_value = arr[0];\n\
    \    let mut min_even_index = -1;\n    let mut min_even_index_in_vec = -1;\n \
    \   for &i in arr {\n        if i % 2 == 0 {\n            if min_even_index ==\
    \ -1 || min_even_index > i {\n                min_even_value = i;\n          \
    \      min_even_index = i;\n                min_even_index_in_vec = i;\n     \
    \       }\n        } else {\n            if min_even_index == -1 || min_even_index\
    \ > i {\n                min_even_value = i;\n                min_even_index =\
    \ i;\n                min_even_index_in_vec = i;\n            }\n        }\n \
    \   }\n    if min_even_index == -1 {\n        return vec![];\n    }\n    let mut\
    \ vec: Vec<isize> = vec![];\n    for i in 0..min_even_index {\n        vec.push(i);\n\
    \    }\n    vec\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp42urqi1q.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value: isize =\
    \ 0;\n    let mut smallest_index: usize = 0;\n    let mut mut_smallest_value:\
    \ isize = 0;\n    let mut mut_smallest_index: usize = 0;\n    let mut mut_mut_smallest_value:\
    \ isize = 0;\n    let mut mut_mut_smallest_index: usize = 0;\n    let mut mut_mut_mut_smallest_value:\
    \ isize = 0;\n    let mut mut_mut_mut_smallest_index: usize = 0;\n    let mut\
    \ mut_mut_mut_mut_smallest_value: isize = 0;\n    let mut mut_mut_mut_mut_smallest_index:\
    \ usize = 0;\n    let mut mut_mut_mut_mut_mut_smallest_value: isize = 0;\n   \
    \ let mut mut_mut_mut_mut_mut_smallest_index: usize = 0;\n    let mut mut_mut_mut_mut_mut_mut_smallest_value:\
    \ isize = 0;\n    let mut mut_mut_mut_mut_mut_mut_smallest_index: usize = 0;\n\
    \    let mut mut_mut_mut_mut_mut_mut_mut_smallest_value: isize = 0;\n    let mut\
    \ mut_mut_mut_mut_mut_mut_mut_mut_smallest_index: usize = 0;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_value:\
    \ isize = 0;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_index:\
    \ usize = 0;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_value:\
    \ isize = 0;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_index:\
    \ usize = 0;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_value:\
    \ isize = 0;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_index:\
    \ usize = 0;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mu\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp15mqgvah.rs:49:71\n   |\n\
    49 |     let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mu\n\
    \   |                                                                       ^\
    \ help: add `;` here\n50 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp15mqgvah.rs:26:30\n   |\n26 | fn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |    -----                     ^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_val = i32::MAX;\n \
    \   let mut min_idx = -1;\n    for &i in arr {\n        if i % 2 == 0 {\n    \
    \        if min_val > i {\n                min_val = i;\n                min_idx\
    \ = i;\n            }\n        }\n    }\n    if min_val == i32::MAX {\n      \
    \  return vec![];\n    }\n    vec![min_val, min_idx]\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgp4uxe_l.rs:29:9\n   |\n\
    29 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpgp4uxe_l.rs:40:10\n   |\n40 |     vec![min_val, min_idx]\n\
    \   |          ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    40 |     vec![min_val.try_into().unwrap(), min_idx]\n   |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 0;\n    let mut min_idx2 = 0;\n    let mut min_idx3 = 0;\n\
    \    for i in arr.iter() {\n        if i % 2 == 0 {\n            if min_value\
    \ == i {\n                min_idx2 = min_idx;\n                min_idx3 = min_idx;\n\
    \            } else {\n                if min_value > i {\n                  \
    \  min_value = i;\n                    min_idx = i;\n                }\n     \
    \       }\n        } else {\n            if min_value > i {\n                min_value\
    \ = i;\n                min_idx = i;\n            }\n        }\n    }\n    if\
    \ min_idx2 == min_idx {\n        min_idx2 = min_idx3;\n    }\n    let mut vec:\
    \ Vec<isize> = vec![];\n    for i in arr.iter() {\n        if i % 2 == 0 {\n \
    \           if min_idx2 == min_idx {\n                vec.push(min_idx);\n   \
    \         } else {\n                vec.push(min_idx2);\n            }\n     \
    \   } else {\n            if min_idx2 == min_idx {\n                vec.push(min_idx3);\n\
    \            } else {\n                vec.push(min_idx2);\n            }\n  \
    \      }\n    }\n    vec\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgug581jo.rs:33:29\n   |\n\
    33 |             if min_value == i {\n   |                             ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    33 |             if min_value == *i {\n   |                             +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpgug581jo.rs:37:32\n   |\n37 |  \
    \               if min_value > i {\n   |                                ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    37 |                 if min_value > *i {\n   |                               \
    \ +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgug581jo.rs:38:33\n   |\n\
    38 |                     min_value = i;\n   |                                \
    \ ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n38 |                     min_value = *i;\n   |                        \
    \         +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgug581jo.rs:39:31\n\
    \   |\n39 |                     min_idx = i;\n   |                           \
    \    ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n39 |                     min_idx = *i;\n   |                 \
    \              +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgug581jo.rs:43:28\n\
    \   |\n43 |             if min_value > i {\n   |                            ^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n43 |             if min_value > *i {\n   |                            +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgug581jo.rs:44:29\n   |\n44 |\
    \                 min_value = i;\n   |                             ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    44 |                 min_value = *i;\n   |                             +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgug581jo.rs:45:27\n   |\n45 |              \
    \   min_idx = i;\n   |                           ^ expected integer, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n45 |                 m"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 0;\n    for &i in arr {\n        if i % 2 == 0 {\n     \
    \       if min_value % 2 == 0 {\n                min_value = i;\n            \
    \    min_idx = i;\n            }\n        }\n    }\n    vec![min_value, min_idx]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcbesv5y1.rs:29:9\n   |\n\
    29 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even_value: isize =\
    \ 0;\n    let mut min_even_index: usize = 0;\n    let mut min_value: isize = 0;\n\
    \    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let\
    \ mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index:\
    \ usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize\
    \ = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n\
    \    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let\
    \ mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index:\
    \ usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize\
    \ = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n\
    \    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let\
    \ mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index:\
    \ usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize\
    \ = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n\
    \    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let\
    \ mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index:\
    \ usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize\
    \ = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n\
    \    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let\
    \ mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index:\
    \ usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize\
    \ = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n\
    \    let mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let\
    \ mut min_index: usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index:\
    \ usize = 0;\n    let mut min_index: usize = 0;\n    let mut min_index: usize\
    \ = 0;\n    let mut min_index: usize = 0;\n    let mut min_\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpfrgdygdx.rs:83:17\n   |\n\
    83 |     let mut min_\n   |                 ^ help: add `;` here\n84 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfrgdygdx.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value: isize =\
    \ 0;\n    let mut smallest_index: usize = 0;\n    let mut even_value: isize =\
    \ 0;\n    let mut even_index: usize = 0;\n    for &i in arr {\n        if i %\
    \ 2 == 0 {\n            even_value = i;\n            even_index = i;\n       \
    \ } else {\n            if smallest_value < i {\n                smallest_value\
    \ = i;\n                smallest_index = i;\n            }\n        }\n    }\n\
    \    if even_index == 0 {\n        return vec![];\n    }\n    let mut even_values\
    \ = vec![];\n    even_values.push(even_value);\n    even_values.push(even_index);\n\
    \    even_values.push(smallest_value);\n    even_values.push(smallest_index);\n\
    \    return even_values;\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpeulmeoba.rs:31:9\n   |\n\
    31 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpeulmeoba.rs:34:26\n   |\n34 |             even_index =\
    \ i;\n   |                          ^ expected `usize`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpeulmeoba.rs:38:34\n   |\n38 |              \
    \   smallest_index = i;\n   |                                  ^ expected `usize`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpeulmeoba.rs:47:22\n\
    \   |\n47 |     even_values.push(even_index);\n   |                      ^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n47 |     even_values.push(even_index.try_into().unwrap());\n\
    \   |                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpeulmeoba.rs:49:22\n   |\n49 |     even_values.push(smallest_index);\n\
    \   |                      ^^^^^^^^^^^^^^ expected `isize`, found `usize`\n  \
    \ |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n49 |     even_values.push(smallest_index.try_into().unwrap());\n\
    \   |                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting\
    \ due to 5 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value: isize =\
    \ 0;\n    let mut smallest_index: usize = 0;\n    let mut even_values: Vec<isize>\
    \ = Vec::new();\n    for i in arr.iter() {\n        if i % 2 == 0 {\n        \
    \    even_values.push(i);\n        }\n        if i == smallest_value {\n     \
    \       smallest_index = i;\n        }\n        if i == smallest_value {\n   \
    \         smallest_value = i;\n        }\n    }\n    if even_values.len() == 0\
    \ {\n        return vec![];\n    }\n    let mut smallest_even_value = even_values[0];\n\
    \    let mut smallest_even_index = even_values[0];\n    for i in even_values.iter()\
    \ {\n        if i < smallest_even_value {\n            smallest_even_value = i;\n\
    \            smallest_even_index = i;\n        }\n    }\n    vec![smallest_value,\
    \ smallest_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp39o9ee1r.rs:32:30\n   |\n\
    32 |             even_values.push(i);\n   |                              ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    32 |             even_values.push(*i);\n   |                              +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp39o9ee1r.rs:35:30\n   |\n35 |  \
    \           smallest_index = i;\n   |                              ^ expected\
    \ `usize`, found `&isize`\n\nerror[E0277]: can't compare `&isize` with `isize`\n\
    \  --> /tmp/tmp39o9ee1r.rs:34:14\n   |\n34 |         if i == smallest_value {\n\
    \   |              ^^ no implementation for `&isize == isize`\n   |\n   = help:\
    \ the trait `PartialEq<isize>` is not implemented for `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp39o9ee1r.rs:38:30\n   |\n38 |             smallest_value\
    \ = i;\n   |                              ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n38 |             smallest_value\
    \ = *i;\n   |                              +\n\nerror[E0277]: can't compare `&isize`\
    \ with `isize`\n  --> /tmp/tmp39o9ee1r.rs:37:14\n   |\n37 |         if i == smallest_value\
    \ {\n   |              ^^ no implementation for `&isize == isize`\n   |\n   =\
    \ help: the trait `PartialEq<isize>` is not implemented for `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp39o9ee1r.rs:47:16\n   |\n47 |         if i <\
    \ smallest_even_value {\n   |                ^^^^^^^^^^^^^^^^^^^\n   |       \
    \         |\n   |                expected `&isize`, found `isize`\n   |      \
    \          help: consider borrowing here: `&smallest_even_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp39o9ee1r.rs:48:35\n   |\n48 |             smallest_even_value\
    \ = i;\n   |                                   ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n48 |             smallest_even_value\
    \ = *i;\n   |                                   +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp39o9ee1r.rs:49:35\n   |\n49 |             smallest_even_index\
    \ = i;\n   |            "
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_val = arr[0];\n   \
    \ let mut min_idx = -1;\n    let mut min_even_val = false;\n    for i in arr.iter().rev()\
    \ {\n        if i % 2 == 0 {\n            if min_even_val {\n                min_even_val\
    \ = false;\n                min_idx = i;\n            } else {\n             \
    \   min_even_val = true;\n                min_val = i;\n            }\n      \
    \  }\n    }\n    if min_even_val {\n        min_even_val = false;\n        min_idx\
    \ = min_val;\n    }\n    vec![min_val, min_idx]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjgyz97uh.rs:34:27\n   |\n\
    34 |                 min_idx = i;\n   |                           ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n34 |  \
    \               min_idx = *i;\n   |                           +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjgyz97uh.rs:37:27\n   |\n37 |              \
    \   min_val = i;\n   |                           ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n37 |                 min_val\
    \ = *i;\n   |                           +\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 0;\n    let mut min_idx2 = 0;\n    for i in arr.iter().rev()\
    \ {\n        if i % 2 == 0 {\n            if min_value == i {\n              \
    \  min_idx2 = min_idx;\n            }\n            min_idx = i;\n            min_value\
    \ = i;\n        }\n    }\n    if min_idx2 == min_idx {\n        vec![]\n    }\
    \ else {\n        vec![min_value, min_idx]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp40duw1f8.rs:32:29\n   |\n\
    32 |             if min_value == i {\n   |                             ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    32 |             if min_value == *i {\n   |                             +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp40duw1f8.rs:35:23\n   |\n35 |  \
    \           min_idx = i;\n   |                       ^ expected integer, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n35 |        \
    \     min_idx = *i;\n   |                       +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp40duw1f8.rs:36:25\n   |\n36 |             min_value = i;\n\
    \   |                         ^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n36 |             min_value = *i;\n\
    \   |                         +\n\nerror: aborting due to 3 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_even_value = arr[0];\n\
    \    let mut smallest_even_index = 0;\n    let mut smallest_even_index_in_arr\
    \ = 0;\n    let mut smallest_even_index_in_arr2 = 0;\n    let mut smallest_even_index_in_arr3\
    \ = 0;\n    let mut smallest_even_index_in_arr4 = 0;\n    let mut smallest_even_index_in_arr5\
    \ = 0;\n    let mut smallest_even_index_in_arr6 = 0;\n    let mut smallest_even_index_in_arr7\
    \ = 0;\n    let mut smallest_even_index_in_arr8 = 0;\n    let mut smallest_even_index_in_arr9\
    \ = 0;\n    let mut smallest_even_index_in_arr10 = 0;\n    let mut smallest_even_index_in_arr11\
    \ = 0;\n    let mut smallest_even_index_in_arr12 = 0;\n    let mut smallest_even_index_in_arr13\
    \ = 0;\n    let mut smallest_even_index_in_arr14 = 0;\n    let mut smallest_even_index_in_arr15\
    \ = 0;\n    let mut smallest_even_index_in_arr16 = 0;\n    let mut smallest_even_index_in_arr17\
    \ = 0;\n    let mut smallest_even_index_in_arr18 = 0;\n    let mut smallest_even_index_in_arr19\
    \ = 0;\n    let mut smallest_even_index_in_arr20 = 0;\n    let mut smallest_even_index_in_arr21\
    \ = 0;\n    let mut smallest_even_index_in_arr22 = 0;\n    let mut smallest_even_index_in_arr23\
    \ = 0;\n    let mut smallest_even_index_in_arr24 = 0;\n    let mut smallest_even_index_in_arr25\
    \ = 0;\n    let mut smallest_even_index_in_arr26 = 0;\n    let mut smallest_even_index_in_arr27\
    \ = 0;\n    let mut smallest_even_index_in_arr28 = 0;\n    let mut smallest_even_index_in_arr29\
    \ = 0;\n    let mut smallest_even_index_in_arr30 = 0;\n    let mut smallest_even_index_in_arr31\
    \ = 0;\n    let mut smallest_even_index_in_arr32 = 0;\n    let mut smallest_even_index_in_arr33\
    \ = 0;\n    let mut smallest_even_index_in_arr34 = 0;\n    let mut smallest_even_index_in_arr35\
    \ = 0;\n    let mut smallest_even_index_in_arr36 = 0;\n    let mut smallest_even_index_in_arr37\
    \ = 0;\n    let mut smallest_even_index_in_arr38 = 0;\n    let mut smallest_even_index_in_arr39\
    \ = 0;\n    let mut smallest_even_index_in_arr40 = 0;\n    let mut smallest_even_index_in_arr41\
    \ = 0;\n    let mut smallest_even\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp2kao6vzw.rs:70:26\n   |\n\
    70 |     let mut smallest_even\n   |                          ^ help: add `;`\
    \ here\n71 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp2kao6vzw.rs:26:30\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |    -----                     ^^^^^^^^^^ expected struct `Vec`, found\
    \ `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or\
    \ `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n       \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even_value = arr[0];\n\
    \    let mut min_even_index = -1;\n    let mut min_even_index_in_vec = -1;\n \
    \   for i in arr.iter().rev() {\n        if i % 2 == 0 {\n            if min_even_value\
    \ == i {\n                min_even_index = i;\n                min_even_index_in_vec\
    \ = i;\n            } else {\n                min_even_value = i;\n          \
    \      min_even_index = i;\n                min_even_index_in_vec = i;\n     \
    \       }\n        }\n    }\n    if min_even_index == -1 {\n        return vec![];\n\
    \    }\n    let mut vec: Vec<isize> = vec![];\n    for i in 0..min_even_index\
    \ {\n        vec.push(i);\n    }\n    vec\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp1mgvrlu.rs:32:34\n   |\n\
    32 |             if min_even_value == i {\n   |                              \
    \    ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n32 |             if min_even_value == *i {\n   |             \
    \                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp1mgvrlu.rs:33:34\n\
    \   |\n33 |                 min_even_index = i;\n   |                        \
    \          ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n33 |                 min_even_index = *i;\n   |          \
    \                        +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp1mgvrlu.rs:34:41\n\
    \   |\n34 |                 min_even_index_in_vec = i;\n   |                 \
    \                        ^ expected integer, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n34 |                 min_even_index_in_vec =\
    \ *i;\n   |                                         +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpp1mgvrlu.rs:36:34\n   |\n36 |                 min_even_value\
    \ = i;\n   |                                  ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n36 |                 min_even_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpp1mgvrlu.rs:37:34\n   |\n37 |                 min_even_index =\
    \ i;\n   |                                  ^ expected integer, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n37 |                 min_even_index\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpp1mgvrlu.rs:38:41\n   |\n38 |                 min_even_index_in_vec\
    \ = i;\n   |                                         ^ expected integer, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n38 |        \
    \         min_even_index_in_vec = *i;\n   |                                  \
    \       +\n\nerror: aborting due to 6 previous errors\n\nFor more information\
    \ about this error, try `rustc --explai"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 0;\n    for i in arr.iter().rev() {\n        if i % 2 ==\
    \ 0 {\n            min_value = i;\n            min_idx = i;\n        }\n    }\n\
    \    vec![min_value, min_idx]\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvm2upu9t.rs:31:25\n   |\n\
    31 |             min_value = i;\n   |                         ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n31 |  \
    \           min_value = *i;\n   |                         +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvm2upu9t.rs:32:23\n   |\n32 |             min_idx = i;\n\
    \   |                       ^ expected integer, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n32 |             min_idx = *i;\n   |       \
    \                +\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    for i in arr.iter().rev() {\n        if\
    \ i % 2 == 0 {\n            if smallest_value < i {\n                smallest_value\
    \ = i;\n                smallest_index = i;\n            }\n        }\n    }\n\
    \    vec![smallest_value, smallest_index]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmtadrjsg.rs:31:33\n   |\n\
    31 |             if smallest_value < i {\n   |                               \
    \  ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n31 |             if smallest_value < *i {\n   |              \
    \                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmtadrjsg.rs:32:34\n\
    \   |\n27 |     let mut smallest_value = arr[0];\n   |                       \
    \       ------ expected due to this value\n...\n32 |                 smallest_value\
    \ = i;\n   |                                  ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n32 |                 smallest_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmtadrjsg.rs:33:34\n   |\n28 |     let mut smallest_index = 0;\n\
    \   |                              - expected due to this value\n...\n33 |   \
    \              smallest_index = i;\n   |                                  ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    33 |                 smallest_index = *i;\n   |                              \
    \    +\n\nerror: aborting due to 3 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_even_value = arr[0];\n\
    \    let mut smallest_even_index = -1;\n    let mut smallest_index = -1;\n   \
    \ let mut smallest_value = -1;\n    for i in arr.iter().cloned() {\n        if\
    \ i % 2 == 0 {\n            if smallest_value == -1 || smallest_value > i {\n\
    \                smallest_even_value = i;\n                smallest_even_index\
    \ = i;\n                smallest_value = i;\n                smallest_index =\
    \ i;\n            }\n        } else {\n            if smallest_value == -1 ||\
    \ smallest_value < i {\n                smallest_even_value = i;\n           \
    \     smallest_even_index = i;\n                smallest_value = i;\n        \
    \        smallest_index = i;\n            }\n        }\n    }\n    if smallest_even_index\
    \ == -1 || smallest_even_index == arr.len() {\n        return vec![];\n    }\n\
    \    return vec![smallest_even_index, smallest_value];\n}\n\nfn main() {\n   \
    \ let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxy2ox5ga.rs:48:60\n   |\n\
    48 |     if smallest_even_index == -1 || smallest_even_index == arr.len() {\n\
    \   |                                                            ^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n48 |     if smallest_even_index\
    \ == -1 || smallest_even_index == arr.len().try_into().unwrap() {\n   |      \
    \                                                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even_value = arr[0];\n\
    \    let mut min_even_index = 0;\n    let mut min_even_index_in_arr = 0;\n   \
    \ let mut min_even_index_in_arr2 = 0;\n    let mut min_even_index_in_arr3 = 0;\n\
    \    let mut min_even_index_in_arr4 = 0;\n    let mut min_even_index_in_arr5 =\
    \ 0;\n    let mut min_even_index_in_arr6 = 0;\n    let mut min_even_index_in_arr7\
    \ = 0;\n    let mut min_even_index_in_arr8 = 0;\n    let mut min_even_index_in_arr9\
    \ = 0;\n    let mut min_even_index_in_arr10 = 0;\n    let mut min_even_index_in_arr11\
    \ = 0;\n    let mut min_even_index_in_arr12 = 0;\n    let mut min_even_index_in_arr13\
    \ = 0;\n    let mut min_even_index_in_arr14 = 0;\n    let mut min_even_index_in_arr15\
    \ = 0;\n    let mut min_even_index_in_arr16 = 0;\n    let mut min_even_index_in_arr17\
    \ = 0;\n    let mut min_even_index_in_arr18 = 0;\n    let mut min_even_index_in_arr19\
    \ = 0;\n    let mut min_even_index_in_arr20 = 0;\n    let mut min_even_index_in_arr21\
    \ = 0;\n    let mut min_even_index_in_arr22 = 0;\n    let mut min_even_index_in_arr23\
    \ = 0;\n    let mut min_even_index_in_arr24 = 0;\n    let mut min_even_index_in_arr25\
    \ = 0;\n    let mut min_even_index_in_arr26 = 0;\n    let mut min_even_index_in_arr27\
    \ = 0;\n    let mut min_even_index_in_arr28 = 0;\n    let mut min_even_index_in_arr29\
    \ = 0;\n    let mut min_even_index_in_arr30 = 0;\n    let mut min_even_index_in_arr31\
    \ = 0;\n    let mut min_even_index_in_arr32 = 0;\n    let mut min_even_index_in_arr33\
    \ = 0;\n    let mut min_even_index_in_arr34 = 0;\n    let mut min_even_index_in_arr35\
    \ = 0;\n    let mut min_even_index_in_arr36 = 0;\n    let mut min_even_index_in_arr37\
    \ = 0;\n    let mut min_even_index_in_arr38 = 0;\n    let mut min_even_index_in_arr39\
    \ = 0;\n    let mut min_even_index_in_arr40 = 0;\n    let mut min_even_index_in_arr41\
    \ = 0;\n    let mut min_even_index_in_arr42 = 0;\n    let mut min_even_index_in_arr43\
    \ = 0;\n    let mut min_even_index_in_arr44 = 0;\n    let mut min_even_index_in_arr45\
    \ = 0;\n    let mut min_even\n}\n\nfn main() {\n    let candidate = pluck;\n \
    \   assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpi94ao66w.rs:74:21\n   |\n\
    74 |     let mut min_even\n   |                     ^ help: add `;` here\n75 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi94ao66w.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 0;\n    for i in arr.iter().rev() {\n        if i % 2 ==\
    \ 0 {\n            min_value = i;\n            min_idx = i;\n        }\n    }\n\
    \    vec![min_value, min_idx]\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvm2upu9t.rs:31:25\n   |\n\
    31 |             min_value = i;\n   |                         ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n31 |  \
    \           min_value = *i;\n   |                         +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvm2upu9t.rs:32:23\n   |\n32 |             min_idx = i;\n\
    \   |                       ^ expected integer, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n32 |             min_idx = *i;\n   |       \
    \                +\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_index = 0;\n    let mut min_even_value = false;\n    for &i in\
    \ arr {\n        if i % 2 == 0 {\n            if min_even_value\n            \
    \    || (min_even_value = true)\n                || (min_value = i)\n        \
    \        || (min_index = arr.iter().position(|&i| i % 2 == 0).unwrap()) {\n  \
    \              continue;\n            }\n        }\n    }\n    vec![min_value,\
    \ min_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpia6otniu.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpia6otniu.rs:33:20\n   |\n33 |                 || (min_even_value\
    \ = true)\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found\
    \ `()`\n   |\nhelp: you might have meant to compare for equality\n   |\n33 | \
    \                || (min_even_value == true)\n   |                           \
    \         ~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpia6otniu.rs:34:20\n\
    \   |\n34 |                 || (min_value = i)\n   |                    ^^^^^^^^^^^^^^^\
    \ expected `bool`, found `()`\n   |\nhelp: you might have meant to compare for\
    \ equality\n   |\n34 |                 || (min_value == i)\n   |             \
    \                  ~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpia6otniu.rs:35:20\n\
    \   |\n35 |                 || (min_index = arr.iter().position(|&i| i % 2 ==\
    \ 0).unwrap()) {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `bool`, found `()`\n   |\nhelp: you might have meant to compare for\
    \ equality\n   |\n35 |                 || (min_index == arr.iter().position(|&i|\
    \ i % 2 == 0).unwrap()) {\n   |                               ~~\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 0;\n    let mut min_idx2 = 0;\n    let mut min_idx3 = 0;\n\
    \    for &i in arr {\n        if i % 2 == 0 {\n            if min_value % 2 ==\
    \ 0 {\n                min_value = i;\n                min_idx = i;\n        \
    \    }\n            if min_idx == i {\n                min_idx2 = i;\n       \
    \     }\n            if min_idx2 == i {\n                min_idx3 = i;\n     \
    \       }\n        }\n    }\n    if min_idx3 == min_idx2 {\n        min_idx3 =\
    \ min_idx2;\n    }\n    if min_idx3 == min_idx {\n        min_idx3 = min_idx;\n\
    \    }\n    if min_idx3 == min_idx {\n        min_idx3 = min_idx;\n    }\n   \
    \ if min_idx3 == min_idx {\n        min_idx3 = min_idx;\n    }\n    if min_idx3\
    \ == min_idx {\n        min_idx3 = min_idx;\n    }\n    if min_idx3 == min_idx\
    \ {\n        min_idx3 = min_idx;\n    }\n    if min_idx3 == min_idx {\n      \
    \  min_idx3 = min_idx;\n    }\n    if min_idx3 == min_idx {\n        min_idx3\
    \ = min_idx;\n    }\n    if min_idx3 == min_idx {\n        min_idx3 = min_idx;\n\
    \    }\n    if min_idx3 == min_idx {\n        min_idx3 = min_idx;\n    }\n   \
    \ if min_idx3 == min_idx {\n        min_idx3 = min_idx;\n    }\n    if min_idx3\
    \ == min_idx {\n        min_idx3 = min_idx;\n    }\n    if min_idx3 == min_idx\
    \ {\n        min_idx3 = min_idx;\n    }\n    if min_idx3 == min_idx {\n      \
    \  min_idx3 = min_idx;\n    }\n    if min_idx3 == min_idx {\n        min_idx3\
    \ = min_idx;\n    }\n    if min_idx3 == min_idx {\n        min_idx3 = min_idx;\n\
    \    }\n    if min_idx3 == min_idx {\n        min_idx3 = min_idx;\n    }\n   \
    \ if min_idx3 == min_idx {\n        min_idx3 = min_idx;\n    }\n    if min_idx3\
    \ == min_idx {\n        min_idx3 = min_idx;\n    }\n    if min_idx3 == min_idx\
    \ {\n        min_idx3 = min_idx;\n    }\n    if min_idx3 == min_idx {\n      \
    \  min_idx3 = min_idx;\n    }\n    if min_idx3 == min_idx {\n        min_idx3\
    \ = min_idx;\n    }\n    if min_idx3 == min_idx {\n        min_idx3 = min_idx;\n\
    \    }\n    if min_idx3 == min_idx {\n        min_idx3 = min_idx;\n    }\n   \
    \ if min_idx3 == min_idx {\n        min_idx3 = \n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpvqn1tfzj.rs:131:3\n\
    \    |\n26  | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    |               \
    \                          - unclosed delimiter\n...\n117 |     if min_idx3 ==\
    \ min_idx {\n    |                            - this delimiter might not be properly\
    \ closed...\n118 |         min_idx3 = \n119 | }\n    | - ...as it matches this\
    \ but it has different indentation\n...\n131 | }\n    |   ^\n\nerror: expected\
    \ expression, found `}`\n   --> /tmp/tmpvqn1tfzj.rs:119:1\n    |\n119 | }\n  \
    \  | ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvqn1tfzj.rs:31:9\n\
    \   |\n31 |     for &i in arr {\n   |         ^^    --- this expression has type\
    \ `isize`\n   |         |\n   |         expected `isize`, found reference\n  \
    \ |\n   = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvqn1tfzj.rs:26:30\n   |\n26 | fn pluck(arr:\
    \ Vec<isize>) -> Vec<isize> {\n   |    -----                     ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_even_value = arr[0];\n\
    \    let mut smallest_even_index = -1;\n    let mut smallest_even_index_in_vec\
    \ = -1;\n    let mut smallest_even_index_in_vec2 = -1;\n    let mut smallest_even_index_in_vec3\
    \ = -1;\n    let mut smallest_even_index_in_vec4 = -1;\n    let mut smallest_even_index_in_vec5\
    \ = -1;\n    let mut smallest_even_index_in_vec6 = -1;\n    let mut smallest_even_index_in_vec7\
    \ = -1;\n    let mut smallest_even_index_in_vec8 = -1;\n    let mut smallest_even_index_in_vec9\
    \ = -1;\n    let mut smallest_even_index_in_vec10 = -1;\n    let mut smallest_even_index_in_vec11\
    \ = -1;\n    let mut smallest_even_index_in_vec12 = -1;\n    let mut smallest_even_index_in_vec13\
    \ = -1;\n    let mut smallest_even_index_in_vec14 = -1;\n    let mut smallest_even_index_in_vec15\
    \ = -1;\n    let mut smallest_even_index_in_vec16 = -1;\n    let mut smallest_even_index_in_vec17\
    \ = -1;\n    let mut smallest_even_index_in_vec18 = -1;\n    let mut smallest_even_index_in_vec19\
    \ = -1;\n    let mut smallest_even_index_in_vec20 = -1;\n    let mut smallest_even_index_in_vec21\
    \ = -1;\n    let mut smallest_even_index_in_vec22 = -1;\n    let mut smallest_even_index_in_vec23\
    \ = -1;\n    let mut smallest_even_index_in_vec24 = -1;\n    let mut smallest_even_index_in_vec25\
    \ = -1;\n    let mut smallest_even_index_in_vec26 = -1;\n    let mut smallest_even_index_in_vec27\
    \ = -1;\n    let mut smallest_even_index_in_vec28 = -1;\n    let mut smallest_even_index_in_vec29\
    \ = -1;\n    let mut smallest_even_index_in_vec30 = -1;\n    let mut smallest_even_index_in_vec31\
    \ = -1;\n    let mut smallest_even_index_in_vec32 = -1;\n    let mut smallest_even_index_in_vec33\
    \ = -1;\n    let mut smallest_even_index_in_vec34 = -1;\n    let mut smallest_even_index_in_vec35\
    \ = -1;\n    let mut smallest_even_index_in_vec36 = -1;\n    let mut smallest_even_index_in_vec37\
    \ = -1;\n    let mut smallest_even_index_in_vec38 = -1;\n    let mut smallest_even_index_in_vec39\
    \ = -1;\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpto9s8715.rs:26:30\n   |\n\
    26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----                \
    \     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut even_values = vec![];\n\
    \    let mut smallest_value = vec![];\n    let mut smallest_index = vec![];\n\
    \    for i in arr.iter() {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \            if i < smallest_value.len() {\n                smallest_value[i]\
    \ = i;\n                smallest_index[i] = i;\n            }\n        }\n   \
    \ }\n    if even_values.len() == 0 {\n        return vec![];\n    }\n    if even_values.len()\
    \ == 1 {\n        return vec![even_values[0]];\n    }\n    if even_values.len()\
    \ > 1 {\n        let mut smallest_even_value = even_values[0];\n        let mut\
    \ smallest_even_index = even_values[0];\n        for i in even_values.iter().rev()\
    \ {\n            if i % 2 == 0 {\n                if i < smallest_even_value.len()\
    \ {\n                    smallest_even_value = i;\n                    smallest_even_index\
    \ = i;\n                }\n            }\n        }\n        smallest_value.push(smallest_even_value);\n\
    \        smallest_index.push(smallest_even_index);\n    }\n    smallest_value\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp8fbn4bp.rs:33:20\n   |\n\
    33 |             if i < smallest_value.len() {\n   |                    ^^^^^^^^^^^^^^^^^^^^\
    \ expected `&isize`, found `usize`\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `&isize`\n  --> /tmp/tmpp8fbn4bp.rs:34:17\n   |\n34 |                 smallest_value[i]\
    \ = i;\n   |                 ^^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>` is not implemented\
    \ for `&isize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<_>`\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `&isize`\n  --> /tmp/tmpp8fbn4bp.rs:35:17\n   |\n35 |                 smallest_index[i]\
    \ = i;\n   |                 ^^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>` is not implemented\
    \ for `&isize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp8fbn4bp.rs:43:21\n\
    \   |\n43 |         return vec![even_values[0]];\n   |                     ^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the type\n\
    \   |\n43 |         return vec![*even_values[0]];\n   |                     +\n\
    \nerror[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmpp8fbn4bp.rs:49:18\n\
    \   |\n49 |             if i % 2 == 0 {\n   |                - ^ - {integer}\n\
    \   |                |\n   |                &&isize\n   |\nhelp: `%` can be used\
    \ on `isize`, you can dereference `i`\n   |\n49 |             if *i % 2 == 0 {\n\
    \   |                +\n\nerror[E0599]: no method named `len` found for reference\
    \ `&isize` in the current scope\n  --> /tmp/tmpp8fbn4bp.rs:50:44\n   |\n50 | \
    \                if i < smallest_even_value.len() {\n   |                    \
    \                        ^^^ method not found in `&isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpp8fbn4bp.rs:59:5\n   |\n26 | fn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |                              ------"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    let mut even_values = Vec::new();\n    for\
    \ i in arr.iter().rev() {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \        }\n        if i == smallest_value {\n            smallest_index = even_values.len();\n\
    \        }\n        if i == smallest_value {\n            smallest_value = i;\n\
    \        }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n \
    \   }\n    if even_values.len() == 1 {\n        return vec![even_values[0]];\n\
    \    }\n    even_values.sort();\n    return vec![even_values[0], even_values[smallest_index]];\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpm2rmvz4j.rs:34:14\n\
    \   |\n34 |         if i == smallest_value {\n   |              ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm2rmvz4j.rs:38:30\n\
    \   |\n38 |             smallest_value = i;\n   |                            \
    \  ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n38 |             smallest_value = *i;\n   |                  \
    \            +\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpm2rmvz4j.rs:37:14\n\
    \   |\n37 |         if i == smallest_value {\n   |              ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm2rmvz4j.rs:45:21\n\
    \   |\n45 |         return vec![even_values[0]];\n   |                     ^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the type\n\
    \   |\n45 |         return vec![*even_values[0]];\n   |                     +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpm2rmvz4j.rs:48:17\n   |\n48 |\
    \     return vec![even_values[0], even_values[smallest_index]];\n   |        \
    \         ^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the type\n   |\n48 |     return vec![*even_values[0], even_values[smallest_index]];\n\
    \   |                 +\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = i32::MAX;\n\
    \    let mut min_idx = -1;\n    for i in arr.iter() {\n        if i % 2 == 0 {\n\
    \            if min_value == i32::MAX {\n                min_value = i;\n    \
    \            min_idx = i;\n            } else {\n                if i < min_value\
    \ {\n                    min_value = i;\n                    min_idx = i;\n  \
    \              }\n            }\n        }\n    }\n    vec![min_value, min_idx]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxv8uzwij.rs:32:29\n   |\n\
    32 |                 min_value = i;\n   |                             ^ expected\
    \ `i32`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxv8uzwij.rs:33:27\n\
    \   |\n33 |                 min_idx = i;\n   |                           ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    33 |                 min_idx = *i;\n   |                           +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxv8uzwij.rs:35:24\n   |\n35 |              \
    \   if i < min_value {\n   |                        ^^^^^^^^^ expected `&isize`,\
    \ found `i32`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxv8uzwij.rs:36:33\n\
    \   |\n36 |                     min_value = i;\n   |                         \
    \        ^ expected `i32`, found `&isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxv8uzwij.rs:37:31\n   |\n37 |                     min_idx = i;\n\
    \   |                               ^ expected integer, found `&isize`\n   |\n\
    help: consider dereferencing the borrow\n   |\n37 |                     min_idx\
    \ = *i;\n   |                               +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxv8uzwij.rs:42:10\n   |\n42 |     vec![min_value, min_idx]\n  \
    \ |          ^^^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    42 |     vec![min_value.try_into().unwrap(), min_idx]\n   |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror: aborting due to 6 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 0;\n    let mut min_idx2 = 0;\n    let mut min_idx3 = 0;\n\
    \    let mut min_idx4 = 0;\n    let mut min_idx5 = 0;\n    let mut min_idx6 =\
    \ 0;\n    let mut min_idx7 = 0;\n    let mut min_idx8 = 0;\n    let mut min_idx9\
    \ = 0;\n    let mut min_idx10 = 0;\n    let mut min_idx11 = 0;\n    let mut min_idx12\
    \ = 0;\n    let mut min_idx13 = 0;\n    let mut min_idx14 = 0;\n    let mut min_idx15\
    \ = 0;\n    let mut min_idx16 = 0;\n    let mut min_idx17 = 0;\n    let mut min_idx18\
    \ = 0;\n    let mut min_idx19 = 0;\n    let mut min_idx20 = 0;\n    let mut min_idx21\
    \ = 0;\n    let mut min_idx22 = 0;\n    let mut min_idx23 = 0;\n    let mut min_idx24\
    \ = 0;\n    let mut min_idx25 = 0;\n    let mut min_idx26 = 0;\n    let mut min_idx27\
    \ = 0;\n    let mut min_idx28 = 0;\n    let mut min_idx29 = 0;\n    let mut min_idx30\
    \ = 0;\n    let mut min_idx31 = 0;\n    let mut min_idx32 = 0;\n    let mut min_idx33\
    \ = 0;\n    let mut min_idx34 = 0;\n    let mut min_idx35 = 0;\n    let mut min_idx36\
    \ = 0;\n    let mut min_idx37 = 0;\n    let mut min_idx38 = 0;\n    let mut min_idx39\
    \ = 0;\n    let mut min_idx40 = 0;\n    let mut min_idx41 = 0;\n    let mut min_idx42\
    \ = 0;\n    let mut min_idx43 = 0;\n    let mut min_idx44 = 0;\n    let mut min_idx45\
    \ = 0;\n    let mut min_idx46 = 0;\n    let mut min_idx47 = 0;\n    let mut min_idx48\
    \ = 0;\n    let mut min_idx49 = 0;\n    let mut min_idx50 = 0;\n    let mut min_idx51\
    \ = 0;\n    let mut min_idx52 = 0;\n    let mut min_idx53 = 0;\n    let mut min_idx54\
    \ = 0;\n    let mut min_idx55 = 0;\n    let mut min_idx56 = 0;\n    let mut min_idx57\
    \ = 0;\n    let mut min_idx58 = 0;\n    let mut min_idx59 = 0;\n    let mut min_idx60\
    \ = 0;\n    let mut min_idx61 = 0;\n    let mut min_idx62 = 0;\n    let mut min_idx63\
    \ = 0;\n    let mut min_idx\n}\n\nfn main() {\n    let candidate = pluck;\n  \
    \  assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_84wucx7.rs:91:20\n   |\n\
    91 |     let mut min_idx\n   |                    ^ help: add `;` here\n92 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_84wucx7.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    let mut mut_smallest_value = smallest_value;\n\
    \    let mut mut_smallest_index = smallest_index;\n    let mut mut_mut_smallest_value\
    \ = mut_smallest_value;\n    let mut mut_mut_smallest_index = mut_smallest_index;\n\
    \    let mut mut_mut_mut_smallest_value = mut_mut_smallest_value;\n    let mut\
    \ mut_mut_mut_smallest_index = mut_mut_smallest_index;\n    let mut mut_mut_mut_mut_smallest_value\
    \ = mut_mut_mut_smallest_value;\n    let mut mut_mut_mut_mut_smallest_index =\
    \ mut_mut_mut_smallest_index;\n    let mut mut_mut_mut_mut_mut_smallest_value\
    \ = mut_mut_mut_mut_smallest_value;\n    let mut mut_mut_mut_mut_mut_smallest_index\
    \ = mut_mut_mut_mut_smallest_index;\n    let mut mut_mut_mut_mut_mut_mut_smallest_value\
    \ = mut_mut_mut_mut_smallest_value;\n    let mut mut_mut_mut_mut_mut_mut_smallest_index\
    \ = mut_mut_mut_mut_mut_smallest_index;\n    let mut mut_mut_mut_mut_mut_mut_mut_smallest_value\
    \ = mut_mut_mut_mut_mut_smallest_value;\n    let mut mut_mut_mut_mut_mut_mut_mut_smallest_index\
    \ = mut_mut_mut_mut_mut_mut_smallest_index;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_smallest_value\
    \ = mut_mut_mut_mut_mut_mut_smallest_value;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_index\
    \ = mut_mut_mut_mut_mut_mut_mut_smallest_index;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_value\
    \ = mut_mut_mut_mut_mut_mut_mut_mut_smallest_value;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_index\
    \ = mut_mut_mut_mut_mu\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpn_1i0_zi.rs:46:92\n   |\n\
    46 |     let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_index =\
    \ mut_mut_mut_mut_mu\n   |                                                   \
    \                                         ^ help: add `;` here\n47 | }\n   | -\
    \ unexpected token\n\nerror[E0425]: cannot find value `mut_mut_mut_mut_mu` in\
    \ this scope\n  --> /tmp/tmpn_1i0_zi.rs:46:74\n   |\n46 |     let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_index\
    \ = mut_mut_mut_mut_mu\n   |                                                 \
    \                         ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpn_1i0_zi.rs:26:30\n   |\n26 | fn pluck(arr:\
    \ Vec<isize>) -> Vec<isize> {\n   |    -----                     ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut even_values = vec![];\n\
    \    let mut smallest_value = vec![];\n    let mut smallest_index = vec![];\n\
    \    for i in arr.iter() {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \        }\n        if even_values.len() == 1 {\n            smallest_value.push(even_values[0]);\n\
    \            smallest_index.push(i);\n        }\n        if even_values.len()\
    \ > 1 {\n            if even_values[0] < smallest_value[0] {\n               \
    \ smallest_value.push(even_values[0]);\n                smallest_index.push(i);\n\
    \            }\n        }\n    }\n    smallest_value\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5y4imllv.rs:45:5\n   |\n\
    26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                         \
    \     ---------- expected `Vec<isize>` because of return type\n...\n45 |     smallest_value\n\
    \   |     ^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value: isize =\
    \ 0;\n    let mut smallest_index: usize = 0;\n    let mut even_value: isize =\
    \ 0;\n    let mut even_index: usize = 0;\n    let mut index: usize = 0;\n    let\
    \ mut even_values: Vec<isize> = vec![];\n    let mut values: Vec<isize> = vec![];\n\
    \    for value in arr {\n        if value % 2 == 0 {\n            even_values.push(value);\n\
    \            even_index += 1;\n        } else {\n            even_value = 0;\n\
    \            even_index = 0;\n            values.push(value);\n            smallest_value\
    \ = value;\n            smallest_index = index;\n        }\n        index += 1;\n\
    \    }\n    if even_values.len() == 0 {\n        return vec![];\n    }\n    if\
    \ even_values.len() == 1 {\n        return vec![even_values[0], even_index];\n\
    \    }\n    if even_values.len() > 1 {\n        let mut smallest_even_value: isize\
    \ = 0;\n        let mut smallest_even_index: usize = 0;\n        for value in\
    \ even_values {\n            if value < smallest_value {\n                smallest_even_value\
    \ = value;\n                smallest_even_index = even_index;\n            }\n\
    \            even_index += 1;\n        }\n        return vec![smallest_even_value,\n\
    \                    smallest_even_index];\n    }\n    return vec![];\n}\n\nfn\
    \ main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1rqpc3ek.rs:51:37\n   |\n\
    51 |         return vec![even_values[0], even_index];\n   |                  \
    \                   ^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you\
    \ can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n51 |         return vec![even_values[0], even_index.try_into().unwrap()];\n\
    \   |                                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1rqpc3ek.rs:64:21\n   |\n64 |              \
    \       smallest_even_index];\n   |                     ^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n64 |                   \
    \  smallest_even_index.try_into().unwrap()];\n   |                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut even_values = vec![];\n\
    \    let mut smallest_value = vec![];\n    let mut smallest_index = vec![];\n\
    \    for i in arr.iter() {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \            if smallest_value.len() == 0 || i < smallest_value[0] {\n       \
    \         smallest_value.push(i);\n                smallest_index.push(i);\n \
    \           }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ vec![];\n    }\n    if smallest_value.len() == 0 {\n        return vec![];\n\
    \    }\n    if even_values.len() == 1 {\n        return vec![even_values[0]];\n\
    \    }\n    if even_values.len() > 1 {\n        let mut smallest_even_value =\
    \ even_values[0];\n        let mut smallest_even_index = smallest_index[0];\n\
    \        for i in even_values.iter().rev() {\n            if i < smallest_even_value\
    \ {\n                smallest_even_value = i;\n                smallest_even_index\
    \ = i;\n            }\n        }\n        return vec![smallest_even_value];\n\
    \    }\n    return vec![];\n}\n\nfn main() {\n    let candidate = pluck;\n   \
    \ assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc43r6mdt.rs:46:21\n   |\n\
    46 |         return vec![even_values[0]];\n   |                     ^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the type\n\
    \   |\n46 |         return vec![*even_values[0]];\n   |                     +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpc43r6mdt.rs:52:20\n   |\n52 |\
    \             if i < smallest_even_value {\n   |                    ^^^^^^^^^^^^^^^^^^^\
    \ expected `&isize`, found `isize`\n   |\n   = note: expected reference `&&isize`\n\
    \              found reference `&isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpc43r6mdt.rs:57:21\n   |\n57 |         return vec![smallest_even_value];\n\
    \   |                     ^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n57 |         return vec![*smallest_even_value];\n\
    \   |                     +\n\nerror: aborting due to 3 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value: isize =\
    \ 0;\n    let mut smallest_index: usize = 0;\n    let mut even_value: isize =\
    \ 0;\n    let mut even_index: usize = 0;\n    let mut index: usize = 0;\n    let\
    \ mut value: isize = 0;\n    let mut even: isize = 0;\n    let mut even_index:\
    \ usize = 0;\n    let mut even_value: isize = 0;\n    let mut even_index: usize\
    \ = 0;\n    let mut even_value: isize = 0;\n    let mut even_index: usize = 0;\n\
    \    let mut even_value: isize = 0;\n    let mut even_index: usize = 0;\n    let\
    \ mut even_value: isize = 0;\n    let mut even_index: usize = 0;\n    let mut\
    \ even_value: isize = 0;\n    let mut even_index: usize = 0;\n    let mut even_value:\
    \ isize = 0;\n    let mut even_index: usize = 0;\n    let mut even_value: isize\
    \ = 0;\n    let mut even_index: usize = 0;\n    let mut even_value: isize = 0;\n\
    \    let mut even_index: usize = 0;\n    let mut even_value: isize = 0;\n    let\
    \ mut even_index: usize = 0;\n    let mut even_value: isize = 0;\n    let mut\
    \ even_index: usize = 0;\n    let mut even_value: isize = 0;\n    let mut even_index:\
    \ usize = 0;\n    let mut even_value: isize = 0;\n    let mut even_index: usize\
    \ = 0;\n    let mut even_value: isize = 0;\n    let mut even_index: usize = 0;\n\
    \    let mut even_value: isize = 0;\n    let mut even_index: usize = 0;\n    let\
    \ mut even_value: isize = 0;\n    let mut even_index: usize = 0;\n    let mut\
    \ even_value: isize = 0;\n    let mut even_index: usize = 0;\n    let mut even_value:\
    \ isize = 0;\n    let mut even_index: usize = 0;\n    let mut even_value: isize\
    \ = 0;\n    let mut even_index: usize = 0;\n    let mut even_value: isize = 0;\n\
    \    let mut even_index: usize = 0;\n    let mut even_value: isize = 0;\n    let\
    \ mut even_index: usize = 0;\n    let mut even_value: isize = 0;\n    let mut\
    \ even_index: usize = 0;\n    let mut even_value: isize = 0;\n    let mut even_index:\
    \ u\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvvfs22ok.rs:78:26\n   |\n\
    78 |     let mut even_index: u\n   |                          ^ help: add `;`\
    \ here\n79 | }\n   | - unexpected token\n\nerror[E0412]: cannot find type `u`\
    \ in this scope\n  --> /tmp/tmpvvfs22ok.rs:78:25\n   |\n78 |     let mut even_index:\
    \ u\n   |                         ^ help: a builtin type with a similar name exists:\
    \ `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvvfs22ok.rs:26:30\n  \
    \ |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----           \
    \          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0412.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 0;\n    let mut min_idx2 = 0;\n    let mut min_idx3 = 0;\n\
    \    for i in arr.iter().rev() {\n        if i % 2 == 0 {\n            if min_value\
    \ == i {\n                min_idx2 = min_idx;\n                min_idx3 = min_idx2;\n\
    \            } else {\n                min_idx2 = min_idx;\n                min_idx3\
    \ = min_idx2;\n            }\n            min_idx = i;\n            min_value\
    \ = i;\n        } else {\n            if min_value == i {\n                min_idx2\
    \ = min_idx;\n                min_idx3 = min_idx2;\n            } else {\n   \
    \             min_idx2 = min_idx;\n                min_idx3 = min_idx2;\n    \
    \        }\n            min_idx = i;\n            min_value = i;\n        }\n\
    \    }\n    if min_idx3 == min_idx2 {\n        min_idx2 = min_idx;\n    }\n  \
    \  if min_idx3 == min_idx {\n        min_idx3 = min_idx2;\n    }\n    if min_idx3\
    \ == min_idx {\n        min_idx3 = min_idx2;\n    }\n    if min_idx3 == min_idx\
    \ {\n        min_idx3 = min_idx2;\n    }\n    if min_idx3 == min_idx {\n     \
    \   min_idx3 = min_idx2;\n    }\n    if min_idx3 == min_idx {\n        min_idx3\
    \ = min_idx2;\n    }\n    if min_idx3 == min_idx {\n        min_idx3 = min_idx2;\n\
    \    }\n    if min_idx3 == min_idx {\n        min_idx3 = min_idx2;\n    }\n  \
    \  if min_idx3 == min_idx {\n        min_idx3 = min_idx2;\n    }\n    if min_idx3\
    \ == min_idx {\n        min_idx3 = min_idx2;\n    }\n    if min_idx3 == min_idx\
    \ {\n        min_idx3 = min_idx2;\n    }\n    if min_idx3 == min_idx {\n     \
    \   min_idx3 = min_idx2;\n    }\n    if min_idx3 == min_idx {\n        min_idx3\
    \ = min_idx2;\n    }\n    if min_idx3 == min_idx {\n        min_idx3 = min_idx2;\n\
    \    }\n    if min_idx3 == min_idx {\n        min_idx3 = min_idx2;\n    }\n  \
    \  if min_idx3 == min_idx {\n        min_idx3 = min_idx2;\n    }\n    if min_idx3\
    \ == min_idx {\n        min_idx3 = min_idx2;\n    }\n    if min_idx3 == min_idx\
    \ {\n        min_idx3 = min_idx2;\n    }\n    if min_idx3 == min_idx {\n     \
    \   min_idx3 = min_idx2;\n    }\n    if min_idx3 == min_idx {\n        min_idx3\
    \ = min_idx2;\n    }\n    if min_idx3 == min_idx {\n        min_idx3 = min_idx2;\n\
    \    }\n    if min_idx3 == min_idx {\n\n}\n\nfn main() {\n    let candidate =\
    \ pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp7gqod9wm.rs:131:3\n\
    \    |\n26  | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    |               \
    \                          - unclosed delimiter\n...\n117 |     if min_idx3 ==\
    \ min_idx {\n    |                            - this delimiter might not be properly\
    \ closed...\n118 | \n119 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n131 | }\n    |   ^\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp7gqod9wm.rs:33:29\n   |\n33 |             if min_value == i {\n   |\
    \                             ^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n33 |             if min_value == *i\
    \ {\n   |                             +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp7gqod9wm.rs:40:23\n   |\n40 |             min_idx = i;\n   |       \
    \                ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n40 |             min_idx = *i;\n   |                     \
    \  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7gqod9wm.rs:41:25\n   |\n\
    41 |             min_value = i;\n   |                         ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n41 |  \
    \           min_value = *i;\n   |                         +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7gqod9wm.rs:43:29\n   |\n43 |             if min_value\
    \ == i {\n   |                             ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n43 |             if min_value\
    \ == *i {\n   |                             +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp7gqod9wm.rs:50:23\n   |\n50 |             min_idx = i;\n   |  \
    \                     ^ expected integer, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n50 |             min_idx = *i;\n   |       \
    \                +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7gqod9wm.rs:51:25\n\
    \   |\n51 |             min_value = i;\n   |                         ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 0;\n    for i in arr.iter().rev() {\n        if i % 2 ==\
    \ 0 {\n            if min_value < i {\n                min_value = i;\n      \
    \          min_idx = i;\n            }\n        }\n    }\n    vec![min_value,\
    \ min_idx]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5629msia.rs:31:28\n   |\n\
    31 |             if min_value < i {\n   |                            ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    31 |             if min_value < *i {\n   |                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5629msia.rs:32:29\n   |\n32 |              \
    \   min_value = i;\n   |                             ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n32 |        \
    \         min_value = *i;\n   |                             +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5629msia.rs:33:27\n   |\n33 |              \
    \   min_idx = i;\n   |                           ^ expected integer, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n33 |                 min_idx\
    \ = *i;\n   |                           +\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 0;\n    let mut min_even_count = 0;\n    for &i in arr {\n\
    \        if i % 2 == 0 {\n            min_even_count += 1;\n            if min_even_count\
    \ > min_value {\n                min_value = i;\n                min_idx = i;\n\
    \            }\n        }\n    }\n    if min_even_count == 0 {\n        return\
    \ vec![];\n    }\n    vec![min_value, min_idx]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw0w1igvm.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 0;\n    for i in arr.iter().rev() {\n        if i % 2 ==\
    \ 0 {\n            if min_value < i {\n                min_value = i;\n      \
    \          min_idx = i;\n            }\n        }\n    }\n    vec![min_value,\
    \ min_idx]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5629msia.rs:31:28\n   |\n\
    31 |             if min_value < i {\n   |                            ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    31 |             if min_value < *i {\n   |                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5629msia.rs:32:29\n   |\n32 |              \
    \   min_value = i;\n   |                             ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n32 |        \
    \         min_value = *i;\n   |                             +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5629msia.rs:33:27\n   |\n33 |              \
    \   min_idx = i;\n   |                           ^ expected integer, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n33 |                 min_idx\
    \ = *i;\n   |                           +\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut even_values = vec![];\n\
    \    let mut smallest_value = vec![];\n    let mut smallest_index = vec![];\n\
    \    for i in arr.iter() {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \            if smallest_value.len() == 0 || smallest_value[0] < i {\n       \
    \         smallest_value.push(i);\n                smallest_index.push(i);\n \
    \           }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ vec![];\n    }\n    if even_values.len() == 1 {\n        return vec![even_values[0]];\n\
    \    }\n    if even_values.len() > 1 {\n        let mut smallest_value = vec![];\n\
    \        let mut smallest_index = vec![];\n        for i in even_values.iter()\
    \ {\n            if i % 2 == 0 {\n                if smallest_value.len() == 0\
    \ || smallest_value[0] < i {\n                    smallest_value.push(i);\n  \
    \                  smallest_index.push(i);\n                }\n            }\n\
    \        }\n        if smallest_value.len() == 1 {\n            return vec![smallest_value[0]];\n\
    \        }\n    }\n    return smallest_index;\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnsda8_mw.rs:43:21\n   |\n\
    43 |         return vec![even_values[0]];\n   |                     ^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the type\n\
    \   |\n43 |         return vec![*even_values[0]];\n   |                     +\n\
    \nerror[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmpnsda8_mw.rs:49:18\n\
    \   |\n49 |             if i % 2 == 0 {\n   |                - ^ - {integer}\n\
    \   |                |\n   |                &&isize\n   |\nhelp: `%` can be used\
    \ on `isize`, you can dereference `i`\n   |\n49 |             if *i % 2 == 0 {\n\
    \   |                +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnsda8_mw.rs:57:25\n\
    \   |\n57 |             return vec![smallest_value[0]];\n   |                \
    \         ^^^^^^^^^^^^^^^^^ expected `isize`, found `&&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnsda8_mw.rs:60:12\n   |\n26 | fn pluck(arr:\
    \ Vec<isize>) -> Vec<isize> {\n   |                              ---------- expected\
    \ `Vec<isize>` because of return type\n...\n60 |     return smallest_index;\n\
    \   |            ^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value: isize =\
    \ 0;\n    let mut smallest_index: usize = 0;\n    let mut even_values: Vec<isize>\
    \ = Vec::new();\n    for &i in arr {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \        }\n        if i == smallest_value {\n            smallest_index = arr.iter().position(|&i|\
    \ i == i).unwrap();\n        }\n        if i == smallest_value {\n           \
    \ smallest_value = i;\n        }\n    }\n    if even_values.len() == 0 {\n   \
    \     return vec![];\n    }\n    let mut smallest_even_value = even_values[0];\n\
    \    let mut smallest_even_index = arr.iter().position(|&i| i == smallest_even_value).unwrap();\n\
    \    for i in even_values.iter().rev() {\n        if i == smallest_value {\n \
    \           smallest_even_value = i;\n            smallest_even_index = arr.iter().position(|&i|\
    \ i == i).unwrap();\n        }\n    }\n    let mut result = vec![smallest_value,\
    \ smallest_index];\n    for i in even_values.iter().rev() {\n        if i == smallest_value\
    \ {\n            result.push(smallest_even_index);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcob3_o2w.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpcob3_o2w.rs:48:35\n   |\n48 |             smallest_even_value\
    \ = i;\n   |                                   ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n48 |             smallest_even_value\
    \ = *i;\n   |                                   +\n\nerror[E0277]: can't compare\
    \ `&isize` with `isize`\n  --> /tmp/tmpcob3_o2w.rs:47:14\n   |\n47 |         if\
    \ i == smallest_value {\n   |              ^^ no implementation for `&isize ==\
    \ isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented for\
    \ `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcob3_o2w.rs:52:43\n\
    \   |\n52 |     let mut result = vec![smallest_value, smallest_index];\n   | \
    \                                          ^^^^^^^^^^^^^^ expected `isize`, found\
    \ `usize`\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpcob3_o2w.rs:54:14\n\
    \   |\n54 |         if i == smallest_value {\n   |              ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcob3_o2w.rs:55:25\n\
    \   |\n55 |             result.push(smallest_even_index);\n   |              \
    \           ^^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you\
    \ can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n55 |             result.push(smallest_even_index.try_into().unwrap());\n\
    \   |                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror:\
    \ aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 0;\n    for &x in arr {\n        if x % 2 == 0 {\n     \
    \       if min_value < x {\n                min_value = x;\n                min_idx\
    \ = x;\n            }\n        }\n    }\n    vec![min_value, min_idx]\n}\n\nfn\
    \ main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwk4c248f.rs:29:9\n   |\n\
    29 |     for &x in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut even_values = vec![];\n\
    \    let mut smallest_value = vec![];\n    let mut smallest_index = vec![];\n\
    \    for i in arr.iter() {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \            if i < smallest_value.len() {\n                smallest_value[i]\
    \ = i;\n                smallest_index[i] = i;\n            }\n        } else\
    \ {\n            if i < smallest_value.len() {\n                smallest_value[i]\
    \ = i;\n                smallest_index[i] = i;\n            }\n        }\n   \
    \ }\n    if even_values.len() == 0 {\n        return vec![];\n    }\n    if even_values.len()\
    \ == 1 {\n        return vec![even_values[0]];\n    }\n    let mut smallest_value_pos\
    \ = 0;\n    for i in even_values.iter() {\n        if smallest_value[smallest_value_pos]\
    \ < i {\n            smallest_value_pos = i;\n        }\n    }\n    let mut smallest_value_neg\
    \ = 0;\n    for i in even_values.iter() {\n        if smallest_value[smallest_value_neg]\
    \ > i {\n            smallest_value_neg = i;\n        }\n    }\n    if smallest_value_neg\
    \ < smallest_value_pos {\n        smallest_value_neg += 1;\n    }\n    smallest_value[smallest_value_pos]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkxqzgyjy.rs:33:20\n   |\n\
    33 |             if i < smallest_value.len() {\n   |                    ^^^^^^^^^^^^^^^^^^^^\
    \ expected `&isize`, found `usize`\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `&isize`\n  --> /tmp/tmpkxqzgyjy.rs:34:17\n   |\n34 |                 smallest_value[i]\
    \ = i;\n   |                 ^^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>` is not implemented\
    \ for `&isize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<_>`\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `&isize`\n  --> /tmp/tmpkxqzgyjy.rs:35:17\n   |\n35 |                 smallest_index[i]\
    \ = i;\n   |                 ^^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>` is not implemented\
    \ for `&isize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkxqzgyjy.rs:38:20\n\
    \   |\n38 |             if i < smallest_value.len() {\n   |                  \
    \  ^^^^^^^^^^^^^^^^^^^^ expected `&isize`, found `usize`\n\nerror[E0277]: the\
    \ type `[_]` cannot be indexed by `&isize`\n  --> /tmp/tmpkxqzgyjy.rs:39:17\n\
    \   |\n39 |                 smallest_value[i] = i;\n   |                 ^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[_]>` is not implemented for `&isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<&isize>` for `Vec<_>`\n\n\
    error[E0277]: the type `[_]` cannot be indexed by `&isize`\n  --> /tmp/tmpkxqzgyjy.rs:40:17\n\
    \   |\n40 |                 smallest_index[i] = i;\n   |                 ^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[_]>` is not implemented for `&isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<&isize>` for `Vec<_>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpkxq"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 0;\n    for i in arr.iter().rev() {\n        if i % 2 ==\
    \ 0 {\n            if min_value < i {\n                min_value = i;\n      \
    \          min_idx = i;\n            }\n        }\n    }\n    vec![min_value,\
    \ min_idx]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5629msia.rs:31:28\n   |\n\
    31 |             if min_value < i {\n   |                            ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    31 |             if min_value < *i {\n   |                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5629msia.rs:32:29\n   |\n32 |              \
    \   min_value = i;\n   |                             ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n32 |        \
    \         min_value = *i;\n   |                             +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5629msia.rs:33:27\n   |\n33 |              \
    \   min_idx = i;\n   |                           ^ expected integer, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n33 |                 min_idx\
    \ = *i;\n   |                           +\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_even_value = arr[0];\n\
    \    let mut smallest_even_index = 0;\n    let mut smallest_even_index_in_vec\
    \ = 0;\n    let mut smallest_even_index_in_vec_to_return = 0;\n    for &i in arr\
    \ {\n        if i % 2 == 0 {\n            if smallest_even_index == i {\n    \
    \            smallest_even_index_in_vec++;\n                smallest_even_index_in_vec_to_return\
    \ = i;\n            }\n            if smallest_even_index < i {\n            \
    \    smallest_even_index = i;\n                smallest_even_index_in_vec = 0;\n\
    \                smallest_even_index_in_vec_to_return = i;\n            }\n  \
    \      }\n    }\n    if smallest_even_index_in_vec == 0 {\n        return vec![];\n\
    \    }\n    let mut returned_vec = vec![smallest_even_value];\n    for &i in arr\
    \ {\n        if i % 2 == 0 {\n            if smallest_even_index_in_vec_to_return\
    \ == i {\n                smallest_even_index_in_vec_to_return = i;\n        \
    \    }\n            if smallest_even_index_in_vec_to_return < i {\n          \
    \      smallest_even_index_in_vec_to_return = i;\n            }\n        }\n \
    \   }\n    returned_vec.push(smallest_even_index_in_vec_to_return);\n    return\
    \ returned_vec;\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `+`\n  --> /tmp/tmp7zwy1fjz.rs:34:44\n\
    \   |\n34 |                 smallest_even_index_in_vec++;\n   |              \
    \                              ^ expected expression\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7zwy1fjz.rs:31:9\n   |\n31 |     for &i in arr {\n   |\
    \         ^^    --- this expression has type `isize`\n   |         |\n   |   \
    \      expected `isize`, found reference\n   |\n   = note:   expected type `isize`\n\
    \           found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7zwy1fjz.rs:48:9\n\
    \   |\n48 |     for &i in arr {\n   |         ^^    --- this expression has type\
    \ `isize`\n   |         |\n   |         expected `isize`, found reference\n  \
    \ |\n   = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value: isize =\
    \ 0;\n    let mut smallest_index: usize = 0;\n    for &node in &arr {\n      \
    \  if node.value % 2 == 0 {\n            if smallest_value == 0 {\n          \
    \      smallest_value = node.value;\n                smallest_index = node.index;\n\
    \            } else {\n                if node.value < smallest_value {\n    \
    \                smallest_value = node.value;\n                    smallest_index\
    \ = node.index;\n                }\n            }\n        }\n    }\n    if smallest_value\
    \ == 0 {\n        return vec![];\n    }\n    let mut result = vec![smallest_value,\
    \ smallest_index];\n    let mut current_index = 0;\n    for &node in &arr {\n\
    \        if node.value % 2 == 0 {\n            if node.index == current_index\
    \ {\n                result.push(node.value);\n            } else {\n        \
    \        result.push(node.value);\n                current_index = node.index;\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0610]: `isize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmps_3e34k8.rs:30:17\n   |\n30 |         if node.value % 2 == 0 {\n\
    \   |                 ^^^^^\n\nerror[E0610]: `isize` is a primitive type and therefore\
    \ doesn't have fields\n  --> /tmp/tmps_3e34k8.rs:32:39\n   |\n32 |           \
    \      smallest_value = node.value;\n   |                                    \
    \   ^^^^^\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't have\
    \ fields\n  --> /tmp/tmps_3e34k8.rs:33:39\n   |\n33 |                 smallest_index\
    \ = node.index;\n   |                                       ^^^^^\n\nerror[E0610]:\
    \ `isize` is a primitive type and therefore doesn't have fields\n  --> /tmp/tmps_3e34k8.rs:35:25\n\
    \   |\n35 |                 if node.value < smallest_value {\n   |           \
    \              ^^^^^\n\nerror[E0610]: `isize` is a primitive type and therefore\
    \ doesn't have fields\n  --> /tmp/tmps_3e34k8.rs:36:43\n   |\n36 |           \
    \          smallest_value = node.value;\n   |                                \
    \           ^^^^^\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't\
    \ have fields\n  --> /tmp/tmps_3e34k8.rs:37:43\n   |\n37 |                   \
    \  smallest_index = node.index;\n   |                                        \
    \   ^^^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps_3e34k8.rs:45:43\n\
    \   |\n45 |     let mut result = vec![smallest_value, smallest_index];\n   | \
    \                                          ^^^^^^^^^^^^^^ expected `isize`, found\
    \ `usize`\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't have\
    \ fields\n  --> /tmp/tmps_3e34k8.rs:48:17\n   |\n48 |         if node.value %\
    \ 2 == 0 {\n   |                 ^^^^^\n\nerror[E0610]: `isize` is a primitive\
    \ type and therefore doesn't have fields\n  --> /tmp/tmps_3e34k8.rs:49:21\n  \
    \ |\n49 |             if node.index == current_index {\n   |                 \
    \    ^^^^^\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't\
    \ have fields\n  --> /tmp/tmps_3e34k8.rs:50:34\n   |\n50 |                 result.push(node.value);\n\
    \   |                                  "
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value: isize =\
    \ 0;\n    let mut smallest_index: usize = 0;\n    let mut even_values = false;\n\
    \    let mut even_values_index = 0;\n    let mut even_values_index2 = 0;\n   \
    \ let mut even_values_index3 = 0;\n    let mut even_values_index4 = 0;\n    let\
    \ mut even_values_index5 = 0;\n    let mut even_values_index6 = 0;\n    let mut\
    \ even_values_index7 = 0;\n    let mut even_values_index8 = 0;\n    let mut even_values_index9\
    \ = 0;\n    let mut even_values_index10 = 0;\n    let mut even_values_index11\
    \ = 0;\n    let mut even_values_index12 = 0;\n    let mut even_values_index13\
    \ = 0;\n    let mut even_values_index14 = 0;\n    let mut even_values_index15\
    \ = 0;\n    let mut even_values_index16 = 0;\n    let mut even_values_index17\
    \ = 0;\n    let mut even_values_index18 = 0;\n    let mut even_values_index19\
    \ = 0;\n    let mut even_values_index20 = 0;\n    let mut even_values_index21\
    \ = 0;\n    let mut even_values_index22 = 0;\n    let mut even_values_index23\
    \ = 0;\n    let mut even_values_index24 = 0;\n    let mut even_values_index25\
    \ = 0;\n    let mut even_values_index26 = 0;\n    let mut even_values_index27\
    \ = 0;\n    let mut even_values_index28 = 0;\n    let mut even_values_index29\
    \ = 0;\n    let mut even_values_index30 = 0;\n    let mut even_values_index31\
    \ = 0;\n    let mut even_values_index32 = 0;\n    let mut even_values_index33\
    \ = 0;\n    let mut even_values_index34 = 0;\n    let mut even_values_index35\
    \ = 0;\n    let mut even_values_index36 = 0;\n    let mut even_values_index37\
    \ = 0;\n    let mut even_values_index38 = 0;\n    let mut even_values_index39\
    \ = 0;\n    let mut even_values_index40 = 0;\n    let mut even_values_index41\
    \ = 0;\n    let mut even_values_index42 = 0;\n    let mut even_values_index43\
    \ = 0;\n    let mut even_values_index44 = 0;\n    let mut even_values_index45\
    \ = 0;\n    let mut even_values_index46 = 0;\n    let mut even_values_index47\
    \ = 0;\n    let mut even_values_index48 = 0;\n    let mut even_values_index49\
    \ = 0;\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpemfe0yc2.rs:26:30\n   |\n\
    26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----                \
    \     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 1;\n    let mut min_idx = 1;\n    for &x in arr {\n    \
    \    if x % 2 == 0 {\n            if min_value % 2 == 0 {\n                min_value\
    \ = x;\n                min_idx = 1;\n            } else {\n                min_value\
    \ = x;\n                min_idx = 2;\n            }\n        }\n    }\n    if\
    \ min_value == 0 {\n        return vec![];\n    }\n    vec![min_value, min_idx]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpct_g3os_.rs:30:9\n   |\n\
    30 |     for &x in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut even_values = Vec::new();\n\
    \    let mut min_value = i32::MAX;\n    let mut min_value_index = -1;\n    for\
    \ i in arr.iter() {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \            if i < min_value {\n                min_value = i;\n            \
    \    min_value_index = i;\n            }\n        }\n    }\n    if even_values.len()\
    \ == 0 {\n        return vec![];\n    }\n    let mut smallest_value = i32::MAX;\n\
    \    let mut smallest_value_index = -1;\n    for i in even_values.iter() {\n \
    \       if i < smallest_value {\n            smallest_value = i;\n           \
    \ smallest_value_index = i;\n        }\n    }\n    let mut result = vec![];\n\
    \    for i in even_values.iter() {\n        if i == smallest_value {\n       \
    \     result.push(smallest_value_index);\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphk1nxc4f.rs:33:20\n   |\n\
    33 |             if i < min_value {\n   |                    ^^^^^^^^^ expected\
    \ `&isize`, found `i32`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphk1nxc4f.rs:34:29\n\
    \   |\n34 |                 min_value = i;\n   |                             ^\
    \ expected `i32`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphk1nxc4f.rs:35:35\n\
    \   |\n35 |                 min_value_index = i;\n   |                       \
    \            ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n35 |                 min_value_index = *i;\n   |         \
    \                          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphk1nxc4f.rs:45:16\n\
    \   |\n45 |         if i < smallest_value {\n   |                ^^^^^^^^^^^^^^\
    \ expected `&&isize`, found `i32`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphk1nxc4f.rs:46:30\n\
    \   |\n46 |             smallest_value = i;\n   |                            \
    \  ^ expected `i32`, found `&&isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmphk1nxc4f.rs:47:36\n   |\n47 |             smallest_value_index = i;\n\
    \   |                                    ^ expected integer, found `&&isize`\n\
    \nerror[E0277]: can't compare `&&isize` with `i32`\n  --> /tmp/tmphk1nxc4f.rs:52:14\n\
    \   |\n52 |         if i == smallest_value {\n   |              ^^ no implementation\
    \ for `&&isize == i32`\n   |\n   = help: the trait `PartialEq<i32>` is not implemented\
    \ for `&&isize`\n\nerror: aborting due to 7 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut even_values = vec![];\n\
    \    let mut smallest_value = vec![];\n    let mut smallest_index = vec![];\n\
    \    let mut smallest_index_value = vec![];\n    for i in arr.iter() {\n     \
    \   if i % 2 == 0 {\n            even_values.push(i);\n            if i < smallest_value.len()\
    \ {\n                smallest_value.push(i);\n                smallest_index.push(i);\n\
    \                smallest_index_value.push(i);\n            }\n        } else\
    \ {\n            if i < smallest_value.len() {\n                smallest_value.push(i);\n\
    \                smallest_index.push(i);\n                smallest_index_value.push(i);\n\
    \            }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ vec![];\n    }\n    if even_values.len() == 1 {\n        return vec![even_values[0]];\n\
    \    }\n    if even_values.len() > 1 {\n        let mut smallest_value_iter =\
    \ smallest_value.iter();\n        let mut smallest_index_iter = smallest_index.iter();\n\
    \        let mut smallest_index_value_iter = smallest_index_value.iter();\n  \
    \      let mut even_values_iter = even_values.iter();\n        if even_values_iter.next().unwrap()\
    \ == even_values_iter.next().unwrap() {\n            smallest_value_iter.next();\n\
    \            smallest_index_iter.next();\n            smallest_index_value_iter.next();\n\
    \        }\n        let mut smallest_value = vec![];\n        let mut smallest_index\
    \ = vec![];\n        let mut smallest_index_value = vec![];\n        for i in\
    \ even_values.iter() {\n            if i % 2 == 0 {\n                smallest_value.push(i);\n\
    \                if i < smallest_value.len() {\n                    smallest_index.push(i);\n\
    \                    smallest_index_value.push(i);\n                }\n      \
    \      } else {\n                if i < smallest_value.len() {\n             \
    \       smallest_value.push(i);\n                    smallest_index.push(i);\n\
    \                    smallest_index_value.push(i);\n                }\n      \
    \      }\n        }\n        if smallest_value.len() == 0 {\n            return\
    \ vec![];\n        }\n        if smallest_value.len() == 1 {\n            return\
    \ vec![smallest_value[0]];\n        }\n        if smallest_value.len() > 1 {\n\
    \            let mut smallest_value_iter = smallest_value.iter();\n          \
    \  let mut smallest_index_iter = smallest_index.iter();\n            let mut smallest_index_value_iter\
    \ = smallest_index_value.iter();\n            let mut even_values_iter = even_values.iter();\n\
    \            if even_values_iter.next().unwrap() == even_values_iter.next().unwrap()\
    \ {\n                smallest_value_iter.next();\n                smallest_index_iter.next();\n\
    \                smallest_index_value_iter.next();\n            }\n          \
    \  let \n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmptrckrhw4.rs:110:3\n\
    \    |\n26  | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    |               \
    \                          - unclosed delimiter\n...\n53  |     if even_values.len()\
    \ > 1 {\n    |                              - unclosed delimiter\n...\n87  | \
    \        if smallest_value.len() > 1 {\n    |                                \
    \     - this delimiter might not be properly closed...\n...\n98  | }\n    | -\
    \ ...as it matches this but it has different indentation\n...\n110 | }\n    |\
    \   ^\n\nerror: expected pattern, found `}`\n  --> /tmp/tmptrckrhw4.rs:98:1\n\
    \   |\n98 | }\n   | ^ expected pattern\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmptrckrhw4.rs:34:20\n   |\n34 |             if i < smallest_value.len()\
    \ {\n   |                    ^^^^^^^^^^^^^^^^^^^^ expected `&isize`, found `usize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptrckrhw4.rs:40:20\n   |\n40 |\
    \             if i < smallest_value.len() {\n   |                    ^^^^^^^^^^^^^^^^^^^^\
    \ expected `&isize`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptrckrhw4.rs:51:21\n\
    \   |\n51 |         return vec![even_values[0]];\n   |                     ^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the type\n\
    \   |\n51 |         return vec![*even_values[0]];\n   |                     +\n\
    \nerror[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmptrckrhw4.rs:67:18\n\
    \   |\n67 |             if i % 2 == 0 {\n   |                - ^ - {integer}\n\
    \   |                |\n   |                &&isize\n   |\nhelp: `%` can be used\
    \ on `isize`, you can dereference `i`\n   |\n67 |             if *i % 2 == 0 {\n\
    \   |                +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptrckrhw4.rs:69:24\n\
    \   |\n69 |                 if i < smallest_value.len() {\n   |              \
    \          ^^^^^^^^^^^^^^^^^^^^ expected `&&isize`, found `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptrckrhw4.rs:74:24\n   |\n74 |              \
    \   if i < smallest_value.len() {\n   |                        ^^^^^^^^^^^^^^^^^^^^\
    \ expected `&&isize"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 0;\n    let mut min_idx2 = 0;\n    let mut min_idx3 = 0;\n\
    \    let mut min_idx4 = 0;\n    let mut min_idx5 = 0;\n    let mut min_idx6 =\
    \ 0;\n    let mut min_idx7 = 0;\n    let mut min_idx8 = 0;\n    let mut min_idx9\
    \ = 0;\n    let mut min_idx10 = 0;\n    let mut min_idx11 = 0;\n    let mut min_idx12\
    \ = 0;\n    let mut min_idx13 = 0;\n    let mut min_idx14 = 0;\n    let mut min_idx15\
    \ = 0;\n    let mut min_idx16 = 0;\n    let mut min_idx17 = 0;\n    let mut min_idx18\
    \ = 0;\n    let mut min_idx19 = 0;\n    let mut min_idx20 = 0;\n    let mut min_idx21\
    \ = 0;\n    let mut min_idx22 = 0;\n    let mut min_idx23 = 0;\n    let mut min_idx24\
    \ = 0;\n    let mut min_idx25 = 0;\n    let mut min_idx26 = 0;\n    let mut min_idx27\
    \ = 0;\n    let mut min_idx28 = 0;\n    let mut min_idx29 = 0;\n    let mut min_idx30\
    \ = 0;\n    let mut min_idx31 = 0;\n    let mut min_idx32 = 0;\n    let mut min_idx33\
    \ = 0;\n    let mut min_idx34 = 0;\n    let mut min_idx35 = 0;\n    let mut min_idx36\
    \ = 0;\n    let mut min_idx37 = 0;\n    let mut min_idx38 = 0;\n    let mut min_idx39\
    \ = 0;\n    let mut min_idx40 = 0;\n    let mut min_idx41 = 0;\n    let mut min_idx42\
    \ = 0;\n    let mut min_idx43 = 0;\n    let mut min_idx44 = 0;\n    let mut min_idx45\
    \ = 0;\n    let mut min_idx46 = 0;\n    let mut min_idx47 = 0;\n    let mut min_idx48\
    \ = 0;\n    let mut min_idx49 = 0;\n    let mut min_idx50 = 0;\n    let mut min_idx51\
    \ = 0;\n    let mut min_idx52 = 0;\n    let mut min_idx53 = 0;\n    let mut min_idx54\
    \ = 0;\n    let mut min_idx55 = 0;\n    let mut min_idx56 = 0;\n    let mut min_idx57\
    \ = 0;\n    let mut min_idx58 = 0;\n    let mut min_idx59 = 0;\n    let mut min_idx60\
    \ = 0;\n    let mut min_idx61 = 0;\n    let mut min_idx62 = 0;\n    let mut min_idx63\
    \ = 0;\n    let mut min_idx\n}\n\nfn main() {\n    let candidate = pluck;\n  \
    \  assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_84wucx7.rs:91:20\n   |\n\
    91 |     let mut min_idx\n   |                    ^ help: add `;` here\n92 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_84wucx7.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 0;\n    let mut min_even_count = 0;\n    for &v in arr.iter().rev()\
    \ {\n        if v % 2 == 0 {\n            min_even_count += 1;\n            if\
    \ min_even_count > min_value {\n                min_value = v;\n             \
    \   min_idx = arr.len() - 1 - v;\n            }\n        }\n    }\n    vec![min_value,\
    \ min_idx]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx5ztfpep.rs:35:43\n   |\n\
    35 |                 min_idx = arr.len() - 1 - v;\n   |                      \
    \                     ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot\
    \ subtract `isize` from `usize`\n  --> /tmp/tmpx5ztfpep.rs:35:41\n   |\n35 | \
    \                min_idx = arr.len() - 1 - v;\n   |                          \
    \               ^ no implementation for `usize - isize`\n   |\n   = help: the\
    \ trait `Sub<isize>` is not implemented for `usize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpx5ztfpep.rs:39:21\n   |\n39 |     vec![min_value, min_idx]\n\
    \   |                     ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n39 |     vec![min_value, min_idx.try_into().unwrap()]\n   |     \
    \                ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = -1;\n    let mut min_idx2 = -1;\n    let mut min_idx3 =\
    \ -1;\n    let mut min_idx4 = -1;\n    let mut min_idx5 = -1;\n    let mut min_idx6\
    \ = -1;\n    let mut min_idx7 = -1;\n    let mut min_idx8 = -1;\n    let mut min_idx9\
    \ = -1;\n    let mut min_idx10 = -1;\n    let mut min_idx11 = -1;\n    let mut\
    \ min_idx12 = -1;\n    let mut min_idx13 = -1;\n    let mut min_idx14 = -1;\n\
    \    let mut min_idx15 = -1;\n    let mut min_idx16 = -1;\n    let mut min_idx17\
    \ = -1;\n    let mut min_idx18 = -1;\n    let mut min_idx19 = -1;\n    let mut\
    \ min_idx20 = -1;\n    let mut min_idx21 = -1;\n    let mut min_idx22 = -1;\n\
    \    let mut min_idx23 = -1;\n    let mut min_idx24 = -1;\n    let mut min_idx25\
    \ = -1;\n    let mut min_idx26 = -1;\n    let mut min_idx27 = -1;\n    let mut\
    \ min_idx28 = -1;\n    let mut min_idx29 = -1;\n    let mut min_idx30 = -1;\n\
    \    let mut min_idx31 = -1;\n    let mut min_idx32 = -1;\n    let mut min_idx33\
    \ = -1;\n    let mut min_idx34 = -1;\n    let mut min_idx35 = -1;\n    let mut\
    \ min_idx36 = -1;\n    let mut min_idx37 = -1;\n    let mut min_idx38 = -1;\n\
    \    let mut min_idx39 = -1;\n    let mut min_idx40 = -1;\n    let mut min_idx41\
    \ = -1;\n    let mut min_idx42 = -1;\n    let mut min_idx43 = -1;\n    let mut\
    \ min_idx44 = -1;\n    let mut min_idx45 = -1;\n    let mut min_idx46 = -1;\n\
    \    let mut min_idx47 = -1;\n    let mut min_idx48 = -1;\n    let mut min_idx49\
    \ = -1;\n    let mut min_idx50 = -1;\n    let mut min_idx51 = -1;\n    let mut\
    \ min_idx52 = -1;\n    let mut min_idx53 = -1;\n    let mut min_idx54 = -1;\n\
    \    let mut min_idx55 = -1;\n    let mut min_idx56 = -1;\n    let mut min_idx57\
    \ = -1;\n    let mut min_\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpplykd72m.rs:85:17\n   |\n\
    85 |     let mut min_\n   |                 ^ help: add `;` here\n86 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpplykd72m.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 0;\n    for i in arr.iter().rev() {\n        if i % 2 ==\
    \ 0 {\n            min_value = i;\n            min_idx = i;\n        }\n    }\n\
    \    vec![min_value, min_idx]\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvm2upu9t.rs:31:25\n   |\n\
    31 |             min_value = i;\n   |                         ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n31 |  \
    \           min_value = *i;\n   |                         +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvm2upu9t.rs:32:23\n   |\n32 |             min_idx = i;\n\
    \   |                       ^ expected integer, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n32 |             min_idx = *i;\n   |       \
    \                +\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 0;\n    for &i in arr {\n        if i % 2 == 0 {\n     \
    \       if min_value == i {\n                min_idx = i;\n            }\n   \
    \         else {\n                min_value = i;\n                min_idx = i;\n\
    \            }\n        }\n    }\n    vec![min_value, min_idx]\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxk_svq51.rs:29:9\n   |\n\
    29 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even_value = arr[0];\n\
    \    let mut min_even_index = -1;\n    let mut min_even_index2 = -1;\n    let\
    \ mut min_even_index3 = -1;\n    let mut min_even_index4 = -1;\n    let mut min_even_index5\
    \ = -1;\n    let mut min_even_index6 = -1;\n    let mut min_even_index7 = -1;\n\
    \    let mut min_even_index8 = -1;\n    let mut min_even_index9 = -1;\n    let\
    \ mut min_even_index10 = -1;\n    let mut min_even_index11 = -1;\n    let mut\
    \ min_even_index12 = -1;\n    let mut min_even_index13 = -1;\n    let mut min_even_index14\
    \ = -1;\n    let mut min_even_index15 = -1;\n    let mut min_even_index16 = -1;\n\
    \    let mut min_even_index17 = -1;\n    let mut min_even_index18 = -1;\n    let\
    \ mut min_even_index19 = -1;\n    let mut min_even_index20 = -1;\n    let mut\
    \ min_even_index21 = -1;\n    let mut min_even_index22 = -1;\n    let mut min_even_index23\
    \ = -1;\n    let mut min_even_index24 = -1;\n    let mut min_even_index25 = -1;\n\
    \    let mut min_even_index26 = -1;\n    let mut min_even_index27 = -1;\n    let\
    \ mut min_even_index28 = -1;\n    let mut min_even_index29 = -1;\n    let mut\
    \ min_even_index30 = -1;\n    let mut min_even_index31 = -1;\n    let mut min_even_index32\
    \ = -1;\n    let mut min_even_index33 = -1;\n    let mut min_even_index34 = -1;\n\
    \    let mut min_even_index35 = -1;\n    let mut min_even_index36 = -1;\n    let\
    \ mut min_even_index37 = -1;\n    let mut min_even_index38 = -1;\n    let mut\
    \ min_even_index39 = -1;\n    let mut min_even_index40 = -1;\n    let mut min_even_index41\
    \ = -1;\n    let mut min_even_index42 = -1;\n    let mut min_even_index43 = -1;\n\
    \    let mut min_even_index44 = -1;\n    let mut min_even_index45 = -1;\n    let\
    \ mut min_even_index46 = -1;\n    let mut min_even_index47 = -1;\n    let mut\
    \ min_even_index48 = -1;\n    let mut min_even_index49 = -1;\n    let mut min_even_index50\
    \ = -1;\n    let mut min_even_index51 = -1;\n    let mut min_even_index\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpcs38ck2d.rs:79:27\n   |\n\
    79 |     let mut min_even_index\n   |                           ^ help: add `;`\
    \ here\n80 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpcs38ck2d.rs:26:30\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |    -----                     ^^^^^^^^^^ expected struct `Vec`, found\
    \ `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or\
    \ `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n       \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_even_value = arr[0];\n\
    \    let mut smallest_even_index = -1;\n    let mut smallest_index = -1;\n   \
    \ for i in arr.iter().rev() {\n        if i % 2 == 0 {\n            if smallest_even_index\
    \ == -1 || smallest_even_index > i {\n                smallest_even_value = i;\n\
    \                smallest_even_index = i;\n                smallest_index = i;\n\
    \            } else {\n                if smallest_even_index > i {\n        \
    \            smallest_even_index = i;\n                    smallest_index = i;\n\
    \                }\n            }\n        }\n    }\n    if smallest_even_index\
    \ == -1 {\n        return vec![];\n    }\n    let mut result = vec![smallest_even_value];\n\
    \    if smallest_index != -1 {\n        result.push(smallest_index);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplgcl1mj0.rs:33:39\n   |\n\
    33 |                 smallest_even_value = i;\n   |                          \
    \             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n33 |                 smallest_even_value = *i;\n   |     \
    \                                  +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmplgcl1mj0.rs:34:39\n   |\n34 |                 smallest_even_index =\
    \ i;\n   |                                       ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n34 |                 smallest_even_index\
    \ = *i;\n   |                                       +\n\nerror[E0277]: can't compare\
    \ `isize` with `&isize`\n  --> /tmp/tmplgcl1mj0.rs:32:65\n   |\n32 |         \
    \    if smallest_even_index == -1 || smallest_even_index > i {\n   |         \
    \                                                        ^ no implementation for\
    \ `isize < &isize` and `isize > &isize`\n   |\n   = help: the trait `PartialOrd<&isize>`\
    \ is not implemented for `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplgcl1mj0.rs:35:34\n\
    \   |\n35 |                 smallest_index = i;\n   |                        \
    \          ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n35 |                 smallest_index = *i;\n   |          \
    \                        +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplgcl1mj0.rs:37:42\n\
    \   |\n37 |                 if smallest_even_index > i {\n   |               \
    \                           ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n37 |                 if smallest_even_index\
    \ > *i {\n   |                                          +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmplgcl1mj0.rs:38:43\n   |\n38 |                     smallest_even_index\
    \ = i;\n   |                                           ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n38 |        \
    \             smallest_even_index = *i;\n   |                                \
    \     "
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value: isize =\
    \ 0;\n    let mut smallest_index: usize = 0;\n    for &i in arr {\n        if\
    \ i % 2 == 0 {\n            if smallest_value == i {\n                smallest_index\
    \ = i;\n            } else {\n                smallest_value = i;\n          \
    \      smallest_index = i;\n            }\n        }\n    }\n    vec![smallest_value,\
    \ smallest_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxahmnf3r.rs:29:9\n   |\n\
    29 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxahmnf3r.rs:32:34\n   |\n32 |                 smallest_index\
    \ = i;\n   |                                  ^ expected `usize`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpxahmnf3r.rs:35:34\n   |\n35 |\
    \                 smallest_index = i;\n   |                                  ^\
    \ expected `usize`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxahmnf3r.rs:39:26\n\
    \   |\n39 |     vec![smallest_value, smallest_index]\n   |                   \
    \       ^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    39 |     vec![smallest_value, smallest_index.try_into().unwrap()]\n   |      \
    \                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due\
    \ to 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_index = 0;\n    let mut min_even_value = false;\n    for &i in\
    \ arr {\n        if i % 2 == 0 {\n            min_even_value = true;\n       \
    \ }\n        if min_even_value\n            && (min_value == 0 || min_value <\
    \ i)\n        {\n            min_value = i;\n            min_even_value = false;\n\
    \            min_index = i;\n        }\n    }\n    if min_even_value\n       \
    \ && (min_value == 0 || min_value < min_index)\n    {\n        min_value = min_index;\n\
    \    }\n    min_value\n        .to_vec()\n        .iter()\n        .cloned()\n\
    \        .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n\
    \        .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n\
    \        .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n\
    \        .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n\
    \        .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n\
    \        .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n\
    \        .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n\
    \        .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n\
    \        .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n\
    \        .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n\
    \        .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n\
    \        .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n\
    \        .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n\
    \        .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n\
    \        .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n\
    \        .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n\
    \        .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n\
    \        .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n\
    \        .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n\
    \        .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n\
    \        .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n\
    \        .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n\
    \        .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n\
    \        .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n\
    \        .cloned()\n        .cloned()\n        .cloned()\n        .clone\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr153y47a.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0599]: no\
    \ method named `to_vec` found for type `isize` in the current scope\n  --> /tmp/tmpr153y47a.rs:48:10\n\
    \   |\n48 |         .to_vec()\n   |          ^^^^^^ help: there is an associated\
    \ function with a similar name: `to_be`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even_value = arr[0];\n\
    \    let mut min_even_index = 0;\n    let mut min_even_index_in_vec = 0;\n   \
    \ let mut min_even_index_in_vec_to_pluck_from = 0;\n    let mut min_even_index_in_vec_to_pluck_to\
    \ = 0;\n    let mut min_even_index_in_vec_to_pluck_to_increment = 0;\n    let\
    \ mut min_even_index_in_vec_to_pluck_to_increment_increment = 0;\n    let mut\
    \ min_even_index_in_vec_to_pluck_to_increment_increment_increment = 0;\n    let\
    \ mut min_even_index_in_vec_to_pluck_to_increment_increment_increment_increment\
    \ = 0;\n    let mut min_even_index_in_vec_to_pluck_to_increment_increment_increment_increment_increment\
    \ = 0;\n    let mut min_even_index_in_vec_to_pluck_to_increment_increment_increment_increment_increment_increment\
    \ = 0;\n    let mut min_even_index_in_vec_to_pluck_to_increment_increment_increment_increment_increment_increment_increment\
    \ = 0;\n    let mut min_even_index_in_vec_to_pluck_to_increment_increment_increment_increment_increment_increment_increment_increment\
    \ = 0;\n    let mut min_even_index_in_vec_to_pluck_to_increment_increment_increment_increment_increment_increment_increment_increment_increment\
    \ = 0;\n    let mut min_even_index_in_vec_to_pluck_to_increment_increment_increment_increment_increment_increment_increment_increment_increment_increment\
    \ = 0;\n    let mut min_even_index_in_vec_to_pluck_to_increment_increment_increment_increment_increment_increment_increment_increment_increment_increment_increment\
    \ = 0;\n    let mut min_even_index_in_vec_to_pluck_to_increment_increment_increment_increment_increment_increment_increment_increment_increment_increment_increment_increment\
    \ = 0;\n    let mut min_even_index_in_vec_to_pluck_to_increment_increment_increment_increment_increment_increment_increment_increment_increment_increment_increment_increment_increment\
    \ = 0;\n    let mut min_even_index_in_vec_to_pluck_to_increment_increment_increment_increment_increment_increment_increment_increment_increment_increment_increment_increment_increment_increment_increment\
    \ = 0;\n    let mut min_even_index_in_vec_to_pluck_to_increment_increment_increment_increment_increment_increment_increment_increment_increment_increment_increment_increment_increment_increment_increment_increment_increment\
    \ = 0;\n    let mut min_even_index_in_vec_to_pluck_to_increment_increment_increment_increment_increment_increment_increment_increment_\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8m0vmnfv.rs:47:127\n   |\n\
    47 |     let mut min_even_index_in_vec_to_pluck_to_increment_increment_increment_increment_increment_increment_increment_increment_\n\
    \   |                                                                        \
    \                                                       ^ help: add `;` here\n\
    48 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8m0vmnfv.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_val = i32::MAX;\n \
    \   let mut min_idx = -1;\n    for i in arr.iter() {\n        if i % 2 == 0 {\n\
    \            if min_val < i {\n                min_val = i;\n                min_idx\
    \ = i;\n            }\n        }\n    }\n    if min_val == i32::MAX {\n      \
    \  return vec![];\n    }\n    let mut vec: Vec<isize> = vec![];\n    for i in\
    \ arr.iter() {\n        if i % 2 == 0 {\n            vec.push(i);\n        }\n\
    \    }\n    vec.push(min_val);\n    vec.push(min_idx);\n    vec\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfd160wzl.rs:31:26\n   |\n\
    31 |             if min_val < i {\n   |                          ^ expected `i32`,\
    \ found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfd160wzl.rs:32:27\n\
    \   |\n32 |                 min_val = i;\n   |                           ^ expected\
    \ `i32`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfd160wzl.rs:33:27\n\
    \   |\n33 |                 min_idx = i;\n   |                           ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    33 |                 min_idx = *i;\n   |                           +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfd160wzl.rs:43:22\n   |\n43 |             vec.push(i);\n\
    \   |                      ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n43 |             vec.push(*i);\n   |       \
    \               +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfd160wzl.rs:46:14\n\
    \   |\n46 |     vec.push(min_val);\n   |              ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n46 |     vec.push(min_val.try_into().unwrap());\n\
    \   |              ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 0;\n    for i in arr.iter().rev() {\n        if i % 2 ==\
    \ 0 {\n            if min_value >= i {\n                min_value = i;\n     \
    \           min_idx = i;\n            }\n        }\n    }\n    vec![min_value,\
    \ min_idx]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3s4aecb_.rs:31:29\n   |\n\
    31 |             if min_value >= i {\n   |                             ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    31 |             if min_value >= *i {\n   |                             +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp3s4aecb_.rs:32:29\n   |\n27 |  \
    \   let mut min_value = arr[0];\n   |                         ------ expected\
    \ due to this value\n...\n32 |                 min_value = i;\n   |          \
    \                   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n32 |                 min_value = *i;\n   |               \
    \              +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3s4aecb_.rs:33:27\n\
    \   |\n28 |     let mut min_idx = 0;\n   |                       - expected due\
    \ to this value\n...\n33 |                 min_idx = i;\n   |                \
    \           ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n33 |                 min_idx = *i;\n   |                 \
    \          +\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 1;\n    let mut min_idx2 = 1;\n    let mut min_idx3 = 1;\n\
    \    let mut min_idx4 = 1;\n    let mut min_idx5 = 1;\n    let mut min_idx6 =\
    \ 1;\n    let mut min_idx7 = 1;\n    let mut min_idx8 = 1;\n    let mut min_idx9\
    \ = 1;\n    let mut min_idx10 = 1;\n    let mut min_idx11 = 1;\n    let mut min_idx12\
    \ = 1;\n    let mut min_idx13 = 1;\n    let mut min_idx14 = 1;\n    let mut min_idx15\
    \ = 1;\n    let mut min_idx16 = 1;\n    let mut min_idx17 = 1;\n    let mut min_idx18\
    \ = 1;\n    let mut min_idx19 = 1;\n    let mut min_idx20 = 1;\n    let mut min_idx21\
    \ = 1;\n    let mut min_idx22 = 1;\n    let mut min_idx23 = 1;\n    let mut min_idx24\
    \ = 1;\n    let mut min_idx25 = 1;\n    let mut min_idx26 = 1;\n    let mut min_idx27\
    \ = 1;\n    let mut min_idx28 = 1;\n    let mut min_idx29 = 1;\n    let mut min_idx30\
    \ = 1;\n    let mut min_idx31 = 1;\n    let mut min_idx32 = 1;\n    let mut min_idx33\
    \ = 1;\n    let mut min_idx34 = 1;\n    let mut min_idx35 = 1;\n    let mut min_idx36\
    \ = 1;\n    let mut min_idx37 = 1;\n    let mut min_idx38 = 1;\n    let mut min_idx39\
    \ = 1;\n    let mut min_idx40 = 1;\n    let mut min_idx41 = 1;\n    let mut min_idx42\
    \ = 1;\n    let mut min_idx43 = 1;\n    let mut min_idx44 = 1;\n    let mut min_idx45\
    \ = 1;\n    let mut min_idx46 = 1;\n    let mut min_idx47 = 1;\n    let mut min_idx48\
    \ = 1;\n    let mut min_idx49 = 1;\n    let mut min_idx50 = 1;\n    let mut min_idx51\
    \ = 1;\n    let mut min_idx52 = 1;\n    let mut min_idx53 = 1;\n    let mut min_idx54\
    \ = 1;\n    let mut min_idx55 = 1;\n    let mut min_idx56 = 1;\n    let mut min_idx57\
    \ = 1;\n    let mut min_idx58 = 1;\n    let mut min_idx59 = 1;\n    let mut min_idx60\
    \ = 1;\n    let mut min_idx61 = 1;\n    let mut min_idx62 = 1;\n    let mut min_idx\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpgockuhk1.rs:90:20\n   |\n\
    90 |     let mut min_idx\n   |                    ^ help: add `;` here\n91 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgockuhk1.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    for i in 1..arr.len() {\n        if arr[i]\
    \ < smallest_value {\n            smallest_value = arr[i];\n            smallest_index\
    \ = i;\n        }\n    }\n    vec![smallest_value, smallest_index]\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx8_b30mm.rs:35:26\n   |\n\
    35 |     vec![smallest_value, smallest_index]\n   |                          ^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n35 |     vec![smallest_value,\
    \ smallest_index.try_into().unwrap()]\n   |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = i32::MAX;\n\
    \    let mut min_idx = -1;\n    for i in arr.iter() {\n        if i % 2 == 0 {\n\
    \            if min_value < i {\n                min_value = i;\n            \
    \    min_idx = i;\n            }\n        }\n    }\n    if min_idx == -1 {\n \
    \       return vec![];\n    }\n    vec![min_value, min_idx]\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvczbidx1.rs:31:28\n   |\n\
    31 |             if min_value < i {\n   |                            ^ expected\
    \ `i32`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvczbidx1.rs:32:29\n\
    \   |\n27 |     let mut min_value = i32::MAX;\n   |                         --------\
    \ expected due to this value\n...\n32 |                 min_value = i;\n   | \
    \                            ^ expected `i32`, found `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvczbidx1.rs:33:27\n   |\n28 |     let mut min_idx\
    \ = -1;\n   |                       -- expected due to this value\n...\n33 | \
    \                min_idx = i;\n   |                           ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n33 |  \
    \               min_idx = *i;\n   |                           +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvczbidx1.rs:40:10\n   |\n40 |     vec![min_value,\
    \ min_idx]\n   |          ^^^^^^^^^ expected `isize`, found `i32`\n   |\nhelp:\
    \ you can convert an `i32` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n40 |     vec![min_value.try_into().unwrap(), min_idx]\n   |     \
    \              ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    let mut mut_counter = 0;\n    for i in arr.iter().cloned()\
    \ {\n        if i % 2 == 0 {\n            smallest_value = i;\n            smallest_index\
    \ = mut_counter;\n        }\n        mut_counter += 1;\n    }\n    smallest_index\n\
    \        .clone()\n        .into_iter()\n        .cloned()\n        .collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `into_iter` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmpo4r8osj4.rs:39:10\n   |\n39 |         .into_iter()\n   |      \
    \    ^^^^^^^^^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0689`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_val = i32::MAX;\n \
    \   let mut min_idx = -1;\n    for i in arr.iter() {\n        if i % 2 == 0 {\n\
    \            if min_val < i {\n                min_val = i;\n                min_idx\
    \ = i;\n            }\n        }\n    }\n    if min_val == i32::MAX {\n      \
    \  return vec![];\n    }\n    let mut result = vec![];\n    for i in arr.iter()\
    \ {\n        if i % 2 == 0 {\n            if min_val == i {\n                result.push(min_idx);\n\
    \            } else {\n                result.push(i);\n            }\n      \
    \  }\n    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr6yx57g6.rs:31:26\n   |\n\
    31 |             if min_val < i {\n   |                          ^ expected `i32`,\
    \ found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr6yx57g6.rs:32:27\n\
    \   |\n32 |                 min_val = i;\n   |                           ^ expected\
    \ `i32`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr6yx57g6.rs:33:27\n\
    \   |\n33 |                 min_idx = i;\n   |                           ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    33 |                 min_idx = *i;\n   |                           +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpr6yx57g6.rs:43:27\n   |\n43 |             if\
    \ min_val == i {\n   |                           ^ expected `i32`, found `&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpr6yx57g6.rs:46:29\n   |\n46 |\
    \                 result.push(i);\n   |                             ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    46 |                 result.push(*i);\n   |                             +\n\n\
    error: aborting due to 5 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even_value = arr[0];\n\
    \    let mut min_even_index = -1;\n    let mut min_even_index_in_vec = -1;\n \
    \   for i in arr.iter().rev() {\n        if i % 2 == 0 {\n            if min_even_index\
    \ == -1 || min_even_index > i {\n                min_even_value = i;\n       \
    \         min_even_index = i;\n                min_even_index_in_vec = i;\n  \
    \          }\n        } else {\n            if min_even_index != -1 && min_even_index\
    \ > i {\n                min_even_index_in_vec = i;\n            }\n        }\n\
    \    }\n    if min_even_index == -1 {\n        return vec![];\n    }\n    if min_even_index_in_vec\
    \ == -1 {\n        return vec![min_even_value];\n    }\n    vec![min_even_value,\n\
    \          min_even_index_in_vec]\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgwkbbgn5.rs:33:34\n   |\n\
    33 |                 min_even_value = i;\n   |                               \
    \   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n33 |                 min_even_value = *i;\n   |              \
    \                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgwkbbgn5.rs:34:34\n\
    \   |\n34 |                 min_even_index = i;\n   |                        \
    \          ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n34 |                 min_even_index = *i;\n   |          \
    \                        +\n\nerror[E0277]: can't compare `isize` with `&isize`\n\
    \  --> /tmp/tmpgwkbbgn5.rs:32:55\n   |\n32 |             if min_even_index ==\
    \ -1 || min_even_index > i {\n   |                                           \
    \            ^ no implementation for `isize < &isize` and `isize > &isize`\n \
    \  |\n   = help: the trait `PartialOrd<&isize>` is not implemented for `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgwkbbgn5.rs:35:41\n   |\n35 |\
    \                 min_even_index_in_vec = i;\n   |                           \
    \              ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n35 |                 min_even_index_in_vec = *i;\n   |   \
    \                                      +\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpgwkbbgn5.rs:38:57\n   |\n38 |             if min_even_index != -1\
    \ && min_even_index > i {\n   |                                              \
    \           ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n38 |             if min_even_index != -1 && min_even_index\
    \ > *i {\n   |                                                         +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgwkbbgn5.rs:39:41\n   |\n39 |              \
    \   min_even_index_in_vec = i;\n   |                                         ^\
    \ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n39 |                 min_even_index_in_vec = *i;\n   |               "
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value: isize =\
    \ 0;\n    let mut smallest_index: usize = 0;\n    let mut even_value: isize =\
    \ 0;\n    let mut even_index: usize = 0;\n    for &i in arr {\n        if i %\
    \ 2 == 0 {\n            even_value = i;\n            even_index = i;\n       \
    \ } else {\n            if smallest_value == 0 {\n                smallest_value\
    \ = i;\n                smallest_index = i;\n            } else {\n          \
    \      if smallest_value < i {\n                    smallest_value = i;\n    \
    \                smallest_index = i;\n                }\n            }\n     \
    \   }\n    }\n    if smallest_value == 0 {\n        return vec![];\n    }\n  \
    \  let mut vec: Vec<isize> = vec![];\n    vec.push(smallest_value);\n    vec.push(smallest_index);\n\
    \    vec.push(even_value);\n    vec.push(even_index);\n    vec\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprm6h_022.rs:31:9\n   |\n\
    31 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprm6h_022.rs:34:26\n   |\n34 |             even_index =\
    \ i;\n   |                          ^ expected `usize`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprm6h_022.rs:38:34\n   |\n38 |              \
    \   smallest_index = i;\n   |                                  ^ expected `usize`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprm6h_022.rs:42:38\n\
    \   |\n42 |                     smallest_index = i;\n   |                    \
    \                  ^ expected `usize`, found `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprm6h_022.rs:52:14\n   |\n52 |     vec.push(smallest_index);\n\
    \   |              ^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n52 |     vec.push(smallest_index.try_into().unwrap());\n   |    \
    \          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmprm6h_022.rs:54:14\n   |\n54 |     vec.push(even_index);\n   | \
    \             ^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n54 |     vec.push(even_index.try_into().unwrap());\n   |              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror: aborting due to 6 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    let mut even_values = Vec::new();\n    for\
    \ i in arr.iter() {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \        }\n        if i == smallest_value {\n            smallest_index = i;\n\
    \        }\n        if i == smallest_value {\n            smallest_value = i;\n\
    \        }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n \
    \   }\n    let mut smallest_even_value = even_values[0];\n    let mut smallest_even_index\
    \ = 0;\n    for i in even_values.iter() {\n        if i == smallest_even_value\
    \ {\n            smallest_even_index = i;\n        }\n        if i == smallest_even_value\
    \ {\n            smallest_even_value = i;\n        }\n    }\n    vec![smallest_value,\
    \ smallest_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp831ae8_1.rs:34:14\n\
    \   |\n34 |         if i == smallest_value {\n   |              ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp831ae8_1.rs:35:30\n\
    \   |\n35 |             smallest_index = i;\n   |                            \
    \  ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n35 |             smallest_index = *i;\n   |                  \
    \            +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp831ae8_1.rs:38:30\n\
    \   |\n38 |             smallest_value = i;\n   |                            \
    \  ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n38 |             smallest_value = *i;\n   |                  \
    \            +\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp831ae8_1.rs:37:14\n\
    \   |\n37 |         if i == smallest_value {\n   |              ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n\nerror[E0277]: can't compare `&isize` with `isize`\n\
    \  --> /tmp/tmp831ae8_1.rs:47:14\n   |\n47 |         if i == smallest_even_value\
    \ {\n   |              ^^ no implementation for `&isize == isize`\n   |\n   =\
    \ help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   = note:\
    \ required because of the requirements on the impl of `PartialEq<&isize>` for\
    \ `&&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp831ae8_1.rs:48:35\n\
    \   |\n48 |             smallest_even_index = i;\n   |                       \
    \            ^ expected integer, found `&&isize`\n\nerror[E0277]: can't compare\
    \ `&isize` with `isize`\n  --> /tmp/tmp831ae8_1.rs:50:14\n   |\n50 |         if\
    \ i == smallest_even_value {\n   |              ^^ no implementation for `&isize\
    \ == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented\
    \ for `&isize`\n   = note: required because of the requirements on the impl of\
    \ `PartialEq<&isize>` for `&&isize`\n\nerro"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr.iter().min();\n\
    \    let mut min_idx = 0;\n    let mut min_even_val = false;\n    let mut min_even_val_idx\
    \ = -1;\n    let mut min_even_val_idx = -1;\n    for idx in arr.iter().rev() {\n\
    \        if idx % 2 == 0 {\n            if min_even_val {\n                if\
    \ min_even_val_idx == idx {\n                    min_even_val_idx = idx;\n   \
    \             }\n            } else {\n                min_even_val = true;\n\
    \                min_even_val_idx = idx;\n            }\n        } else {\n  \
    \          min_value = idx;\n            min_idx = idx;\n            min_even_val\
    \ = false;\n            min_even_val_idx = -1;\n        }\n    }\n    if min_even_val\
    \ {\n        vec![min_even_val_idx, min_even_val_idx]\n    } else {\n        vec![min_idx,\
    \ min_idx]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1gn69tjv.rs:36:40\n   |\n\
    36 |                     min_even_val_idx = idx;\n   |                       \
    \                 ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n36 |                     min_even_val_idx = *idx;\n   |  \
    \                                      +\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp1gn69tjv.rs:40:36\n   |\n40 |                 min_even_val_idx =\
    \ idx;\n   |                                    ^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n40 |                 min_even_val_idx\
    \ = *idx;\n   |                                    +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1gn69tjv.rs:43:25\n   |\n43 |             min_value = idx;\n\
    \   |                         ^^^\n   |                         |\n   |      \
    \                   expected enum `Option`, found `&isize`\n   |             \
    \            help: try using a variant of the expected enum: `Some(idx)`\n   |\n\
    \   = note:   expected enum `Option<&isize>`\n           found reference `&isize`\n\
    \nerror[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp1gn69tjv.rs:35:37\n\
    \   |\n35 |                 if min_even_val_idx == idx {\n   |               \
    \                      ^^ no implementation for `isize == &isize`\n   |\n   =\
    \ help: the trait `PartialEq<&isize>` is not implemented for `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1gn69tjv.rs:44:23\n   |\n44 |             min_idx\
    \ = idx;\n   |                       ^^^ expected integer, found `&isize`\n  \
    \ |\nhelp: consider dereferencing the borrow\n   |\n44 |             min_idx =\
    \ *idx;\n   |                       +\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut even_values = Vec::new();\n\
    \    let mut smallest_value = vec![0; arr.len()];\n    let mut smallest_index\
    \ = vec![0; arr.len()];\n    let mut smallest_index_value = vec![0; arr.len()];\n\
    \    for i in 0..arr.len() {\n        if arr[i] % 2 == 0 {\n            even_values.push(i);\n\
    \            if arr[i] < smallest_value[0] {\n                smallest_value[0]\
    \ = arr[i];\n                smallest_index[0] = i;\n            }\n         \
    \   if arr[i] < smallest_index_value[0] {\n                smallest_index_value[0]\
    \ = arr[i];\n            }\n        }\n    }\n    if even_values.len() == 0 {\n\
    \        return vec![];\n    }\n    for i in 0..arr.len() {\n        if arr[i]\
    \ % 2 == 0 {\n            if arr[i] < smallest_value[0] {\n                smallest_value[0]\
    \ = arr[i];\n                smallest_index[0] = i;\n            }\n         \
    \   if arr[i] < smallest_index_value[0] {\n                smallest_index_value[0]\
    \ = arr[i];\n            }\n        }\n    }\n    for i in 0..arr.len() {\n  \
    \      if arr[i] % 2 == 0 {\n            if arr[i] < smallest_value[0] {\n   \
    \             smallest_value[0] = arr[i];\n                smallest_index[0] =\
    \ i;\n            }\n            if arr[i] < smallest_index_value[0] {\n     \
    \           smallest_index_value[0] = arr[i];\n            }\n        }\n    }\n\
    \    for i in 0..arr.len() {\n        if arr[i] % 2 == 0 {\n            if arr[i]\
    \ < smallest_value[0] {\n                smallest_value[0] = arr[i];\n       \
    \         smallest_index[0] = i;\n            }\n            if arr[i] < smallest_index_value[0]\
    \ {\n                smallest_index_value[0] = arr[i];\n            }\n      \
    \  }\n    }\n    for i in 0..arr.len() {\n        if arr[i] % 2 == 0 {\n     \
    \       if arr[i] < smallest_value[0] {\n                smallest_value[0] = arr[i];\n\
    \                smallest_index[0] = i;\n            }\n            if arr[i]\
    \ < smallest_index_value[0] {\n                smallest_index_value[0] = arr[i];\n\
    \            }\n        }\n    }\n    for i in 0..arr.len() {\n        if arr[i]\
    \ % 2 == 0 {\n            if arr[i] < smallest_value[0] {\n                smallest_value[0]\
    \ = arr[i];\n                smallest_index[0] = i;\n            }\n         \
    \   if arr[i] < smallest_index_value[0] {\n                smallest_index_value[0]\
    \ = arr[i];\n            }\n        }\n    }\n    for i in 0..arr.len() {\n  \
    \      if arr[i] % 2 == 0 {\n            if arr[i] < smallest_value[0] {\n   \
    \             smallest_value[0] = arr[i];\n                smallest_index[0] =\
    \ i;\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpffhxab3e.rs:118:3\n\
    \    |\n26  | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    |               \
    \                          - unclosed delimiter\n...\n101 |     for i in 0..arr.len()\
    \ {\n    |                           - unclosed delimiter\n102 |         if arr[i]\
    \ % 2 == 0 {\n    |                            - unclosed delimiter\n103 |   \
    \          if arr[i] < smallest_value[0] {\n    |                            \
    \               - this delimiter might not be properly closed...\n...\n106 | }\n\
    \    | - ...as it matches this but it has different indentation\n...\n118 | }\n\
    \    |   ^\n\nerror[E0308]: mismatched types\n   --> /tmp/tmpffhxab3e.rs:101:5\n\
    \    |\n26  |   fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    |             \
    \                   ---------- expected `Vec<isize>` because of return type\n\
    ...\n101 | /     for i in 0..arr.len() {\n102 | |         if arr[i] % 2 == 0 {\n\
    103 | |             if arr[i] < smallest_value[0] {\n104 | |                 smallest_value[0]\
    \ = arr[i];\n...   |\n117 | |     assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n\
    118 | | }\n    | |__^ expected struct `Vec`, found `()`\n    |\n    = note: expected\
    \ struct `Vec<isize>`\n            found unit type `()`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 0;\n    for i in arr.iter().rev() {\n        if i % 2 ==\
    \ 0 {\n            if min_value > i {\n                min_value = i;\n      \
    \          min_idx = i;\n            }\n        }\n    }\n    vec![min_value,\
    \ min_idx]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjzjh771y.rs:31:28\n   |\n\
    31 |             if min_value > i {\n   |                            ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    31 |             if min_value > *i {\n   |                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjzjh771y.rs:32:29\n   |\n32 |              \
    \   min_value = i;\n   |                             ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n32 |        \
    \         min_value = *i;\n   |                             +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjzjh771y.rs:33:27\n   |\n33 |              \
    \   min_idx = i;\n   |                           ^ expected integer, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n33 |                 min_idx\
    \ = *i;\n   |                           +\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut even_values = vec![];\n\
    \    let mut smallest_value = vec![];\n    let mut smallest_index = vec![];\n\
    \    for i in arr.iter() {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \            if i < smallest_value.len() {\n                smallest_value.push(i);\n\
    \                smallest_index.push(i);\n            }\n        }\n    }\n  \
    \  if even_values.len() == 0 {\n        return vec![];\n    }\n    if even_values.len()\
    \ == 1 {\n        return vec![even_values[0]];\n    }\n    if even_values.len()\
    \ > 1 {\n        let mut smallest_even_value = even_values[0];\n        let mut\
    \ smallest_even_index = even_values[0];\n        for i in even_values.iter().rev()\
    \ {\n            if i % 2 == 0 {\n                if i < smallest_even_value.len()\
    \ {\n                    smallest_even_value = i;\n                    smallest_even_index\
    \ = i;\n                }\n            }\n        }\n        return vec![smallest_even_value,\n\
    \                    smallest_even_index];\n    }\n    return vec![];\n}\n\nfn\
    \ main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplnoai810.rs:33:20\n   |\n\
    33 |             if i < smallest_value.len() {\n   |                    ^^^^^^^^^^^^^^^^^^^^\
    \ expected `&isize`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplnoai810.rs:43:21\n\
    \   |\n43 |         return vec![even_values[0]];\n   |                     ^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the type\n\
    \   |\n43 |         return vec![*even_values[0]];\n   |                     +\n\
    \nerror[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmplnoai810.rs:49:18\n\
    \   |\n49 |             if i % 2 == 0 {\n   |                - ^ - {integer}\n\
    \   |                |\n   |                &&isize\n   |\nhelp: `%` can be used\
    \ on `isize`, you can dereference `i`\n   |\n49 |             if *i % 2 == 0 {\n\
    \   |                +\n\nerror[E0599]: no method named `len` found for reference\
    \ `&isize` in the current scope\n  --> /tmp/tmplnoai810.rs:50:44\n   |\n50 | \
    \                if i < smallest_even_value.len() {\n   |                    \
    \                        ^^^ method not found in `&isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmplnoai810.rs:56:21\n   |\n56 |         return vec![smallest_even_value,\n\
    \   |                     ^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n56 |         return vec![*smallest_even_value,\n\
    \   |                     +\n\nerror: aborting due to 5 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    let mut even_values = Vec::new();\n    for\
    \ &i in arr {\n        if i % 2 == 0 {\n            even_values.push(i);\n   \
    \     }\n        if i == smallest_value {\n            smallest_index = even_values.len();\n\
    \        }\n        if i == smallest_value {\n            smallest_value = i;\n\
    \        }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n \
    \   }\n    if even_values.len() == 1 {\n        return vec![even_values[0]];\n\
    \    }\n    if even_values.len() == 2 {\n        return vec![even_values[0], even_values[1]];\n\
    \    }\n    if even_values.len() == 3 {\n        return vec![even_values[0], even_values[1],\
    \ even_values[2]];\n    }\n    if even_values.len() == 4 {\n        return vec![even_values[0],\
    \ even_values[1], even_values[2], even_values[3]];\n    }\n    if even_values.len()\
    \ == 5 {\n        return vec![even_values[0], even_values[1], even_values[2],\
    \ even_values[3], even_values[4]];\n    }\n    if even_values.len() == 6 {\n \
    \       return vec![even_values[0], even_values[1], even_values[2], even_values[3],\
    \ even_values[4], even_values[5]];\n    }\n    if even_values.len() == 7 {\n \
    \       return vec![even_values[0], even_values[1], even_values[2], even_values[3],\
    \ even_values[4], even_values[5], even_values[6]];\n    }\n    if even_values.len()\
    \ == 8 {\n        return vec![even_values[0], even_values[1], even_values[2],\
    \ even_values[3], even_values[4], even_values[5], even_values[6], even_values[7]];\n\
    \    }\n    if even_values.len() == 9 {\n        return vec![even_values[0], even_values[1],\
    \ even_values[2], even_values[3], even_values[4], even_values[5], even_values[6],\
    \ even_values[7], even_values[8]];\n    }\n    if even_values.len() == 10 {\n\
    \        return vec![even_values[0], even_values[1], even_values[2], even_values[3],\
    \ even_values[4], even_values[5], even_values[6], even_values[7], even_values[8],\
    \ even_values[9]];\n    }\n    if even_values.len() == 11 {\n        return vec![even_values[0],\
    \ even_values[1], even_values[2], even_values[3], even_values[4], even_values[5],\
    \ even_values[6], even_values[7], even_values[8], even_values[9], even_values[10]];\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1ap6jv0l.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0317]: `if`\
    \ may be missing an `else` clause\n  --> /tmp/tmp1ap6jv0l.rs:74:5\n   |\n26 |\
    \   fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                          \
    \      ---------- expected `Vec<isize>` because of this return type\n...\n74 |\
    \ /     if even_values.len() == 11 {\n75 | |         return vec![even_values[0],\
    \ even_values[1], even_values[2], even_values[3], even_values[4], even_values[5],\
    \ even_values[6], even_...\n76 | |     }\n   | |_____^ expected struct `Vec`,\
    \ found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found\
    \ unit type `()`\n   = note: `if` expressions without `else` evaluate to `()`\n\
    \   = help: consider adding an `else` block that evaluates to the expected type\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0317.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    let mut even_values = Vec::new();\n    for\
    \ i in arr.iter().rev() {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \        }\n        if i == smallest_value {\n            smallest_index = even_values.iter().rev().next().unwrap();\n\
    \        }\n        if i == smallest_value {\n            smallest_value = i;\n\
    \        }\n    }\n    even_values.iter().rev().next().unwrap()\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp0s9h0q0o.rs:34:14\n\
    \   |\n34 |         if i == smallest_value {\n   |              ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0s9h0q0o.rs:35:30\n\
    \   |\n35 |             smallest_index = even_values.iter().rev().next().unwrap();\n\
    \   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ integer, found `&&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0s9h0q0o.rs:38:30\n\
    \   |\n38 |             smallest_value = i;\n   |                            \
    \  ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n38 |             smallest_value = *i;\n   |                  \
    \            +\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp0s9h0q0o.rs:37:14\n\
    \   |\n37 |         if i == smallest_value {\n   |              ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0s9h0q0o.rs:41:5\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \            ---------- expected `Vec<isize>` because of return type\n...\n41\
    \ |     even_values.iter().rev().next().unwrap()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `&&isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found reference `&&isize`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    for i in arr.iter().rev() {\n        if\
    \ i % 2 == 0 {\n            if smallest_value >= i {\n                smallest_value\
    \ = i;\n                smallest_index = i;\n            }\n        }\n    }\n\
    \    vec![smallest_value, smallest_index]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppr2jo_x4.rs:31:34\n   |\n\
    31 |             if smallest_value >= i {\n   |                              \
    \    ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n31 |             if smallest_value >= *i {\n   |             \
    \                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppr2jo_x4.rs:32:34\n\
    \   |\n32 |                 smallest_value = i;\n   |                        \
    \          ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n32 |                 smallest_value = *i;\n   |          \
    \                        +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppr2jo_x4.rs:33:34\n\
    \   |\n33 |                 smallest_index = i;\n   |                        \
    \          ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n33 |                 smallest_index = *i;\n   |          \
    \                        +\n\nerror: aborting due to 3 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = i32::MAX;\n\
    \    let mut min_idx = 0;\n    let mut even_values = Vec::new();\n    for i in\
    \ arr.iter() {\n        if i % 2 == 0 {\n            even_values.push(i);\n  \
    \      }\n        if i < min_value {\n            min_value = i;\n           \
    \ min_idx = i;\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut min_even_val = i32::MAX;\n    let mut min_even_val_idx\
    \ = 0;\n    for i in even_values.iter() {\n        if i < min_even_val {\n   \
    \         min_even_val = i;\n            min_even_val_idx = i;\n        }\n  \
    \  }\n    let mut result = vec![];\n    for i in even_values.iter() {\n      \
    \  if i == min_even_val {\n            result.push(min_even_val_idx);\n      \
    \  }\n    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzcy23grb.rs:34:16\n   |\n\
    34 |         if i < min_value {\n   |                ^^^^^^^^^ expected `&isize`,\
    \ found `i32`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzcy23grb.rs:35:25\n\
    \   |\n35 |             min_value = i;\n   |                         ^ expected\
    \ `i32`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzcy23grb.rs:36:23\n\
    \   |\n36 |             min_idx = i;\n   |                       ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n36 |  \
    \           min_idx = *i;\n   |                       +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzcy23grb.rs:45:16\n   |\n45 |         if i < min_even_val\
    \ {\n   |                ^^^^^^^^^^^^ expected `&&isize`, found `i32`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzcy23grb.rs:46:28\n   |\n46 |             min_even_val\
    \ = i;\n   |                            ^ expected `i32`, found `&&isize`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpzcy23grb.rs:47:32\n   |\n47 |  \
    \           min_even_val_idx = i;\n   |                                ^ expected\
    \ integer, found `&&isize`\n\nerror[E0277]: can't compare `&&isize` with `i32`\n\
    \  --> /tmp/tmpzcy23grb.rs:52:14\n   |\n52 |         if i == min_even_val {\n\
    \   |              ^^ no implementation for `&&isize == i32`\n   |\n   = help:\
    \ the trait `PartialEq<i32>` is not implemented for `&&isize`\n\nerror: aborting\
    \ due to 7 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even_value = arr[0];\n\
    \    let mut min_even_index = -1;\n    let mut min_even_index_in_vec = -1;\n \
    \   let mut min_even_index_in_vec_vec = -1;\n    for &i in arr {\n        if i\
    \ % 2 == 0 {\n            if min_even_index == -1 || min_even_index > i {\n  \
    \              min_even_index = i;\n                min_even_index_in_vec = i;\n\
    \                min_even_index_in_vec_vec = i;\n            }\n        } else\
    \ {\n            if min_even_index != -1 && min_even_index < i {\n           \
    \     min_even_index_in_vec_vec = min_even_index_in_vec;\n                min_even_index_in_vec\
    \ = i;\n            }\n        }\n    }\n    if min_even_index == -1 {\n     \
    \   return vec![];\n    }\n    let mut vec: Vec<isize> = vec![];\n    for i in\
    \ 0..arr.len() {\n        if i == min_even_index {\n            vec.push(min_even_index_in_vec);\n\
    \        } else {\n            vec.push(i);\n        }\n    }\n    return vec;\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3wp28rlm.rs:31:9\n   |\n\
    31 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3wp28rlm.rs:51:22\n   |\n51 |             vec.push(min_even_index_in_vec);\n\
    \   |                      ^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n51 |             vec.push(min_even_index_in_vec.try_into().unwrap());\n\
    \   |                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp3wp28rlm.rs:28:30\n\
    \   |\n28 |     let mut min_even_index = -1;\n   |                           \
    \   ^^ the trait `Neg` is not implemented for `usize`\n\nerror[E0277]: the trait\
    \ bound `usize: Neg` is not satisfied\n  --> /tmp/tmp3wp28rlm.rs:29:37\n   |\n\
    29 |     let mut min_even_index_in_vec = -1;\n   |                           \
    \          ^^ the trait `Neg` is not implemented for `usize`\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp3wp28rlm.rs:30:41\n\
    \   |\n30 |     let mut min_even_index_in_vec_vec = -1;\n   |                \
    \                         ^^ the trait `Neg` is not implemented for `usize`\n\n\
    error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp3wp28rlm.rs:33:34\n\
    \   |\n33 |             if min_even_index == -1 || min_even_index > i {\n   |\
    \                                  ^^ the trait `Neg` is not implemented for `usize`\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp3wp28rlm.rs:39:34\n\
    \   |\n39 |             if min_even_index != -1 && min_even_index < i {\n   |\
    \                                  ^^ the trait `Neg` is not implemented for `usize`\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp3wp28rlm.rs:45:26\n\
    \   |\n45 |     if min_even_index == -1"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 0;\n    for i in arr.iter().rev() {\n        if i % 2 ==\
    \ 0 {\n            if min_value > i {\n                min_value = i;\n      \
    \          min_idx = i;\n            }\n        }\n    }\n    vec![min_value,\
    \ min_idx]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjzjh771y.rs:31:28\n   |\n\
    31 |             if min_value > i {\n   |                            ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    31 |             if min_value > *i {\n   |                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjzjh771y.rs:32:29\n   |\n32 |              \
    \   min_value = i;\n   |                             ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n32 |        \
    \         min_value = *i;\n   |                             +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjzjh771y.rs:33:27\n   |\n33 |              \
    \   min_idx = i;\n   |                           ^ expected integer, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n33 |                 min_idx\
    \ = *i;\n   |                           +\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_val = arr[0];\n   \
    \ let mut min_idx = -1;\n    for i in arr.iter().rev() {\n        if i % 2 ==\
    \ 0 {\n            if min_val < i {\n                min_val = i;\n          \
    \      min_idx = i;\n            }\n        }\n    }\n    if min_val == arr[0]\
    \ {\n        return vec![];\n    }\n    vec![min_val, min_idx]\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp302ke7tw.rs:31:26\n   |\n\
    31 |             if min_val < i {\n   |                          ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n31 |  \
    \           if min_val < *i {\n   |                          +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp302ke7tw.rs:32:27\n   |\n32 |              \
    \   min_val = i;\n   |                           ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n32 |                 min_val\
    \ = *i;\n   |                           +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp302ke7tw.rs:33:27\n   |\n33 |                 min_idx = i;\n  \
    \ |                           ^ expected integer, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n33 |                 min_idx = *i;\n\
    \   |                           +\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 0;\n    for &i in arr {\n        if i % 2 == 0 {\n     \
    \       if min_value == i {\n                min_idx = i;\n            } else\
    \ {\n                min_value = i;\n                min_idx = i;\n          \
    \  }\n        }\n    }\n    vec![min_value, min_idx]\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj0h1_0zw.rs:29:9\n   |\n\
    29 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_index = 0;\n    for i in arr.iter().rev() {\n        if i % 2\
    \ == 0 {\n            if min_value < i {\n                min_value = i;\n   \
    \             min_index = i;\n            }\n        }\n    }\n    vec![min_value,\
    \ min_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr_v4e3j6.rs:31:28\n   |\n\
    31 |             if min_value < i {\n   |                            ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    31 |             if min_value < *i {\n   |                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpr_v4e3j6.rs:32:29\n   |\n32 |              \
    \   min_value = i;\n   |                             ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n32 |        \
    \         min_value = *i;\n   |                             +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpr_v4e3j6.rs:33:29\n   |\n33 |              \
    \   min_index = i;\n   |                             ^ expected integer, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n33 |        \
    \         min_index = *i;\n   |                             +\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 101
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_val = arr[0];\n   \
    \ let mut min_idx = -1;\n    let mut min_even_val = false;\n    for &x in arr.iter()\
    \ {\n        if x % 2 == 0 {\n            if min_even_val {\n                min_even_val\
    \ = false;\n                min_idx = x;\n            } else {\n             \
    \   min_even_val = true;\n                min_val = x;\n            }\n      \
    \  }\n    }\n    if min_even_val {\n        min_even_val = false;\n        min_idx\
    \ = min_val;\n    }\n    vec![min_val, min_idx]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 2]`,\n right: `[2, 1]`', /tmp/tmpkhhg7iga.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_val = i32::MAX;\n \
    \   let mut min_idx = -1;\n    for i in arr.iter() {\n        if i % 2 == 0 {\n\
    \            if min_val > i {\n                min_val = i;\n                min_idx\
    \ = i;\n            }\n        }\n    }\n    if min_val == i32::MAX {\n      \
    \  return vec![];\n    }\n    let mut ret = vec![];\n    for i in arr.iter() {\n\
    \        if i % 2 == 0 {\n            if min_val > i {\n                min_val\
    \ = i;\n                min_idx = i;\n            }\n        }\n    }\n    ret\
    \ = vec![min_val, min_idx];\n    ret\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1wyj44wi.rs:31:26\n   |\n\
    31 |             if min_val > i {\n   |                          ^ expected `i32`,\
    \ found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1wyj44wi.rs:32:27\n\
    \   |\n32 |                 min_val = i;\n   |                           ^ expected\
    \ `i32`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1wyj44wi.rs:33:27\n\
    \   |\n33 |                 min_idx = i;\n   |                           ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    33 |                 min_idx = *i;\n   |                           +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1wyj44wi.rs:43:26\n   |\n43 |             if\
    \ min_val > i {\n   |                          ^ expected `i32`, found `&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp1wyj44wi.rs:44:27\n   |\n44 |\
    \                 min_val = i;\n   |                           ^ expected `i32`,\
    \ found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1wyj44wi.rs:45:27\n\
    \   |\n45 |                 min_idx = i;\n   |                           ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    45 |                 min_idx = *i;\n   |                           +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1wyj44wi.rs:50:5\n   |\n26 | fn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>`\
    \ because of return type\n...\n50 |     ret\n   |     ^^^ expected `isize`, found\
    \ `i32`\n   |\n   = note: expected struct `Vec<isize>`\n              found struct\
    \ `Vec<i32>`\n\nerror: aborting due to 7 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 0;\n    for i in arr.iter().rev() {\n        if i % 2 ==\
    \ 0 {\n            if min_value < i {\n                min_value = i;\n      \
    \          min_idx = i;\n            }\n        }\n    }\n    vec![min_value,\
    \ min_idx]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5629msia.rs:31:28\n   |\n\
    31 |             if min_value < i {\n   |                            ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    31 |             if min_value < *i {\n   |                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5629msia.rs:32:29\n   |\n32 |              \
    \   min_value = i;\n   |                             ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n32 |        \
    \         min_value = *i;\n   |                             +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5629msia.rs:33:27\n   |\n33 |              \
    \   min_idx = i;\n   |                           ^ expected integer, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n33 |                 min_idx\
    \ = *i;\n   |                           +\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    for i in arr.iter().rev() {\n        if\
    \ i % 2 == 0 {\n            if smallest_value < i {\n                smallest_value\
    \ = i;\n                smallest_index = i;\n            }\n        }\n    }\n\
    \    vec![smallest_value, smallest_index]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmtadrjsg.rs:31:33\n   |\n\
    31 |             if smallest_value < i {\n   |                               \
    \  ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n31 |             if smallest_value < *i {\n   |              \
    \                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmtadrjsg.rs:32:34\n\
    \   |\n27 |     let mut smallest_value = arr[0];\n   |                       \
    \       ------ expected due to this value\n...\n32 |                 smallest_value\
    \ = i;\n   |                                  ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n32 |                 smallest_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmtadrjsg.rs:33:34\n   |\n28 |     let mut smallest_index = 0;\n\
    \   |                              - expected due to this value\n...\n33 |   \
    \              smallest_index = i;\n   |                                  ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    33 |                 smallest_index = *i;\n   |                              \
    \    +\n\nerror: aborting due to 3 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smalest_value = arr[0];\n\
    \    let mut smalest_index = 0;\n    for i in 1..arr.len() {\n        if arr[i]\
    \ < smalest_value {\n            smalest_value = arr[i];\n            smalest_index\
    \ = i;\n        }\n    }\n    vec![smalest_value, smalest_index]\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1289cmxe.rs:35:25\n   |\n\
    35 |     vec![smalest_value, smalest_index]\n   |                         ^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n35 |     vec![smalest_value,\
    \ smalest_index.try_into().unwrap()]\n   |                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value: isize =\
    \ 0;\n    let mut smallest_index: usize = 0;\n    let mut mut_smallest_value:\
    \ isize = 0;\n    let mut mut_smallest_index: usize = 0;\n    let mut mut_mut_smallest_value:\
    \ isize = 0;\n    let mut mut_mut_smallest_index: usize = 0;\n    let mut mut_mut_mut_smallest_value:\
    \ isize = 0;\n    let mut mut_mut_mut_smallest_index: usize = 0;\n    let mut\
    \ mut_mut_mut_mut_smallest_value: isize = 0;\n    let mut mut_mut_mut_mut_smallest_index:\
    \ usize = 0;\n    let mut mut_mut_mut_mut_mut_smallest_value: isize = 0;\n   \
    \ let mut mut_mut_mut_mut_mut_smallest_index: usize = 0;\n    let mut mut_mut_mut_mut_mut_mut_smallest_value:\
    \ isize = 0;\n    let mut mut_mut_mut_mut_mut_mut_smallest_index: usize = 0;\n\
    \    let mut mut_mut_mut_mut_mut_mut_mut_smallest_value: isize = 0;\n    let mut\
    \ mut_mut_mut_mut_mut_mut_mut_mut_smallest_index: usize = 0;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_value:\
    \ isize = 0;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_index:\
    \ usize = 0;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_value:\
    \ isize = 0;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_index:\
    \ usize = 0;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_value:\
    \ isize = 0;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_index:\
    \ usize = 0;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mu\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp15mqgvah.rs:49:71\n   |\n\
    49 |     let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mu\n\
    \   |                                                                       ^\
    \ help: add `;` here\n50 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp15mqgvah.rs:26:30\n   |\n26 | fn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |    -----                     ^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 1;\n    let mut min_idx2 = 1;\n    let mut min_idx3 = 1;\n\
    \    let mut min_idx4 = 1;\n    let mut min_idx5 = 1;\n    let mut min_idx6 =\
    \ 1;\n    let mut min_idx7 = 1;\n    let mut min_idx8 = 1;\n    let mut min_idx9\
    \ = 1;\n    let mut min_idx10 = 1;\n    let mut min_idx11 = 1;\n    let mut min_idx12\
    \ = 1;\n    let mut min_idx13 = 1;\n    let mut min_idx14 = 1;\n    let mut min_idx15\
    \ = 1;\n    let mut min_idx16 = 1;\n    let mut min_idx17 = 1;\n    let mut min_idx18\
    \ = 1;\n    let mut min_idx19 = 1;\n    let mut min_idx20 = 1;\n    let mut min_idx21\
    \ = 1;\n    let mut min_idx22 = 1;\n    let mut min_idx23 = 1;\n    let mut min_idx24\
    \ = 1;\n    let mut min_idx25 = 1;\n    let mut min_idx26 = 1;\n    let mut min_idx27\
    \ = 1;\n    let mut min_idx28 = 1;\n    let mut min_idx29 = 1;\n    let mut min_idx30\
    \ = 1;\n    let mut min_idx31 = 1;\n    let mut min_idx32 = 1;\n    let mut min_idx33\
    \ = 1;\n    let mut min_idx34 = 1;\n    let mut min_idx35 = 1;\n    let mut min_idx36\
    \ = 1;\n    let mut min_idx37 = 1;\n    let mut min_idx38 = 1;\n    let mut min_idx39\
    \ = 1;\n    let mut min_idx40 = 1;\n    let mut min_idx41 = 1;\n    let mut min_idx42\
    \ = 1;\n    let mut min_idx43 = 1;\n    let mut min_idx44 = 1;\n    let mut min_idx45\
    \ = 1;\n    let mut min_idx46 = 1;\n    let mut min_idx47 = 1;\n    let mut min_idx48\
    \ = 1;\n    let mut min_idx49 = 1;\n    let mut min_idx50 = 1;\n    let mut min_idx51\
    \ = 1;\n    let mut min_idx52 = 1;\n    let mut min_idx53 = 1;\n    let mut min_idx54\
    \ = 1;\n    let mut min_idx55 = 1;\n    let mut min_idx56 = 1;\n    let mut min_idx57\
    \ = 1;\n    let mut min_idx58 = 1;\n    let mut min_idx59 = 1;\n    let mut min_idx60\
    \ = 1;\n    let mut min_idx61 = 1;\n    let mut min_idx62 = 1;\n    let mut min_idx\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpgockuhk1.rs:90:20\n   |\n\
    90 |     let mut min_idx\n   |                    ^ help: add `;` here\n91 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgockuhk1.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    let mut mut_counter = 0;\n    for &i in\
    \ arr {\n        if i % 2 == 0 {\n            if smallest_value == i {\n     \
    \           smallest_index = mut_counter;\n            }\n            smallest_value\
    \ = i;\n            mut_counter = 1;\n        } else {\n            mut_counter\
    \ += 1;\n        }\n    }\n    if mut_counter == 0 {\n        return vec![];\n\
    \    }\n    vec![smallest_value, smallest_index]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsbereark.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    let mut even_values = Vec::new();\n    for\
    \ &x in arr {\n        if x % 2 == 0 {\n            even_values.push(x);\n   \
    \     }\n        if x < smallest_value {\n            smallest_value = x;\n  \
    \          smallest_index = even_values.len();\n        }\n        if x == smallest_value\
    \ {\n            smallest_index += even_values.len();\n        }\n    }\n    if\
    \ even_values.len() == 0 {\n        return vec![];\n    }\n    let mut smallest_even_value\
    \ = even_values[0];\n    let mut smallest_even_index = 0;\n    for &x in even_values\
    \ {\n        if x < smallest_even_value {\n            smallest_even_value = x;\n\
    \            smallest_even_index = even_values.len();\n        }\n        if x\
    \ == smallest_even_value {\n            smallest_even_index += even_values.len();\n\
    \        }\n    }\n    vec![smallest_value, smallest_index].into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp68dra4vf.rs:30:9\n   |\n\
    30 |     for &x in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp68dra4vf.rs:47:9\n   |\n47 |     for &x in even_values\
    \ {\n   |         ^^    ----------- this expression has type `isize`\n   |   \
    \      |\n   |         expected `isize`, found reference\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp68dra4vf.rs:56:26\n   |\n56 |     vec![smallest_value, smallest_index].into_iter().collect()\n\
    \   |                          ^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut even_values = vec![];\n\
    \    let mut smallest_value = vec![];\n    let mut smallest_index = vec![];\n\
    \    for i in arr.iter() {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \            if i < smallest_value.len() {\n                smallest_value.push(smallest_value[i]);\n\
    \                smallest_index.push(smallest_index[i]);\n            }\n    \
    \    }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n    }\n\
    \    if even_values.len() == 1 {\n        smallest_value.push(even_values[0]);\n\
    \        smallest_index.push(0);\n        return vec![smallest_value[smallest_index.len()],\
    \ smallest_index.len()];\n    }\n    let mut smallest_value_len = even_values.len();\n\
    \    for i in even_values.iter() {\n        if i < smallest_value.len() {\n  \
    \          smallest_value_len = i;\n        }\n    }\n    for i in even_values.iter()\
    \ {\n        if i < smallest_value.len() {\n            smallest_value.push(smallest_value[i]);\n\
    \            smallest_index.push(smallest_index[i]);\n        }\n    }\n    for\
    \ i in even_values.iter() {\n        if i < smallest_value_len {\n           \
    \ smallest_value.push(even_values[i]);\n            smallest_index.push(even_values.iter().position(|&x|\
    \ x == i).unwrap());\n        }\n    }\n    smallest_value.push(even_values[smallest_value_len]);\n\
    \    smallest_index.push(even_values.iter().position(|&x| x == smallest_value_len).unwrap());\n\
    \    smallest_value\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoh2bqu0r.rs:33:20\n   |\n\
    33 |             if i < smallest_value.len() {\n   |                    ^^^^^^^^^^^^^^^^^^^^\
    \ expected `&isize`, found `usize`\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `&isize`\n  --> /tmp/tmpoh2bqu0r.rs:34:37\n   |\n34 |                 smallest_value.push(smallest_value[i]);\n\
    \   |                                     ^^^^^^^^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>`\
    \ is not implemented for `&isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<&isize>` for `Vec<_>`\n\nerror[E0277]: the type `[_]`\
    \ cannot be indexed by `&isize`\n  --> /tmp/tmpoh2bqu0r.rs:35:37\n   |\n35 | \
    \                smallest_index.push(smallest_index[i]);\n   |               \
    \                      ^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>` is not implemented\
    \ for `&isize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoh2bqu0r.rs:45:21\n\
    \   |\n45 |         return vec![smallest_value[smallest_index.len()], smallest_index.len()];\n\
    \   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the type\n   |\n45 |    \
    \     return vec![*smallest_value[smallest_index.len()], smallest_index.len()];\n\
    \   |                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoh2bqu0r.rs:49:16\n\
    \   |\n49 |         if i < smallest_value.len() {\n   |                ^^^^^^^^^^^^^^^^^^^^\
    \ expected `&&isize`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoh2bqu0r.rs:50:34\n\
    \   |\n50 |             smallest_value_len = i;\n   |                        \
    \          ^ expected `usize`, found `&&isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpoh2bqu0r.rs:54:16\n   |\n54 |         if i < smallest_value.len()\
    \ {\n   |                ^^^^^^^^^^^^^^^^^^^^ expected `&&isize`, found `usize`\n\
    \nerro"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 0;\n    let mut min_idx = arr.iter().enumerate().min_by_key(|(_,\
    \ v)| {\n        if v < min_value {\n            min_value = v;\n            min_idx\
    \ = *v;\n        }\n    });\n    min_idx\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw9s60suz.rs:30:16\n   |\n\
    30 |         if v < min_value {\n   |                ^^^^^^^^^ expected `&&isize`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw9s60suz.rs:31:25\n\
    \   |\n31 |             min_value = v;\n   |                         ^ expected\
    \ `isize`, found `&&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw9s60suz.rs:32:23\n\
    \   |\n32 |             min_idx = *v;\n   |                       ^^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    32 |             min_idx = **v;\n   |                       +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpw9s60suz.rs:35:5\n   |\n26 | fn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |                              ---------- expected `Vec<isize>`\
    \ because of return type\n...\n35 |     min_idx\n   |     ^^^^^^^ expected struct\
    \ `Vec`, found enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \                found enum `Option<(usize, &isize)>`\n\nerror: aborting due to\
    \ 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    for i in arr.iter().rev() {\n        if\
    \ i % 2 == 0 {\n            if smallest_value < i {\n                smallest_value\
    \ = i;\n                smallest_index = i;\n            }\n        }\n    }\n\
    \    vec![smallest_value, smallest_index]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmtadrjsg.rs:31:33\n   |\n\
    31 |             if smallest_value < i {\n   |                               \
    \  ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n31 |             if smallest_value < *i {\n   |              \
    \                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmtadrjsg.rs:32:34\n\
    \   |\n27 |     let mut smallest_value = arr[0];\n   |                       \
    \       ------ expected due to this value\n...\n32 |                 smallest_value\
    \ = i;\n   |                                  ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n32 |                 smallest_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmtadrjsg.rs:33:34\n   |\n28 |     let mut smallest_index = 0;\n\
    \   |                              - expected due to this value\n...\n33 |   \
    \              smallest_index = i;\n   |                                  ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    33 |                 smallest_index = *i;\n   |                              \
    \    +\n\nerror: aborting due to 3 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value: isize =\
    \ 0;\n    let mut smallest_index: usize = 0;\n    let mut smallest_even_value:\
    \ isize = 0;\n    let mut even_values: Vec<isize> = vec![];\n    for i in arr\
    \ {\n        if i % 2 == 0 {\n            even_values.push(i);\n            if\
    \ smallest_even_value < i {\n                smallest_even_value = i;\n      \
    \          smallest_index = i;\n            }\n        } else {\n            if\
    \ smallest_even_value < i {\n                smallest_even_value = i;\n      \
    \          smallest_index = i;\n            }\n        }\n    }\n    if even_values.len()\
    \ == 0 {\n        return vec![];\n    }\n    if even_values.len() == 1 {\n   \
    \     return vec![smallest_even_value];\n    }\n    if even_values.len() > 1 {\n\
    \        let mut smallest_even_value: isize = even_values[0];\n        let mut\
    \ smallest_index: usize = 0;\n        for i in even_values.iter().rev() {\n  \
    \          if i % 2 == 0 {\n                if smallest_even_value < i {\n   \
    \                 smallest_even_value = i;\n                    smallest_index\
    \ = i;\n                }\n            } else {\n                if smallest_even_value\
    \ < i {\n                    smallest_even_value = i;\n                    smallest_index\
    \ = i;\n                }\n            }\n        }\n        return vec![smallest_even_value,smallest_index];\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_is_o7r6.rs:36:34\n   |\n\
    36 |                 smallest_index = i;\n   |                               \
    \   ^ expected `usize`, found `isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp_is_o7r6.rs:41:34\n   |\n41 |                 smallest_index = i;\n\
    \   |                                  ^ expected `usize`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_is_o7r6.rs:56:42\n   |\n56 |              \
    \   if smallest_even_value < i {\n   |                                       \
    \   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n56 |                 if smallest_even_value < *i {\n   |     \
    \                                     +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp_is_o7r6.rs:57:43\n   |\n57 |                     smallest_even_value\
    \ = i;\n   |                                           ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n57 |        \
    \             smallest_even_value = *i;\n   |                                \
    \           +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_is_o7r6.rs:58:38\n\
    \   |\n58 |                     smallest_index = i;\n   |                    \
    \                  ^ expected `usize`, found `&isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_is_o7r6.rs:61:42\n   |\n61 |                 if smallest_even_value\
    \ < i {\n   |                                          ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n61 |        \
    \         if smallest_even_value < *i {\n   |                                \
    \          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_is_o7r6.rs:62:43\n\
    \   |\n62 |                     smallest_even_value = i;\n   |               \
    \                            ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n62 |                     smallest_even_value\
    \ = *i;\n   |                                           +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_is_o7r6.rs:63:38\n   |\n63 |                     "
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut even_values = vec![];\n\
    \    let mut smallest_value = vec![];\n    let mut smallest_index = vec![];\n\
    \    for i in arr.iter() {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \        }\n        if even_values.len() == 1 {\n            smallest_value.push(even_values[0]);\n\
    \            smallest_index.push(i);\n        }\n        if even_values.len()\
    \ > 1 {\n            if even_values[0] < smallest_value[0] {\n               \
    \ smallest_value.push(even_values[0]);\n                smallest_index.push(i);\n\
    \            }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ vec![];\n    }\n    if even_values.len() == 1 {\n        return vec![smallest_value[0],\
    \ smallest_index[0]];\n    }\n    if even_values.len() > 1 {\n        if even_values[0]\
    \ < smallest_value[0] {\n            return vec![smallest_value[0], smallest_index[0]];\n\
    \        }\n    }\n    return vec![];\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb9myxne_.rs:49:21\n   |\n\
    49 |         return vec![smallest_value[0], smallest_index[0]];\n   |        \
    \             ^^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the type\n   |\n49 |         return vec![*smallest_value[0],\
    \ smallest_index[0]];\n   |                     +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpb9myxne_.rs:53:25\n   |\n53 |             return vec![smallest_value[0],\
    \ smallest_index[0]];\n   |                         ^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the type\n   |\n\
    53 |             return vec![*smallest_value[0], smallest_index[0]];\n   |   \
    \                      +\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    for &i in arr {\n        if i % 2 == 0 {\n\
    \            if smallest_value < i {\n                smallest_value = i;\n  \
    \              smallest_index = i;\n            }\n        }\n    }\n    vec![smallest_value,\
    \ smallest_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdwakmk9z.rs:29:9\n   |\n\
    29 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 0;\n    for i in arr.iter().rev() {\n        if i % 2 ==\
    \ 0 {\n            min_value = i;\n            min_idx = i;\n        }\n    }\n\
    \    vec![min_value, min_idx]\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvm2upu9t.rs:31:25\n   |\n\
    31 |             min_value = i;\n   |                         ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n31 |  \
    \           min_value = *i;\n   |                         +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvm2upu9t.rs:32:23\n   |\n32 |             min_idx = i;\n\
    \   |                       ^ expected integer, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n32 |             min_idx = *i;\n   |       \
    \                +\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 101
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_index = 0;\n    for i in arr.iter().cloned() {\n        if i %\
    \ 2 == 0 {\n            if min_value % 2 == 0 {\n                min_value = i;\n\
    \                min_index = i;\n            } else {\n                min_value\
    \ = min_value + i;\n                min_index = i;\n            }\n        }\n\
    \    }\n    vec![min_value, min_index]\n}\n\nfn main() {\n    let candidate =\
    \ pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 2]`,\n right: `[2, 1]`', /tmp/tmpr106c7y7.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = -1;\n    for i in arr.iter().rev() {\n        if i % 2 ==\
    \ 0 {\n            if min_value == i {\n                min_idx = i;\n       \
    \     }\n            min_value = i;\n        }\n    }\n    vec![min_value, min_idx]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiw8q6_xk.rs:31:29\n   |\n\
    31 |             if min_value == i {\n   |                             ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    31 |             if min_value == *i {\n   |                             +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpiw8q6_xk.rs:32:27\n   |\n32 |  \
    \               min_idx = i;\n   |                           ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n32 |  \
    \               min_idx = *i;\n   |                           +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpiw8q6_xk.rs:34:25\n   |\n34 |             min_value\
    \ = i;\n   |                         ^ expected `isize`, found `&isize`\n   |\n\
    help: consider dereferencing the borrow\n   |\n34 |             min_value = *i;\n\
    \   |                         +\n\nerror: aborting due to 3 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_even_value = arr[0];\n\
    \    let mut smallest_even_index = -1;\n    let mut smallest_value_index = -1;\n\
    \    for &i in arr {\n        if i % 2 == 0 {\n            if smallest_even_index\
    \ == -1 || smallest_even_index > i {\n                smallest_even_value = i;\n\
    \                smallest_even_index = i;\n            }\n        } else {\n \
    \           if smallest_value_index == -1 || smallest_value_index > i {\n    \
    \            smallest_value_index = i;\n            }\n        }\n    }\n    if\
    \ smallest_even_index == -1 {\n        return vec![];\n    }\n    let mut result\
    \ = vec![smallest_even_value];\n    if smallest_value_index != -1 {\n        result.push(smallest_value_index);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmaij7or5.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_val = i32::MAX;\n \
    \   let mut min_idx = -1;\n    for i in arr {\n        if i % 2 == 0 {\n     \
    \       if min_val > i {\n                min_val = i;\n                min_idx\
    \ = i;\n            }\n        }\n    }\n    if min_val == i32::MAX {\n      \
    \  return vec![];\n    }\n    let mut result = vec![];\n    for i in arr {\n \
    \       if i == min_val {\n            result.push(min_idx);\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu89q8qxi.rs:31:26\n   |\n\
    31 |             if min_val > i {\n   |                          ^ expected `i32`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to an `i32` and panic\
    \ if the converted value doesn't fit\n   |\n31 |             if min_val > i.try_into().unwrap()\
    \ {\n   |                          ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpu89q8qxi.rs:32:27\n   |\n32 |                 min_val =\
    \ i;\n   |                           ^ expected `i32`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpu89q8qxi.rs:42:17\n   |\n42 |         if i ==\
    \ min_val {\n   |                 ^^^^^^^ expected `isize`, found `i32`\n   |\n\
    help: you can convert an `i32` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n42 |         if i == min_val.try_into().unwrap() {\n   |\
    \                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 0;\n    for i in arr.iter().rev() {\n        if i % 2 ==\
    \ 0 {\n            if min_value < i {\n                min_value = i;\n      \
    \          min_idx = i;\n            }\n        }\n    }\n    vec![min_value,\
    \ min_idx]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5629msia.rs:31:28\n   |\n\
    31 |             if min_value < i {\n   |                            ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    31 |             if min_value < *i {\n   |                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5629msia.rs:32:29\n   |\n32 |              \
    \   min_value = i;\n   |                             ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n32 |        \
    \         min_value = *i;\n   |                             +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5629msia.rs:33:27\n   |\n33 |              \
    \   min_idx = i;\n   |                           ^ expected integer, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n33 |                 min_idx\
    \ = *i;\n   |                           +\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = -1;\n    let mut min_idx2 = -1;\n    for i in arr.iter().rev()\
    \ {\n        if i % 2 == 0 {\n            if min_idx2 == -1 || min_value > min_value\
    \ {\n                min_value = i;\n                min_idx = i;\n          \
    \      min_idx2 = i;\n            } else {\n                min_idx2 = i;\n  \
    \          }\n        }\n    }\n    if min_idx2 == -1 {\n        return vec![];\n\
    \    }\n    vec![min_value, min_idx2]\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxkg765ay.rs:33:29\n   |\n\
    33 |                 min_value = i;\n   |                             ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    33 |                 min_value = *i;\n   |                             +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxkg765ay.rs:34:27\n   |\n34 |              \
    \   min_idx = i;\n   |                           ^ expected integer, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n34 |                 min_idx\
    \ = *i;\n   |                           +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxkg765ay.rs:35:28\n   |\n35 |                 min_idx2 = i;\n \
    \  |                            ^ expected integer, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n35 |                 min_idx2 = *i;\n\
    \   |                            +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxkg765ay.rs:37:28\n\
    \   |\n37 |                 min_idx2 = i;\n   |                            ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    37 |                 min_idx2 = *i;\n   |                            +\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 0;\n    for &i in arr {\n        if i % 2 == 0 {\n     \
    \       if min_value > i {\n                min_value = i;\n                min_idx\
    \ = i;\n            }\n        }\n    }\n    vec![min_value, min_idx]\n}\n\nfn\
    \ main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprit4c3re.rs:29:9\n   |\n\
    29 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_val = arr[0];\n   \
    \ let mut min_idx = 0;\n    let mut min_even_val = false;\n    for &i in arr {\n\
    \        if i % 2 == 0 {\n            if min_even_val {\n                min_even_val\
    \ = false;\n            }\n            min_even_val = true;\n            min_val\
    \ = i;\n            min_idx = i;\n        }\n    }\n    if min_even_val {\n  \
    \      min_even_val = false;\n    }\n    vec![min_val, min_idx]\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7e1wkoyx.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even_value = arr[0];\n\
    \    let mut min_even_index = -1;\n    let mut min_even_index_in_vec = -1;\n \
    \   for i in arr.iter().cloned() {\n        if i % 2 == 0 {\n            if min_even_index\
    \ == -1 || min_even_index > i {\n                min_even_index = i;\n       \
    \         min_even_index_in_vec = i;\n            }\n        } else {\n      \
    \      if min_even_index != -1 && min_even_index == i {\n                min_even_index_in_vec++;\n\
    \            }\n        }\n    }\n    if min_even_index == -1 {\n        return\
    \ vec![];\n    }\n    let mut result = vec![min_even_value];\n    if min_even_index_in_vec\
    \ == 1 {\n        result.push(min_even_index);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `+`\n  --> /tmp/tmpk_2pvixh.rs:38:39\n\
    \   |\n38 |                 min_even_index_in_vec++;\n   |                   \
    \                    ^ expected expression\n\nerror: aborting due to previous\
    \ error\n\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    let mut even_values = Vec::new();\n    for\
    \ &value in arr {\n        if value % 2 == 0 {\n            even_values.push(value);\n\
    \        }\n        if value < smallest_value {\n            smallest_value =\
    \ value;\n            smallest_index = even_values.iter().position(|&x| x == smallest_value).unwrap();\n\
    \        }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n \
    \   }\n    let mut smallest_even_value = even_values[0];\n    let mut smallest_even_index\
    \ = even_values.iter().position(|&x| x == smallest_even_value).unwrap();\n   \
    \ for &value in even_values {\n        if value < smallest_even_value {\n    \
    \        smallest_even_value = value;\n            smallest_even_index = even_values.iter().position(|&x|\
    \ x == smallest_even_value).unwrap();\n        }\n    }\n    vec![smallest_value,\
    \ smallest_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpizz2s8_j.rs:30:9\n   |\n\
    30 |     for &value in arr {\n   |         ^^^^^^    --- this expression has type\
    \ `isize`\n   |         |\n   |         expected `isize`, found reference\n  \
    \ |\n   = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpizz2s8_j.rs:44:9\n   |\n44 |     for &value\
    \ in even_values {\n   |         ^^^^^^    ----------- this expression has type\
    \ `isize`\n   |         |\n   |         expected `isize`, found reference\n  \
    \ |\n   = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpizz2s8_j.rs:50:26\n   |\n50 |     vec![smallest_value,\
    \ smallest_index]\n   |                          ^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n50 |     vec![smallest_value, smallest_index.try_into().unwrap()]\n\
    \   |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 0;\n    for i in arr.iter().rev() {\n        if i % 2 ==\
    \ 0 {\n            if min_value > i {\n                min_value = i;\n      \
    \          min_idx = i;\n            }\n        }\n    }\n    vec![min_value,\
    \ min_idx]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjzjh771y.rs:31:28\n   |\n\
    31 |             if min_value > i {\n   |                            ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    31 |             if min_value > *i {\n   |                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjzjh771y.rs:32:29\n   |\n32 |              \
    \   min_value = i;\n   |                             ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n32 |        \
    \         min_value = *i;\n   |                             +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjzjh771y.rs:33:27\n   |\n33 |              \
    \   min_idx = i;\n   |                           ^ expected integer, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n33 |                 min_idx\
    \ = *i;\n   |                           +\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_val = arr[0];\n   \
    \ let mut min_idx = -1;\n    for i in arr.iter().rev() {\n        if i % 2 ==\
    \ 0 {\n            if min_val < i {\n                min_val = i;\n          \
    \      min_idx = i;\n            }\n        }\n    }\n    if min_idx == -1 {\n\
    \        return vec![];\n    }\n    vec![min_val, min_idx]\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk8kv4u7_.rs:31:26\n   |\n\
    31 |             if min_val < i {\n   |                          ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n31 |  \
    \           if min_val < *i {\n   |                          +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpk8kv4u7_.rs:32:27\n   |\n32 |              \
    \   min_val = i;\n   |                           ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n32 |                 min_val\
    \ = *i;\n   |                           +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpk8kv4u7_.rs:33:27\n   |\n33 |                 min_idx = i;\n  \
    \ |                           ^ expected integer, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n33 |                 min_idx = *i;\n\
    \   |                           +\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_even_value = arr[0];\n\
    \    let mut smallest_even_index = -1;\n    let mut smallest_value_index = -1;\n\
    \    for &mut value in arr.iter_mut() {\n        if value % 2 == 0 {\n       \
    \     if smallest_even_index == -1 || value < smallest_even_value\n          \
    \      || smallest_even_index == value {\n                smallest_even_value\
    \ = value;\n                smallest_even_index = value;\n                smallest_value_index\
    \ = arr.iter().position(|&x| x == value);\n            }\n        } else {\n \
    \           if smallest_even_index == -1 || value < smallest_even_value\n    \
    \            || smallest_even_index == value {\n                smallest_even_value\
    \ = value;\n                smallest_even_index = value;\n            }\n    \
    \    }\n    }\n    if smallest_even_index == -1 {\n        return vec![];\n  \
    \  }\n    let mut result = vec![smallest_even_value];\n    result[smallest_value_index]\
    \ = smallest_even_index;\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpocdml9rh.rs:36:40\n   |\n\
    36 |                 smallest_value_index = arr.iter().position(|&x| x == value);\n\
    \   |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n\
    \              found enum `Option<usize>`\n\nerror[E0277]: the trait bound `usize:\
    \ Neg` is not satisfied\n  --> /tmp/tmpocdml9rh.rs:29:36\n   |\n29 |     let mut\
    \ smallest_value_index = -1;\n   |                                    ^^ the trait\
    \ `Neg` is not implemented for `usize`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value: isize =\
    \ 0;\n    let mut smallest_index: usize = 0;\n    let mut even_values: Vec<isize>\
    \ = Vec::new();\n    for &i in arr {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \        }\n        if i == smallest_value {\n            smallest_index = arr.iter().position(|&i|\
    \ i == i).unwrap();\n        }\n        if i == smallest_value {\n           \
    \ smallest_value = i;\n        }\n    }\n    if even_values.len() == 0 {\n   \
    \     return vec![];\n    }\n    if even_values.len() == 1 {\n        return vec![even_values[0]];\n\
    \    }\n    if even_values.len() == 2 {\n        return vec![even_values[0], even_values[1]];\n\
    \    }\n    if even_values.len() == 3 {\n        return vec![even_values[0], even_values[1],\
    \ even_values[2]];\n    }\n    if even_values.len() == 4 {\n        return vec![even_values[0],\
    \ even_values[1], even_values[2], even_values[3]];\n    }\n    if even_values.len()\
    \ == 5 {\n        return vec![even_values[0], even_values[1], even_values[2],\
    \ even_values[3], even_values[4]];\n    }\n    if even_values.len() == 6 {\n \
    \       return vec![even_values[0], even_values[1], even_values[2], even_values[3],\
    \ even_values[4], even_values[5]];\n    }\n    if even_values.len() == 7 {\n \
    \       return vec![even_values[0], even_values[1], even_values[2], even_values[3],\
    \ even_values[4], even_values[5], even_values[6]];\n    }\n    if even_values.len()\
    \ == 8 {\n        return vec![even_values[0], even_values[1], even_values[2],\
    \ even_values[3], even_values[4], even_values[5], even_values[6], even_values[7]];\n\
    \    }\n    if even_values.len() == 9 {\n        return vec![even_values[0], even_values[1],\
    \ even_values[2], even_values[3], even_values[4], even_values[5], even_values[6],\
    \ even_values[7], even_values[8]];\n    }\n    if even_values.len() == 10 {\n\
    \        return vec![even_values[0], even_values[1], even_values[2], even_values[3],\
    \ even_values[4], even_values[5], even_values[6], even_values[7], even_values[8],\
    \ even_values[9]];\n    }\n    if even_values.len() == 11 {\n        return vec![even_values[0],\
    \ even_values[1], even_values[2], even_values[3], even_values[4], even_values[5],\
    \ even_values[6], even_values[7], \n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp8oqcstk5.rs:88:3\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \                       - unclosed delimiter\n...\n74 |     if even_values.len()\
    \ == 11 {\n   |                                - this delimiter might not be properly\
    \ closed...\n75 |         return vec![even_values[0], ev...\n76 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n88 | }\n   |   ^\n\n\
    error: mismatched closing delimiter: `}`\n  --> /tmp/tmp8oqcstk5.rs:75:20\n  \
    \ |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                    \
    \                     - closing delimiter possibly meant for this\n...\n75 | \
    \        return vec![even_values[0], even_values[1], even_values[2], even_values[3],\
    \ even_values[4], even_values[5], even_values[6], even_...\n   |             \
    \       ^ unclosed delimiter\n76 | }\n   | ^ mismatched closing delimiter\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp8oqcstk5.rs:30:9\n   |\n30 |   \
    \  for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8oqcstk5.rs:26:30\n   |\n26 | fn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |    -----                     ^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = -1;\n    for &i in arr {\n        if i % 2 == 0 {\n    \
    \        if min_value >= i {\n                min_value = i;\n               \
    \ min_idx = i;\n            }\n        }\n    }\n    if min_value == arr[0] {\n\
    \        vec![]\n    } else {\n        vec![min_value, min_idx]\n    }\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpml5gy31m.rs:29:9\n   |\n\
    29 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_even_value = arr[0];\n\
    \    let mut smallest_even_index = -1;\n    let mut smallest_even_index_value\
    \ = arr[0];\n    let mut smallest_even_index_value = arr[0];\n    let mut smallest_even_index_value\
    \ = arr[0];\n    let mut smallest_even_index_value = arr[0];\n    let mut smallest_even_index_value\
    \ = arr[0];\n    let mut smallest_even_index_value = arr[0];\n    let mut smallest_even_index_value\
    \ = arr[0];\n    let mut smallest_even_index_value = arr[0];\n    let mut smallest_even_index_value\
    \ = arr[0];\n    let mut smallest_even_index_value = arr[0];\n    let mut smallest_even_index_value\
    \ = arr[0];\n    let mut smallest_even_index_value = arr[0];\n    let mut smallest_even_index_value\
    \ = arr[0];\n    let mut smallest_even_index_value = arr[0];\n    let mut smallest_even_index_value\
    \ = arr[0];\n    let mut smallest_even_index_value = arr[0];\n    let mut smallest_even_index_value\
    \ = arr[0];\n    let mut smallest_even_index_value = arr[0];\n    let mut smallest_even_index_value\
    \ = arr[0];\n    let mut smallest_even_index_value = arr[0];\n    let mut smallest_even_index_value\
    \ = arr[0];\n    let mut smallest_even_index_value = arr[0];\n    let mut smallest_even_index_value\
    \ = arr[0];\n    let mut smallest_even_index_value = arr[0];\n    let mut smallest_even_index_value\
    \ = arr[0];\n    let mut smallest_even_index_value = arr[0];\n    let mut smallest_even_index_value\
    \ = arr[0];\n    let mut smallest_even_index_value = arr[0];\n    let mut smallest_even_index_value\
    \ = arr[0];\n    let mut smallest_even_index_value = arr[0];\n    let mut smallest_even_index_value\
    \ = arr[0];\n    let mut smallest_even_index_value = arr[0];\n    let mut smallest_even_index_value\
    \ = arr[0];\n    let mut smallest_even_index_value = arr[0];\n    let mut smallest_even_index_value\
    \ = arr[0];\n    let mut smallest_even_index_value = arr[0];\n    let mut smallest_even_index_value\
    \ = arr[0];\n    let mut smallest_even_index_value = arr[0];\n    let mut smallest_even_index_value\
    \ = arr[0];\n    let mut smallest_even_index_value = arr[0];\n    let mut smallest_even_index_value\
    \ = arr[0];\n    let mut smallest_even_index_value = arr[0];\n    let mut smallest_even_index_value\
    \ = arr[0];\n    let mut smallest_even_index_value = arr[0];\n    let mut smallest_even_index_value\
    \ = arr\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmputd6kgv4.rs:73:44\n   |\n\
    73 |     let mut smallest_even_index_value = arr\n   |                       \
    \                     ^ help: add `;` here\n74 | }\n   | - unexpected token\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmputd6kgv4.rs:26:30\n   |\n26 | fn\
    \ pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----                     ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even_value = arr[0];\n\
    \    let mut min_even_index = 0;\n    let mut min_even_index_in_arr = 0;\n   \
    \ let mut min_even_index_in_arr2 = 0;\n    let mut min_even_index_in_arr3 = 0;\n\
    \    let mut min_even_index_in_arr4 = 0;\n    let mut min_even_index_in_arr5 =\
    \ 0;\n    let mut min_even_index_in_arr6 = 0;\n    let mut min_even_index_in_arr7\
    \ = 0;\n    let mut min_even_index_in_arr8 = 0;\n    let mut min_even_index_in_arr9\
    \ = 0;\n    let mut min_even_index_in_arr10 = 0;\n    let mut min_even_index_in_arr11\
    \ = 0;\n    let mut min_even_index_in_arr12 = 0;\n    let mut min_even_index_in_arr13\
    \ = 0;\n    let mut min_even_index_in_arr14 = 0;\n    let mut min_even_index_in_arr15\
    \ = 0;\n    let mut min_even_index_in_arr16 = 0;\n    let mut min_even_index_in_arr17\
    \ = 0;\n    let mut min_even_index_in_arr18 = 0;\n    let mut min_even_index_in_arr19\
    \ = 0;\n    let mut min_even_index_in_arr20 = 0;\n    let mut min_even_index_in_arr21\
    \ = 0;\n    let mut min_even_index_in_arr22 = 0;\n    let mut min_even_index_in_arr23\
    \ = 0;\n    let mut min_even_index_in_arr24 = 0;\n    let mut min_even_index_in_arr25\
    \ = 0;\n    let mut min_even_index_in_arr26 = 0;\n    let mut min_even_index_in_arr27\
    \ = 0;\n    let mut min_even_index_in_arr28 = 0;\n    let mut min_even_index_in_arr29\
    \ = 0;\n    let mut min_even_index_in_arr30 = 0;\n    let mut min_even_index_in_arr31\
    \ = 0;\n    let mut min_even_index_in_arr32 = 0;\n    let mut min_even_index_in_arr33\
    \ = 0;\n    let mut min_even_index_in_arr34 = 0;\n    let mut min_even_index_in_arr35\
    \ = 0;\n    let mut min_even_index_in_arr36 = 0;\n    let mut min_even_index_in_arr37\
    \ = 0;\n    let mut min_even_index_in_arr38 = 0;\n    let mut min_even_index_in_arr39\
    \ = 0;\n    let mut min_even_index_in_arr40 = 0;\n    let mut min_even_index_in_arr41\
    \ = 0;\n    let mut min_even_index_in_arr42 = 0;\n    let mut min_even_index_in_arr43\
    \ = 0;\n    let mut min_even_index_in_arr44 = 0;\n    let mut min_even_index_in_arr45\
    \ = 0;\n    let mut min_even\n}\n\nfn main() {\n    let candidate = pluck;\n \
    \   assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpi94ao66w.rs:74:21\n   |\n\
    74 |     let mut min_even\n   |                     ^ help: add `;` here\n75 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi94ao66w.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even_value = arr[0];\n\
    \    let mut min_even_index = -1;\n    let mut min_even_index_in_arr = -1;\n \
    \   let mut min_even_index_in_arr2 = -1;\n    let mut min_even_index_in_arr3 =\
    \ -1;\n    let mut min_even_index_in_arr4 = -1;\n    let mut min_even_index_in_arr5\
    \ = -1;\n    let mut min_even_index_in_arr6 = -1;\n    let mut min_even_index_in_arr7\
    \ = -1;\n    let mut min_even_index_in_arr8 = -1;\n    let mut min_even_index_in_arr9\
    \ = -1;\n    let mut min_even_index_in_arr10 = -1;\n    let mut min_even_index_in_arr11\
    \ = -1;\n    let mut min_even_index_in_arr12 = -1;\n    let mut min_even_index_in_arr13\
    \ = -1;\n    let mut min_even_index_in_arr14 = -1;\n    let mut min_even_index_in_arr15\
    \ = -1;\n    let mut min_even_index_in_arr16 = -1;\n    let mut min_even_index_in_arr17\
    \ = -1;\n    let mut min_even_index_in_arr18 = -1;\n    let mut min_even_index_in_arr19\
    \ = -1;\n    let mut min_even_index_in_arr20 = -1;\n    let mut min_even_index_in_arr21\
    \ = -1;\n    let mut min_even_index_in_arr22 = -1;\n    let mut min_even_index_in_arr23\
    \ = -1;\n    let mut min_even_index_in_arr24 = -1;\n    let mut min_even_index_in_arr25\
    \ = -1;\n    let mut min_even_index_in_arr26 = -1;\n    let mut min_even_index_in_arr27\
    \ = -1;\n    let mut min_even_index_in_arr28 = -1;\n    let mut min_even_index_in_arr29\
    \ = -1;\n    let mut min_even_index_in_arr30 = -1;\n    let mut min_even_index_in_arr31\
    \ = -1;\n    let mut min_even_index_in_arr32 = -1;\n    let mut min_even_index_in_arr33\
    \ = -1;\n    let mut min_even_index_in_arr34 = -1;\n    let mut min_even_index_in_arr35\
    \ = -1;\n    let mut min_even_index_in_arr36 = -1;\n    let mut min_even_index_in_arr37\
    \ = -1;\n    let mut min_even_index_in_arr38 = -1;\n    let mut min_even_index_in_arr39\
    \ = -1;\n    let mut min_even_index_in_arr40 = -1;\n    let mut min_even_index_in_arr41\
    \ = -1;\n    let mut min_even_index_in_arr42 = -1;\n    let mut min_\n}\n\nfn\
    \ main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvb37g8kh.rs:71:17\n   |\n\
    71 |     let mut min_\n   |                 ^ help: add `;` here\n72 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvb37g8kh.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 0;\n    let mut min_idx = arr.iter().enumerate().min_by_key(|(_,\
    \ v)| {\n        if v < min_value {\n            min_value = v;\n            min_idx\
    \ = v;\n        }\n    });\n    vec![min_value, min_idx]\n}\n\nfn main() {\n \
    \   let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb00zj2g9.rs:30:16\n   |\n\
    30 |         if v < min_value {\n   |                ^^^^^^^^^ expected `&&isize`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb00zj2g9.rs:31:25\n\
    \   |\n31 |             min_value = v;\n   |                         ^ expected\
    \ `isize`, found `&&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb00zj2g9.rs:32:23\n\
    \   |\n32 |             min_idx = v;\n   |                       ^ expected integer,\
    \ found `&&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb00zj2g9.rs:35:21\n\
    \   |\n35 |     vec![min_value, min_idx]\n   |                     ^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<(usize, &isize)>`\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 0;\n    let mut min_idx = arr.iter().enumerate().min_by_key(|(_,\
    \ v)| {\n        if v < min_value {\n            min_value = v;\n            min_idx\
    \ = _;\n        }\n        v\n    });\n    min_idx\n        .unwrap()\n      \
    \  .1\n        .clone()\n        .unwrap()\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0658]: destructuring assignments are unstable\n  --> /tmp/tmp3ka7ul68.rs:32:23\n\
    \   |\n32 |             min_idx = _;\n   |                       ^\n   |\n   =\
    \ note: see issue #71126 <https://github.com/rust-lang/rust/issues/71126> for\
    \ more information\n\nerror: in expressions, `_` can only be used on the left-hand\
    \ side of an assignment\n  --> /tmp/tmp3ka7ul68.rs:32:23\n   |\n32 |         \
    \    min_idx = _;\n   |                       ^ `_` not allowed here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3ka7ul68.rs:30:16\n   |\n30 |         if v <\
    \ min_value {\n   |                ^^^^^^^^^ expected `&&isize`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp3ka7ul68.rs:31:25\n   |\n31 |\
    \             min_value = v;\n   |                         ^ expected `isize`,\
    \ found `&&isize`\n\nerror[E0599]: no method named `unwrap` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmp3ka7ul68.rs:40:10\n   |\n40 |         .unwrap()\n\
    \   |          ^^^^^^ method not found in `isize`\n\nerror: aborting due to 5\
    \ previous errors\n\nSome errors have detailed explanations: E0308, E0599, E0658.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smalest_value = arr[0];\n\
    \    let mut smalest_index = 0;\n    let mut even_values = Vec::new();\n    for\
    \ i in arr.iter().cloned() {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \        }\n        if i == smalest_value {\n            smalest_index = even_values.iter().enumerate().min_by_key(|(_,\
    \ v)| v).unwrap().0;\n        }\n        if i == smalest_value {\n           \
    \ smalest_value = i;\n        }\n    }\n    if even_values.len() == 0 {\n    \
    \    return vec![];\n    }\n    even_values[smalest_index];\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplhcvwy7j.rs:26:30\n   |\n\
    26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----                \
    \     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n...\n44 |     even_values[smalest_index];\n\
    \   |                               - help: consider removing this semicolon\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 0;\n    let mut min_idx2 = 0;\n    let mut min_idx3 = 0;\n\
    \    let mut min_idx4 = 0;\n    let mut min_idx5 = 0;\n    let mut min_idx6 =\
    \ 0;\n    let mut min_idx7 = 0;\n    let mut min_idx8 = 0;\n    let mut min_idx9\
    \ = 0;\n    let mut min_idx10 = 0;\n    let mut min_idx11 = 0;\n    let mut min_idx12\
    \ = 0;\n    let mut min_idx13 = 0;\n    let mut min_idx14 = 0;\n    let mut min_idx15\
    \ = 0;\n    let mut min_idx16 = 0;\n    let mut min_idx17 = 0;\n    let mut min_idx18\
    \ = 0;\n    let mut min_idx19 = 0;\n    let mut min_idx20 = 0;\n    let mut min_idx21\
    \ = 0;\n    let mut min_idx22 = 0;\n    let mut min_idx23 = 0;\n    let mut min_idx24\
    \ = 0;\n    let mut min_idx25 = 0;\n    let mut min_idx26 = 0;\n    let mut min_idx27\
    \ = 0;\n    let mut min_idx28 = 0;\n    let mut min_idx29 = 0;\n    let mut min_idx30\
    \ = 0;\n    let mut min_idx31 = 0;\n    let mut min_idx32 = 0;\n    let mut min_idx33\
    \ = 0;\n    let mut min_idx34 = 0;\n    let mut min_idx35 = 0;\n    let mut min_idx36\
    \ = 0;\n    let mut min_idx37 = 0;\n    let mut min_idx38 = 0;\n    let mut min_idx39\
    \ = 0;\n    let mut min_idx40 = 0;\n    let mut min_idx41 = 0;\n    let mut min_idx42\
    \ = 0;\n    let mut min_idx43 = 0;\n    let mut min_idx44 = 0;\n    let mut min_idx45\
    \ = 0;\n    let mut min_idx46 = 0;\n    let mut min_idx47 = 0;\n    let mut min_idx48\
    \ = 0;\n    let mut min_idx49 = 0;\n    let mut min_idx50 = 0;\n    let mut min_idx51\
    \ = 0;\n    let mut min_idx52 = 0;\n    let mut min_idx53 = 0;\n    let mut min_idx54\
    \ = 0;\n    let mut min_idx55 = 0;\n    let mut min_idx56 = 0;\n    let mut min_idx57\
    \ = 0;\n    let mut min_idx58 = 0;\n    let mut min_idx59 = 0;\n    let mut min_idx60\
    \ = 0;\n    let mut min_idx61 = 0;\n    let mut min_idx62 = 0;\n    let mut min_idx63\
    \ = 0;\n    let mut min_idx\n}\n\nfn main() {\n    let candidate = pluck;\n  \
    \  assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_84wucx7.rs:91:20\n   |\n\
    91 |     let mut min_idx\n   |                    ^ help: add `;` here\n92 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_84wucx7.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value: isize =\
    \ 0;\n    let mut smallest_index: usize = 0;\n    let mut smallest_even_value:\
    \ isize = 0;\n    let mut even_values: Vec<isize> = vec![];\n    for i in arr\
    \ {\n        if i % 2 == 0 {\n            even_values.push(i);\n        }\n  \
    \      if i == smallest_value {\n            smallest_even_value = i;\n      \
    \  }\n        if i == smallest_value {\n            smallest_index = i;\n    \
    \    }\n        if i == smallest_value {\n            smallest_value = i;\n  \
    \      }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n   \
    \ }\n    if even_values.len() == 1 {\n        return vec![smallest_even_value];\n\
    \    }\n    if even_values.len() == 2 {\n        if even_values[0] < even_values[1]\
    \ {\n            return vec![even_values[0], smallest_index];\n        }\n   \
    \     return vec![even_values[1], smallest_index];\n    }\n    if even_values.len()\
    \ == 3 {\n        if even_values[0] < even_values[1] {\n            if even_values[0]\
    \ < even_values[2] {\n                return vec![even_values[0], even_values[1],\
    \ smallest_index];\n            }\n            return vec![even_values[1], even_values[2],\
    \ smallest_index];\n        }\n        if even_values[1] < even_values[2] {\n\
    \            return vec![even_values[0], even_values[1], smallest_index];\n  \
    \      }\n        return vec![even_values[0], even_values[2], smallest_index];\n\
    \    }\n    if even_values.len() == 4 {\n        if even_values[0] < even_values[1]\
    \ {\n            if even_values[0] < even_values[2] {\n                if even_values[0]\
    \ < even_values[3] {\n                    return vec![even_values[0], even_values[1],\
    \ even_values[2], smallest_index];\n                }\n                return\
    \ vec![even_values[0], even_values[1], even_values[3], smallest_index];\n    \
    \        }\n            if even_values[1] < even_values[2] {\n               \
    \ return vec![even_values[0], even_values[1], even_values[2], smallest_index];\n\
    \            }\n            return vec![even_values[0], even_values[2], even_values[3],\
    \ smallest_index];\n        }\n        if even_values[1] < even_values[2] {\n\
    \            if even_values[1] < even_values[3] {\n                return vec![even_values[0],\
    \ even_values[1], even_values[2], even_values[3], smallest_index];\n         \
    \   }\n            return vec![even_values[0], even_values[1], even_values[3],\
    \ even_values[4], smallest_index];\n        }\n        if even_values[2] < even_values[3]\
    \ {\n            return vec![even_values[0], even_values[1], even\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmphuq8a1cf.rs:102:3\n\
    \    |\n26  | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    |               \
    \                          - unclosed delimiter\n...\n69  |     if even_values.len()\
    \ == 4 {\n    |                               - unclosed delimiter\n...\n88  |\
    \         if even_values[2] < even_values[3] {\n    |                        \
    \                    - this delimiter might not be properly closed...\n89  | \
    \            return vec![even_values[0], even_values[1], even\n90  | }\n    |\
    \ - ...as it matches this but it has different indentation\n...\n102 | }\n   \
    \ |   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmphuq8a1cf.rs:89:24\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \                       - closing delimiter possibly meant for this\n...\n89 |\
    \             return vec![even_values[0], even_values[1], even\n   |         \
    \               ^ unclosed delimiter\n90 | }\n   | ^ mismatched closing delimiter\n\
    \nerror[E0425]: cannot find value `even` in this scope\n  --> /tmp/tmphuq8a1cf.rs:89:57\n\
    \   |\n89 |             return vec![even_values[0], even_values[1], even\n   |\
    \                                                         ^^^^ not found in this\
    \ scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphuq8a1cf.rs:39:30\n \
    \  |\n39 |             smallest_index = i;\n   |                             \
    \ ^ expected `usize`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphuq8a1cf.rs:53:41\n\
    \   |\n53 |             return vec![even_values[0], smallest_index];\n   |   \
    \                                      ^^^^^^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n53 |             return vec![even_values[0],\
    \ smallest_index.try_into().unwrap()];\n   |                                 \
    \        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmphuq8a1cf.rs:55:37\n   |\n55 |         return vec![even_values[1],\
    \ smallest_index];\n   |                   "
  stdout: ''
  timestamp: 1659748595
- exit_code: 101
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_even_value = arr[0];\n\
    \    let mut smallest_even_index = -1;\n    let mut smallest_index = -1;\n   \
    \ let mut smallest_value = arr[0];\n    for &x in arr.iter() {\n        if x %\
    \ 2 == 0 {\n            if smallest_even_value < x {\n                smallest_even_value\
    \ = x;\n                smallest_even_index = smallest_index;\n            }\n\
    \            smallest_value = x;\n            smallest_index = x;\n        }\n\
    \    }\n    if smallest_even_value == 0 {\n        return vec![];\n    }\n   \
    \ let mut result = vec![smallest_even_value];\n    if smallest_even_index != -1\
    \ {\n        result.push(smallest_even_index);\n    }\n    if smallest_index !=\
    \ -1 {\n        result.push(smallest_index);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 2]`,\n right: `[2, 1]`', /tmp/tmpuv_ikqb9.rs:56:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748596
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even_value = arr[0];\n\
    \    let mut min_even_index = 0;\n    let mut min_even_index_in_arr = 0;\n   \
    \ let mut min_even_index_in_arr_with_min_even_value = 0;\n    let mut min_even_index_in_arr_with_min_even_value_in_arr\
    \ = 0;\n    let mut min_even_index_in_arr_with_min_even_value_in_arr_with_min_even_value\
    \ = 0;\n    let mut min_even_index_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr\
    \ = 0;\n    let mut min_even_index_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value\
    \ = 0;\n    let mut min_even_index_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr\
    \ = 0;\n    let mut min_even_index_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value\
    \ = 0;\n    let mut min_even_index_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr\
    \ = 0;\n    let mut min_even_index_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value\
    \ = 0;\n    let mut min_even_index_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr\
    \ = 0;\n    let mut min_even_index_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value\
    \ = 0;\n    let mut min_even_index_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr\
    \ = 0;\n    let mut min_even_index_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value\
    \ = 0;\n    let mut min_even_index_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value_in_arr_with_min_even_value\
    \ = 0;\n    let mut min_even_index_in_arr_with_min_even_value_in_arr_with_min_even_value_in_\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpcnyw7fzk.rs:44:85\n   |\n\
    44 |     let mut min_even_index_in_arr_with_min_even_value_in_arr_with_min_even_value_in_\n\
    \   |                                                                        \
    \             ^ help: add `;` here\n45 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcnyw7fzk.rs:26:30\n   |\n26 | fn pluck(arr:\
    \ Vec<isize>) -> Vec<isize> {\n   |    -----                     ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smalest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    let mut smallest_even_value = false;\n \
    \   for &mut i in arr.iter_mut() {\n        if i % 2 == 0 {\n            if smallest_even_value\n\
    \                || (smallest_even_value = true)\n                || (smallest_index\
    \ = i) {\n                smalest_value = i;\n            }\n        } else {\n\
    \            smallest_even_value = false;\n        }\n    }\n    vec![smalest_value,\
    \ smallest_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph7h9da1r.rs:33:20\n   |\n\
    33 |                 || (smallest_even_value = true)\n   |                   \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `()`\n   |\nhelp: you might\
    \ have meant to compare for equality\n   |\n33 |                 || (smallest_even_value\
    \ == true)\n   |                                         ~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmph7h9da1r.rs:34:20\n   |\n34 |                 || (smallest_index\
    \ = i) {\n   |                    ^^^^^^^^^^^^^^^^^^^^ expected `bool`, found\
    \ `()`\n   |\nhelp: you might have meant to compare for equality\n   |\n34 | \
    \                || (smallest_index == i) {\n   |                            \
    \        ~~\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    let mut even_values = Vec::new();\n    for\
    \ &i in arr {\n        if i % 2 == 0 {\n            even_values.push(i);\n   \
    \     }\n        if i == smallest_value {\n            smallest_index = i;\n \
    \       }\n        if i == smallest_value {\n            smallest_value = i;\n\
    \        }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n \
    \   }\n    even_values.sort();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_values.dedup();\n    even_values.dedup();\n\
    \    even_values.dedup();\n    even_value\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `even_value` in this scope\n  --> /tmp/tmpc8ik0a7s.rs:96:5\n\
    \   |\n96 |     even_value\n   |     ^^^^^^^^^^ help: a local variable with a\
    \ similar name exists: `even_values`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpc8ik0a7s.rs:30:9\n   |\n30 |     for &i in arr {\n   |         ^^  \
    \  --- this expression has type `isize`\n   |         |\n   |         expected\
    \ `isize`, found reference\n   |\n   = note:   expected type `isize`\n       \
    \    found reference `&_`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value: isize =\
    \ 0;\n    let mut smallest_index: usize = 0;\n    let mut mut_smallest_value:\
    \ isize = 0;\n    let mut mut_smallest_index: usize = 0;\n    let mut mut_mut_smallest_value:\
    \ isize = 0;\n    let mut mut_mut_smallest_index: usize = 0;\n    let mut mut_mut_mut_smallest_value:\
    \ isize = 0;\n    let mut mut_mut_mut_smallest_index: usize = 0;\n    let mut\
    \ mut_mut_mut_mut_smallest_value: isize = 0;\n    let mut mut_mut_mut_mut_smallest_index:\
    \ usize = 0;\n    let mut mut_mut_mut_mut_mut_smallest_value: isize = 0;\n   \
    \ let mut mut_mut_mut_mut_mut_smallest_index: usize = 0;\n    let mut mut_mut_mut_mut_mut_mut_smallest_value:\
    \ isize = 0;\n    let mut mut_mut_mut_mut_mut_mut_smallest_index: usize = 0;\n\
    \    let mut mut_mut_mut_mut_mut_mut_mut_smallest_value: isize = 0;\n    let mut\
    \ mut_mut_mut_mut_mut_mut_mut_mut_smallest_index: usize = 0;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_value:\
    \ isize = 0;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_index:\
    \ usize = 0;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_value:\
    \ isize = 0;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_index:\
    \ usize = 0;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_value:\
    \ isize = 0;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_index:\
    \ usize = 0;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mu\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp15mqgvah.rs:49:71\n   |\n\
    49 |     let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mu\n\
    \   |                                                                       ^\
    \ help: add `;` here\n50 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp15mqgvah.rs:26:30\n   |\n26 | fn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |    -----                     ^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value: isize =\
    \ 0;\n    let mut smallest_index: usize = 0;\n    let mut even_values = vec![];\n\
    \    let mut even_values_index: Vec<usize> = vec![];\n    for i in arr {\n   \
    \     if i % 2 == 0 {\n            even_values.push(i);\n            even_values_index.push(i);\n\
    \        } else {\n            if smallest_value == 0 {\n                smallest_value\
    \ = i;\n                smallest_index = i;\n            } else {\n          \
    \      if i < smallest_value {\n                    smallest_value = i;\n    \
    \                smallest_index = i;\n                }\n            }\n     \
    \   }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n    }\n\
    \    let mut smallest_even_value = even_values[0];\n    let mut smallest_even_value_index\
    \ = even_values_index[0];\n    for i in even_values_index {\n        if i < smallest_even_value_index\
    \ {\n            smallest_even_value = even_values[i];\n            smallest_even_value_index\
    \ = i;\n        }\n    }\n    vec![smallest_value, smallest_even_value_index]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsy87dpzi.rs:34:36\n   |\n\
    34 |             even_values_index.push(i);\n   |                            \
    \        ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n34 |      \
    \       even_values_index.push(i.try_into().unwrap());\n   |                 \
    \                   ~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsy87dpzi.rs:38:34\n   |\n38 |                 smallest_index =\
    \ i;\n   |                                  ^ expected `usize`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsy87dpzi.rs:42:38\n   |\n42 |\
    \                     smallest_index = i;\n   |                              \
    \        ^ expected `usize`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsy87dpzi.rs:58:26\n   |\n58 |     vec![smallest_value, smallest_even_value_index]\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n58 |     vec![smallest_value, smallest_even_value_index.try_into().unwrap()]\n\
    \   |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 0;\n    for i in arr.iter().rev() {\n        if i % 2 ==\
    \ 0 {\n            if min_value < i {\n                min_value = i;\n      \
    \          min_idx = i;\n            }\n        }\n    }\n    vec![min_value,\
    \ min_idx]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5629msia.rs:31:28\n   |\n\
    31 |             if min_value < i {\n   |                            ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    31 |             if min_value < *i {\n   |                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5629msia.rs:32:29\n   |\n32 |              \
    \   min_value = i;\n   |                             ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n32 |        \
    \         min_value = *i;\n   |                             +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5629msia.rs:33:27\n   |\n33 |              \
    \   min_idx = i;\n   |                           ^ expected integer, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n33 |                 min_idx\
    \ = *i;\n   |                           +\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748594
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_even_value = arr[0];\n\
    \    let mut smallest_even_index = -1;\n    let mut smallest_value_index = -1;\n\
    \    for &i in arr {\n        if i % 2 == 0 {\n            if smallest_even_index\
    \ == -1 || smallest_even_index > i {\n                smallest_even_value = i;\n\
    \                smallest_even_index = i;\n                smallest_value_index\
    \ = i;\n            } else {\n                if smallest_value_index == -1 ||\
    \ smallest_value_index > i {\n                    smallest_value_index = i;\n\
    \                }\n            }\n        }\n    }\n    vec![smallest_even_index,\
    \ smallest_value_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuc35n9j_.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 0;\n    for i in arr.iter().rev() {\n        if i % 2 ==\
    \ 0 {\n            if min_value == i {\n                min_idx = i;\n       \
    \     } else {\n                min_value = i;\n                min_idx = i;\n\
    \            }\n        }\n    }\n    vec![min_value, min_idx]\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv4zhri4c.rs:31:29\n   |\n\
    31 |             if min_value == i {\n   |                             ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    31 |             if min_value == *i {\n   |                             +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpv4zhri4c.rs:32:27\n   |\n32 |  \
    \               min_idx = i;\n   |                           ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n32 |  \
    \               min_idx = *i;\n   |                           +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpv4zhri4c.rs:34:29\n   |\n34 |              \
    \   min_value = i;\n   |                             ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n34 |        \
    \         min_value = *i;\n   |                             +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpv4zhri4c.rs:35:27\n   |\n35 |              \
    \   min_idx = i;\n   |                           ^ expected integer, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n35 |                 min_idx\
    \ = *i;\n   |                           +\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut even_values = vec![];\n\
    \    let mut min_value = i32::MAX;\n    let mut min_value_index = -1;\n    for\
    \ &i in arr {\n        if i % 2 == 0 {\n            even_values.push(i);\n   \
    \         if i < min_value {\n                min_value = i;\n               \
    \ min_value_index = i;\n            }\n        }\n    }\n    if even_values.len()\
    \ == 0 {\n        return vec![];\n    }\n    if even_values.len() == 1 {\n   \
    \     return vec![even_values[0]];\n    }\n    let mut even_values_sorted = even_values.iter().cloned().collect::<Vec<_>>();\n\
    \    even_values_sorted.sort();\n    let mut even_values_sorted_index = even_values.iter().cloned().collect::<Vec<_>>();\n\
    \    even_values_sorted_index.sort();\n    let mut min_value_index = -1;\n   \
    \ for i in even_values_sorted_index {\n        if i == min_value_index {\n   \
    \         continue;\n        }\n        if min_value_index == -1 || i < min_value_index\
    \ {\n            min_value_index = i;\n        }\n    }\n    if min_value_index\
    \ == -1 {\n        return vec![];\n    }\n    let mut min_value = even_values_sorted[min_value_index];\n\
    \    for i in even_values_sorted_index {\n        if i == min_value_index {\n\
    \            continue;\n        }\n        if min_value % 2 == 0 {\n         \
    \   min_value = i;\n        }\n    }\n    let mut min_value_index = -1;\n    for\
    \ i in even_values_sorted_index {\n        if i == min_value_index {\n       \
    \     continue;\n        }\n        if min_value_index == -1 || i < min_value_index\
    \ {\n            min_value_index = i;\n        }\n    }\n    if min_value_index\
    \ == -1 {\n        return vec![];\n    }\n    let mut min_value = even_values_sorted[min_value_index];\n\
    \    for i in even_values_sorted_index {\n        if i == min_value_index {\n\
    \            continue;\n        }\n        if min_value % 2 == 0 {\n         \
    \   min_value = i;\n        }\n    }\n    let mut min_value_index = -1;\n    for\
    \ i in even_values_sorted_index {\n        if i == min_value_index {\n       \
    \     continue;\n        }\n        if min_value_index == -1 || i < min_value_index\
    \ {\n            min_value_index = i;\n        }\n    }\n    if min_value_index\
    \ == -1 {\n        return vec![];\n    }\n    let mut min_value = even_values_sorted[min_value_index];\n\
    \    for i in even_values_sorted_index {\n        if i == min_value_index {\n\
    \            continue;\n        }\n        if min_value % 2 == 0 {\n         \
    \   min_value = i;\n        }\n    }\n    let mut \n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n   --> /tmp/tmpr9i26eqs.rs:113:1\n\
    \    |\n113 | }\n    | ^ expected identifier\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpr9i26eqs.rs:30:9\n   |\n30 |     for &i in arr {\n   |        \
    \ ^^    --- this expression has type `isize`\n   |         |\n   |         expected\
    \ `isize`, found reference\n   |\n   = note:   expected type `isize`\n       \
    \    found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr9i26eqs.rs:43:21\n\
    \   |\n43 |         return vec![even_values[0]];\n   |                     ^^^^^^^^^^^^^^\
    \ expected `isize`, found `i32`\n\nerror[E0277]: the type `[i32]` cannot be indexed\
    \ by `i32`\n  --> /tmp/tmpr9i26eqs.rs:61:25\n   |\n61 |     let mut min_value\
    \ = even_values_sorted[min_value_index];\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[i32]>` is not implemented for `i32`\n   = note: required\
    \ because of the requirements on the impl of `Index<i32>` for `Vec<i32>`\n\nerror[E0277]:\
    \ the type `[i32]` cannot be indexed by `i32`\n  --> /tmp/tmpr9i26eqs.rs:82:25\n\
    \   |\n82 |     let mut min_value = even_values_sorted[min_value_index];\n   |\
    \                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[i32]>`\
    \ is not implemented for `i32`\n   = note: required because of the requirements\
    \ on the impl of `Index<i32>` for `Vec<i32>`\n\nerror[E0277]: the type `[i32]`\
    \ cannot be indexed by `i32`\n   --> /tmp/tmpr9i26eqs.rs:103:25\n    |\n103 |\
    \     let mut min_value = even_values_sorted[min_value_index];\n    |        \
    \                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n    |\n    = help: the trait `SliceIndex<[i32]>`\
    \ is not implemented for `i32`\n    = note: required because of the requirements\
    \ on the impl of `Index<i32>` for `Vec<i32>`\n\nerror: aborting due to 6 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ a"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    let mut smallest_even_value = false;\n \
    \   for &mut value in arr.iter_mut() {\n        if value == 0 {\n            smallest_even_value\
    \ = true;\n        }\n        if smallest_even_value\n            && smallest_value\
    \ > 0\n            && value < smallest_value\n        {\n            smallest_even_value\
    \ = false;\n            smallest_value = value;\n            smallest_index =\
    \ arr.iter().position(|&x| x == value);\n        }\n    }\n    if smallest_even_value\n\
    \        && smallest_value > 0\n        && smallest_index == 0\n    {\n      \
    \  smallest_index = 1;\n    }\n    vec![smallest_value, smallest_index]\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzh5uodg1.rs:40:30\n   |\n\
    40 |             smallest_index = arr.iter().position(|&x| x == value);\n   |\
    \                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer,\
    \ found enum `Option`\n   |\n   = note: expected type `{integer}`\n          \
    \    found enum `Option<usize>`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    let mut even_values = Vec::new();\n    for\
    \ i in arr.iter() {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \        }\n        if i == smallest_value {\n            smallest_index = i;\n\
    \        }\n        if i == smallest_value {\n            smallest_value = i;\n\
    \        }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n \
    \   }\n    if even_values.len() == 1 {\n        return vec![even_values[0]];\n\
    \    }\n    if even_values.len() > 1 {\n        let mut smallest_even_value =\
    \ even_values[0];\n        let mut smallest_even_index = 0;\n        for i in\
    \ even_values.iter() {\n            if i < smallest_even_value {\n           \
    \     smallest_even_value = i;\n                smallest_even_index = i;\n   \
    \         }\n        }\n        return vec![smallest_even_index, smallest_even_value];\n\
    \    }\n    return vec![];\n}\n\nfn main() {\n    let candidate = pluck;\n   \
    \ assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpl53matk7.rs:34:14\n\
    \   |\n34 |         if i == smallest_value {\n   |              ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl53matk7.rs:35:30\n\
    \   |\n35 |             smallest_index = i;\n   |                            \
    \  ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n35 |             smallest_index = *i;\n   |                  \
    \            +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl53matk7.rs:38:30\n\
    \   |\n38 |             smallest_value = i;\n   |                            \
    \  ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n38 |             smallest_value = *i;\n   |                  \
    \            +\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpl53matk7.rs:37:14\n\
    \   |\n37 |         if i == smallest_value {\n   |              ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl53matk7.rs:45:21\n\
    \   |\n45 |         return vec![even_values[0]];\n   |                     ^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the type\n\
    \   |\n45 |         return vec![*even_values[0]];\n   |                     +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpl53matk7.rs:51:20\n   |\n51 |\
    \             if i < smallest_even_value {\n   |                    ^^^^^^^^^^^^^^^^^^^\
    \ expected `&isize`, found `isize`\n   |\n   = note: expected reference `&&isize`\n\
    \              found reference `&isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpl53matk7.rs:53:39\n   |\n53 |                 smallest_even_index =\
    \ i;\n   |                                       ^ expected integer, found `&&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpl53matk7.rs:56:42\n   |\n56 |\
    \         return vec![smallest_even_index, smallest_even_value];\n   |       \
    \   "
  stdout: ''
  timestamp: 1659748596
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = -1;\n    let mut min_idx2 = -1;\n    for i in arr.iter().rev()\
    \ {\n        if i % 2 == 0 {\n            if min_value == i {\n              \
    \  min_idx2 = min_idx;\n            }\n            min_idx = i;\n            min_value\
    \ = i;\n        } else {\n            if min_value == i {\n                min_idx2\
    \ = min_idx;\n            }\n        }\n    }\n    if min_idx2 == -1 {\n     \
    \   return vec![];\n    }\n    let mut min_idx3 = -1;\n    for i in arr.iter().rev()\
    \ {\n        if i % 2 == 0 {\n            if min_value == i {\n              \
    \  min_idx3 = min_idx2;\n            }\n            min_idx2 = min_idx;\n    \
    \        min_idx = i;\n            min_value = i;\n        } else {\n        \
    \    if min_value == i {\n                min_idx3 = min_idx2;\n            }\n\
    \        }\n    }\n    if min_idx3 == -1 {\n        return vec![];\n    }\n  \
    \  let mut min_idx4 = -1;\n    for i in arr.iter().rev() {\n        if i % 2 ==\
    \ 0 {\n            if min_value == i {\n                min_idx4 = min_idx3;\n\
    \            }\n            min_idx3 = min_idx;\n            min_idx = i;\n  \
    \          min_value = i;\n        } else {\n            if min_value == i {\n\
    \                min_idx4 = min_idx3;\n            }\n        }\n    }\n    if\
    \ min_idx4 == -1 {\n        return vec![];\n    }\n    let mut min_idx5 = -1;\n\
    \    for i in arr.iter().rev() {\n        if i % 2 == 0 {\n            if min_value\
    \ == i {\n                min_idx5 = min_idx4;\n            }\n            min_idx4\
    \ = min_idx;\n            min_idx = i;\n            min_value = i;\n        }\
    \ else {\n            if min_value == i {\n                min_idx5 = min_idx4;\n\
    \            }\n        }\n    }\n    if min_idx5 == -1 {\n        return vec![];\n\
    \    }\n    let mut min_idx6 = -1;\n    for i in arr.iter().rev() {\n        if\
    \ i % 2 == 0 {\n            if min_value == i {\n                min_idx6 = min_idx5;\n\
    \            }\n            min_idx5 = min_idx;\n            min_idx = i;\n  \
    \          min_value = i;\n        } else {\n            if min_value == i {\n\
    \                min_idx6 = min_idx5;\n            }\n        }\n    }\n    if\
    \ min_idx6 == -1 {\n        return vec![];\n    }\n    let mut min_idx7 = -1;\n\
    \    for i in arr.iter().rev() {\n        if i % 2 == 0 {\n            if min_value\
    \ == i {\n                min_idx7 = min_idx6;\n            }\n            min_idx6\
    \ = min_idx;\n            min_idx = i;\n            min_value = i;\n        }\
    \ else {\n            if min_value == i {\n                min_idx7 = min_idx6;\n\
    \            }\n        }\n\n}\n\nfn main() {\n    let candidate = pluck;\n  \
    \  assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpp1qd3bxd.rs:145:3\n\
    \    |\n26  | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    |               \
    \                          - unclosed delimiter\n...\n119 |     for i in arr.iter().rev()\
    \ {\n    |                               - this delimiter might not be properly\
    \ closed...\n...\n133 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n145 | }\n    |   ^\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpp1qd3bxd.rs:32:29\n   |\n32 |             if min_value == i {\n   |\
    \                             ^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n32 |             if min_value == *i\
    \ {\n   |                             +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpp1qd3bxd.rs:35:23\n   |\n35 |             min_idx = i;\n   |       \
    \                ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n35 |             min_idx = *i;\n   |                     \
    \  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp1qd3bxd.rs:36:25\n   |\n\
    36 |             min_value = i;\n   |                         ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n36 |  \
    \           min_value = *i;\n   |                         +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpp1qd3bxd.rs:38:29\n   |\n38 |             if min_value\
    \ == i {\n   |                             ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n38 |             if min_value\
    \ == *i {\n   |                             +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpp1qd3bxd.rs:49:29\n   |\n49 |             if min_value == i {\n\
    \   |                             ^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n49 |             if min_value == *i\
    \ {\n   |                             +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpp1qd3bxd.rs:53:23\n   |\n53 |             min_idx = i;\n   |       \
    \                ^ expected integer, found `&isize`\n   |\nhelp: consider "
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value: isize =\
    \ 0;\n    let mut smallest_index: usize = 0;\n    let mut mut_smallest_value:\
    \ isize = 0;\n    let mut mut_smallest_index: usize = 0;\n    let mut mut_mut_smallest_value:\
    \ isize = 0;\n    let mut mut_mut_smallest_index: usize = 0;\n    let mut mut_mut_mut_smallest_value:\
    \ isize = 0;\n    let mut mut_mut_mut_smallest_index: usize = 0;\n    let mut\
    \ mut_mut_mut_mut_smallest_value: isize = 0;\n    let mut mut_mut_mut_mut_smallest_index:\
    \ usize = 0;\n    let mut mut_mut_mut_mut_mut_smallest_value: isize = 0;\n   \
    \ let mut mut_mut_mut_mut_mut_smallest_index: usize = 0;\n    let mut mut_mut_mut_mut_mut_mut_smallest_value:\
    \ isize = 0;\n    let mut mut_mut_mut_mut_mut_mut_smallest_index: usize = 0;\n\
    \    let mut mut_mut_mut_mut_mut_mut_mut_smallest_value: isize = 0;\n    let mut\
    \ mut_mut_mut_mut_mut_mut_mut_mut_smallest_index: usize = 0;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_value:\
    \ isize = 0;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_index:\
    \ usize = 0;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_value:\
    \ isize = 0;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_index:\
    \ usize = 0;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_value:\
    \ isize = 0;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_index:\
    \ usize = 0;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mu\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp15mqgvah.rs:49:71\n   |\n\
    49 |     let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mu\n\
    \   |                                                                       ^\
    \ help: add `;` here\n50 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp15mqgvah.rs:26:30\n   |\n26 | fn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |    -----                     ^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_even_value = arr[0];\n\
    \    let mut smallest_even_index = -1;\n    let mut smallest_index = -1;\n   \
    \ for i in arr.iter().rev() {\n        if i % 2 == 0 {\n            if smallest_even_index\
    \ == -1 || smallest_even_index > i {\n                smallest_even_index = i;\n\
    \                smallest_even_value = arr[i];\n            }\n        } else\
    \ {\n            if smallest_index == -1 || smallest_index > i {\n           \
    \     smallest_index = i;\n            }\n        }\n    }\n    smallest_even_index\n\
    \        .iter()\n        .cloned()\n        .filter(|&x| x % 2 == 0)\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n      \
    \  .cloned()\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5d0dlk5h.rs:33:39\n   |\n\
    33 |                 smallest_even_index = i;\n   |                          \
    \             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n33 |                 smallest_even_index = *i;\n   |     \
    \                                  +\n\nerror[E0277]: can't compare `isize` with\
    \ `&isize`\n  --> /tmp/tmp5d0dlk5h.rs:32:65\n   |\n32 |             if smallest_even_index\
    \ == -1 || smallest_even_index > i {\n   |                                   \
    \                              ^ no implementation for `isize < &isize` and `isize\
    \ > &isize`\n   |\n   = help: the trait `PartialOrd<&isize>` is not implemented\
    \ for `isize`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n\
    \  --> /tmp/tmp5d0dlk5h.rs:34:39\n   |\n34 |                 smallest_even_value\
    \ = arr[i];\n   |                                       ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `&isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5d0dlk5h.rs:38:34\n   |\n38 |                 smallest_index\
    \ = i;\n   |                                  ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n38 |                 smallest_index\
    \ = *i;\n   |                                  +\n\nerror[E0599]: no method named\
    \ `iter` found for type `isize` in the current scope\n  --> /tmp/tmp5d0dlk5h.rs:43:10\n\
    \   |\n43 |         .iter()\n   |          ^^^^ method not found in `isize`\n\n\
    error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp5d0dlk5h.rs:37:55\n\
    \   |\n37 |             if smallest_index == -1 || smallest_index > i {\n   |\
    \                                                       ^ no implementation for\
    \ `isize < &isize` and `isize > &isize`\n   |\n   = help: the trait `PartialOrd<&isize>`\
    \ is not implemented for `isize`\n\nerror: aborting due to 6 previous errors\n\
    \nSome errors "
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 0;\n    let mut min_idx2 = 0;\n    for &i in arr {\n   \
    \     if i % 2 == 0 {\n            if min_value == i {\n                min_idx2\
    \ = min_idx;\n            } else {\n                min_value = i;\n         \
    \       min_idx = i;\n                min_idx2 = i;\n            }\n        }\n\
    \    }\n    if min_idx2 == min_idx {\n        min_idx2 = min_idx;\n    }\n   \
    \ vec![min_value, min_idx2]\n}\n\nfn main() {\n    let candidate = pluck;\n  \
    \  assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp445h1aa_.rs:30:9\n   |\n\
    30 |     for &i in arr {\n   |         ^^    --- this expression has type `isize`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut even_values = vec![];\n\
    \    let mut smallest_value = vec![];\n    let mut smallest_index = vec![];\n\
    \    for i in arr.iter() {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \            if i < smallest_value.len() {\n                smallest_value[i]\
    \ = i;\n                smallest_index[i] = i;\n            } else {\n       \
    \         smallest_value[i] = i;\n                smallest_index[i] = i;\n   \
    \         }\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ vec![];\n    }\n    for i in even_values.iter() {\n        if smallest_value[i]\
    \ < i {\n            smallest_value[i] = i;\n            smallest_index[i] = i;\n\
    \        }\n    }\n    for i in even_values.iter() {\n        if smallest_value[i]\
    \ == i {\n            smallest_index[i] = i;\n        }\n    }\n    for i in even_values.iter()\
    \ {\n        if smallest_value[i] < i {\n            smallest_value[i] = i;\n\
    \            smallest_index[i] = i;\n        }\n    }\n    for i in even_values.iter()\
    \ {\n        if smallest_value[i] == i {\n            smallest_index[i] = i;\n\
    \        }\n    }\n    for i in even_values.iter() {\n        if smallest_value[i]\
    \ < i {\n            smallest_value[i] = i;\n            smallest_index[i] = i;\n\
    \        }\n    }\n    for i in even_values.iter() {\n        if smallest_value[i]\
    \ == i {\n            smallest_index[i] = i;\n        }\n    }\n    for i in even_values.iter()\
    \ {\n        if smallest_value[i] < i {\n            smallest_value[i] = i;\n\
    \            smallest_index[i] = i;\n        }\n    }\n    for i in even_values.iter()\
    \ {\n        if smallest_value[i] == i {\n            smallest_index[i] = i;\n\
    \        }\n    }\n    for i in even_values.iter() {\n        if smallest_value[i]\
    \ < i {\n            smallest_value[i] = i;\n            smallest_index[i] = i;\n\
    \        }\n    }\n    for i in even_values.iter() {\n        if smallest_value[i]\
    \ == i {\n            smallest_index[i] = i;\n        }\n    }\n    for i in even_values.iter()\
    \ {\n        if smallest_value[i] < i {\n            smallest_value[i] = i;\n\
    \            smallest_index[i] = i;\n        }\n    }\n    for i in even_values.iter()\
    \ {\n        if smallest_value[i] == i {\n            smallest_index[i] = i;\n\
    \        }\n    }\n    for i in even_values.iter() {\n        if smallest_value[i]\
    \ < i {\n            smallest_value[i] = i;\n            smallest_index[i] = i;\n\
    \        }\n    }\n    for i in even_values.iter() {\n        if smallest_value[i]\
    \ == i \n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpmp74wuts.rs:131:3\n\
    \    |\n26  | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    |               \
    \                          - unclosed delimiter\n...\n117 |     for i in even_values.iter()\
    \ {\n    |                                 - this delimiter might not be properly\
    \ closed...\n118 |         if smallest_value[i] == i \n119 | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n131 | }\n    |   ^\n\n\
    error: expected `{`, found `}`\n   --> /tmp/tmpmp74wuts.rs:119:1\n    |\n118 |\
    \         if smallest_value[i] == i \n    |         -- this `if` expression has\
    \ a condition, but no block\n119 | }\n    | ^ expected `{`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpmp74wuts.rs:33:20\n   |\n33 |             if i < smallest_value.len()\
    \ {\n   |                    ^^^^^^^^^^^^^^^^^^^^ expected `&isize`, found `usize`\n\
    \nerror[E0277]: the type `[_]` cannot be indexed by `&isize`\n  --> /tmp/tmpmp74wuts.rs:34:17\n\
    \   |\n34 |                 smallest_value[i] = i;\n   |                 ^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[_]>` is not implemented for `&isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<&isize>` for `Vec<_>`\n\n\
    error[E0277]: the type `[_]` cannot be indexed by `&isize`\n  --> /tmp/tmpmp74wuts.rs:35:17\n\
    \   |\n35 |                 smallest_index[i] = i;\n   |                 ^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[_]>` is not implemented for `&isize`\n   = note: required\
    \ because of the requirements on the impl of `Index<&isize>` for `Vec<_>`\n\n\
    error[E0277]: the type `[_]` cannot be indexed by `&isize`\n  --> /tmp/tmpmp74wuts.rs:37:17\n\
    \   |\n37 |                 smallest_value[i] = i;\n   |                 ^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[_]>` is not implemented for `&isize`\n   = note: required\
    \ because of the requirements on the impl o"
  stdout: ''
  timestamp: 1659748596
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_even_value = arr[0];\n\
    \    let mut smallest_even_index = -1;\n    let mut smallest_index = -1;\n   \
    \ for i in arr.iter().rev() {\n        if i % 2 == 0 {\n            if smallest_even_index\
    \ == -1 || smallest_even_index > i {\n                smallest_even_index = i;\n\
    \                smallest_even_value = arr[i];\n            }\n        } else\
    \ {\n            if smallest_index == -1 || smallest_index > i {\n           \
    \     smallest_index = i;\n            }\n        }\n    }\n    if smallest_even_index\
    \ == -1 {\n        return vec![];\n    }\n    vec![smallest_even_index, smallest_even_value]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmue8f2u9.rs:33:39\n   |\n\
    33 |                 smallest_even_index = i;\n   |                          \
    \             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n33 |                 smallest_even_index = *i;\n   |     \
    \                                  +\n\nerror[E0277]: can't compare `isize` with\
    \ `&isize`\n  --> /tmp/tmpmue8f2u9.rs:32:65\n   |\n32 |             if smallest_even_index\
    \ == -1 || smallest_even_index > i {\n   |                                   \
    \                              ^ no implementation for `isize < &isize` and `isize\
    \ > &isize`\n   |\n   = help: the trait `PartialOrd<&isize>` is not implemented\
    \ for `isize`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n\
    \  --> /tmp/tmpmue8f2u9.rs:34:39\n   |\n34 |                 smallest_even_value\
    \ = arr[i];\n   |                                       ^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `&isize`\n   = note: required because of the requirements\
    \ on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpmue8f2u9.rs:38:34\n   |\n38 |                 smallest_index\
    \ = i;\n   |                                  ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n38 |                 smallest_index\
    \ = *i;\n   |                                  +\n\nerror[E0277]: can't compare\
    \ `isize` with `&isize`\n  --> /tmp/tmpmue8f2u9.rs:37:55\n   |\n37 |         \
    \    if smallest_index == -1 || smallest_index > i {\n   |                   \
    \                                    ^ no implementation for `isize < &isize`\
    \ and `isize > &isize`\n   |\n   = help: the trait `PartialOrd<&isize>` is not\
    \ implemented for `isize`\n\nerror: aborting due to 5 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748596
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut min_idx = -1;\n    for i in arr.iter() {\n        if *i % 2 == 0\
    \ {\n            if *i < min_val {\n                min_val = *i;\n          \
    \      min_idx = i;\n            }\n        }\n    }\n    vec![min_val, min_idx]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwhltsee5.rs:31:21\n   |\n\
    31 |             if *i < min_val {\n   |                     ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n31 |             if *i < min_val.try_into().unwrap()\
    \ {\n   |                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwhltsee5.rs:32:27\n   |\n32 |                 min_val =\
    \ *i;\n   |                           ^^ expected `i32`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwhltsee5.rs:33:27\n   |\n33 |              \
    \   min_idx = i;\n   |                           ^ expected integer, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n33 |                 min_idx\
    \ = *i;\n   |                           +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwhltsee5.rs:37:10\n   |\n37 |     vec![min_val, min_idx]\n   |\
    \          ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    37 |     vec![min_val.try_into().unwrap(), min_idx]\n   |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748595
- exit_code: 101
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_val = arr[0];\n   \
    \ let mut min_idx = -1;\n    let mut min_even_val = false;\n    for i in arr.iter().cloned()\
    \ {\n        if i % 2 == 0 {\n            if min_even_val {\n                min_even_val\
    \ = false;\n                min_idx = i;\n            } else {\n             \
    \   min_even_val = true;\n                min_val = i;\n            }\n      \
    \  } else {\n            min_even_val = false;\n            min_idx = -1;\n  \
    \          min_val = i;\n        }\n    }\n    if min_even_val {\n        min_even_val\
    \ = false;\n        min_idx = min_val;\n    } else {\n        min_even_val = true;\n\
    \        min_idx = -1;\n        min_val = min_val;\n    }\n    vec![min_val, min_idx]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, -1]`,\n right: `[2, 1]`', /tmp/tmpeptxzpad.rs:58:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659748596
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 0;\n    let mut min_idx2 = 0;\n    let mut min_idx3 = 0;\n\
    \    let mut min_idx4 = 0;\n    let mut min_idx5 = 0;\n    let mut min_idx6 =\
    \ 0;\n    let mut min_idx7 = 0;\n    let mut min_idx8 = 0;\n    let mut min_idx9\
    \ = 0;\n    let mut min_idx10 = 0;\n    let mut min_idx11 = 0;\n    let mut min_idx12\
    \ = 0;\n    let mut min_idx13 = 0;\n    let mut min_idx14 = 0;\n    let mut min_idx15\
    \ = 0;\n    let mut min_idx16 = 0;\n    let mut min_idx17 = 0;\n    let mut min_idx18\
    \ = 0;\n    let mut min_idx19 = 0;\n    let mut min_idx20 = 0;\n    let mut min_idx21\
    \ = 0;\n    let mut min_idx22 = 0;\n    let mut min_idx23 = 0;\n    let mut min_idx24\
    \ = 0;\n    let mut min_idx25 = 0;\n    let mut min_idx26 = 0;\n    let mut min_idx27\
    \ = 0;\n    let mut min_idx28 = 0;\n    let mut min_idx29 = 0;\n    let mut min_idx30\
    \ = 0;\n    let mut min_idx31 = 0;\n    let mut min_idx32 = 0;\n    let mut min_idx33\
    \ = 0;\n    let mut min_idx34 = 0;\n    let mut min_idx35 = 0;\n    let mut min_idx36\
    \ = 0;\n    let mut min_idx37 = 0;\n    let mut min_idx38 = 0;\n    let mut min_idx39\
    \ = 0;\n    let mut min_idx40 = 0;\n    let mut min_idx41 = 0;\n    let mut min_idx42\
    \ = 0;\n    let mut min_idx43 = 0;\n    let mut min_idx44 = 0;\n    let mut min_idx45\
    \ = 0;\n    let mut min_idx46 = 0;\n    let mut min_idx47 = 0;\n    let mut min_idx48\
    \ = 0;\n    let mut min_idx49 = 0;\n    let mut min_idx50 = 0;\n    let mut min_idx51\
    \ = 0;\n    let mut min_idx52 = 0;\n    let mut min_idx53 = 0;\n    let mut min_idx54\
    \ = 0;\n    let mut min_idx55 = 0;\n    let mut min_idx56 = 0;\n    let mut min_idx57\
    \ = 0;\n    let mut min_idx58 = 0;\n    let mut min_idx59 = 0;\n    let mut min_idx60\
    \ = 0;\n    let mut min_idx61 = 0;\n    let mut min_idx62 = 0;\n    let mut min_idx63\
    \ = 0;\n    let mut min_idx\n}\n\nfn main() {\n    let candidate = pluck;\n  \
    \  assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_84wucx7.rs:91:20\n   |\n\
    91 |     let mut min_idx\n   |                    ^ help: add `;` here\n92 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_84wucx7.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smalest_value = arr[0];\n\
    \    let mut smalest_index = 0;\n    let mut even_values = Vec::new();\n    for\
    \ i in arr.iter().rev() {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \            if i < smalest_value {\n                smalest_value = i;\n    \
    \            smalest_index = i;\n            }\n        }\n    }\n    if even_values.len()\
    \ == 0 {\n        return vec![];\n    }\n    let mut smallest_even_value = even_values[0];\n\
    \    let mut smallest_even_index = even_values[0];\n    for i in even_values.iter().rev()\
    \ {\n        if i < smallest_even_value {\n            smallest_even_value = i;\n\
    \            smallest_even_index = i;\n        }\n    }\n    let mut result =\
    \ vec![];\n    for i in even_values.iter().rev() {\n        if i == smallest_even_value\
    \ {\n            result.push(i);\n        }\n    }\n    if result.len() == 0 {\n\
    \        return vec![];\n    }\n    result.push(smallest_even_index);\n    result\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp88qc58x9.rs:33:20\n   |\n\
    33 |             if i < smalest_value {\n   |                    ^^^^^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&isize`, found `isize`\n\
    \   |                    help: consider borrowing here: `&smalest_value`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp88qc58x9.rs:34:33\n   |\n34 |              \
    \   smalest_value = i;\n   |                                 ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n34 |  \
    \               smalest_value = *i;\n   |                                 +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp88qc58x9.rs:35:33\n   |\n35 |  \
    \               smalest_index = i;\n   |                                 ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    35 |                 smalest_index = *i;\n   |                               \
    \  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp88qc58x9.rs:45:16\n   |\n\
    45 |         if i < smallest_even_value {\n   |                ^^^^^^^^^^^^^^^^^^^\
    \ expected `&isize`, found `isize`\n   |\n   = note: expected reference `&&isize`\n\
    \              found reference `&isize`\n\nerror[E0277]: can't compare `&isize`\
    \ with `isize`\n  --> /tmp/tmp88qc58x9.rs:52:14\n   |\n52 |         if i == smallest_even_value\
    \ {\n   |              ^^ no implementation for `&isize == isize`\n   |\n   =\
    \ help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   = note:\
    \ required because of the requirements on the impl of `PartialEq<&isize>` for\
    \ `&&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp88qc58x9.rs:59:17\n\
    \   |\n59 |     result.push(smallest_even_index);\n   |                 ^^^^^^^^^^^^^^^^^^^\
    \ expected `&isize`, found `isize`\n   |\n   = note: expected reference `&&isize`\n\
    \              found reference `&isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp88qc58x9.rs:60:5\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |                              ---------- expected `Vec<isize>` because\
    \ of return type\n...\n60 |     res"
  stdout: ''
  timestamp: 1659748596
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value: isize =\
    \ 0;\n    let mut smallest_index: usize = 0;\n    let mut even_value_count: usize\
    \ = 0;\n    let mut even_values: Vec<isize> = Vec::new();\n    for &node in &arr\
    \ {\n        if node.value % 2 == 0 {\n            even_values.push(node.value);\n\
    \            even_value_count = even_values.len();\n        }\n        if node.value\
    \ < smallest_value {\n            smallest_value = node.value;\n            smallest_index\
    \ = even_values.iter().position(|&x| x == node.value).unwrap();\n        }\n \
    \   }\n    if even_values.len() == 0 {\n        return vec![];\n    }\n    if\
    \ even_values.len() == 1 {\n        return vec![even_values[0]];\n    }\n    if\
    \ even_values.len() > 1 {\n        let mut smallest_even_value = even_values[0];\n\
    \        let mut smallest_even_index = even_values.iter().position(|&x| x == smallest_even_value).unwrap();\n\
    \        for &node in &arr {\n            if node.value % 2 == 0 {\n         \
    \       if node.value < smallest_even_value {\n                    smallest_even_value\
    \ = node.value;\n                    smallest_even_index = even_values.iter().position(|&x|\
    \ x == node.value).unwrap();\n                }\n            }\n        }\n  \
    \      return vec![smallest_even_value];\n    }\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0610]: `isize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmpinja88dq.rs:32:17\n   |\n32 |         if node.value % 2 == 0 {\n\
    \   |                 ^^^^^\n\nerror[E0610]: `isize` is a primitive type and therefore\
    \ doesn't have fields\n  --> /tmp/tmpinja88dq.rs:33:35\n   |\n33 |           \
    \  even_values.push(node.value);\n   |                                   ^^^^^\n\
    \nerror[E0610]: `isize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmpinja88dq.rs:36:17\n   |\n36 |         if node.value < smallest_value\
    \ {\n   |                 ^^^^^\n\nerror[E0610]: `isize` is a primitive type and\
    \ therefore doesn't have fields\n  --> /tmp/tmpinja88dq.rs:37:35\n   |\n37 | \
    \            smallest_value = node.value;\n   |                              \
    \     ^^^^^\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't\
    \ have fields\n  --> /tmp/tmpinja88dq.rs:38:73\n   |\n38 |             smallest_index\
    \ = even_values.iter().position(|&x| x == node.value).unwrap();\n   |        \
    \                                                                 ^^^^^\n\nerror[E0610]:\
    \ `isize` is a primitive type and therefore doesn't have fields\n  --> /tmp/tmpinja88dq.rs:51:21\n\
    \   |\n51 |             if node.value % 2 == 0 {\n   |                     ^^^^^\n\
    \nerror[E0610]: `isize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmpinja88dq.rs:52:25\n   |\n52 |                 if node.value < smallest_even_value\
    \ {\n   |                         ^^^^^\n\nerror[E0610]: `isize` is a primitive\
    \ type and therefore doesn't have fields\n  --> /tmp/tmpinja88dq.rs:53:48\n  \
    \ |\n53 |                     smallest_even_value = node.value;\n   |        \
    \                                        ^^^^^\n\nerror[E0610]: `isize` is a primitive\
    \ type and therefore doesn't have fields\n  --> /tmp/tmpinja88dq.rs:54:86\n  \
    \ |\n54 |                     smallest_even_index = even_values.iter().position(|&x|\
    \ x == node.value).unwrap();\n   |                                           \
    \                                           ^^^^^\n\nerror: aborting due to 9\
    \ previous err"
  stdout: ''
  timestamp: 1659748596
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_val = i32::MAX;\n \
    \   let mut min_idx = -1;\n    for i in arr.iter() {\n        if i % 2 == 0 {\n\
    \            if min_val < i {\n                min_val = i;\n                min_idx\
    \ = i;\n            }\n        }\n    }\n    if min_val == i32::MAX {\n      \
    \  return vec![];\n    }\n    let mut result = vec![];\n    for i in arr.iter()\
    \ {\n        if i == min_val {\n            result.push(min_idx);\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_raa2qqn.rs:31:26\n   |\n\
    31 |             if min_val < i {\n   |                          ^ expected `i32`,\
    \ found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_raa2qqn.rs:32:27\n\
    \   |\n32 |                 min_val = i;\n   |                           ^ expected\
    \ `i32`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_raa2qqn.rs:33:27\n\
    \   |\n33 |                 min_idx = i;\n   |                           ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    33 |                 min_idx = *i;\n   |                           +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_raa2qqn.rs:42:17\n   |\n42 |         if i ==\
    \ min_val {\n   |                 ^^^^^^^ expected `isize`, found `i32`\n\nerror[E0277]:\
    \ can't compare `&isize` with `i32`\n  --> /tmp/tmp_raa2qqn.rs:42:14\n   |\n42\
    \ |         if i == min_val {\n   |              ^^ no implementation for `&isize\
    \ == i32`\n   |\n   = help: the trait `PartialEq<i32>` is not implemented for\
    \ `&isize`\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659748596
