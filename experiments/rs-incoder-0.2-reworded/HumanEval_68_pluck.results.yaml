name: HumanEval_68_pluck
language: rs
results:
- program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 0;\n    let mut min_idx2 = 0;\n    let mut min_idx3 = 0;\n\
    \    let mut min_idx4 = 0;\n    let mut min_idx5 = 0;\n    let mut min_idx6 =\
    \ 0;\n    let mut min_idx7 = 0;\n    let mut min_idx8 = 0;\n    let mut min_idx9\
    \ = 0;\n    let mut min_idx10 = 0;\n    let mut min_idx11 = 0;\n    let mut min_idx12\
    \ = 0;\n    let mut min_idx13 = 0;\n    let mut min_idx14 = 0;\n    let mut min_idx15\
    \ = 0;\n    let mut min_idx16 = 0;\n    let mut min_idx17 = 0;\n    let mut min_idx18\
    \ = 0;\n    let mut min_idx19 = 0;\n    let mut min_idx20 = 0;\n    let mut min_idx21\
    \ = 0;\n    let mut min_idx22 = 0;\n    let mut min_idx23 = 0;\n    let mut min_idx24\
    \ = 0;\n    let mut min_idx25 = 0;\n    let mut min_idx26 = 0;\n    let mut min_idx27\
    \ = 0;\n    let mut min_idx28 = 0;\n    let mut min_idx29 = 0;\n    let mut min_idx30\
    \ = 0;\n    let mut min_idx31 = 0;\n    let mut min_idx32 = 0;\n    let mut min_idx33\
    \ = 0;\n    let mut min_idx34 = 0;\n    let mut min_idx35 = 0;\n    let mut min_idx36\
    \ = 0;\n    let mut min_idx37 = 0;\n    let mut min_idx38 = 0;\n    let mut min_idx39\
    \ = 0;\n    let mut min_idx40 = 0;\n    let mut min_idx41 = 0;\n    let mut min_idx42\
    \ = 0;\n    let mut min_idx43 = 0;\n    let mut min_idx44 = 0;\n    let mut min_idx45\
    \ = 0;\n    let mut min_idx46 = 0;\n    let mut min_idx47 = 0;\n    let mut min_idx48\
    \ = 0;\n    let mut min_idx49 = 0;\n    let mut min_idx50 = 0;\n    let mut min_idx51\
    \ = 0;\n    let mut min_idx52 = 0;\n    let mut min_idx53 = 0;\n    let mut min_idx54\
    \ = 0;\n    let mut min_idx55 = 0;\n    let mut min_idx56 = 0;\n    let mut min_idx57\
    \ = 0;\n    let mut min_idx58 = 0;\n    let mut min_idx59 = 0;\n    let mut min_idx60\
    \ = 0;\n    let mut min_idx61 = 0;\n    let mut min_idx62 = 0;\n    let mut min_idx63\
    \ = 0;\n    let mut min_idx\n}\n\nfn main() {\n    let candidate = pluck;\n  \
    \  assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_84wucx7.rs:91:20\n   |\n\
    91 |     let mut min_idx\n   |                    ^ help: add `;` here\n92 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_84wucx7.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 0;\n    for i in arr.iter().rev() {\n        if i % 2 ==\
    \ 0 {\n            if min_value == i {\n                min_idx = i;\n       \
    \     }\n            min_value = i;\n        }\n    }\n    vec![min_value, min_idx]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd4dolmfn.rs:31:29\n   |\n\
    31 |             if min_value == i {\n   |                             ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    31 |             if min_value == *i {\n   |                             +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpd4dolmfn.rs:32:27\n   |\n28 |  \
    \   let mut min_idx = 0;\n   |                       - expected due to this value\n\
    ...\n32 |                 min_idx = i;\n   |                           ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    32 |                 min_idx = *i;\n   |                           +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpd4dolmfn.rs:34:25\n   |\n27 |     let mut min_value\
    \ = arr[0];\n   |                         ------ expected due to this value\n\
    ...\n34 |             min_value = i;\n   |                         ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    34 |             min_value = *i;\n   |                         +\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value: isize =\
    \ 0;\n    let mut smallest_index: usize = 0;\n    let mut mut_smallest_value:\
    \ isize = 0;\n    let mut mut_smallest_index: usize = 0;\n    let mut mut_mut_smallest_value:\
    \ isize = 0;\n    let mut mut_mut_smallest_index: usize = 0;\n    let mut mut_mut_mut_smallest_value:\
    \ isize = 0;\n    let mut mut_mut_mut_smallest_index: usize = 0;\n    let mut\
    \ mut_mut_mut_mut_smallest_value: isize = 0;\n    let mut mut_mut_mut_mut_smallest_index:\
    \ usize = 0;\n    let mut mut_mut_mut_mut_mut_smallest_value: isize = 0;\n   \
    \ let mut mut_mut_mut_mut_mut_smallest_index: usize = 0;\n    let mut mut_mut_mut_mut_mut_mut_smallest_value:\
    \ isize = 0;\n    let mut mut_mut_mut_mut_mut_mut_smallest_index: usize = 0;\n\
    \    let mut mut_mut_mut_mut_mut_mut_mut_smallest_value: isize = 0;\n    let mut\
    \ mut_mut_mut_mut_mut_mut_mut_mut_smallest_index: usize = 0;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_value:\
    \ isize = 0;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_index:\
    \ usize = 0;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_value:\
    \ isize = 0;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_index:\
    \ usize = 0;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_value:\
    \ isize = 0;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_smallest_index:\
    \ usize = 0;\n    let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mu\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp15mqgvah.rs:49:71\n   |\n\
    49 |     let mut mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mut_mu\n\
    \   |                                                                       ^\
    \ help: add `;` here\n50 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp15mqgvah.rs:26:30\n   |\n26 | fn pluck(arr: Vec<isize>)\
    \ -> Vec<isize> {\n   |    -----                     ^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 0;\n    for i in arr.iter().rev() {\n        if i % 2 ==\
    \ 0 {\n            if min_value >= i {\n                min_value = i;\n     \
    \           min_idx = i;\n            }\n        }\n    }\n    vec![min_value,\
    \ min_idx]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3s4aecb_.rs:31:29\n   |\n\
    31 |             if min_value >= i {\n   |                             ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    31 |             if min_value >= *i {\n   |                             +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp3s4aecb_.rs:32:29\n   |\n27 |  \
    \   let mut min_value = arr[0];\n   |                         ------ expected\
    \ due to this value\n...\n32 |                 min_value = i;\n   |          \
    \                   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n32 |                 min_value = *i;\n   |               \
    \              +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3s4aecb_.rs:33:27\n\
    \   |\n28 |     let mut min_idx = 0;\n   |                       - expected due\
    \ to this value\n...\n33 |                 min_idx = i;\n   |                \
    \           ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n33 |                 min_idx = *i;\n   |                 \
    \          +\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = i32::MAX;\n\
    \    let mut min_idx = -1;\n    for i in arr.iter() {\n        if i % 2 == 0 {\n\
    \            if min_value < i {\n                min_value = i;\n            \
    \    min_idx = i;\n            }\n        }\n    }\n    if min_idx == -1 {\n \
    \       return vec![];\n    }\n    vec![min_value, min_idx]\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvczbidx1.rs:31:28\n   |\n\
    31 |             if min_value < i {\n   |                            ^ expected\
    \ `i32`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvczbidx1.rs:32:29\n\
    \   |\n27 |     let mut min_value = i32::MAX;\n   |                         --------\
    \ expected due to this value\n...\n32 |                 min_value = i;\n   | \
    \                            ^ expected `i32`, found `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvczbidx1.rs:33:27\n   |\n28 |     let mut min_idx\
    \ = -1;\n   |                       -- expected due to this value\n...\n33 | \
    \                min_idx = i;\n   |                           ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n33 |  \
    \               min_idx = *i;\n   |                           +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvczbidx1.rs:40:10\n   |\n40 |     vec![min_value,\
    \ min_idx]\n   |          ^^^^^^^^^ expected `isize`, found `i32`\n   |\nhelp:\
    \ you can convert an `i32` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n40 |     vec![min_value.try_into().unwrap(), min_idx]\n   |     \
    \              ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    for i in arr.iter().rev() {\n        if\
    \ i % 2 == 0 {\n            if smallest_value < i {\n                smallest_value\
    \ = i;\n                smallest_index = i;\n            }\n        }\n    }\n\
    \    vec![smallest_value, smallest_index]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpytbrv3ym.rs:31:33\n   |\n\
    31 |             if smallest_value < i {\n   |                               \
    \  ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n31 |             if smallest_value < *i {\n   |              \
    \                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpytbrv3ym.rs:32:34\n\
    \   |\n27 |     let mut smallest_value = arr[0];\n   |                       \
    \       ------ expected due to this value\n...\n32 |                 smallest_value\
    \ = i;\n   |                                  ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n32 |                 smallest_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpytbrv3ym.rs:33:34\n   |\n28 |     let mut smallest_index = 0;\n\
    \   |                              - expected due to this value\n...\n33 |   \
    \              smallest_index = i;\n   |                                  ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    33 |                 smallest_index = *i;\n   |                              \
    \    +\n\nerror: aborting due to 3 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = i32::MAX;\n\
    \    let mut min_idx = -1;\n    let mut min_idx2 = -1;\n    for i in arr.iter()\
    \ {\n        if i % 2 == 0 {\n            if min_value < i {\n               \
    \ min_value = i;\n                min_idx = i;\n            }\n        } else\
    \ {\n            if min_idx2 < i {\n                min_idx2 = i;\n          \
    \  }\n        }\n    }\n    if min_idx2 == min_idx {\n        return vec![];\n\
    \    }\n    return vec![min_value, min_idx];\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxf2_xml7.rs:32:28\n   |\n\
    32 |             if min_value < i {\n   |                            ^ expected\
    \ `i32`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxf2_xml7.rs:33:29\n\
    \   |\n27 |     let mut min_value = i32::MAX;\n   |                         --------\
    \ expected due to this value\n...\n33 |                 min_value = i;\n   | \
    \                            ^ expected `i32`, found `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxf2_xml7.rs:34:27\n   |\n28 |     let mut min_idx\
    \ = -1;\n   |                       -- expected due to this value\n...\n34 | \
    \                min_idx = i;\n   |                           ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n34 |  \
    \               min_idx = *i;\n   |                           +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxf2_xml7.rs:38:28\n   |\n29 |     let mut min_idx2\
    \ = -1;\n   |                        -- expected due to this value\n...\n38 |\
    \                 min_idx2 = i;\n   |                            ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n38 |  \
    \               min_idx2 = *i;\n   |                            +\n\nerror[E0277]:\
    \ can't compare `isize` with `&isize`\n  --> /tmp/tmpxf2_xml7.rs:37:25\n   |\n\
    37 |             if min_idx2 < i {\n   |                         ^ no implementation\
    \ for `isize < &isize` and `isize > &isize`\n   |\n   = help: the trait `PartialOrd<&isize>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpxf2_xml7.rs:45:17\n   |\n45 |     return vec![min_value, min_idx];\n\
    \   |                 ^^^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you\
    \ can convert an `i32` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n45 |     return vec![min_value.try_int"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value: isize =\
    \ 0;\n    let mut smallest_index: isize = 0;\n    let mut even_values: Vec<isize>\
    \ = Vec::new();\n    for value in arr {\n        if value % 2 == 0 {\n       \
    \     even_values.push(value);\n        }\n        if value == smallest_value\
    \ {\n            smallest_index = arr.iter().position(|&x| x == value).unwrap();\n\
    \        }\n        if value < smallest_value {\n            smallest_value =\
    \ value;\n        }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n\
    \    }\n    if even_values.len() == 1 {\n        return vec![even_values[0]];\n\
    \    }\n    let mut smallest_even_value = even_values[0];\n    let mut smallest_even_index\
    \ = smallest_index;\n    for value in even_values {\n        if value < smallest_even_value\
    \ {\n            smallest_even_value = value;\n            smallest_even_index\
    \ = arr.iter().position(|&x| x == value).unwrap();\n        }\n    }\n    vec![smallest_even_value,\n\
    \         smallest_even_index]\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw3ndoh9v.rs:35:30\n   |\n\
    28 |     let mut smallest_index: isize = 0;\n   |                            \
    \ ----- expected due to this type\n...\n35 |             smallest_index = arr.iter().position(|&x|\
    \ x == value).unwrap();\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw3ndoh9v.rs:52:35\n\
    \   |\n48 |     let mut smallest_even_index = smallest_index;\n   |          \
    \                         -------------- expected due to this value\n...\n52 |\
    \             smallest_even_index = arr.iter().position(|&x| x == value).unwrap();\n\
    \   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut even_values = vec![];\n\
    \    let mut smallest_value = vec![];\n    let mut smallest_index = vec![];\n\
    \    for i in arr.iter() {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \            if i < smallest_value.len() {\n                smallest_value[i]\
    \ = i;\n                smallest_index[i] = i;\n            }\n        } else\
    \ {\n            if i < smallest_value.len() {\n                smallest_value[i]\
    \ = i;\n                smallest_index[i] = i;\n            }\n        }\n   \
    \ }\n    if even_values.len() == 0 {\n        return vec![];\n    }\n    if even_values.len()\
    \ == 1 {\n        return vec![even_values[0]];\n    }\n    if even_values.len()\
    \ > 1 {\n        let mut smallest_value_iter = even_values.iter().cloned().collect::<Vec<_>>();\n\
    \        let mut smallest_index_iter = smallest_index.iter().cloned().collect::<Vec<_>>();\n\
    \        let mut smallest_value = vec![];\n        let mut smallest_index = vec![];\n\
    \        for i in even_values.iter() {\n            if i < smallest_value.len()\
    \ {\n                smallest_value[i] = i;\n                smallest_index[i]\
    \ = i;\n            }\n        }\n        for i in even_values.iter() {\n    \
    \        if i < smallest_value.len() {\n                smallest_value[i] = i;\n\
    \                smallest_index[i] = i;\n            }\n        }\n        for\
    \ i in even_values.iter() {\n            if i < smallest_value.len() {\n     \
    \           smallest_value[i] = i;\n                smallest_index[i] = i;\n \
    \           }\n        }\n        for i in even_values.iter() {\n            if\
    \ i < smallest_value.len() {\n                smallest_value[i] = i;\n       \
    \         smallest_index[i] = i;\n            }\n        }\n        for i in even_values.iter()\
    \ {\n            if i < smallest_value.len() {\n                smallest_value[i]\
    \ = i;\n                smallest_index[i] = i;\n            }\n        }\n   \
    \     for i in even_values.iter() {\n            if i < smallest_value.len() {\n\
    \                smallest_value[i] = i;\n                smallest_index[i] = i;\n\
    \            }\n        }\n        for i in even_values.iter() {\n           \
    \ if i < smallest_value.len() {\n                smallest_value[i] = i;\n    \
    \            smallest_index[i] = i;\n            }\n        }\n        for i in\
    \ even_values.iter() {\n            if i < smallest_value.len() {\n          \
    \      smallest_value[i] = i;\n                smallest_index[i] = i;\n      \
    \      }\n        }\n        for i in even_values.iter() {\n            if i <\
    \ smallest_value.len() {\n                smallest_value[i] = i;\n           \
    \     smallest_index[i] = i;\n            }\n        }\n        for i in even_values.iter()\
    \ {\n            if \n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp57s0k_bm.rs:123:3\n\
    \    |\n26  | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    |               \
    \                          - unclosed delimiter\n...\n50  |     if even_values.len()\
    \ > 1 {\n    |                              - unclosed delimiter\n...\n109 | \
    \        for i in even_values.iter() {\n    |                                \
    \     - this delimiter might not be properly closed...\n110 |             if \n\
    111 | }\n    | - ...as it matches this but it has different indentation\n...\n\
    123 | }\n    |   ^\n\nerror: expected expression, found `}`\n   --> /tmp/tmp57s0k_bm.rs:111:1\n\
    \    |\n111 | }\n    | ^ expected expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp57s0k_bm.rs:33:20\n   |\n33 |             if i < smallest_value.len()\
    \ {\n   |                    ^^^^^^^^^^^^^^^^^^^^ expected `&isize`, found `usize`\n\
    \nerror[E0277]: the type `[_]` cannot be indexed by `&isize`\n  --> /tmp/tmp57s0k_bm.rs:34:17\n\
    \   |\n34 |                 smallest_value[i] = i;\n   |                 ^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[_]>` is not implemented for `&isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<&isize>` for `Vec<_>`\n\nerror[E0277]:\
    \ the type `[_]` cannot be indexed by `&isize`\n  --> /tmp/tmp57s0k_bm.rs:35:17\n\
    \   |\n35 |                 smallest_index[i] = i;\n   |                 ^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[_]>` is not implemented for `&isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<&isize>` for `Vec<_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp57s0k_bm.rs:38:20\n   |\n38 |             if\
    \ i < smallest_value.len() {\n   |                    ^^^^^^^^^^^^^^^^^^^^ expected\
    \ `&isize`, found `usize`\n\nerror[E0277]: the type `[_]` cannot be indexed by\
    \ `&is"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value: isize =\
    \ 0;\n    let mut smallest_index: usize = 0;\n    let mut smallest_even_value:\
    \ isize = 0;\n    let mut mut_even_value: isize = 0;\n    let mut mut_index: usize\
    \ = 0;\n    let mut mut_index: usize = 0;\n    let mut mut_index: usize = 0;\n\
    \    let mut mut_index: usize = 0;\n    let mut mut_index: usize = 0;\n    let\
    \ mut mut_index: usize = 0;\n    let mut mut_index: usize = 0;\n    let mut mut_index:\
    \ usize = 0;\n    let mut mut_index: usize = 0;\n    let mut mut_index: usize\
    \ = 0;\n    let mut mut_index: usize = 0;\n    let mut mut_index: usize = 0;\n\
    \    let mut mut_index: usize = 0;\n    let mut mut_index: usize = 0;\n    let\
    \ mut mut_index: usize = 0;\n    let mut mut_index: usize = 0;\n    let mut mut_index:\
    \ usize = 0;\n    let mut mut_index: usize = 0;\n    let mut mut_index: usize\
    \ = 0;\n    let mut mut_index: usize = 0;\n    let mut mut_index: usize = 0;\n\
    \    let mut mut_index: usize = 0;\n    let mut mut_index: usize = 0;\n    let\
    \ mut mut_index: usize = 0;\n    let mut mut_index: usize = 0;\n    let mut mut_index:\
    \ usize = 0;\n    let mut mut_index: usize = 0;\n    let mut mut_index: usize\
    \ = 0;\n    let mut mut_index: usize = 0;\n    let mut mut_index: usize = 0;\n\
    \    let mut mut_index: usize = 0;\n    let mut mut_index: usize = 0;\n    let\
    \ mut mut_index: usize = 0;\n    let mut mut_index: usize = 0;\n    let mut mut_index:\
    \ usize = 0;\n    let mut mut_index: usize = 0;\n    let mut mut_index: usize\
    \ = 0;\n    let mut mut_index: usize = 0;\n    let mut mut_index: usize = 0;\n\
    \    let mut mut_index: usize = 0;\n    let mut mut_index: usize = 0;\n    let\
    \ mut mut_index: usize = 0;\n    let mut mut_index: usize = 0;\n    let mut mut_index:\
    \ usize = 0;\n    let mut mut_index: usize = 0;\n    let mut mut_index: usize\
    \ = 0;\n    let mut mut_index: usize\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp2l1g2whj.rs:77:29\n   |\n\
    77 |     let mut mut_index: usize\n   |                             ^ help: add\
    \ `;` here\n78 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2l1g2whj.rs:26:30\n   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize>\
    \ {\n   |    -----                     ^^^^^^^^^^ expected struct `Vec`, found\
    \ `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or\
    \ `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n       \
    \    found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut even_values = vec![];\n\
    \    let mut smallest_value = vec![];\n    let mut smallest_index = vec![];\n\
    \    for i in arr.iter() {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \            if i < smallest_value.len() {\n                smallest_value[i]\
    \ = i;\n                smallest_index[i] = i;\n            }\n        } else\
    \ {\n            if i < smallest_value.len() {\n                smallest_value[i]\
    \ = i;\n                smallest_index[i] = i;\n            }\n        }\n   \
    \ }\n    if even_values.len() == 0 {\n        return vec![];\n    }\n    if even_values.len()\
    \ == 1 {\n        return vec![even_values[0]];\n    }\n    if even_values.len()\
    \ > 1 {\n        let mut smallest_even_value = even_values[0];\n        let mut\
    \ smallest_even_index = even_values[0];\n        for i in even_values.iter().rev()\
    \ {\n            if i % 2 == 0 {\n                if i < smallest_even_value.len()\
    \ {\n                    smallest_even_value = i;\n                    smallest_even_index\
    \ = i;\n                }\n            } else {\n                if i < smallest_even_value.len()\
    \ {\n                    smallest_even_value = i;\n                    smallest_even_index\
    \ = i;\n                }\n            }\n        }\n        return vec![smallest_even_value];\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbj86inof.rs:33:20\n   |\n\
    33 |             if i < smallest_value.len() {\n   |                    ^^^^^^^^^^^^^^^^^^^^\
    \ expected `&isize`, found `usize`\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `&isize`\n  --> /tmp/tmpbj86inof.rs:34:17\n   |\n34 |                 smallest_value[i]\
    \ = i;\n   |                 ^^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>` is not implemented\
    \ for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<&isize>`\
    \ for `Vec<_>`\n\nerror[E0277]: the type `[_]` cannot be indexed by `&isize`\n\
    \  --> /tmp/tmpbj86inof.rs:35:17\n   |\n35 |                 smallest_index[i]\
    \ = i;\n   |                 ^^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>` is not implemented\
    \ for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<&isize>`\
    \ for `Vec<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbj86inof.rs:38:20\n\
    \   |\n38 |             if i < smallest_value.len() {\n   |                  \
    \  ^^^^^^^^^^^^^^^^^^^^ expected `&isize`, found `usize`\n\nerror[E0277]: the\
    \ type `[_]` cannot be indexed by `&isize`\n  --> /tmp/tmpbj86inof.rs:39:17\n\
    \   |\n39 |                 smallest_value[i] = i;\n   |                 ^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[_]>` is not implemented for `&isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<&isize>` for `Vec<_>`\n\nerror[E0277]:\
    \ the type `[_]` cannot be indexed by `&isize`\n  --> /tmp/tmpbj86inof.rs:40:17\n\
    \   |\n40 |                 smallest_index[i] = i;\n   |                 ^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value: isize =\
    \ 0;\n    let mut smallest_index: usize = 0;\n    let mut even_values = Vec::new();\n\
    \    let mut even_values_index: Vec<usize> = Vec::new();\n    for &node in arr\
    \ {\n        if node.value % 2 == 0 {\n            even_values.push(node.value);\n\
    \            even_values_index.push(node.index);\n        }\n        if node.value\
    \ < smallest_value {\n            smallest_value = node.value;\n            smallest_index\
    \ = node.index;\n        }\n    }\n    if even_values.len() == 0 {\n        return\
    \ vec![];\n    }\n    let mut smallest_even_value = even_values[0];\n    let mut\
    \ smallest_even_index = even_values_index[0];\n    for &node in even_values.iter().rev()\
    \ {\n        if node < smallest_even_value {\n            smallest_even_value\
    \ = node;\n            smallest_even_index = even_values_index[even_values.iter().rev().position(|&x|\
    \ x == node).unwrap()];\n        }\n    }\n    even_values.clear();\n    even_values_index.clear();\n\
    \    even_values.push(smallest_even_value);\n    even_values_index.push(smallest_even_index);\n\
    \    even_values.sort_unstable();\n    even_values_index.sort_unstable();\n  \
    \  even_values.iter().cloned().collect()\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc2pr4blz.rs:31:9\n   |\n\
    31 |     for &node in arr {\n   |         ^^^^^    --- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `node`\n   |\n\
    \   = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut even_values = vec![];\n\
    \    let mut smallest_value = vec![];\n    let mut smallest_index = vec![];\n\
    \    for i in arr.iter() {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \            if i < smallest_value.len() {\n                smallest_value.push(smallest_value[i]);\n\
    \                smallest_index.push(smallest_index[i]);\n            }\n    \
    \    }\n    }\n    if even_values.len() == 0 {\n        return vec![];\n    }\n\
    \    if even_values.len() == 1 {\n        return vec![even_values[0]];\n    }\n\
    \    if even_values.len() == 2 {\n        if even_values[0] < even_values[1] {\n\
    \            return vec![even_values[0], even_values[1]];\n        } else {\n\
    \            return vec![even_values[1], even_values[0]];\n        }\n    }\n\
    \    if even_values.len() == 3 {\n        if even_values[0] < even_values[1] &&\
    \ even_values[0] < even_values[2] {\n            return vec![even_values[0], even_values[1]];\n\
    \        }\n        if even_values[1] < even_values[2] {\n            return vec![even_values[1],\
    \ even_values[2]];\n        }\n        if even_values[0] < even_values[1] && even_values[1]\
    \ < even_values[2] {\n            return vec![even_values[0], even_values[2]];\n\
    \        }\n        if even_values[0] < even_values[1] && even_values[2] < even_values[2]\
    \ {\n            return vec![even_values[1], even_values[2]];\n        }\n   \
    \ }\n    if even_values.len() == 4 {\n        if even_values[0] < even_values[1]\
    \ && even_values[0] < even_values[2] && even_values[0] < even_values[3] {\n  \
    \          return vec![even_values[0], even_values[1]];\n        }\n        if\
    \ even_values[1] < even_values[2] && even_values[1] < even_values[3] {\n     \
    \       return vec![even_values[1], even_values[2]];\n        }\n        if even_values[2]\
    \ < even_values[3] {\n            return vec![even_values[2], even_values[3]];\n\
    \        }\n    }\n    if even_values.len() == 5 {\n        if even_values[0]\
    \ < even_values[1] && even_values[0] < even_values[2] && even_values[0] < even_values[3]\
    \ && even_values[0] < even_values[4] {\n            return vec![even_values[0],\
    \ even_values[1]];\n        }\n        if even_values[1] < even_values[2] && even_values[1]\
    \ < even_values[3] && even_values[1] < even_values[4] {\n            return vec![even_values[1],\
    \ even_values[2]];\n        }\n        if even_values[2] < even_values[3] && even_values[2]\
    \ < even_value\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpac6pgl48.rs:97:3\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \                       - unclosed delimiter\n...\n77 |     if even_values.len()\
    \ == 5 {\n   |                               - this delimiter might not be properly\
    \ closed...\n...\n85 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n97 | }\n   |   ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmpac6pgl48.rs:85:1\n\
    \   |\n84 |         if even_values[2] < even_values[3] && even_values[2] < even_value\n\
    \   |         -- this `if` expression has a condition, but no block\n85 | }\n\
    \   | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpac6pgl48.rs:33:20\n\
    \   |\n33 |             if i < smallest_value.len() {\n   |                  \
    \  ^^^^^^^^^^^^^^^^^^^^ expected `&isize`, found `usize`\n\nerror[E0277]: the\
    \ type `[_]` cannot be indexed by `&isize`\n  --> /tmp/tmpac6pgl48.rs:34:37\n\
    \   |\n34 |                 smallest_value.push(smallest_value[i]);\n   |    \
    \                                 ^^^^^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>` is\
    \ not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<_>`\n\nerror[E0277]: the type `[_]` cannot be indexed\
    \ by `&isize`\n  --> /tmp/tmpac6pgl48.rs:35:37\n   |\n35 |                 smallest_index.push(smallest_index[i]);\n\
    \   |                                     ^^^^^^^^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>`\
    \ is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpac6pgl48.rs:43:21\n\
    \   |\n43 |         return vec![even_values[0]];\n   |                     ^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n  "
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = -1;\n    for i in arr.iter().rev() {\n        if i % 2 ==\
    \ 0 {\n            if min_value < i {\n                min_value = i;\n      \
    \          min_idx = i;\n            }\n        }\n    }\n    if min_idx == -1\
    \ {\n        return vec![];\n    }\n    vec![min_value, min_idx]\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp810vwvta.rs:31:28\n   |\n\
    31 |             if min_value < i {\n   |                            ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    31 |             if min_value < *i {\n   |                            +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp810vwvta.rs:32:29\n   |\n27 |     let mut min_value\
    \ = arr[0];\n   |                         ------ expected due to this value\n\
    ...\n32 |                 min_value = i;\n   |                             ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    32 |                 min_value = *i;\n   |                             +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp810vwvta.rs:33:27\n   |\n28 |     let mut min_idx\
    \ = -1;\n   |                       -- expected due to this value\n...\n33 | \
    \                min_idx = i;\n   |                           ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n33 |  \
    \               min_idx = *i;\n   |                           +\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_val = arr[0];\n   \
    \ let mut min_idx = 0;\n    let mut min_idx2 = 0;\n    let mut min_idx3 = 0;\n\
    \    let mut min_idx4 = 0;\n    let mut min_idx5 = 0;\n    let mut min_idx6 =\
    \ 0;\n    let mut min_idx7 = 0;\n    let mut min_idx8 = 0;\n    let mut min_idx9\
    \ = 0;\n    let mut min_idx10 = 0;\n    let mut min_idx11 = 0;\n    let mut min_idx12\
    \ = 0;\n    let mut min_idx13 = 0;\n    let mut min_idx14 = 0;\n    let mut min_idx15\
    \ = 0;\n    let mut min_idx16 = 0;\n    let mut min_idx17 = 0;\n    let mut min_idx18\
    \ = 0;\n    let mut min_idx19 = 0;\n    let mut min_idx20 = 0;\n    let mut min_idx21\
    \ = 0;\n    let mut min_idx22 = 0;\n    let mut min_idx23 = 0;\n    let mut min_idx24\
    \ = 0;\n    let mut min_idx25 = 0;\n    let mut min_idx26 = 0;\n    let mut min_idx27\
    \ = 0;\n    let mut min_idx28 = 0;\n    let mut min_idx29 = 0;\n    let mut min_idx30\
    \ = 0;\n    let mut min_idx31 = 0;\n    let mut min_idx32 = 0;\n    let mut min_idx33\
    \ = 0;\n    let mut min_idx34 = 0;\n    let mut min_idx35 = 0;\n    let mut min_idx36\
    \ = 0;\n    let mut min_idx37 = 0;\n    let mut min_idx38 = 0;\n    let mut min_idx39\
    \ = 0;\n    let mut min_idx40 = 0;\n    let mut min_idx41 = 0;\n    let mut min_idx42\
    \ = 0;\n    let mut min_idx43 = 0;\n    let mut min_idx44 = 0;\n    let mut min_idx45\
    \ = 0;\n    let mut min_idx46 = 0;\n    let mut min_idx47 = 0;\n    let mut min_idx48\
    \ = 0;\n    let mut min_idx49 = 0;\n    let mut min_idx50 = 0;\n    let mut min_idx51\
    \ = 0;\n    let mut min_idx52 = 0;\n    let mut min_idx53 = 0;\n    let mut min_idx54\
    \ = 0;\n    let mut min_idx55 = 0;\n    let mut min_idx56 = 0;\n    let mut min_idx57\
    \ = 0;\n    let mut min_idx58 = 0;\n    let mut min_idx59 = 0;\n    let mut min_idx60\
    \ = 0;\n    let mut min_idx61 = 0;\n    let mut min_idx62 = 0;\n    let mut min_idx63\
    \ = 0;\n    let mut min_idx\n}\n\nfn main() {\n    let candidate = pluck;\n  \
    \  assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5rse7rbo.rs:91:20\n   |\n\
    91 |     let mut min_idx\n   |                    ^ help: add `;` here\n92 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5rse7rbo.rs:26:30\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----         \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_value = arr[0];\n \
    \   let mut min_idx = 0;\n    let mut min_idx2 = 0;\n    for i in arr.iter().rev()\
    \ {\n        if i % 2 == 0 {\n            if min_value >= i {\n              \
    \  min_value = i;\n                min_idx = i;\n            }\n        } else\
    \ {\n            if min_value >= i {\n                min_value = i;\n       \
    \         min_idx2 = i;\n            }\n        }\n    }\n    if min_idx2 == min_idx\
    \ {\n        min_idx2\n    } else {\n        min_idx\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuilok3yq.rs:32:29\n   |\n\
    32 |             if min_value >= i {\n   |                             ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    32 |             if min_value >= *i {\n   |                             +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpuilok3yq.rs:33:29\n   |\n27 |  \
    \   let mut min_value = arr[0];\n   |                         ------ expected\
    \ due to this value\n...\n33 |                 min_value = i;\n   |          \
    \                   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n33 |                 min_value = *i;\n   |               \
    \              +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuilok3yq.rs:34:27\n\
    \   |\n28 |     let mut min_idx = 0;\n   |                       - expected due\
    \ to this value\n...\n34 |                 min_idx = i;\n   |                \
    \           ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n34 |                 min_idx = *i;\n   |                 \
    \          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuilok3yq.rs:37:29\n\
    \   |\n37 |             if min_value >= i {\n   |                            \
    \ ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n37 |             if min_value >= *i {\n   |                           \
    \  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuilok3yq.rs:38:29\n   |\n\
    27 |     let mut min_value = arr[0];\n   |                         ------ expected\
    \ due to this value\n...\n38 |                 min_value = i;\n   |          \
    \                   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n38 |                 min_value = *i;\n   |               \
    \              +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuilok3yq.rs:39:28\n\
    \   |\n29 |     let mut min_idx2 = 0;\n   |                        - expected\
    \ due to this value\n...\n39 |                 min_idx2 = i;\n   |           \
    \                 ^ expected integer, found `&isize`\n   |\nhelp: consid"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut even_values = vec![];\n\
    \    let mut smallest_value = vec![];\n    let mut smallest_index = vec![];\n\
    \    for i in arr.iter() {\n        if i % 2 == 0 {\n            even_values.push(i);\n\
    \            if i < smallest_value.len() {\n                smallest_value[i]\
    \ = i;\n                smallest_index[i] = i;\n            }\n        }\n   \
    \ }\n    if even_values.len() == 0 {\n        return vec![];\n    }\n    let mut\
    \ smallest_value_len = even_values.len();\n    for i in even_values.iter() {\n\
    \        if smallest_value[smallest_value_len - 1] == i {\n            smallest_value_len--;\n\
    \        }\n    }\n    for i in 0..smallest_value_len {\n        if even_values[i]\
    \ == smallest_value[i] {\n            smallest_index[i] = even_values[i];\n  \
    \      }\n    }\n    smallest_value\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpop6jvppo.rs:45:33\n\
    \   |\n45 |             smallest_value_len--;\n   |                          \
    \       ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpop6jvppo.rs:33:20\n\
    \   |\n33 |             if i < smallest_value.len() {\n   |                  \
    \  ^^^^^^^^^^^^^^^^^^^^ expected `&isize`, found `usize`\n\nerror[E0277]: the\
    \ type `[_]` cannot be indexed by `&isize`\n  --> /tmp/tmpop6jvppo.rs:34:17\n\
    \   |\n34 |                 smallest_value[i] = i;\n   |                 ^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[_]>` is not implemented for `&isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<&isize>` for `Vec<_>`\n\nerror[E0277]:\
    \ the type `[_]` cannot be indexed by `&isize`\n  --> /tmp/tmpop6jvppo.rs:35:17\n\
    \   |\n35 |                 smallest_index[i] = i;\n   |                 ^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[_]>` is not implemented for `&isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<&isize>` for `Vec<_>`\n\nerror[E0277]:\
    \ can't compare `isize` with `&&isize`\n  --> /tmp/tmpop6jvppo.rs:44:51\n   |\n\
    44 |         if smallest_value[smallest_value_len - 1] == i {\n   |          \
    \                                         ^^ no implementation for `isize == &&isize`\n\
    \   |\n   = help: the trait `PartialEq<&&isize>` is not implemented for `isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpop6jvppo.rs:49:27\n\
    \   |\n49 |         if even_values[i] == smallest_value[i] {\n   |           \
    \                ^^ no imp"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    for i in arr.iter().rev() {\n        if\
    \ i % 2 == 0 {\n            if smallest_value < i {\n                smallest_value\
    \ = i;\n                smallest_index = i;\n            }\n        }\n    }\n\
    \    vec![smallest_value, smallest_index]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmtadrjsg.rs:31:33\n   |\n\
    31 |             if smallest_value < i {\n   |                               \
    \  ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n31 |             if smallest_value < *i {\n   |              \
    \                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmtadrjsg.rs:32:34\n\
    \   |\n27 |     let mut smallest_value = arr[0];\n   |                       \
    \       ------ expected due to this value\n...\n32 |                 smallest_value\
    \ = i;\n   |                                  ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n32 |                 smallest_value\
    \ = *i;\n   |                                  +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmtadrjsg.rs:33:34\n   |\n28 |     let mut smallest_index = 0;\n\
    \   |                              - expected due to this value\n...\n33 |   \
    \              smallest_index = i;\n   |                                  ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    33 |                 smallest_index = *i;\n   |                              \
    \    +\n\nerror: aborting due to 3 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value: isize =\
    \ 0;\n    let mut smallest_index: usize = 0;\n    let mut smallest_even_value:\
    \ isize = 0;\n    for &i in arr {\n        if i % 2 == 0 {\n            smallest_even_value\
    \ = i;\n        }\n        if i == smallest_value {\n            smallest_index\
    \ = i;\n        }\n        if i == smallest_even_value {\n            smallest_value\
    \ = i;\n        }\n    }\n    smallest_value\n        .clone()\n        .to_vec()\n\
    \        .iter()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .cloned()\n  \
    \      .cloned()\n        .cloned()\n        .cloned()\n        .\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: unexpected token: `}`\n   --> /tmp/tmpdnplgl2q.rs:148:1\n    |\n\
    148 | }\n    | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdnplgl2q.rs:30:9\n\
    \   |\n30 |     for &i in arr {\n   |         ^^    --- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `i`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdnplgl2q.rs:35:30\n   |\n28 |     let mut smallest_index:\
    \ usize = 0;\n   |                             ----- expected due to this type\n\
    ...\n35 |             smallest_index = i;\n   |                              ^\
    \ expected `usize`, found `isize`\n\nerror[E0599]: no method named `to_vec` found\
    \ for type `isize` in the current scope\n  --> /tmp/tmpdnplgl2q.rs:43:10\n   |\n\
    43 |         .to_vec()\n   |          ^^^^^^ help: there is an associated function\
    \ with a similar name: `to_be`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_value = arr[0];\n\
    \    let mut smallest_index = 0;\n    let mut even_value = false;\n    for i in\
    \ arr.iter() {\n        if i % 2 == 0 {\n            even_value = true;\n    \
    \    }\n        if i == smallest_value {\n            smallest_index = i;\n  \
    \      }\n        if even_value\n            && smallest_value == i\n        \
    \    && smallest_index == i\n        {\n            smallest_value = i;\n    \
    \        smallest_index = i;\n            even_value = false;\n        }\n   \
    \ }\n    if even_value\n        && smallest_value == smallest_index\n        &&\
    \ smallest_index == arr.len() - 1\n    {\n        smallest_value = smallest_index;\n\
    \        smallest_index = arr.len() - 1;\n    }\n    vec![smallest_value, smallest_index]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpjcq4nko1.rs:34:14\n\
    \   |\n34 |         if i == smallest_value {\n   |              ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpjcq4nko1.rs:35:30\n   |\n28 |     let mut smallest_index = 0;\n   |\
    \                              - expected due to this value\n...\n35 |       \
    \      smallest_index = i;\n   |                              ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n35 |  \
    \           smallest_index = *i;\n   |                              +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjcq4nko1.rs:38:34\n   |\n38 |             &&\
    \ smallest_value == i\n   |                                  ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n38 |  \
    \           && smallest_value == *i\n   |                                  +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpjcq4nko1.rs:41:30\n   |\n27 |\
    \     let mut smallest_value = arr[0];\n   |                              ------\
    \ expected due to this value\n...\n41 |             smallest_value = i;\n   |\
    \                              ^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n41 |             smallest_value = *i;\n\
    \   |                              +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpjcq4nko1.rs:42:30\n   |\n28 |     let mut smallest_index = 0;\n   |\
    \                              - expected due to this value\n...\n42 |       \
    \      smallest_index = i;\n   |                              ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n42 |  \
    \           smallest_index = *i;\n   |                              +\n\nerror[E0277]:\
    \ can't"
  exit_code: 1
  status: SyntaxError
