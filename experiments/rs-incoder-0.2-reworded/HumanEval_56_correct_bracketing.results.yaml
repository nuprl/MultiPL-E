language: rs
name: HumanEval_56_correct_bracketing
results:
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    while brackets.len() > 0 {\n\
    \        let mut open_bracket = String::new();\n        let mut close_bracket\
    \ = String::new();\n        let mut open_brackets = String::new();\n        let\
    \ mut close_brackets = String::new();\n        while brackets.len() > 0 {\n  \
    \          if brackets.starts_with(\"<<\") {\n                open_bracket = brackets.split_off(1).unwrap();\n\
    \                open_brackets = open_brackets + open_bracket;\n             \
    \   brackets = brackets.split_off(1).unwrap();\n            } else if brackets.starts_with(\"\
    >>\") {\n                close_bracket = brackets.split_off(1).unwrap();\n   \
    \             close_brackets = close_brackets + close_bracket;\n             \
    \   brackets = brackets.split_off(1).unwrap();\n            } else {\n       \
    \         break;\n            }\n        }\n        if open_brackets.len() ==\
    \ close_brackets.len() {\n            if open_brackets.is_empty() {\n        \
    \        return true;\n            }\n            if close_brackets.is_empty()\
    \ {\n                return false;\n            }\n            if open_brackets.starts_with(close_brackets)\
    \ {\n                open_brackets = open_brackets.split_off(close_brackets.len()).unwrap();\n\
    \                close_brackets = close_brackets.split_off(open_brackets.len()).unwrap();\n\
    \            } else {\n                return false;\n            }\n        }\
    \ else {\n            return false;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpa5ydzntl.rs:22:54\n   |\n22 |                 open_bracket\
    \ = brackets.split_off(1).unwrap();\n   |                                    \
    \                  ^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpa5ydzntl.rs:23:49\n   |\n23 |                 open_brackets\
    \ = open_brackets + open_bracket;\n   |                                      \
    \           ^^^^^^^^^^^^\n   |                                               \
    \  |\n   |                                                 expected `&str`, found\
    \ struct `String`\n   |                                                 help:\
    \ consider borrowing here: `&open_bracket`\n\nerror[E0599]: no method named `unwrap`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpa5ydzntl.rs:24:50\n\
    \   |\n24 |                 brackets = brackets.split_off(1).unwrap();\n   | \
    \                                                 ^^^^^^ method not found in `String`\n\
    \nerror[E0599]: no method named `unwrap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpa5ydzntl.rs:26:55\n   |\n26 |                 close_bracket\
    \ = brackets.split_off(1).unwrap();\n   |                                    \
    \                   ^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpa5ydzntl.rs:27:51\n   |\n27 |                 close_brackets\
    \ = close_brackets + close_bracket;\n   |                                    \
    \               ^^^^^^^^^^^^^\n   |                                          \
    \         |\n   |                                                   expected `&str`,\
    \ found struct `String`\n   |                                                \
    \   help: consider borrowing here: `&close_bracket`\n\nerror[E0599]: no method\
    \ named `unwrap` found for struct `String` in the current scope\n  --> /tmp/tmpa5ydzntl.rs:28:50\n\
    \   |\n28 |                 brackets = brackets.split_off(1).unwrap();\n   | \
    \                                                 ^^^^^^ method not found in `String`\n\
    \nerror[E"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut opening_brackets = Vec::new();\n    let\
    \ mut closing_brackets = Vec::new();\n\n    for c in brackets {\n        if c\
    \ == '<' {\n            stack.push(c);\n            opening_brackets.push(c);\n\
    \        }\n        if c == '>' {\n            if stack.len() == 0 {\n       \
    \         return false;\n            }\n            closing_brackets.push(stack.last().unwrap());\n\
    \            stack.pop();\n        }\n    }\n    if stack.len() != 0 {\n     \
    \   return false;\n    }\n    if opening_brackets.len() != closing_brackets.len()\
    \ {\n        return false;\n    }\n    for c in opening_brackets {\n        if\
    \ c != closing_brackets.last() {\n            return false;\n        }\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpv6iznvai.rs:16:14\n\
    \   |\n16 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    while brackets.len() > 0 {\n\
    \        let mut open_bracket = String::new();\n        let mut close_bracket\
    \ = String::new();\n        let mut open_brackets = String::new();\n        let\
    \ mut close_brackets = String::new();\n        while brackets.len() > 0 {\n  \
    \          let mut open_bracket = String::new();\n            let mut close_bracket\
    \ = String::new();\n            let mut open_brackets = String::new();\n     \
    \       let mut close_brackets = String::new();\n            if brackets.starts_with(\"\
    <<\") {\n                open_bracket = brackets.split_off(1).unwrap();\n    \
    \            open_brackets = open_bracket.trim_left_matches('>').trim_left_matches('<');\n\
    \                open_brackets = open_brackets.trim_left_matches('>').trim_left_matches('<');\n\
    \                open_brackets = open_brackets.trim_left_matches('>').trim_left_matches('<');\n\
    \                open_brackets = open_brackets.trim_left_matches('>').trim_left_matches('<');\n\
    \                open_brackets = open_brackets.trim_left_matches('>').trim_left_matches('<');\n\
    \                open_brackets = open_brackets.trim_left_matches('>').trim_left_matches('<');\n\
    \                open_brackets = open_brackets.trim_left_matches('>').trim_left_matches('<');\n\
    \                open_brackets = open_brackets.trim_left_matches('>').trim_left_matches('<');\n\
    \                open_brackets = open_brackets.trim_left_matches('>').trim_left_matches('<');\n\
    \                open_brackets = open_brackets.trim_left_matches('>').trim_left_matches('<');\n\
    \                open_brackets = open_brackets.trim_left_matches('>').trim_left_matches('<');\n\
    \                open_brackets = open_brackets.trim_left_matches('>').trim_left_matches('<');\n\
    \                open_brackets = open_brackets.trim_left_matches('>').trim_left_matches('<');\n\
    \                open_brackets = open_brackets.trim_left_matches('>').trim_left_matches('\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmplade58qf.rs:40:88\n\
    \   |\n40 |                 open_brackets = open_brackets.trim_left_matches('>').trim_left_matches('\n\
    \   |                                                                        \
    \                ^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0762`.\n"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_brackets_stack = Vec::new();\n    let mut closed_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack_size = open_brackets_stack.len();\n\
    \    let mut closed_brackets_stack_size = closed_brackets_stack.len();\n    let\
    \ mut open_brackets_stack_ptr = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut closed_brackets_stack_ptr = &mut closed_brackets_stack[closed_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_end = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut closed_brackets_stack_ptr_end = &mut closed_brackets_stack[closed_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_end_ptr = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut closed_brackets_stack_ptr_end_ptr = &mut closed_brackets_stack[closed_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_end_ptr_end = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut closed_brackets_stack_ptr_end_ptr_end = &mut closed_brackets_stack[closed_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_end_ptr_end_ptr = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut closed_brackets_stack_ptr_end_ptr_end_ptr = &mut closed_brackets_stack[closed_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_end_ptr_end_ptr_end = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut closed_brackets_stack_ptr_end_ptr_end_ptr_end = &mut closed_brackets_stack[closed_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_end_ptr_end_ptr_end_ptr = &mut open_brackets_stack[open_brackets_stack_size];\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptbc7efq5.rs:11:44\n   |\n\
    11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\">\", \"\");\n    brackets.replace(\"<<\", \"\");\n    brackets.replace(\"\
    >>\", \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    bracket\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `bracket` in this scope\n  --> /tmp/tmpqqz_o7zx.rs:72:5\n\
    \   |\n72 |     bracket\n   |     ^^^^^^^ help: a local variable with a similar\
    \ name exists: `brackets`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    for bracket in brackets.chars() {\n        if bracket == '<' {\n        \
    \    open_brackets.push('>');\n            closed_brackets.push('<');\n      \
    \  } else if bracket == '>' {\n            open_brackets.push('<');\n        \
    \    closed_brackets.push('>');\n        } else {\n            open_brackets.push(bracket);\n\
    \        }\n    }\n    open_brackets.chars().all(|c| closed_brackets.chars().any(|c|\
    \ c == c))\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmphv1quxrr.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().skip_while(|c| !c.is_ascii_letter()).collect());\n\
    \    while stack.len() > 0 {\n        let mut open = stack.pop();\n        let\
    \ mut close = stack.pop();\n        if open == close {\n            continue;\n\
    \        }\n        if open == \">\" && close == \"<\" {\n            stack.push(\"\
    <<\");\n            stack.push(\"<<\");\n            stack.push(\"<<\");\n   \
    \         stack.push(\"<<\");\n            stack.push(\"<<\");\n            stack.push(\"\
    <<\");\n            stack.push(\"<<\");\n            stack.push(\"<<\");\n   \
    \         stack.push(\"<<\");\n            stack.push(\"<<\");\n            stack.push(\"\
    <<\");\n            stack.push(\"<<\");\n            stack.push(\"<<\");\n   \
    \         stack.push(\"<<\");\n            stack.push(\"<<\");\n            stack.push(\"\
    <<\");\n            stack.push(\"<<\");\n            stack.push(\"<<\");\n   \
    \         stack.push(\"<<\");\n            stack.push(\"<<\");\n            stack.push(\"\
    <<\");\n            stack.push(\"<<\");\n            stack.push(\"<<\");\n   \
    \         stack.push(\"<<\");\n            stack.push(\"<<\");\n            stack.push(\"\
    <<\");\n            stack.push(\"<<\");\n            stack.push(\"<<\");\n   \
    \         stack.push(\"<<\");\n            stack.push(\"<<\");\n            stack.push(\"\
    <<\");\n            stack.push(\"<<\");\n            stack.push(\"<<\");\n   \
    \         stack.push(\"<<\");\n            stack.push(\"<<\");\n            stack.push(\"\
    <<\");\n            stack.push(\"<<\");\n            stack.push(\"<<\");\n   \
    \         stack.push(\"<<\");\n            stack.push(\"<<\");\n            stack.push(\"\
    <<\");\n            stack.push(\"<<\");\n            stack.push(\"<<\");\n   \
    \         stack.push(\"<<\");\n            stack.push(\"<<\");\n            stack.push(\"\
    <<\");\n            stack.push(\"<<\");\n            stack.push(\"<<\");\n   \
    \         stack.push(\"<<\");\n            stack.push(\"<<\");\n            stack.push(\"\
    <<\");\n            stack.push(\"<<\");\n            stack.push(\"<<\");\n   \
    \         stack.push(\"<<\");\n            stack.push(\"<<\");\n            stack.push(\"\
    <<\");\n            stack.push(\"<<\");\n            stack.push(\"<<\");\n   \
    \         stack.push(\"<<\");\n            stack.push(\"<<\");\n            stack.push(\"\
    <<\");\n            stack.push(\"<<\");\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpu6pcnxvh.rs:99:3\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - unclosed delimiter\n...\n14 |     while\
    \ stack.len() > 0 {\n   |                           - unclosed delimiter\n...\n\
    20 |         if open == \">\" && close == \"<\" {\n   |                      \
    \                  - this delimiter might not be properly closed...\n...\n83 |\
    \ }\n   | - ...as it matches this but it has different indentation\n...\n99 |\
    \ }\n   |   ^\n\nerror[E0599]: no method named `is_ascii_letter` found for reference\
    \ `&char` in the current scope\n  --> /tmp/tmpu6pcnxvh.rs:13:51\n   |\n13 |  \
    \   stack.push(brackets.chars().skip_while(|c| !c.is_ascii_letter()).collect());\n\
    \   |                                                   ^^^^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `is_ascii`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpu6pcnxvh.rs:20:20\n   |\n20 |         if open\
    \ == \">\" && close == \"<\" {\n   |                    ^^^ expected enum `Option`,\
    \ found `&str`\n   |\n   = note:   expected enum `Option<_>`\n           found\
    \ reference `&'static str`\nhelp: try wrapping the expression in `Some`\n   |\n\
    20 |         if open == Some(\">\") && close == \"<\" {\n   |                \
    \    +++++   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu6pcnxvh.rs:20:36\n\
    \   |\n20 |         if open == \">\" && close == \"<\" {\n   |               \
    \                     ^^^ expected enum `Option`, found `&str`\n   |\n   = note:\
    \   expected enum `Option<_>`\n           found reference `&'static str`\nhelp:\
    \ try wrapping the expression in `Some`\n   |\n20 |         if open == \">\" &&\
    \ close == Some(\"<\") {\n   |                                    +++++   +\n\n\
    error[E0277]: a value of type `&str` cannot be built from an iterator over elements\
    \ of type `char`\n    --> /tmp/tmpu6pcnxvh.rs:13:70\n     |\n13   |     stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).collect());\n     |                                  \
    \                                    ^^^^^^^ v"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = Vec::new();\n    let mut open_brackets: Vec<usize> =\
    \ Vec::new();\n    let mut close_brackets: Vec<usize> = Vec::new();\n    let mut\
    \ open_brackets_size: usize = 0;\n    let mut close_brackets_size: usize = 0;\n\
    \    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut \n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmplu57kvcv.rs:51:1\n\
    \   |\n51 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack_size = open_brackets_stack.len();\n\
    \    let mut close_brackets_stack_size = close_brackets_stack.len();\n    let\
    \ mut open_brackets_stack_ptr = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut close_brackets_stack_ptr = &mut close_brackets_stack[close_brackets_stack_size];\n\
    \    let mut open_brackets_ptr = &mut open_brackets[open_brackets_stack_ptr];\n\
    \    let mut close_brackets_ptr = &mut close_brackets[close_brackets_stack_ptr];\n\
    \    let mut open_brackets_ptr_end = &mut open_brackets[open_brackets_stack_ptr];\n\
    \    let mut close_brackets_ptr_end = &mut close_brackets[close_brackets_stack_ptr];\n\
    \    let mut open_brackets_ptr_end_ptr = &mut open_brackets_ptr_end;\n    let\
    \ mut close_brackets_ptr_end_ptr = &mut close_brackets_ptr_end;\n    let mut open_brackets_ptr_end_ptr_end\
    \ = &mut open_brackets_ptr_end;\n    let mut close_brackets_ptr_end_ptr_end =\
    \ &mut close_brackets_ptr_end;\n    let mut open_brackets_ptr_end_ptr_end_ptr\
    \ = &mut open_brackets_ptr_end_ptr_end;\n    let mut close_brackets_ptr_end_ptr_end_ptr\
    \ = &mut close_brackets_ptr_end_ptr_end;\n    let mut open_brackets_ptr_end_ptr_end_ptr_end\
    \ = &mut open_brackets_ptr_end_ptr_end_ptr;\n    let mut close_brackets_ptr_end_ptr_end_ptr_end\
    \ = &mut close_brackets_ptr_end_ptr_end_ptr;\n    let mut open_brackets_ptr_end_ptr_end_ptr_\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9wnvsse4.rs:32:47\n   |\n\
    32 |     let mut open_brackets_ptr_end_ptr_end_ptr_\n   |                    \
    \                           ^ help: add `;` here\n33 | }\n   | - unexpected token\n\
    \nerror[E0277]: the type `String` cannot be indexed by `&mut _`\n  --> /tmp/tmp9wnvsse4.rs:20:38\n\
    \   |\n20 |     let mut open_brackets_ptr = &mut open_brackets[open_brackets_stack_ptr];\n\
    \   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `&mut _`\n   |\n   = help: the trait `Index<&mut\
    \ _>` is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `&mut _`\n\
    \  --> /tmp/tmp9wnvsse4.rs:21:39\n   |\n21 |     let mut close_brackets_ptr =\
    \ &mut close_brackets[close_brackets_stack_ptr];\n   |                       \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `&mut _`\n   |\n   = help: the trait `Index<&mut _>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `&mut _`\n\
    \  --> /tmp/tmp9wnvsse4.rs:22:42\n   |\n22 |     let mut open_brackets_ptr_end\
    \ = &mut open_brackets[open_brackets_stack_ptr];\n   |                       \
    \                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    for c in brackets {\n        if c == '<' {\n            opening_brackets.push(c);\n\
    \        } else {\n            closing_brackets.push(c);\n        }\n    }\n \
    \   opening_brackets.chars().all(|c| closing_brackets.chars().any(|c| c == c))\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp2n4qbnn7.rs:14:14\n\
    \   |\n14 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiapp5l8z.rs:11:44\n   |\n\
    11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_brackets_stack = Vec::new();\n    let mut closed_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack_size = open_brackets_stack.len();\n\
    \    let mut closed_brackets_stack_size = closed_brackets_stack.len();\n    let\
    \ mut open_brackets_stack_pos = 0;\n    let mut closed_brackets_stack_pos = 0;\n\
    \    let mut open_brackets_stack_end = open_brackets_stack_size;\n    let mut\
    \ closed_brackets_stack_end = closed_brackets_stack_size;\n    let mut open_brackets_stack_last_pos\
    \ = 0;\n    let mut closed_brackets_stack_last_pos = 0;\n    let mut open_brackets_stack_last_end\
    \ = open_brackets_stack_size;\n    let mut closed_brackets_stack_last_end = closed_brackets_stack_size;\n\
    \    let mut open_brackets_stack_last_size = open_brackets_stack_size;\n    let\
    \ mut closed_brackets_stack_last_size = closed_brackets_stack_size;\n    let mut\
    \ open_brackets_stack_last_pos = 0;\n    let mut closed_brackets_stack_last_pos\
    \ = 0;\n    let mut open_brackets_stack_last_end = open_brackets_stack_size;\n\
    \    let mut closed_brackets_stack_last_end = closed_brackets_stack_size;\n  \
    \  let mut open_brackets_stack_last_size = open_brackets_stack_size;\n    let\
    \ mut closed_brackets_stack_last_size = closed_brackets_stack_size;\n    let mut\
    \ open_brackets_stack_last_pos = 0;\n    let mut closed_brackets_stack_last_pos\
    \ = 0;\n    let mut open_brackets_stack_last_end = open_brackets_stack_size;\n\
    \    let mut closed_brackets_stack_last_end = closed_brackets_stack_size;\n  \
    \  let mut open_brackets_stack_last_size = open_brackets_stack_size;\n    let\
    \ mut closed_brackets_stack_last_size = closed_brackets_stack_size;\n    let mut\
    \ open_brackets_stack_last_pos = 0;\n    let mut closed_brackets_stack_last_pos\
    \ = 0;\n    let mut open_brackets_stack_last_end = open_brackets_stack_size;\n\
    \    let mut closed_brackets_stack_last_end = closed_brackets_stack\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmps7ccqijp.rs:43:67\n   |\n\
    43 |     let mut closed_brackets_stack_last_end = closed_brackets_stack\n   |\
    \                                                                   ^ help: add\
    \ `;` here\n44 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmps7ccqijp.rs:11:44\n   |\n11 | fn correct_bracketing(brackets: String)\
    \ -> bool {\n   |    ------------------                      ^^^^ expected `bool`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_brackets_stack = Vec::new();\n    let mut closed_brackets_stack\
    \ = Vec::new();\n    let mut i = 0;\n    while i < brackets.len() {\n        let\
    \ c = brackets[i];\n        if c == '<' {\n            if open_brackets_stack.len()\
    \ == 0 {\n                open_brackets_stack.push(i);\n            }\n      \
    \      open_brackets.push(c);\n        } else if c == '>' {\n            if closed_brackets_stack.len()\
    \ == 0 {\n                closed_brackets_stack.push(i);\n            }\n    \
    \        closed_brackets.push(c);\n        } else {\n            if open_brackets_stack.len()\
    \ > 0 {\n                open_brackets_stack.pop();\n            }\n         \
    \   if closed_brackets_stack.len() > 0 {\n                closed_brackets_stack.pop();\n\
    \            }\n        }\n        i += 1;\n    }\n    if open_brackets.len()\
    \ != closed_brackets.len() {\n        return false;\n    }\n    let mut i = 0;\n\
    \    while i < open_brackets.len() {\n        if open_brackets[i] != closed_brackets[i]\
    \ {\n            return false;\n        }\n        i += 1;\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp0ol5um2w.rs:18:17\n\
    \   |\n18 |         let c = brackets[i];\n   |                 ^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp0ol5um2w.rs:44:12\n   |\n44 |         if open_brackets[i] != closed_brackets[i]\
    \ {\n   |            ^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp0ol5um2w.rs:44:32\n   |\n44 |         if open_brackets[i] != closed_brackets[i]\
    \ {\n   |                                ^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for c in brackets {\n        if c == '<' {\n  \
    \          stack.push(c);\n        } else if c == '>' {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.pop();\n\
    \        } else {\n            if stack.len() != 0 {\n                return false;\n\
    \            }\n        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n   \
    \ let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmprh1locet.rs:13:14\n\
    \   |\n13 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    let mut opening_bracket = String::new();\n    let mut closing_bracket = String::new();\n\
    \    let mut opening_brackets = String::new();\n    let mut closing_brackets =\
    \ String::new();\n    let mut opening_bracket = String::new();\n    let mut closing_bracket\
    \ = String::new();\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_brackets = String::new();\n    let mut opening_bracket = String::new();\n\
    \    let mut closing_bracket = String::new();\n    let mut opening_brackets =\
    \ String::new();\n    let mut closing_brackets = String::new();\n    let mut opening_bracket\
    \ = String::new();\n    let mut closing_bracket = String::new();\n    let mut\
    \ opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    let mut opening_bracket = String::new();\n    let mut closing_bracket = String::new();\n\
    \    let mut opening_brackets = String::new();\n    let mut closing_brackets =\
    \ String::new();\n    let mut opening_bracket = String::new();\n    let mut closing_bracket\
    \ = String::new();\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_brackets = String::new();\n    let mut opening_bracket = String::new();\n\
    \    let mut closing_bracket = String::new();\n    let mut opening_brackets =\
    \ String::new();\n    let mut closing_brackets = String::new();\n    let mut opening_bracket\
    \ = String::new();\n    let mut closing_bracket = String::new();\n    let mut\
    \ opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    let mut opening_bracket = String::new();\n    let mut closing_bracket = String::new();\n\
    \    let mut opening_brackets = String::new();\n    let mut closing_brackets =\
    \ String::new();\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvxb4ya5q.rs:11:44\n   |\n\
    11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    for bracket in brackets.chars() {\n        if bracket == '<' {\n        \
    \    open_brackets.push('>');\n            close_brackets.push('<');\n       \
    \ } else if bracket == '>' {\n            open_brackets.push('<');\n         \
    \   close_brackets.push('>');\n        } else {\n            open_brackets.push(bracket);\n\
    \            close_brackets.push(bracket);\n        }\n    }\n    open_brackets\
    \ == close_brackets\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpfl7zrlyv.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = vec![];\n    for c in brackets.chars() {\n        if c == '<' {\n\
    \            stack.push(c);\n        } else if c == '>' {\n            if stack.is_empty()\
    \ {\n                return false;\n            }\n            stack.pop();\n\
    \        } else {\n            return false;\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_iter = brackets.chars().enumerate().filter(|(_, c)|\
    \ c != '<').collect::<Vec<_>>();\n    let mut close_brackets_iter = brackets.chars().enumerate().filter(|(_,\
    \ c)| c != '>').collect::<Vec<_>>();\n    let mut open_brackets_iter = open_brackets_iter.into_iter().map(|(_,\
    \ c)| c as char);\n    let mut close_brackets_iter = close_brackets_iter.into_iter().map(|(_,\
    \ c)| c as char);\n    let mut open_brackets_iter = open_brackets_iter.filter(|c|\
    \ !open_brackets.contains(&c));\n    let mut close_brackets_iter = close_brackets_iter.filter(|c|\
    \ !close_brackets.contains(&c));\n    let mut open_brackets_iter = open_brackets_iter.collect::<Vec<_>>();\n\
    \    let mut close_brackets_iter = close_brackets_iter.collect::<Vec<_>>();\n\
    \    let mut open_brackets_iter = open_brackets_iter.into_iter().map(|c| c as\
    \ char);\n    let mut close_brackets_iter = close_brackets_iter.into_iter().map(|c|\
    \ c as char);\n    let mut open_brackets_iter = open_brackets_iter.filter(|c|\
    \ !open_brackets.contains(&c));\n    let mut close_brackets_iter = close_brackets_iter.filter(|c|\
    \ !close_brackets.contains(&c));\n    let mut open_brackets_iter = open_brackets_iter.collect::<Vec<_>>();\n\
    \    let mut close_brackets_iter = close_brackets_iter.collect::<Vec<_>>();\n\
    \    let mut open_brackets_iter = open_brackets_iter.into_iter().map(|c| c as\
    \ char);\n    let mut close_brackets_iter = close_brackets_iter.into_iter().map(|c|\
    \ c as char);\n    let mut open_brackets_iter = open_brackets_iter.filter(|c|\
    \ !open_brackets.contains(&c));\n    let mut close_bra\n}\n\nfn main() {\n   \
    \ let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpjq836bjc.rs:31:22\n   |\n\
    31 |     let mut close_bra\n   |                      ^ help: add `;` here\n32\
    \ | }\n   | - unexpected token\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpjq836bjc.rs:14:81\n   |\n14 |     let mut open_brackets_iter =\
    \ brackets.chars().enumerate().filter(|(_, c)| c != '<').collect::<Vec<_>>();\n\
    \   |                                                                        \
    \         ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpjq836bjc.rs:15:82\n   |\n15 |     let mut close_brackets_iter =\
    \ brackets.chars().enumerate().filter(|(_, c)| c != '>').collect::<Vec<_>>();\n\
    \   |                                                                        \
    \          ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: expected a `Fn<(char,)>` closure,\
    \ found `char`\n    --> /tmp/tmpjq836bjc.rs:18:88\n     |\n18   |     let mut\
    \ open_brackets_iter = open_brackets_iter.filter(|c| !open_brackets.contains(&c));\n\
    \     |                                                                      \
    \         -------- ^^ expected an `Fn<(char,)>` closure, found `char`\n     |\
    \                                                                            \
    \   |\n     |                                                                \
    \               required by a bound introduced by this call\n     |\n     = help:\
    \ the trait `Fn<(char,)>` is not implemented for `char`\n     = help: the trait\
    \ `Pattern<'a>` is implemented for `char`\n     = note: required because of the\
    \ requirements on the impl of `FnOnce<(char,)>` for `&char`\n     = note: required\
    \ because of the requirements on the impl of `Pattern<'_>` for `&&char`\nnote:\
    \ required by a bound in `core::str::<impl str>::contains`\n\ne"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_count = String::new();\n    let mut close_brackets_count\
    \ = String::new();\n    let mut open_brackets_count_map = HashMap::new();\n  \
    \  let mut close_brackets_count_map = HashMap::new();\n    let mut open_brackets_count_map_sorted\
    \ = HashMap::new();\n    let mut close_brackets_count_map_sorted = HashMap::new();\n\
    \    let mut open_brackets_count_map_sorted_reverse = HashMap::new();\n    let\
    \ mut close_brackets_count_map_sorted_reverse = HashMap::new();\n    let mut open_brackets_count_map_sorted_reverse_sorted\
    \ = HashMap::new();\n    let mut close_brackets_count_map_sorted_reverse_sorted\
    \ = HashMap::new();\n    let mut open_brackets_count_map_sorted_reverse_sorted_reverse\
    \ = HashMap::new();\n    let mut close_brackets_count_map_sorted_reverse_sorted_reverse\
    \ = HashMap::new();\n    let mut open_brackets_count_map_sorted_reverse_sorted_reverse_sorted\
    \ = HashMap::new();\n    let mut close_brackets_count_map_sorted_reverse_sorted_reverse_sorted\
    \ = HashMap::new();\n    let mut open_brackets_count_map_sorted_reverse_sorted_reverse_sorted_reverse\
    \ = HashMap::new();\n    let mut close_brackets_count_map_sorted_reverse_sorted_reverse_sorted_reverse\
    \ = HashMap::new();\n    let mut open_brackets_count_map_sorted_reverse_sorted_reverse_sorted_reverse_sorted\
    \ = HashMap::new();\n    let mut close_brackets_count_map_sorted_reverse_sorted_reverse_sorted_reverse_sorted\
    \ = HashMap::new();\n    let mut open_brackets_count_map_sorted_reverse_sorted_reverse_sorted_reverse_sorted_reverse\
    \ = HashMap::new();\n    let mut close_brackets_count_map_sorted_reverse_sorted_reverse_sorted_reverse_sorted_reverse\
    \ = HashMap::new();\n    let mut open_brackets_count_map_sorted_reverse_sorted_reverse_sorted_reverse_sorted_reverse_sorted\
    \ = HashMap::new();\n    let mut close_brackets_count_map_sorted_reverse_sorted_reverse_sorted_reverse_sorted_reverse_sorted\
    \ = HashMap::new();\n    let mut open_brackets_count_map_sorted_reverse_sorted_reverse_sorted_reverse_sorted_reverse_sorted_reverse\
    \ = HashMap::new();\n    let mut \n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp8gbph9e8.rs:38:1\n\
    \   |\n38 | }\n   | ^ expected identifier\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmp8gbph9e8.rs:16:39\n   |\n16\
    \ |     let mut open_brackets_count_map = HashMap::new();\n   |              \
    \                         ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp8gbph9e8.rs:17:40\n\
    \   |\n17 |     let mut close_brackets_count_map = HashMap::new();\n   |     \
    \                                   ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmp8gbph9e8.rs:18:46\n   |\n18 |     let mut open_brackets_count_map_sorted\
    \ = HashMap::new();\n   |                                              ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmp8gbph9e8.rs:19:47\n   |\n19\
    \ |     let mut close_brackets_count_map_sorted = HashMap::new();\n   |      \
    \                                         ^^^^^^^ not found in this scope\n  \
    \ |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmp8gbph9e8.rs:20:54\n   |\n20 |     let mut open_brackets_count_map_sorted_reverse\
    \ = HashMap::new();\n   |                                                    \
    \  ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmp8gbph9e8.rs:21:55\n   |\n21\
    \ |     let mut close_brackets_count_map_sorted_reverse = HashMap::new();\n  \
    \ |                                                       ^^^^^^^ no"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_brackets_iter = brackets.char_indices();\n    let mut closed_brackets_iter\
    \ = brackets.char_indices();\n    let mut open_brackets_next = open_brackets_iter.next();\n\
    \    let mut closed_brackets_next = closed_brackets_iter.next();\n    while let\
    \ Some(open_bracket) = open_brackets_next {\n        if let Some(closed_bracket)\
    \ = closed_brackets_next {\n            if open_bracket.0 != closed_bracket.0\
    \ {\n                open_brackets += open_bracket;\n                closed_brackets\
    \ += closed_bracket;\n            }\n            open_brackets_next = open_brackets_iter.next();\n\
    \            closed_brackets_next = closed_brackets_iter.next();\n        } else\
    \ {\n            open_brackets += open_bracket;\n            closed_brackets_next\
    \ = closed_brackets_iter.next();\n        }\n    }\n    open_brackets == closed_brackets\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph_goy0gb.rs:21:34\n   |\n\
    21 |                 open_brackets += open_bracket;\n   |                    \
    \              ^^^^^^^^^^^^ expected `&str`, found tuple\n   |\n   = note: expected\
    \ reference `&str`\n                  found tuple `(usize, char)`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmph_goy0gb.rs:22:36\n   |\n22 |              \
    \   closed_brackets += closed_bracket;\n   |                                 \
    \   ^^^^^^^^^^^^^^ expected `&str`, found tuple\n   |\n   = note: expected reference\
    \ `&str`\n                  found tuple `(usize, char)`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmph_goy0gb.rs:27:30\n   |\n27 |             open_brackets\
    \ += open_bracket;\n   |                              ^^^^^^^^^^^^ expected `&str`,\
    \ found tuple\n   |\n   = note: expected reference `&str`\n                  found\
    \ tuple `(usize, char)`\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut open_brackets = String::new();\n    let\
    \ mut close_brackets = String::new();\n    let mut open_brackets_count = String::new();\n\
    \    let mut close_brackets_count = String::new();\n    let mut open_brackets_count_stack\
    \ = Vec::new();\n    let mut close_brackets_count_stack = Vec::new();\n    let\
    \ mut open_brackets_count_stack_size = String::new();\n    let mut close_brackets_count_stack_size\
    \ = String::new();\n    let mut open_brackets_count_stack_ptr = String::new();\n\
    \    let mut close_brackets_count_stack_ptr = String::new();\n    let mut open_brackets_count_stack_ptr_ptr\
    \ = String::new();\n    let mut close_brackets_count_stack_ptr_ptr = String::new();\n\
    \    let mut open_brackets_count_stack_ptr_ptr_ptr = String::new();\n    let mut\
    \ close_brackets_count_stack_ptr_ptr_ptr = String::new();\n    let mut open_brackets_count_stack_ptr_ptr_ptr_ptr\
    \ = String::new();\n    let mut close_brackets_count_stack_ptr_ptr_ptr_ptr = String::new();\n\
    \    let mut open_brackets_count_stack_ptr_ptr_ptr_ptr_ptr = String::new();\n\
    \    let mut close_brackets_count_stack_ptr_ptr_ptr_ptr_ptr = String::new();\n\
    \    let mut open_brackets_count_stack_ptr_ptr_ptr_ptr_ptr_ptr = String::new();\n\
    \    let mut close_brackets_count_stack_ptr_ptr_ptr_ptr_ptr = String::new();\n\
    \    let mut open_brackets_count_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr = String::new();\n\
    \    let mut close_brackets_count_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr = String::new();\n\
    \    let mut open_brackets_count_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr = String::new();\n\
    \    let mut close_brackets_count_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr = String::new();\n\
    \    let mut open_brackets_count_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr = String::new();\n\
    \    let mut close_brackets_count_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr = String::new();\n\
    \    let mut open_brackets_count_stack_ptr\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpujlagl6k.rs:39:42\n   |\n\
    39 |     let mut open_brackets_count_stack_ptr\n   |                         \
    \                 ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpujlagl6k.rs:11:44\n   |\n11 | fn correct_bracketing(brackets:\
    \ String) -> bool {\n   |    ------------------                      ^^^^ expected\
    \ `bool`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749137
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut open_brackets = Vec::new();\n    let mut\
    \ close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n  \
    \  let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = \n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp7fm40r46.rs:52:1\n\
    \   |\n52 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659749137
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_count = String::new();\n    let mut close_brackets_count\
    \ = String::new();\n    let mut open_brackets_count_map = HashMap::new();\n  \
    \  let mut close_brackets_count_map = HashMap::new();\n    let mut open_brackets_count_map_sorted\
    \ = HashMap::new();\n    let mut close_brackets_count_map_sorted = HashMap::new();\n\
    \    let mut open_brackets_count_map_sorted_reverse = HashMap::new();\n    let\
    \ mut close_brackets_count_map_sorted_reverse = HashMap::new();\n    let mut open_brackets_count_map_sorted_reverse\
    \ = HashMap::new();\n    let mut close_brackets_count_map_sorted_reverse = HashMap::new();\n\
    \    let mut open_brackets_count_map_sorted_reverse = HashMap::new();\n    let\
    \ mut close_brackets_count_map_sorted_reverse = HashMap::new();\n    let mut open_brackets_count_map_sorted_reverse\
    \ = HashMap::new();\n    let mut close_brackets_count_map_sorted_reverse = HashMap::new();\n\
    \    let mut open_brackets_count_map_sorted_reverse = HashMap::new();\n    let\
    \ mut close_brackets_count_map_sorted_reverse = HashMap::new();\n    let mut open_brackets_count_map_sorted_reverse\
    \ = HashMap::new();\n    let mut close_brackets_count_map_sorted_reverse = HashMap::new();\n\
    \    let mut open_brackets_count_map_sorted_reverse = HashMap::new();\n    let\
    \ mut close_brackets_count_map_sorted_reverse = HashMap::new();\n    let mut open_brackets_count_map_sorted_reverse\
    \ = HashMap::new();\n    let mut close_brackets_count_map_sorted_reverse = HashMap::new();\n\
    \    let mut open_brackets_count_map_sorted_reverse = HashMap::new();\n    let\
    \ mut close_brackets_count_map_sorted_reverse = HashMap::new();\n    let mut open_brackets_count_map_sorted_reverse\
    \ = HashMap::new();\n    let mut close_brackets_count_map_sorted_reverse = HashMap::new();\n\
    \    let mut open_brackets_count_map_\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpf7zap2lw.rs:40:37\n   |\n\
    40 |     let mut open_brackets_count_map_\n   |                              \
    \       ^ help: add `;` here\n41 | }\n   | - unexpected token\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpf7zap2lw.rs:16:39\n\
    \   |\n16 |     let mut open_brackets_count_map = HashMap::new();\n   |      \
    \                                 ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmpf7zap2lw.rs:17:40\n   |\n17 |     let mut close_brackets_count_map\
    \ = HashMap::new();\n   |                                        ^^^^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmpf7zap2lw.rs:18:46\n   |\n18 |     let mut open_brackets_count_map_sorted\
    \ = HashMap::new();\n   |                                              ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmpf7zap2lw.rs:19:47\n   |\n19\
    \ |     let mut close_brackets_count_map_sorted = HashMap::new();\n   |      \
    \                                         ^^^^^^^ not found in this scope\n  \
    \ |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmpf7zap2lw.rs:20:54\n   |\n20 |     let mut open_brackets_count_map_sorted_reverse\
    \ = HashMap::new();\n   |                                                    \
    \  ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmpf7zap2lw.rs:21:55\n   |\n21\
    \ |     let mut close_brackets_count_map_sorted_"
  stdout: ''
  timestamp: 1659749137
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ {\n        c != '<' && c != '>'\n    })\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmptmenvxhd.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    while brackets.len() > 0 {\n\
    \        let mut open_bracket = String::new();\n        let mut close_bracket\
    \ = String::new();\n        if brackets.starts_with(\"<<\") {\n            open_bracket\
    \ = brackets.split_off(1).unwrap();\n            close_bracket = brackets.split_off(1).unwrap();\n\
    \            brackets = brackets.split_off(1).unwrap();\n        }\n        if\
    \ brackets.starts_with(\"<>\") {\n            open_bracket = brackets.split_off(2).unwrap();\n\
    \            close_bracket = brackets.split_off(2).unwrap();\n            brackets\
    \ = brackets.split_off(2).unwrap();\n        }\n        if brackets.starts_with(\"\
    <\") {\n            open_bracket = brackets.split_off(1).unwrap();\n         \
    \   close_bracket = brackets.split_off(1).unwrap();\n            brackets = brackets.split_off(1).unwrap();\n\
    \        }\n        if brackets.starts_with(\">\") {\n            open_bracket\
    \ = brackets.split_off(1).unwrap();\n            close_bracket = brackets.split_off(1).unwrap();\n\
    \            brackets = brackets.split_off(1).unwrap();\n        }\n        if\
    \ open_bracket.len() == 0 {\n            return false;\n        }\n        if\
    \ close_bracket.len() == 0 {\n            return false;\n        }\n        if\
    \ open_bracket.starts_with(close_bracket) {\n            open_brackets.push_str(open_bracket);\n\
    \            close_brackets.push_str(close_bracket);\n        } else {\n     \
    \       return false;\n        }\n    }\n    if open_brackets.len() != close_brackets.len()\
    \ {\n        return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpunnwv134.rs:19:50\n   |\n19 |             open_bracket\
    \ = brackets.split_off(1).unwrap();\n   |                                    \
    \              ^^^^^^ method not found in `String`\n\nerror[E0599]: no method\
    \ named `unwrap` found for struct `String` in the current scope\n  --> /tmp/tmpunnwv134.rs:20:51\n\
    \   |\n20 |             close_bracket = brackets.split_off(1).unwrap();\n   |\
    \                                                   ^^^^^^ method not found in\
    \ `String`\n\nerror[E0599]: no method named `unwrap` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpunnwv134.rs:21:46\n   |\n21 |          \
    \   brackets = brackets.split_off(1).unwrap();\n   |                         \
    \                     ^^^^^^ method not found in `String`\n\nerror[E0599]: no\
    \ method named `unwrap` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpunnwv134.rs:24:50\n   |\n24 |             open_bracket = brackets.split_off(2).unwrap();\n\
    \   |                                                  ^^^^^^ method not found\
    \ in `String`\n\nerror[E0599]: no method named `unwrap` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpunnwv134.rs:25:51\n   |\n25 |          \
    \   close_bracket = brackets.split_off(2).unwrap();\n   |                    \
    \                               ^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `unwrap` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpunnwv134.rs:26:46\n   |\n26 |             brackets = brackets.split_off(2).unwrap();\n\
    \   |                                              ^^^^^^ method not found in\
    \ `String`\n\nerror[E0599]: no method named `unwrap` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpunnwv134.rs:29:50\n   |\n29 |          \
    \   open_bracket = brackets.split_off(1).unwrap();\n   |                     \
    \                             ^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `unwrap` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpunnwv134.rs:30"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\">\", \"\");\n    brackets.replace(\"<<\", \"\");\n    brackets.replace(\"\
    >>\", \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\"\
    );\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp_2vks7xx.rs:91:56\n\
    \   |\n91 |       assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    \   |  ________________________________________________________^\n92 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659749137
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    for bracket in brackets.chars() {\n        if bracket == '<' {\n        \
    \    open_brackets.push('>');\n            close_brackets.push('<');\n       \
    \ } else if bracket == '>' {\n            open_brackets.push('<');\n         \
    \   close_brackets.push('>');\n        } else {\n            open_brackets.push(bracket);\n\
    \            close_brackets.push(bracket);\n        }\n    }\n    open_brackets.chars().all(|c|\
    \ close_brackets.chars().any(|c| c == c))\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqjuq_pv_.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    let mut opening_brackets_stack = Vec::new();\n    let mut closing_brackets_stack\
    \ = Vec::new();\n    let mut opening_brackets_stack_size = opening_brackets_stack.len();\n\
    \    let mut closing_brackets_stack_size = closing_brackets_stack.len();\n   \
    \ let mut opening_brackets_stack_ptr = &mut opening_brackets_stack[opening_brackets_stack_size];\n\
    \    let mut closing_brackets_stack_ptr = &mut closing_brackets_stack[closing_brackets_stack_size];\n\
    \    let mut opening_brackets_stack_ptr_next = &mut opening_brackets_stack[opening_brackets_stack_size];\n\
    \    let mut closing_brackets_stack_ptr_next = &mut closing_brackets_stack[closing_brackets_stack_size];\n\
    \    let mut opening_brackets_stack_ptr_next_next = &mut opening_brackets_stack[opening_brackets_stack_size];\n\
    \    let mut closing_brackets_stack_ptr_next_next = &mut closing_brackets_stack[closing_brackets_stack_size];\n\
    \    let mut opening_brackets_stack_ptr_next_next_next = &mut opening_brackets_stack[opening_brackets_stack_size];\n\
    \    let mut closing_brackets_stack_ptr_next_next_next = &mut closing_brackets_stack[closing_brackets_stack_size];\n\
    \    let mut opening_brackets_stack_ptr_next_next_next_next = &mut opening_brackets_stack[opening_brackets_stack_size];\n\
    \    let mut closing_brackets_stack_ptr_next_next_next_next = &mut closing_brackets_stack[closing_brackets_stack_size];\n\
    \    let mut opening_brackets_stack_ptr_next_next_next_next_next = &mut opening_brackets_stack[opening_brackets_stack_size];\n\
    \    let mut closing_brackets_stack_ptr_next_next_next_next_next = &mut closing_brackets_stack[closing_brackets_stack_size];\n\
    \    let mut opening_b\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmph7l52h7f.rs:30:22\n   |\n\
    30 |     let mut opening_b\n   |                      ^ help: add `;` here\n31\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph7l52h7f.rs:11:44\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749137
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_iter = brackets.chars().enumerate();\n    let mut close_brackets_iter\
    \ = brackets.chars().enumerate();\n    let mut open_brackets_next = open_brackets_iter.next();\n\
    \    let mut close_brackets_next = close_brackets_iter.next();\n    while open_brackets_next.is_some()\
    \ && close_brackets_next.is_some() {\n        let open_bracket = open_brackets_next.unwrap();\n\
    \        let close_bracket = close_brackets_next.unwrap();\n        if open_bracket.1.is_whitespace()\
    \ {\n            open_brackets_next = open_brackets_iter.next();\n        }\n\
    \        if close_bracket.1.is_whitespace() {\n            close_brackets_next\
    \ = close_brackets_iter.next();\n        }\n        if open_bracket.1 == close_bracket.1\
    \ {\n            open_brackets.push_str(open_bracket.0);\n            close_brackets.push_str(close_bracket.0);\n\
    \            open_brackets_next = open_brackets_iter.next();\n            close_brackets_next\
    \ = close_brackets_iter.next();\n        } else {\n            if open_bracket.1\
    \ == \">\" {\n                open_brackets.push_str(open_bracket.0);\n      \
    \          open_brackets_next = open_brackets_iter.next();\n            } else\
    \ {\n                open_brackets.push_str(open_bracket.0);\n               \
    \ close_brackets.push_str(open_bracket.0);\n                close_brackets_next\
    \ = close_brackets_iter.next();\n            }\n        }\n    }\n    open_brackets.len()\
    \ == close_brackets.len()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppn9qflod.rs:28:36\n   |\n\
    28 |             open_brackets.push_str(open_bracket.0);\n   |               \
    \                     ^^^^^^^^^^^^^^ expected `&str`, found `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmppn9qflod.rs:29:37\n   |\n29 |             close_brackets.push_str(close_bracket.0);\n\
    \   |                                     ^^^^^^^^^^^^^^^ expected `&str`, found\
    \ `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppn9qflod.rs:33:34\n\
    \   |\n33 |             if open_bracket.1 == \">\" {\n   |                   \
    \               ^^^ expected `char`, found `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmppn9qflod.rs:34:40\n   |\n34 |                 open_brackets.push_str(open_bracket.0);\n\
    \   |                                        ^^^^^^^^^^^^^^ expected `&str`, found\
    \ `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppn9qflod.rs:37:40\n\
    \   |\n37 |                 open_brackets.push_str(open_bracket.0);\n   |    \
    \                                    ^^^^^^^^^^^^^^ expected `&str`, found `usize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmppn9qflod.rs:38:41\n   |\n38 |\
    \                 close_brackets.push_str(open_bracket.0);\n   |             \
    \                            ^^^^^^^^^^^^^^ expected `&str`, found `usize`\n\n\
    error: aborting due to 6 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\">\", \"\");\n    brackets.replace(\"<<\", \"\");\n    brackets.replace(\"\
    >>\", \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpxq21qjci.rs:65:1\n   |\n65\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxq21qjci.rs:64:5\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                  ---- expected `bool` because of return type\n\
    ...\n64 |     brackets.\n   |     ^^^^^^^^ expected `bool`, found struct `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    for ch in brackets.chars() {\n        if\
    \ ch == '<' {\n            stack.push(0);\n        } else if ch == '>' {\n   \
    \         if stack.len() == 0 {\n                return false;\n            }\n\
    \            stack.pop();\n        } else {\n            if stack.len() == 0 {\n\
    \                return false;\n            }\n            stack.push(stack.len()\
    \ - 1);\n        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    for ch in brackets.chars() {\n        if\
    \ ch == '<' {\n            stack.push(0);\n        } else {\n            if let\
    \ Some(index) = (stack.last_mut() + 1).cloned() {\n                stack[index]\
    \ = ch;\n            } else {\n                return false;\n            }\n\
    \        }\n    }\n    stack.last_mut().map(|i| stack.pop()).unwrap_or(true)\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot add `{integer}` to `Option<&mut usize>`\n  --> /tmp/tmps1p8w68c.rs:17:52\n\
    \   |\n17 |             if let Some(index) = (stack.last_mut() + 1).cloned() {\n\
    \   |                                   ---------------- ^ - {integer}\n   | \
    \                                  |\n   |                                   Option<&mut\
    \ usize>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps1p8w68c.rs:24:53\n\
    \   |\n24 |     stack.last_mut().map(|i| stack.pop()).unwrap_or(true)\n   |  \
    \                                                   ^^^^ expected enum `Option`,\
    \ found `bool`\n   |\n   = note: expected enum `Option<usize>`\n             \
    \ found type `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps1p8w68c.rs:24:5\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                  ---- expected `bool` because of return type\n\
    ...\n24 |     stack.last_mut().map(|i| stack.pop()).unwrap_or(true)\n   |    \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found\
    \ enum `Option`\n   |\n   = note: expected type `bool`\n              found enum\
    \ `Option<usize>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0369.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().skip_while(|c| !c.is_ascii_letter()).collect());\n\
    \    while stack.len() > 0 {\n        let mut current = stack.pop().unwrap();\n\
    \        if current == '<' {\n            stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).collect());\n        } else if current == '>' {\n    \
    \        stack.push(brackets.chars().skip_while(|c| !c.is_ascii_letter()).collect());\n\
    \        } else {\n            return false;\n        }\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpbe0me1kk.rs:13:51\n   |\n13 |     stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).collect());\n   |                                    \
    \               ^^^^^^^^^^^^^^^ method not found in `&char`\n\nerror[E0599]: no\
    \ method named `is_ascii_letter` found for reference `&char` in the current scope\n\
    \  --> /tmp/tmpbe0me1kk.rs:17:59\n   |\n17 |             stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).collect());\n   |                                    \
    \                       ^^^^^^^^^^^^^^^ method not found in `&char`\n\nerror[E0599]:\
    \ no method named `is_ascii_letter` found for reference `&char` in the current\
    \ scope\n  --> /tmp/tmpbe0me1kk.rs:19:59\n   |\n19 |             stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).collect());\n   |                                    \
    \                       ^^^^^^^^^^^^^^^ method not found in `&char`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for c in brackets.chars() {\n        if c == '<'\
    \ {\n            stack.push(c);\n        } else if c == '>' {\n            if\
    \ stack.len() == 0 {\n                return false;\n            }\n         \
    \   stack.pop();\n        } else {\n            if stack.len() != 0 {\n      \
    \          return false;\n            }\n        }\n    }\n    stack.len() ==\
    \ 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut opening_brackets = String::new();\n   \
    \ let mut closing_brackets = String::new();\n    let mut opening_brackets_count\
    \ = String::new();\n    let mut closing_brackets_count = String::new();\n    let\
    \ mut opening_brackets_count_stack = String::new();\n    let mut closing_brackets_count_stack\
    \ = String::new();\n    let mut opening_brackets_count_stack = String::new();\n\
    \    let mut closing_brackets_count_stack = String::new();\n    let mut opening_brackets_count_stack\
    \ = String::new();\n    let mut closing_brackets_count_stack = String::new();\n\
    \    let mut opening_brackets_count_stack = String::new();\n    let mut closing_brackets_count_stack\
    \ = String::new();\n    let mut opening_brackets_count_stack = String::new();\n\
    \    let mut closing_brackets_count_stack = String::new();\n    let mut opening_brackets_count_stack\
    \ = String::new();\n    let mut closing_brackets_count_stack = String::new();\n\
    \    let mut opening_brackets_count_stack = String::new();\n    let mut closing_brackets_count_stack\
    \ = String::new();\n    let mut opening_brackets_count_stack = String::new();\n\
    \    let mut closing_brackets_count_stack = String::new();\n    let mut opening_brackets_count_stack\
    \ = String::new();\n    let mut closing_brackets_count_stack = String::new();\n\
    \    let mut opening_brackets_count_stack = String::new();\n    let mut closing_brackets_count_stack\
    \ = String::new();\n    let mut opening_brackets_count_stack = String::new();\n\
    \    let mut closing_brackets_count_stack = String::new();\n    let mut opening_brackets_count_stack\
    \ = String::new();\n    let mut closing_brackets_count_stack = String::new();\n\
    \    let mut opening_brackets_count_stack = String::new();\n    let mut closing_brackets_count_stack\
    \ = String::new();\n    let mut opening_brackets_count_stack = String::new();\n\
    \n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb509b_8x.rs:11:44\n   |\n\
    11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749137
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    let mut open_brackets: Vec<usize> = vec![];\n\
    \    let mut close_brackets: Vec<usize> = vec![];\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_bra\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwr52jbg_.rs:50:22\n   |\n\
    50 |     let mut close_bra\n   |                      ^ help: add `;` here\n51\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwr52jbg_.rs:11:44\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749137
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == '<' || c == '>')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp2pvnwbzp.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    let mut open_brackets: Vec<usize> = vec![];\n\
    \    let mut close_brackets: Vec<usize> = vec![];\n    let mut open_brackets_idx:\
    \ usize = 0;\n    let mut close_brackets_idx: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_idx2:\
    \ usize = 0;\n    let mut close_brackets_idx2: usize = 0;\n    let mut open_brackets_size2:\
    \ usize = 0;\n    let mut close_brackets_size2: usize = 0;\n    let mut open_brackets_idx3:\
    \ usize = 0;\n    let mut close_brackets_idx3: usize = 0;\n    let mut open_brackets_size3:\
    \ usize = 0;\n    let mut close_brackets_size3: usize = 0;\n    let mut open_brackets_idx4:\
    \ usize = 0;\n    let mut close_brackets_idx4: usize = 0;\n    let mut open_brackets_size4:\
    \ usize = 0;\n    let mut close_brackets_size4: usize = 0;\n    let mut open_brackets_idx5:\
    \ usize = 0;\n    let mut close_brackets_idx5: usize = 0;\n    let mut open_brackets_size5:\
    \ usize = 0;\n    let mut close_brackets_size5: usize = 0;\n    let mut open_brackets_idx6:\
    \ usize = 0;\n    let mut close_brackets_idx6: usize = 0;\n    let mut open_brackets_size6:\
    \ usize = 0;\n    let mut close_brackets_size6: usize = 0;\n    let mut open_brackets_idx7:\
    \ usize = 0;\n    let mut close_brackets_idx7: usize = 0;\n    let mut open_brackets_size7:\
    \ usize = 0;\n    let mut close_brackets_size7: usize = 0;\n    let mut open_brackets_idx8:\
    \ usize = 0;\n    let mut close_brackets_idx8: usize = 0;\n    let mut open_brackets_size8:\
    \ usize = 0;\n    let mut close_brackets_size8: usize = 0;\n    let mut \n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp79mhn2t5.rs:48:1\n\
    \   |\n48 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659749137
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack\
    \ = Vec::new();\n\n    for bracket in brackets.chars() {\n        if bracket ==\
    \ '<' {\n            open_brackets.push(bracket);\n            open_brackets_stack.push(bracket);\n\
    \        } else if bracket == '>' {\n            close_brackets.push(bracket);\n\
    \            close_brackets_stack.push(bracket);\n        } else if bracket ==\
    \ '{' {\n            if open_brackets_stack.len() > 0 {\n                open_brackets_stack.pop();\n\
    \                open_brackets.push(bracket);\n            } else {\n        \
    \        open_brackets.push(bracket);\n            }\n        } else if bracket\
    \ == '}' {\n            if close_brackets_stack.len() > 0 {\n                close_brackets_stack.pop();\n\
    \                close_brackets.push(bracket);\n            } else {\n       \
    \         close_brackets.push(bracket);\n            }\n        } else {\n   \
    \         if open_brackets_stack.len() > 0 {\n                open_brackets_stack.pop();\n\
    \                open_brackets.push(bracket);\n            } else {\n        \
    \        open_brackets.push(bracket);\n            }\n        }\n    }\n\n   \
    \ if open_brackets.len() != close_brackets.len() {\n        return false;\n  \
    \  }\n\n    let mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets = String::new();\n    let mut close_brackets\
    \ = String::new();\n\n    for bracket in brackets.chars() {\n        if bracket\
    \ == '<' {\n            open_brackets.push(bracket);\n            open_brackets_stack.push(bracket);\n\
    \        } else if bracket == '>' {\n            close_brackets.push(bracket);\n\
    \            close_brackets_stack.push(bracket);\n        } else if bracket ==\
    \ '{' {\n            if open_brackets_stack.len() > 0 {\n                open_brackets_stack.pop();\n\
    \                open_brackets.push(bracket);\n            } else {\n        \
    \        open_brackets.push(bracket);\n            }\n        } else if bracket\
    \ == '}' \n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpxpwnvaez.rs:88:3\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - unclosed delimiter\n...\n57 |     for\
    \ bracket in brackets.chars() {\n   |                                     - this\
    \ delimiter might not be properly closed...\n...\n72 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n88 | }\n   |   ^\n\nerror: expected\
    \ `{`, found `}`\n  --> /tmp/tmpxpwnvaez.rs:72:1\n   |\n71 |         } else if\
    \ bracket == '}' \n   |                -- this `if` expression has a condition,\
    \ but no block\n72 | }\n   | ^ expected `{`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxpwnvaez.rs:11:44\n   |\n11 | fn correct_bracketing(brackets: String)\
    \ -> bool {\n   |    ------------------                      ^^^^ expected `bool`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749137
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for c in brackets.chars() {\n        if c == '<'\
    \ {\n            stack.push(c);\n        } else if c == '>' {\n            if\
    \ stack.len() == 0 {\n                return false;\n            }\n         \
    \   stack.pop();\n        } else {\n            if stack.len() != 0 {\n      \
    \          return false;\n            }\n        }\n    }\n    stack.len() ==\
    \ 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749138
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == '<' || c == '>')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp2pvnwbzp.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().skip_while(|c| !c.is_ascii_letter()).collect::<Vec<_>>());\n\
    \    loop {\n        if stack.len() == 0 {\n            return false;\n      \
    \  }\n        let mut current = stack.pop().unwrap();\n        if current == \"\
    >\" || current == \"<\" {\n            stack.push(current);\n        } else {\n\
    \            return false;\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpczxq88fy.rs:13:51\n   |\n13 |     stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).collect::<Vec<_>>());\n   |                          \
    \                         ^^^^^^^^^^^^^^^ method not found in `&char`\n\nerror[E0277]:\
    \ can't compare `Vec<char>` with `&str`\n  --> /tmp/tmpczxq88fy.rs:19:20\n   |\n\
    19 |         if current == \">\" || current == \"<\" {\n   |                 \
    \   ^^ no implementation for `Vec<char> == &str`\n   |\n   = help: the trait `PartialEq<&str>`\
    \ is not implemented for `Vec<char>`\n\nerror[E0277]: can't compare `Vec<char>`\
    \ with `&str`\n  --> /tmp/tmpczxq88fy.rs:19:38\n   |\n19 |         if current\
    \ == \">\" || current == \"<\" {\n   |                                      ^^\
    \ no implementation for `Vec<char> == &str`\n   |\n   = help: the trait `PartialEq<&str>`\
    \ is not implemented for `Vec<char>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    let mut opening_brackets = String::new();\n\
    \    let mut closing_brackets = String::new();\n    while brackets.len() > 0 {\n\
    \        let mut opening_bracket = String::new();\n        let mut closing_bracket\
    \ = String::new();\n        let mut opening_brackets = String::new();\n      \
    \  let mut closing_brackets = String::new();\n        while brackets.len() > 0\
    \ {\n            let mut opening_bracket = brackets.chars().next().unwrap();\n\
    \            let mut closing_bracket = brackets.chars().next().unwrap();\n   \
    \         if opening_bracket.chars().any(|c| !c.is_ascii_letter()) {\n       \
    \         opening_bracket = opening_bracket.to_string();\n            }\n    \
    \        if closing_bracket.chars().any(|c| !c.is_ascii_letter()) {\n        \
    \        closing_bracket = closing_bracket.to_string();\n            }\n     \
    \       if opening_bracket.chars().any(|c| !c.is_ascii_letter()) {\n         \
    \       opening_bracket = opening_bracket.to_string();\n            }\n      \
    \      if closing_bracket.chars().any(|c| !c.is_ascii_letter()) {\n          \
    \      closing_bracket = closing_bracket.to_string();\n            }\n       \
    \     if opening_bracket.chars().any(|c| !c.is_ascii_letter()) {\n           \
    \     opening_bracket = opening_bracket.to_string();\n            }\n        \
    \    if closing_bracket.chars().any(|c| !c.is_ascii_letter()) {\n            \
    \    closing_bracket = closing_bracket.to_string();\n            }\n         \
    \   if opening_bracket.chars().any(|c| !c.is_ascii_letter()) {\n             \
    \   opening_bracket = opening_bracket.to_string();\n            }\n          \
    \  if closing_bracket.chars().any(|c| !c.is_ascii_letter()) {\n              \
    \  closing_bracket = closing_bracket.to_string();\n            }\n           \
    \ if opening_bracket.chars().any(|c| !c.is_ascii_letter()) {\n               \
    \ opening_bracket = opening_bracket.to_string();\n            }\n            if\
    \ closing_bracket.chars().any(|c| !c.is_ascii_letter()) {\n                closing_bracket\
    \ = closing_bracket.to_string();\n            }\n            if opening_bracket.chars().\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp8zqvbo0m.rs:70:3\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - unclosed delimiter\n...\n15 |     while\
    \ brackets.len() > 0 {\n   |                              - unclosed delimiter\n\
    ...\n20 |         while brackets.len() > 0 {\n   |                           \
    \       - this delimiter might not be properly closed...\n...\n54 | }\n   | -\
    \ ...as it matches this but it has different indentation\n...\n70 | }\n   |  \
    \ ^\n\nerror: unexpected token: `}`\n  --> /tmp/tmp8zqvbo0m.rs:54:1\n   |\n54\
    \ | }\n   | ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmp8zqvbo0m.rs:54:1\n\
    \   |\n53 |             if opening_bracket.chars().\n   |             -- this\
    \ `if` expression has a condition, but no block\n54 | }\n   | ^ expected `{`\n\
    \nerror[E0599]: no method named `chars` found for type `char` in the current scope\n\
    \  --> /tmp/tmp8zqvbo0m.rs:23:32\n   |\n23 |             if opening_bracket.chars().any(|c|\
    \ !c.is_ascii_letter()) {\n   |                                ^^^^^ method not\
    \ found in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8zqvbo0m.rs:24:35\n\
    \   |\n24 |                 opening_bracket = opening_bracket.to_string();\n \
    \  |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found struct `String`\n\nerror[E0599]: no method named `chars` found for type\
    \ `char` in the current scope\n  --> /tmp/tmp8zqvbo0m.rs:26:32\n   |\n26 |   \
    \          if closing_bracket.chars().any(|c| !c.is_ascii_letter()) {\n   |  \
    \                              ^^^^^ method not found in `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8zqvbo0m.rs:27:35\n   |\n27 |              \
    \   closing_bracket = closing_bracket.to_string();\n   |                     \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \nerror[E0599]: no method named `chars` found for type `char` in the current scope\n\
    \  --> /tmp/tmp8zqvbo0m.rs:29:32\n   |\n29 |             if opening_bracket.chars().any(|c|\
    \ !c.is_ascii_letter()) {\n   |            "
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\">\", \"\");\n    brackets.replace(\"<<\", \"\");\n    brackets.replace(\"\
    >>\", \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    bracket\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `bracket` in this scope\n  --> /tmp/tmpqqz_o7zx.rs:72:5\n\
    \   |\n72 |     bracket\n   |     ^^^^^^^ help: a local variable with a similar\
    \ name exists: `brackets`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ {\n        c != '<' && c != '>'\n    })\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmptmenvxhd.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_iter = brackets.chars().enumerate().filter(|&(_, c)|\
    \ c != '<').collect::<Vec<_>>();\n    let mut close_brackets_iter = brackets.chars().enumerate().filter(|&(_,\
    \ c)| c != '>').collect::<Vec<_>>();\n    let mut open_brackets_iter = open_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut close_brackets_iter = close_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut open_brackets_iter = open_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut close_brackets_iter = close_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut open_brackets_iter = open_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut close_brackets_iter = close_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut open_brackets_iter = open_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut close_brackets_iter = close_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut open_brackets_iter = open_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut close_brackets_iter = close_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut open_brackets_iter = open_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut close_brackets_iter = close_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut open_brackets_iter = open_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut close_brackets_iter = close_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut open_brackets_iter = open_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut close_brackets_iter = close_bracket\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpoo_u4ob5.rs:31:48\n   |\n\
    31 |     let mut close_brackets_iter = close_bracket\n   |                   \
    \                             ^ help: add `;` here\n32 | }\n   | - unexpected\
    \ token\n\nerror[E0425]: cannot find value `close_bracket` in this scope\n  -->\
    \ /tmp/tmpoo_u4ob5.rs:31:35\n   |\n31 |     let mut close_brackets_iter = close_bracket\n\
    \   |                                   ^^^^^^^^^^^^^ help: a local variable with\
    \ a similar name exists: `close_brackets`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpoo_u4ob5.rs:11:44\n   |\n11 | fn correct_bracketing(brackets: String)\
    \ -> bool {\n   |    ------------------                      ^^^^ expected `bool`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut opening_brackets = String::new();\n   \
    \ let mut closing_brackets = String::new();\n    let mut opening_brackets_count\
    \ = String::new();\n    let mut closing_brackets_count = String::new();\n    let\
    \ mut opening_brackets_count_stack = Vec::new();\n    let mut closing_brackets_count_stack\
    \ = Vec::new();\n    let mut opening_brackets_count_stack = Vec::new();\n    let\
    \ mut closing_brackets_count_stack = Vec::new();\n    let mut opening_brackets_count_stack\
    \ = Vec::new();\n    let mut closing_brackets_count_stack = Vec::new();\n    let\
    \ mut opening_brackets_count_stack = Vec::new();\n    let mut closing_brackets_count_stack\
    \ = Vec::new();\n    let mut opening_brackets_count_stack = Vec::new();\n    let\
    \ mut closing_brackets_count_stack = Vec::new();\n    let mut opening_brackets_count_stack\
    \ = Vec::new();\n    let mut closing_brackets_count_stack = Vec::new();\n    let\
    \ mut opening_brackets_count_stack = Vec::new();\n    let mut closing_brackets_count_stack\
    \ = Vec::new();\n    let mut opening_brackets_count_stack = Vec::new();\n    let\
    \ mut closing_brackets_count_stack = Vec::new();\n    let mut opening_brackets_count_stack\
    \ = Vec::new();\n    let mut closing_brackets_count_stack = Vec::new();\n    let\
    \ mut opening_brackets_count_stack = Vec::new();\n    let mut closing_brackets_count_stack\
    \ = Vec::new();\n    let mut opening_brackets_count_stack = Vec::new();\n    let\
    \ mut closing_brackets_count_stack = Vec::new();\n    let mut opening_brackets_count_stack\
    \ = Vec::new();\n    let mut closing_brackets_count_stack = Vec::new();\n    let\
    \ mut opening_brackets_count_stack = Vec::new();\n    let mut closing_brackets_count_stack\
    \ = Vec::new();\n    let mut opening_brackets_count_stack = Vec::new();\n\n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptn3cvgkw.rs:11:44\n   |\n\
    11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749137
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    while brackets.len() > 0 {\n\
    \        let mut open_bracket = String::new();\n        let mut close_bracket\
    \ = String::new();\n        let mut open_brackets = String::new();\n        let\
    \ mut close_brackets = String::new();\n        while brackets.len() > 0 {\n  \
    \          let mut open_bracket = String::new();\n            let mut close_bracket\
    \ = String::new();\n            let mut open_brackets = String::new();\n     \
    \       let mut close_brackets = String::new();\n            brackets.split_whitespace().for_each(|c|\
    \ {\n                match c {\n                    '<' => open_brackets.push(c),\n\
    \                    '>' => close_brackets.push(c),\n                    _ =>\
    \ (),\n                }\n            });\n            if open_brackets.len()\
    \ == 0 {\n                open_bracket = open_bracket;\n            } else {\n\
    \                open_bracket = open_brackets.join(\" \");\n            }\n  \
    \          if close_brackets.len() == 0 {\n                close_bracket = close_bracket;\n\
    \            } else {\n                close_bracket = close_brackets.join(\"\
    \ \");\n            }\n            open_brackets = open_bracket;\n           \
    \ close_brackets = close_bracket;\n        }\n        open_brackets = open_brackets.join(\"\
    \ \");\n        close_brackets = close_brackets.join(\" \");\n        brackets\
    \ = open_brackets + close_brackets;\n    }\n    brackets == \"\"\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl0psc23z.rs:27:21\n   |\n\
    26 |                 match c {\n   |                       - this expression has\
    \ type `&str`\n27 |                     '<' => open_brackets.push(c),\n   |  \
    \                   ^^^ expected `str`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpl0psc23z.rs:28:21\n   |\n26 |                 match c {\n\
    \   |                       - this expression has type `&str`\n27 |          \
    \           '<' => open_brackets.push(c),\n28 |                     '>' => close_brackets.push(c),\n\
    \   |                     ^^^ expected `str`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpl0psc23z.rs:27:47\n   |\n27 |                     '<' =>\
    \ open_brackets.push(c),\n   |                                               ^\
    \ expected `char`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl0psc23z.rs:28:48\n\
    \   |\n28 |                     '>' => close_brackets.push(c),\n   |         \
    \                                       ^ expected `char`, found `&str`\n\nerror[E0599]:\
    \ no method named `join` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpl0psc23z.rs:35:46\n   |\n35 |                 open_bracket = open_brackets.join(\"\
    \ \");\n   |                                              ^^^^ method not found\
    \ in `String`\n\nerror[E0599]: no method named `join` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpl0psc23z.rs:40:48\n   |\n40 |          \
    \       close_bracket = close_brackets.join(\" \");\n   |                    \
    \                            ^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `join` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpl0psc23z.rs:45:39\n   |\n45 |         open_brackets = open_brackets.join(\"\
    \ \");\n   |                                       ^^^^ method not found in `String`\n\
    \nerror[E0599]: no method named `join` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpl0psc23z.rs:46:41\n   |\n46 |         close_brackets =\
    \ close_brackets.join(\" \");\n   |                                         ^^^^\
    \ method not"
  stdout: ''
  timestamp: 1659749138
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().collect::<Vec<_>>());\n\
    \    while stack.len() > 0 {\n        let mut current = stack.pop().unwrap();\n\
    \        if current.len() == 0 {\n            continue;\n        }\n        let\
    \ mut next = current.clone();\n        let mut found = false;\n        while !next.is_empty()\
    \ {\n            let mut next = next.clone();\n            if let Some(open) =\
    \ next.pop() {\n                if let Some(close) = current.pop() {\n       \
    \             if open == close {\n                        found = true;\n    \
    \                } else {\n                        break;\n                  \
    \  }\n                } else {\n                    break;\n                }\n\
    \            } else {\n                break;\n            }\n        }\n    \
    \    if !found {\n            return false;\n        }\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpm159qllz.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    for c in brackets.chars() {\n        if\
    \ c == '<' {\n            stack.push(brackets.len());\n        }\n        if c\
    \ == '>' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        }\n    }\n    stack.len() ==\
    \ 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749138
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ {\n        c >= '<' && c <= '>'\n    })\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp97buwhrr.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\">\", \"\");\n    brackets.replace(\"<<\", \"\");\n    brackets.replace(\"\
    >>\", \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpfpfabilx.rs:82:56\n\
    \   |\n82 |       assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    \   |  ________________________________________________________^\n83 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for c in brackets.chars() {\n        if c == '<'\
    \ {\n            stack.push(c);\n        } else if c == '>' {\n            if\
    \ stack.is_empty() {\n                return false;\n            }\n         \
    \   stack.pop();\n        } else {\n            if stack.is_empty() {\n      \
    \          return false;\n            }\n            stack.pop();\n          \
    \  stack.push(c);\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749138
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    while let Some(open) = brackets.find('<')\
    \ {\n        if let Some(close) = brackets.find('>') {\n            if open !=\
    \ close {\n                return false;\n            }\n            brackets.remove(open);\n\
    \            brackets.remove(close);\n        } else {\n            return false;\n\
    \        }\n    }\n    brackets.is_empty()\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9xdcp08t.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    for c in brackets {\n        if c == '<' {\n            open_brackets.push(c);\n\
    \        } else if c == '>' {\n            close_brackets.push(c);\n        }\
    \ else {\n            return false;\n        }\n    }\n    if open_brackets.len()\
    \ != close_brackets.len() {\n        return false;\n    }\n    for c in open_brackets\
    \ {\n        if close_brackets.contains(&c) {\n            return false;\n   \
    \     }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n   --> /tmp/tmpozqz3wyv.rs:14:14\n\
    \    |\n14  |     for c in brackets {\n    |              ^^^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help: the\
    \ trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror[E0277]: `String` is not an iterator\n   --> /tmp/tmpozqz3wyv.rs:26:14\n\
    \    |\n26  |     for c in open_brackets {\n    |              ^^^^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help:\
    \ the trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut opening_brackets = Vec::new();\n    let\
    \ mut closing_brackets = Vec::new();\n    let mut opening_bracket = String::new();\n\
    \    let mut closing_bracket = String::new();\n    let mut opening_brackets =\
    \ String::new();\n    let mut closing_brackets = String::new();\n    let mut opening_bracket\
    \ = String::new();\n    let mut closing_bracket = String::new();\n    let mut\
    \ opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    let mut opening_bracket = String::new();\n    let mut closing_bracket = String::new();\n\
    \    let mut opening_brackets = String::new();\n    let mut closing_brackets =\
    \ String::new();\n    let mut opening_bracket = String::new();\n    let mut closing_bracket\
    \ = String::new();\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_brackets = String::new();\n    let mut opening_bracket = String::new();\n\
    \    let mut closing_bracket = String::new();\n    let mut opening_brackets =\
    \ String::new();\n    let mut closing_brackets = String::new();\n    let mut opening_bracket\
    \ = String::new();\n    let mut closing_bracket = String::new();\n    let mut\
    \ opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    let mut opening_bracket = String::new();\n    let mut closing_bracket = String::new();\n\
    \    let mut opening_brackets = String::new();\n    let mut closing_brackets =\
    \ String::new();\n    let mut opening_bracket = String::new();\n    let mut closing_bracket\
    \ = String::new();\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_brackets = String::new();\n    let mut opening_bracket = String::new();\n\
    \    let mut closing_bracket = String::new();\n    let mut opening_brackets =\
    \ String::new();\n    let mu\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_mmr54ss.rs:50:11\n   |\n\
    50 |     let mu\n   |           ^ help: add `;` here\n51 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_mmr54ss.rs:11:44\n \
    \  |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut open_brackets = Vec::new();\n    let mut\
    \ close_brackets = Vec::new();\n    stack.push(brackets);\n    while !stack.is_empty()\
    \ {\n        let mut current = stack.pop();\n        if current.len() == 0 {\n\
    \            continue;\n        }\n        if current.len() == 1 {\n         \
    \   if current == \"<\" {\n                open_brackets.push(current);\n    \
    \        } else {\n                close_brackets.push(current);\n           \
    \ }\n            continue;\n        }\n        let mut open = current.chars().nth(1).unwrap();\n\
    \        let mut close = current.chars().nth(current.len() - 1).unwrap();\n  \
    \      if open == close {\n            stack.push(current);\n            continue;\n\
    \        }\n        if open == \"<\" {\n            stack.push(current);\n   \
    \         stack.push(open);\n            stack.push(close);\n        } else {\n\
    \            stack.push(current);\n            stack.push(\"</\");\n         \
    \   stack.push(open);\n            stack.push(close);\n        }\n    }\n    open_brackets.iter().all(|x|\
    \ close_brackets.iter().any(|y| x == y))\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpecvoklxz.rs:18:20\n   |\n18 |         if current.len()\
    \ == 0 {\n   |                    ^^^ method not found in `Option<String>`\n\n\
    error[E0599]: no method named `len` found for enum `Option` in the current scope\n\
    \  --> /tmp/tmpecvoklxz.rs:21:20\n   |\n21 |         if current.len() == 1 {\n\
    \   |                    ^^^ method not found in `Option<String>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpecvoklxz.rs:22:27\n   |\n22 |             if\
    \ current == \"<\" {\n   |                           ^^^ expected enum `Option`,\
    \ found `&str`\n   |\n   = note:   expected enum `Option<String>`\n          \
    \ found reference `&'static str`\n\nerror[E0599]: no method named `chars` found\
    \ for enum `Option` in the current scope\n  --> /tmp/tmpecvoklxz.rs:29:32\n  \
    \ |\n29 |         let mut open = current.chars().nth(1).unwrap();\n   |      \
    \                          ^^^^^ method not found in `Option<String>`\n\nerror[E0599]:\
    \ no method named `chars` found for enum `Option` in the current scope\n  -->\
    \ /tmp/tmpecvoklxz.rs:30:33\n   |\n30 |         let mut close = current.chars().nth(current.len()\
    \ - 1).unwrap();\n   |                                 ^^^^^ method not found\
    \ in `Option<String>`\n\nerror[E0599]: no method named `len` found for enum `Option`\
    \ in the current scope\n  --> /tmp/tmpecvoklxz.rs:30:53\n   |\n30 |         let\
    \ mut close = current.chars().nth(current.len() - 1).unwrap();\n   |         \
    \                                            ^^^ method not found in `Option<String>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpecvoklxz.rs:32:24\n   |\n32 |\
    \             stack.push(current);\n   |                        ^^^^^^^ expected\
    \ struct `String`, found enum `Option`\n   |\n   = note: expected struct `String`\n\
    \                found enum `Option<String>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpecvoklxz.rs:36:24\n   |\n36 |             stack.push(current);\n\
    \   |                        ^^^^^^^ expected struct `String`, found enum `Option`\n\
    \   |\n   = note: expected struct `String`"
  stdout: ''
  timestamp: 1659749138
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \n    for bracket in brackets.chars() {\n        if bracket == '<' {\n       \
    \     opening_brackets.push('>');\n            closing_brackets.push('<');\n \
    \       } else if bracket == '>' {\n            opening_brackets.push('<');\n\
    \            closing_brackets.push('>');\n        } else {\n            opening_brackets.push(bracket);\n\
    \            closing_brackets.push(bracket);\n        }\n    }\n\n    opening_brackets.chars().all(|c|\
    \ closing_brackets.chars().any(|c| c == c))\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpnozs9dtn.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack_size = open_brackets_stack.len();\n\
    \    let mut close_brackets_stack_size = close_brackets_stack.len();\n    let\
    \ mut open_brackets_stack_pos = 0;\n    let mut close_brackets_stack_pos = 0;\n\
    \    let mut open_brackets_stack_end = open_brackets_stack_size;\n    let mut\
    \ close_brackets_stack_end = close_brackets_stack_size;\n    let mut open_brackets_stack_pos\
    \ = 0;\n    let mut close_brackets_stack_pos = 0;\n    let mut open_brackets_stack_end\
    \ = open_brackets_stack_size;\n    let mut close_brackets_stack_end = close_brackets_stack_size;\n\
    \    let mut open_brackets_stack_pos = 0;\n    let mut close_brackets_stack_pos\
    \ = 0;\n    let mut open_brackets_stack_end = open_brackets_stack_size;\n    let\
    \ mut close_brackets_stack_end = close_brackets_stack_size;\n    let mut open_brackets_stack_pos\
    \ = 0;\n    let mut close_brackets_stack_pos = 0;\n    let mut open_brackets_stack_end\
    \ = open_brackets_stack_size;\n    let mut close_brackets_stack_end = close_brackets_stack_size;\n\
    \    let mut open_brackets_stack_pos = 0;\n    let mut close_brackets_stack_pos\
    \ = 0;\n    let mut open_brackets_stack_end = open_brackets_stack_size;\n    let\
    \ mut close_brackets_stack_end = close_brackets_stack_size;\n    let mut open_brackets_stack_pos\
    \ = 0;\n    let mut close_brackets_stack_pos = 0;\n    let mut open_brackets_stack_end\
    \ = open_brackets_stack_size;\n    let mut close_brackets_stack_end = close_brackets_stack_size;\n\
    \    let mut open_brackets_stack_pos = 0;\n    let mut close_brackets_stack_pos\
    \ = 0;\n    let mut open_brackets_stack_end = open_brackets_stack_size;\n    let\
    \ mut \n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp0f9qufbw.rs:46:1\n\
    \   |\n46 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    let mut open_brackets = String::new();\n\
    \    let mut closed_brackets = String::new();\n    while brackets.len() > 0 {\n\
    \        let mut open_bracket = String::new();\n        let mut closed_bracket\
    \ = String::new();\n        let mut open_brackets = String::new();\n        let\
    \ mut closed_brackets = String::new();\n        while brackets.len() > 0 {\n \
    \           if brackets.starts_with('>') {\n                closed_brackets.push(brackets.trim_start().to_string());\n\
    \                brackets = brackets.trim_end();\n            } else if brackets.starts_with('<')\
    \ {\n                open_brackets.push(brackets.trim_start().to_string());\n\
    \                brackets = brackets.trim_end();\n            } else {\n     \
    \           open_brackets.push(brackets.trim_start().to_string());\n         \
    \       brackets = brackets.trim_end();\n            }\n        }\n        if\
    \ open_brackets.len() > 0 {\n            open_bracket = open_brackets.trim_start().to_string();\n\
    \        }\n        if closed_brackets.len() > 0 {\n            closed_bracket\
    \ = closed_brackets.trim_start().to_string();\n        }\n        if open_bracket.len()\
    \ > 0 && closed_bracket.len() > 0 {\n            return false;\n        }\n  \
    \  }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n  \
    \  assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpom_tig3w.rs:22:38\n   |\n\
    22 |                 closed_brackets.push(brackets.trim_start().to_string());\n\
    \   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpom_tig3w.rs:23:28\n\
    \   |\n23 |                 brackets = brackets.trim_end();\n   |            \
    \                ^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                            |\n   |                            expected struct\
    \ `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpom_tig3w.rs:25:36\n\
    \   |\n25 |                 open_brackets.push(brackets.trim_start().to_string());\n\
    \   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpom_tig3w.rs:26:28\n\
    \   |\n26 |                 brackets = brackets.trim_end();\n   |            \
    \                ^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                            |\n   |                            expected struct\
    \ `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpom_tig3w.rs:28:36\n\
    \   |\n28 |                 open_brackets.push(brackets.trim_start().to_string());\n\
    \   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpom_tig3w.rs:29:28\n\
    \   |\n29 |                 brackets = brackets.trim_end();\n   |            \
    \                ^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                            |\n   |                            expected struct\
    \ `String`, found `&str`\n\nerror: aborting due to 6 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiapp5l8z.rs:11:44\n   |\n\
    11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    for ch in brackets.chars() {\n        if\
    \ ch == '<' {\n            stack.push(0);\n        } else if ch == '>' {\n   \
    \         if stack.len() == 0 {\n                return false;\n            }\n\
    \            let mut i = stack.len() - 1;\n            while i >= 0 {\n      \
    \          if stack[i] == ch {\n                    stack.pop();\n           \
    \     } else {\n                    break;\n                }\n              \
    \  i -= 1;\n            }\n        } else {\n            if stack.len() == 0 {\n\
    \                return false;\n            }\n            let mut i = stack.len()\
    \ - 1;\n            while i >= 0 {\n                if stack[i] == ch {\n    \
    \                stack.pop();\n                } else {\n                    break;\n\
    \                }\n                i -= 1;\n            }\n            stack.push(ch);\n\
    \        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5cqaks1i.rs:22:32\n   |\n\
    22 |                 if stack[i] == ch {\n   |                               \
    \ ^^ expected `usize`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5cqaks1i.rs:35:32\n\
    \   |\n35 |                 if stack[i] == ch {\n   |                        \
    \        ^^ expected `usize`, found `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5cqaks1i.rs:42:24\n   |\n42 |             stack.push(ch);\n   |\
    \                        ^^ expected `usize`, found `char`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\">\", \"\");\n    brackets.replace(\"<<\", \"\");\n    brackets.replace(\"\
    >>\", \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpfpfabilx.rs:82:56\n\
    \   |\n82 |       assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    \   |  ________________________________________________________^\n83 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\"\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmp9wbzn1cu.rs:75:21\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - closing delimiter possibly meant for\
    \ this\n...\n75 |     brackets.replace(\"<\", \"\"\n   |                     ^\
    \ unclosed delimiter\n76 | }\n   | ^ mismatched closing delimiter\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9wbzn1cu.rs:75:5\n   |\n11 |   fn correct_bracketing(brackets:\
    \ String) -> bool {\n   |                                              ---- expected\
    \ `bool` because of return type\n...\n75 | /     brackets.replace(\"<\", \"\"\n\
    76 | | }\n   | |_^ expected `bool`, found struct `String`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for c in brackets.chars() {\n        if c == '<'\
    \ {\n            stack.push(c);\n        } else if c == '>' {\n            if\
    \ stack.len() == 0 {\n                return false;\n            }\n         \
    \   stack.pop();\n        } else {\n            if stack.len() != 0 {\n      \
    \          return false;\n            }\n        }\n    }\n    stack.len() ==\
    \ 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    for bracket in brackets {\n        if bracket == '<' {\n            open_brackets.push('>');\n\
    \            close_brackets.push('<');\n        } else if bracket == '>' {\n \
    \           open_brackets.push('<');\n            close_brackets.push('>');\n\
    \        } else {\n            open_brackets.push(bracket);\n            close_brackets.push(bracket);\n\
    \        }\n    }\n    open_brackets == close_brackets\n}\n\nfn main() {\n   \
    \ let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n   --> /tmp/tmpxv41v05t.rs:14:20\n\
    \    |\n14  |     for bracket in brackets {\n    |                    ^^^^^^^^\
    \ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n \
    \   = help: the trait `Iterator` is not implemented for `String`\n    = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `String`\n\
    note: required by `into_iter`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().skip_while(|c| !c.is_ascii_letter()).collect::<Vec<_>>());\n\
    \    while let Some(mut c) = stack.pop() {\n        if let Some(mut c2) = stack.pop()\
    \ {\n            if c == c2 {\n                stack.push(c);\n            } else\
    \ {\n                return false;\n            }\n        } else {\n        \
    \    return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpfrq3lsqx.rs:13:51\n   |\n13 |     stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).collect::<Vec<_>>());\n   |                          \
    \                         ^^^^^^^^^^^^^^^ method not found in `&char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    while brackets.len() > 0 {\n\
    \        let mut open_bracket = String::new();\n        let mut close_bracket\
    \ = String::new();\n        if brackets.starts_with(\"<<\") {\n            open_bracket\
    \ = \"<\";\n            close_bracket = \">\";\n        }\n        if brackets.starts_with(\"\
    >>\") {\n            open_bracket = \">\";\n            close_bracket = \"<\"\
    ;\n        }\n        if brackets.starts_with(\"<<<\") {\n            open_bracket\
    \ = \"<\";\n            close_bracket = \"<\";\n        }\n        if brackets.starts_with(\"\
    >>>\") {\n            open_bracket = \">\";\n            close_bracket = \">\"\
    ;\n        }\n        if brackets.starts_with(\"<<>\") {\n            open_bracket\
    \ = \"<\";\n            close_bracket = \">\";\n        }\n        if brackets.starts_with(\"\
    <<<\") {\n            open_bracket = \"<\";\n            close_bracket = \"<\"\
    ;\n        }\n        if brackets.starts_with(\">>>\") {\n            open_bracket\
    \ = \">\";\n            close_bracket = \">\";\n        }\n        if brackets.starts_with(\"\
    <<<\") {\n            open_bracket = \"<\";\n            close_bracket = \"<\"\
    ;\n        }\n        if brackets.starts_with(\"<<\") {\n            open_bracket\
    \ = \"<\";\n            close_bracket = \"<\";\n        }\n        if brackets.starts_with(\"\
    >>\") {\n            open_bracket = \">\";\n            close_bracket = \">\"\
    ;\n        }\n        if brackets.starts_with(\"<<\") {\n            open_bracket\
    \ = \"<\";\n            close_bracket = \"<\";\n        }\n        if brackets.starts_with(\"\
    >>\") {\n            open_bracket = \">\";\n            close_bracket = \">\"\
    ;\n        }\n        if brackets.starts_with(\"<<<\") {\n            open_bracket\
    \ = \"<\";\n            close_bracket = \"<\";\n        }\n        if brackets.starts_with(\"\
    <<\") {\n            open_bracket = \"<\";\n            close_bracket = \"<\"\
    ;\n        }\n        if brackets.starts_with(\">>\") {\n            open_bracket\
    \ = \">\";\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmprxo_a29a.rs:92:3\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - unclosed delimiter\n...\n15 |     while\
    \ brackets.len() > 0 {\n   |                              - unclosed delimiter\n\
    ...\n74 |         if brackets.starts_with(\">>\") {\n   |                    \
    \                   - this delimiter might not be properly closed...\n75 |   \
    \          open_bracket = \">\";\n76 | }\n   | - ...as it matches this but it\
    \ has different indentation\n...\n92 | }\n   |   ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprxo_a29a.rs:19:28\n   |\n19 |             open_bracket\
    \ = \"<\";\n   |                            ^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                            |\n   |            \
    \                expected struct `String`, found `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprxo_a29a.rs:20:29\n   |\n20 |             close_bracket\
    \ = \">\";\n   |                             ^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                             |\n   |           \
    \                  expected struct `String`, found `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprxo_a29a.rs:23:28\n   |\n23 |             open_bracket\
    \ = \">\";\n   |                            ^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                            |\n   |            \
    \                expected struct `String`, found `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprxo_a29a.rs:24:29\n   |\n24 |             close_bracket\
    \ = \"<\";\n   |                             ^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                             |\n   |           \
    \                  expected struct `String`, found `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprxo_a29a.rs:27:28\n   |\n27 |             open_bracket\
    \ = \"<\";\n   |                            ^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                            |\n   |            \
    \                expe"
  stdout: ''
  timestamp: 1659749138
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == '>' || c == '<')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmptrk6cdso.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_count = String::new();\n    let mut close_brackets_count\
    \ = String::new();\n    let mut open_brackets_count_map = String::new();\n   \
    \ let mut close_brackets_count_map = String::new();\n    let mut open_brackets_count_map_reverse\
    \ = String::new();\n    let mut close_brackets_count_map_reverse = String::new();\n\
    \    let mut open_brackets_count_map_reverse_map = String::new();\n    let mut\
    \ close_brackets_count_map_reverse_map = String::new();\n    let mut open_brackets_count_map_reverse_map_reverse\
    \ = String::new();\n    let mut close_brackets_count_map_reverse_map_reverse =\
    \ String::new();\n    let mut open_brackets_count_map_reverse_map_reverse_map\
    \ = String::new();\n    let mut close_brackets_count_map_reverse_map_reverse_map\
    \ = String::new();\n    let mut open_brackets_count_map_reverse_map_reverse_map_reverse\
    \ = String::new();\n    let mut close_brackets_count_map_reverse_map_reverse_map_reverse\
    \ = String::new();\n    let mut open_brackets_count_map_reverse_map_reverse_map_reverse_map\
    \ = String::new();\n    let mut close_brackets_count_map_reverse_map_reverse_map_reverse_map\
    \ = String::new();\n    let mut open_brackets_count_map_reverse_map_reverse_map_reverse_map_reverse\
    \ = String::new();\n    let mut close_brackets_count_map_reverse_map_reverse_map_reverse_map_reverse\
    \ = String::new();\n    let mut open_brackets_count_map_reverse_map_reverse_map_reverse_map_reverse_map\
    \ = String::new();\n    let mut close_brackets_count_map_reverse_map_reverse_map_reverse_map_reverse_map\
    \ = String::new();\n    let mut open_brackets_count_map_reverse_map_reverse_map_reverse_map_reverse_map_reverse\
    \ = String::new();\n    let mut close_brackets_count_map_reverse_map_reverse_map_reverse_map_reverse_map_reverse\
    \ = String::new();\n    let mut open_brackets_count_map_reverse_map_reverse_map_reverse_map_reverse_map_reverse_map\
    \ = String::new();\n    let mut close_brackets_count_map_reverse_map_reverse_map_reverse_map_reverse_map_reverse_map\
    \ = String::new();\n    let mut open_brackets_\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpgipdwag0.rs:38:27\n   |\n\
    38 |     let mut open_brackets_\n   |                           ^ help: add `;`\
    \ here\n39 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpgipdwag0.rs:11:44\n   |\n11 | fn correct_bracketing(brackets: String)\
    \ -> bool {\n   |    ------------------                      ^^^^ expected `bool`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for c in brackets.chars() {\n        if c == '<'\
    \ {\n            stack.push(c);\n        } else if c == '>' {\n            if\
    \ stack.len() == 0 {\n                return false;\n            }\n         \
    \   stack.pop();\n        } else {\n            if stack.len() == 0 {\n      \
    \          return false;\n            }\n            stack.pop();\n          \
    \  stack.push(c);\n        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749138
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_iter = brackets.char_indices();\n    let mut close_brackets_iter\
    \ = brackets.char_indices();\n    let mut open_brackets_next = open_brackets_iter.next();\n\
    \    let mut close_brackets_next = close_brackets_iter.next();\n    while let\
    \ Some(open_bracket) = open_brackets_next {\n        if let Some(close_bracket)\
    \ = close_brackets_next {\n            if open_bracket.0 != close_bracket.0 {\n\
    \                return false;\n            }\n            open_brackets_next\
    \ = open_brackets_iter.next();\n            close_brackets_next = close_brackets_iter.next();\n\
    \        } else {\n            open_brackets_next = open_brackets_iter.next();\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmphwxe_zi7.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = Vec::new();\n    for ch in brackets.chars() {\n    \
    \    if ch == '<' {\n            stack.push(0);\n        } else if ch == '>' {\n\
    \            if stack.len() == 0 {\n                return false;\n          \
    \  }\n            stack.pop();\n        } else {\n            if stack.len() ==\
    \ 0 {\n                return false;\n            }\n            stack.push(stack.len()\
    \ - 1);\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749138
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for ch in brackets.chars() {\n        if ch ==\
    \ '<' {\n            stack.push('<');\n        } else if ch == '>' {\n       \
    \     if stack.len() == 0 {\n                return false;\n            }\n  \
    \          stack.pop();\n        } else {\n            if stack.len() == 0 {\n\
    \                return false;\n            }\n            stack.push(ch);\n \
    \       }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\">\", \"\");\n    brackets.replace(\"<<\", \"\");\n    brackets.replace(\"\
    >>\", \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp5fy1z25j.rs:80:56\n\
    \   |\n80 |       assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    \   |  ________________________________________________________^\n81 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening_brackets = brackets.chars().filter(|c| c == '<').collect::<Vec<_>>();\n\
    \    let mut closing_brackets = brackets.chars().filter(|c| c == '>').collect::<Vec<_>>();\n\
    \    opening_brackets.sort_unstable();\n    closing_brackets.sort_unstable();\n\
    \    let mut opening_brackets_iter = opening_brackets.iter();\n    let mut closing_brackets_iter\
    \ = closing_brackets.iter();\n    let mut opening_brackets_next = opening_brackets_iter.next();\n\
    \    let mut closing_brackets_next = closing_brackets_iter.next();\n    while\
    \ opening_brackets_next != None && closing_brackets_next != None {\n        if\
    \ opening_brackets_next == closing_brackets_next {\n            opening_brackets_next\
    \ = opening_brackets_iter.next();\n            closing_brackets_next = closing_brackets_iter.next();\n\
    \        } else {\n            return false;\n        }\n    }\n    opening_brackets_next\
    \ == None && closing_brackets_next == None\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpd14pqhnh.rs:12:62\n\
    \   |\n12 |     let mut opening_brackets = brackets.chars().filter(|c| c == '<').collect::<Vec<_>>();\n\
    \   |                                                              ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpd14pqhnh.rs:13:62\n\
    \   |\n13 |     let mut closing_brackets = brackets.chars().filter(|c| c == '>').collect::<Vec<_>>();\n\
    \   |                                                              ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == '<' || c == '>')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp2pvnwbzp.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    while brackets.len() > 0 {\n     \
    \   let mut opening = brackets.chars().nth(1).unwrap();\n        let mut closing\
    \ = brackets.chars().nth(1).unwrap();\n        if opening != closing {\n     \
    \       return false;\n        }\n        brackets = brackets.chars().nth(2).unwrap();\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnedusp8t.rs:19:20\n   |\n\
    19 |         brackets = brackets.chars().nth(2).unwrap();\n   |              \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                    |\n   |                    expected\
    \ struct `String`, found `char`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut open_brackets = Vec::new();\n    let mut\
    \ close_brackets = Vec::new();\n\n    for bracket in brackets.chars() {\n    \
    \    if bracket == '<' {\n            stack.push(bracket);\n            open_brackets.push(bracket);\n\
    \        } else if bracket == '>' {\n            if stack.len() == 0 {\n     \
    \           return false;\n            }\n            close_brackets.push(stack.pop());\n\
    \        } else if bracket == '{' {\n            if stack.len() == 0 {\n     \
    \           return false;\n            }\n            stack.push(bracket);\n \
    \       } else if bracket == '}' {\n            if stack.len() == 0 {\n      \
    \          return false;\n            }\n            close_brackets.push(stack.pop());\n\
    \        } else {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.push(bracket);\n        }\n    }\n\n    if stack.len()\
    \ != 0 {\n        return false;\n    }\n\n    if open_brackets.len() != close_brackets.len()\
    \ {\n        return false;\n    }\n\n    for open_bracket in open_brackets {\n\
    \        if close_brackets.contains(&open_bracket) {\n            return false;\n\
    \        }\n    }\n\n    return true;\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphrw4in3h.rs:52:36\n   |\n\
    52 |         if close_brackets.contains(&open_bracket) {\n   |               \
    \                     ^^^^^^^^^^^^^ expected enum `Option`, found `char`\n   |\n\
    \   = note: expected reference `&Option<char>`\n              found reference\
    \ `&char`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\"\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmp9wbzn1cu.rs:75:21\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - closing delimiter possibly meant for\
    \ this\n...\n75 |     brackets.replace(\"<\", \"\"\n   |                     ^\
    \ unclosed delimiter\n76 | }\n   | ^ mismatched closing delimiter\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9wbzn1cu.rs:75:5\n   |\n11 |   fn correct_bracketing(brackets:\
    \ String) -> bool {\n   |                                              ---- expected\
    \ `bool` because of return type\n...\n75 | /     brackets.replace(\"<\", \"\"\n\
    76 | | }\n   | |_^ expected `bool`, found struct `String`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\">\", \"\");\n    brackets.replace(\"<<\", \"\");\n    brackets.replace(\"\
    >>\", \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    bracket\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `bracket` in this scope\n  --> /tmp/tmpqqz_o7zx.rs:72:5\n\
    \   |\n72 |     bracket\n   |     ^^^^^^^ help: a local variable with a similar\
    \ name exists: `brackets`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
- exit_code: -1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    let mut open_brackets = Vec::new();\n    let mut close_brackets = Vec::new();\n\
    \    while let Some(open) = stack.pop() {\n        if open == ']' {\n        \
    \    close_brackets.push(open);\n        } else if open == '[' {\n           \
    \ open_brackets.push(open);\n        } else {\n            stack.push(open);\n\
    \        }\n    }\n    close_brackets.iter().all(|c| open_brackets.contains(c))\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659749143
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\">\", \"\");\n    brackets.replace(\"<<\", \"\");\n    brackets.replace(\"\
    >>\", \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpe5dbyfzj.rs:80:56\n\
    \   |\n80 |       assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    \   |  ________________________________________________________^\n81 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    while brackets.len() > 0 {\n\
    \        let mut open_bracket = String::new();\n        let mut close_bracket\
    \ = String::new();\n        let mut bracket = brackets.chars().nth(0).unwrap();\n\
    \        while bracket != '>' {\n            if bracket == '<' {\n           \
    \     open_bracket.push(bracket);\n                bracket = brackets.chars().nth(1).unwrap();\n\
    \            } else {\n                close_bracket.push(bracket);\n        \
    \        bracket = brackets.chars().nth(1).unwrap();\n            }\n        }\n\
    \        if open_bracket.len() > close_bracket.len() {\n            close_brackets.push(close_bracket);\n\
    \        } else {\n            open_brackets.push(open_bracket);\n        }\n\
    \        brackets = brackets.chars().nth(1).unwrap();\n    }\n    open_brackets.len()\
    \ == close_brackets.len()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuijn188m.rs:29:33\n   |\n\
    29 |             close_brackets.push(close_bracket);\n   |                   \
    \              ^^^^^^^^^^^^^ expected `char`, found struct `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpuijn188m.rs:31:32\n   |\n31 |             open_brackets.push(open_bracket);\n\
    \   |                                ^^^^^^^^^^^^ expected `char`, found struct\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuijn188m.rs:33:20\n\
    \   |\n33 |         brackets = brackets.chars().nth(1).unwrap();\n   |       \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                    |\n   |                    expected\
    \ struct `String`, found `char`\n\nerror: aborting due to 3 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    let mut found = false;\n    while !stack.is_empty() {\n        let c = stack.pop().unwrap();\n\
    \        if c == '<' {\n            if stack.len() == 0 {\n                return\
    \ false;\n            }\n            let next = stack.pop().unwrap();\n      \
    \      if next == '>' {\n                found = true;\n            }\n      \
    \      stack.push(c);\n        } else {\n            stack.push(c);\n        }\n\
    \    }\n    found\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpd6m69hue.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\">\", \"\");\n    brackets.replace(\"<<\", \"\");\n    brackets.replace(\"\
    >>\", \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpxq21qjci.rs:65:1\n   |\n65\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxq21qjci.rs:64:5\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                  ---- expected `bool` because of return type\n\
    ...\n64 |     brackets.\n   |     ^^^^^^^^ expected `bool`, found struct `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_iter = brackets.char_indices();\n    let mut close_brackets_iter\
    \ = brackets.char_indices();\n    let mut open_brackets_next = open_brackets_iter.next();\n\
    \    let mut close_brackets_next = close_brackets_iter.next();\n    while let\
    \ Some(next) = open_brackets_next {\n        if let Some(prev) = close_brackets_next\
    \ {\n            if open_brackets.chars().any(|c| c == *prev) {\n            \
    \    open_brackets.push_str(&*open_brackets_next);\n                close_brackets.push_str(&*close_brackets_next);\n\
    \                open_brackets_next = open_brackets_iter.next();\n           \
    \     close_brackets_next = close_brackets_iter.next();\n            } else {\n\
    \                open_brackets.push_str(&*open_brackets_next);\n             \
    \   close_brackets.push_str(&*close_brackets_next);\n                open_brackets_next\
    \ = open_brackets_iter.next();\n                close_brackets_next = close_brackets_iter.next();\n\
    \            }\n        } else {\n            open_brackets.push_str(&*open_brackets_next);\n\
    \            close_brackets.push_str(&*close_brackets_next);\n            open_brackets_next\
    \ = open_brackets_iter.next();\n            close_brackets_next = close_brackets_iter.next();\n\
    \        }\n    }\n    open_brackets.len() == close_brackets.len()\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `(usize, char)` cannot be dereferenced\n  --> /tmp/tmpw2yklv2p.rs:20:51\n\
    \   |\n20 |             if open_brackets.chars().any(|c| c == *prev) {\n   | \
    \                                                  ^^^^^\n\nerror[E0614]: type\
    \ `Option<(usize, char)>` cannot be dereferenced\n  --> /tmp/tmpw2yklv2p.rs:21:41\n\
    \   |\n21 |                 open_brackets.push_str(&*open_brackets_next);\n  \
    \ |                                         ^^^^^^^^^^^^^^^^^^^\n\nerror[E0614]:\
    \ type `Option<(usize, char)>` cannot be dereferenced\n  --> /tmp/tmpw2yklv2p.rs:22:42\n\
    \   |\n22 |                 close_brackets.push_str(&*close_brackets_next);\n\
    \   |                                          ^^^^^^^^^^^^^^^^^^^^\n\nerror[E0614]:\
    \ type `Option<(usize, char)>` cannot be dereferenced\n  --> /tmp/tmpw2yklv2p.rs:26:41\n\
    \   |\n26 |                 open_brackets.push_str(&*open_brackets_next);\n  \
    \ |                                         ^^^^^^^^^^^^^^^^^^^\n\nerror[E0614]:\
    \ type `Option<(usize, char)>` cannot be dereferenced\n  --> /tmp/tmpw2yklv2p.rs:27:42\n\
    \   |\n27 |                 close_brackets.push_str(&*close_brackets_next);\n\
    \   |                                          ^^^^^^^^^^^^^^^^^^^^\n\nerror[E0614]:\
    \ type `Option<(usize, char)>` cannot be dereferenced\n  --> /tmp/tmpw2yklv2p.rs:32:37\n\
    \   |\n32 |             open_brackets.push_str(&*open_brackets_next);\n   |  \
    \                                   ^^^^^^^^^^^^^^^^^^^\n\nerror[E0614]: type\
    \ `Option<(usize, char)>` cannot be dereferenced\n  --> /tmp/tmpw2yklv2p.rs:33:38\n\
    \   |\n33 |             close_brackets.push_str(&*close_brackets_next);\n   |\
    \                                      ^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting\
    \ due to 7 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0614`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\"\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmp9wbzn1cu.rs:75:21\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - closing delimiter possibly meant for\
    \ this\n...\n75 |     brackets.replace(\"<\", \"\"\n   |                     ^\
    \ unclosed delimiter\n76 | }\n   | ^ mismatched closing delimiter\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9wbzn1cu.rs:75:5\n   |\n11 |   fn correct_bracketing(brackets:\
    \ String) -> bool {\n   |                                              ---- expected\
    \ `bool` because of return type\n...\n75 | /     brackets.replace(\"<\", \"\"\n\
    76 | | }\n   | |_^ expected `bool`, found struct `String`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\"\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmp9wbzn1cu.rs:75:21\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - closing delimiter possibly meant for\
    \ this\n...\n75 |     brackets.replace(\"<\", \"\"\n   |                     ^\
    \ unclosed delimiter\n76 | }\n   | ^ mismatched closing delimiter\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9wbzn1cu.rs:75:5\n   |\n11 |   fn correct_bracketing(brackets:\
    \ String) -> bool {\n   |                                              ---- expected\
    \ `bool` because of return type\n...\n75 | /     brackets.replace(\"<\", \"\"\n\
    76 | | }\n   | |_^ expected `bool`, found struct `String`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\"\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmp9wbzn1cu.rs:75:21\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - closing delimiter possibly meant for\
    \ this\n...\n75 |     brackets.replace(\"<\", \"\"\n   |                     ^\
    \ unclosed delimiter\n76 | }\n   | ^ mismatched closing delimiter\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9wbzn1cu.rs:75:5\n   |\n11 |   fn correct_bracketing(brackets:\
    \ String) -> bool {\n   |                                              ---- expected\
    \ `bool` because of return type\n...\n75 | /     brackets.replace(\"<\", \"\"\n\
    76 | | }\n   | |_^ expected `bool`, found struct `String`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack_size = open_brackets_stack.len();\n\
    \    let mut close_brackets_stack_size = close_brackets_stack.len();\n    let\
    \ mut open_brackets_stack_pos = 0;\n    let mut close_brackets_stack_pos = 0;\n\
    \    let mut open_brackets_stack_end = open_brackets_stack_size;\n    let mut\
    \ close_brackets_stack_end = close_brackets_stack_size;\n    let mut open_brackets_stack_top\
    \ = open_brackets_stack_size;\n    let mut close_brackets_stack_top = close_brackets_stack_size;\n\
    \    let mut open_brackets_stack_bottom = open_brackets_stack_size;\n    let mut\
    \ close_brackets_stack_bottom = close_brackets_stack_size;\n    let mut open_brackets_stack_top\
    \ = open_brackets_stack_size;\n    let mut close_brackets_stack_top = close_brackets_stack_size;\n\
    \    let mut open_brackets_stack_bottom = open_brackets_stack_size;\n    let mut\
    \ close_brackets_stack_bottom = close_brackets_stack_size;\n    let mut open_brackets_stack_top\
    \ = open_brackets_stack_size;\n    let mut close_brackets_stack_top = close_brackets_stack_size;\n\
    \    let mut open_brackets_stack_bottom = open_brackets_stack_size;\n    let mut\
    \ close_brackets_stack_bottom = close_brackets_stack_size;\n    let mut open_brackets_stack_top\
    \ = open_brackets_stack_size;\n    let mut close_brackets_stack_top = close_brackets_stack_size;\n\
    \    let mut open_brackets_stack_bottom = open_brackets_stack_size;\n    let mut\
    \ close_brackets_stack_bottom = close_brackets_stack_size;\n    let mut open_brackets_stack_top\
    \ = open_brackets_stack_size;\n    let mut close_brackets_stack_top = close_brackets_stack_size;\n\
    \    let mut open_bra\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpjdkk9g12.rs:40:21\n   |\n\
    40 |     let mut open_bra\n   |                     ^ help: add `;` here\n41 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjdkk9g12.rs:11:44\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\">\", \"\");\n    brackets.replace(\"<<\", \"\");\n    brackets.replace(\"\
    >>\", \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    bracket\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `bracket` in this scope\n  --> /tmp/tmpqqz_o7zx.rs:72:5\n\
    \   |\n72 |     bracket\n   |     ^^^^^^^ help: a local variable with a similar\
    \ name exists: `brackets`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    let mut open_brackets = String::new();\n\
    \    let mut closed_brackets = String::new();\n    while brackets.len() > 0 {\n\
    \        let mut open_bracket = String::new();\n        let mut closed_bracket\
    \ = String::new();\n        if brackets.starts_with(\"<<\") {\n            open_bracket\
    \ = \"<\";\n            closed_bracket = \">\";\n        }\n        if brackets.starts_with(\"\
    <>\") {\n            open_bracket = \"<\";\n            closed_bracket = \">\"\
    ;\n        }\n        if brackets.starts_with(\">>\") {\n            open_bracket\
    \ = \">\";\n            closed_bracket = \">\";\n        }\n        if brackets.starts_with(\"\
    <<<\") {\n            open_bracket = \"<\";\n            closed_bracket = \">\"\
    ;\n        }\n        if brackets.starts_with(\"<>>>\") {\n            open_bracket\
    \ = \"<\";\n            closed_bracket = \">\";\n        }\n        if brackets.starts_with(\"\
    <<>>\") {\n            open_bracket = \"<\";\n            closed_bracket = \"\
    >\";\n        }\n        if brackets.starts_with(\"<<<>>\") {\n            open_bracket\
    \ = \"<\";\n            closed_bracket = \">\";\n        }\n        if brackets.starts_with(\"\
    <><<\") {\n            open_bracket = \"<\";\n            closed_bracket = \"\
    >\";\n        }\n        if brackets.starts_with(\"<><>\") {\n            open_bracket\
    \ = \"<\";\n            closed_bracket = \">\";\n        }\n        if brackets.starts_with(\"\
    <><><<\") {\n            open_bracket = \"<\";\n            closed_bracket = \"\
    >\";\n        }\n        if brackets.starts_with(\"<><><>\") {\n            open_bracket\
    \ = \"<\";\n            closed_bracket = \">\";\n        }\n        if brackets.starts_with(\"\
    <><><><<\") {\n            open_bracket = \"<\";\n            closed_bracket =\
    \ \">\";\n        }\n        if brackets.starts_with(\"<><><><>\") {\n       \
    \     open_bracket = \"<\";\n            closed_bracket = \">\";\n        }\n\
    \        if brackets.starts_with(\"<><><><><<\") {\n            open_bracket =\
    \ \"<\";\n            closed_bracket = \">\";\n        }\n        if brackets.starts_with(\"\
    <><><><><>\") {\n            open_bracket\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpbmfyi73n.rs:92:3\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - unclosed delimiter\n...\n15 |     while\
    \ brackets.len() > 0 {\n   |                              - unclosed delimiter\n\
    ...\n74 |         if brackets.starts_with(\"<><><><><>\") {\n   |            \
    \                                   - this delimiter might not be properly closed...\n\
    75 |             open_bracket\n76 | }\n   | - ...as it matches this but it has\
    \ different indentation\n...\n92 | }\n   |   ^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbmfyi73n.rs:19:28\n   |\n19 |             open_bracket = \"<\"\
    ;\n   |                            ^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                            |\n   |                            expected struct\
    \ `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbmfyi73n.rs:20:30\n\
    \   |\n20 |             closed_bracket = \">\";\n   |                        \
    \      ^^^- help: try using a conversion method: `.to_string()`\n   |        \
    \                      |\n   |                              expected struct `String`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbmfyi73n.rs:23:28\n\
    \   |\n23 |             open_bracket = \"<\";\n   |                          \
    \  ^^^- help: try using a conversion method: `.to_string()`\n   |            \
    \                |\n   |                            expected struct `String`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbmfyi73n.rs:24:30\n\
    \   |\n24 |             closed_bracket = \">\";\n   |                        \
    \      ^^^- help: try using a conversion method: `.to_string()`\n   |        \
    \                      |\n   |                              expected struct `String`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbmfyi73n.rs:27:28\n\
    \   |\n27 |             open_bracket = \">\";\n   |                          \
    \  ^^^- help: try using a conversion method: `.to_string()`\n   |            \
    \                |\n   |               "
  stdout: ''
  timestamp: 1659749139
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack_size = open_brackets_stack.len();\n\
    \    let mut close_brackets_stack_size = close_brackets_stack.len();\n    let\
    \ mut open_brackets_stack_ptr = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut close_brackets_stack_ptr = &mut close_brackets_stack[close_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_next = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut close_brackets_stack_ptr_next = &mut close_brackets_stack[close_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_next_next = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut close_brackets_stack_ptr_next_next = &mut close_brackets_stack[close_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_next_next_next = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut close_brackets_stack_ptr_next_next_next = &mut close_brackets_stack[close_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_next_next_next_next = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut close_brackets_stack_ptr_next_next_next_next = &mut close_brackets_stack[close_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_next_next_next_next_next = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut close_brackets_stack_ptr_next_next_next_next_next = &mut close_brackets_stack[close_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_next_next_next_next_next_next = &mut open_brackets_stack[open\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmp2loctukd.rs:31:1\n   |\n31 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmp2loctukd.rs:30:93\n   |\n11 | fn correct_bracketing(brackets: String)\
    \ -> bool {\n   |                                                 - closing delimiter\
    \ possibly meant for this\n...\n30 |     let mut open_brackets_stack_ptr_next_next_next_next_next_next\
    \ = &mut open_brackets_stack[open\n   |                                      \
    \                                                       ^ unclosed delimiter\n\
    31 | }\n   | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous\
    \ errors\n\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c >= '<' && c <= '>')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplovuwbj0.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_iter = brackets.chars().enumerate().filter(|(_, c)|\
    \ c != '<').collect::<Vec<_>>();\n    let mut close_brackets_iter = brackets.chars().enumerate().filter(|(_,\
    \ c)| c != '>').collect::<Vec<_>>();\n    let mut open_brackets_iter = open_brackets_iter.into_iter().filter(|(_,\
    \ c)| c != '<').collect::<Vec<_>>();\n    let mut close_brackets_iter = close_brackets_iter.into_iter().filter(|(_,\
    \ c)| c != '>').collect::<Vec<_>>();\n    let mut open_brackets_iter = open_brackets_iter.into_iter().filter(|(_,\
    \ c)| c != '<').collect::<Vec<_>>();\n    let mut close_brackets_iter = close_brackets_iter.into_iter().filter(|(_,\
    \ c)| c != '>').collect::<Vec<_>>();\n    let mut open_brackets_iter = open_brackets_iter.into_iter().filter(|(_,\
    \ c)| c != '<').collect::<Vec<_>>();\n    let mut close_brackets_iter = close_brackets_iter.into_iter().filter(|(_,\
    \ c)| c != '>').collect::<Vec<_>>();\n    let mut open_brackets_iter = open_brackets_iter.into_iter().filter(|(_,\
    \ c)| c != '<').collect::<Vec<_>>();\n    let mut close_brackets_iter = close_brackets_iter.into_iter().filter(|(_,\
    \ c)| c != '>').collect::<Vec<_>>();\n    let mut open_brackets_iter = open_brackets_iter.into_iter().filter(|(_,\
    \ c)| c != '<').collect::<Vec<_>>();\n    let mut close_brackets_iter = close_brackets_iter.into_iter().filter(|(_,\
    \ c)| c != '>').collect::<Vec<_>>();\n    let mut open_brackets_iter = open_brackets_iter.into_iter().filter(|(_,\
    \ c)| c != '<').collect::<Vec<_>>();\n    let mut close_brackets_iter = close_bracket\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmptnf7mdk4.rs:27:48\n   |\n\
    27 |     let mut close_brackets_iter = close_bracket\n   |                   \
    \                             ^ help: add `;` here\n28 | }\n   | - unexpected\
    \ token\n\nerror[E0425]: cannot find value `close_bracket` in this scope\n  -->\
    \ /tmp/tmptnf7mdk4.rs:27:35\n   |\n27 |     let mut close_brackets_iter = close_bracket\n\
    \   |                                   ^^^^^^^^^^^^^ help: a local variable with\
    \ a similar name exists: `close_brackets`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmptnf7mdk4.rs:14:81\n   |\n14 |     let mut open_brackets_iter\
    \ = brackets.chars().enumerate().filter(|(_, c)| c != '<').collect::<Vec<_>>();\n\
    \   |                                                                        \
    \         ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmptnf7mdk4.rs:15:82\n   |\n15 |     let mut\
    \ close_brackets_iter = brackets.chars().enumerate().filter(|(_, c)| c != '>').collect::<Vec<_>>();\n\
    \   |                                                                        \
    \          ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmptnf7mdk4.rs:16:83\n   |\n16 |     let mut\
    \ open_brackets_iter = open_brackets_iter.into_iter().filter(|(_, c)| c != '<').collect::<Vec<_>>();\n\
    \   |                                                                        \
    \           ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmptnf7mdk4.rs:17:85\n   |\n17 |     let mut\
    \ close_brackets_iter = close_brackets_iter.into_iter().filter(|(_, c)| c != '>').collect::<Vec<_>>();\n\
    \   |                                                                        \
    \             ^^ no implementation for `&char == char`\n   |\n "
  stdout: ''
  timestamp: 1659749138
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    for bracket in brackets.chars() {\n        if bracket == '<' {\n        \
    \    open_brackets.push('>');\n            close_brackets.push('<');\n       \
    \ } else if bracket == '>' {\n            open_brackets.push('<');\n         \
    \   close_brackets.push('>');\n        } else {\n            open_brackets.push(bracket);\n\
    \            close_brackets.push(bracket);\n        }\n    }\n    open_brackets\
    \ == close_brackets\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpfl7zrlyv.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for c in brackets.chars() {\n        if c == '<'\
    \ {\n            stack.push(c);\n        } else if c == '>' {\n            if\
    \ stack.len() == 0 {\n                return false;\n            }\n         \
    \   stack.pop();\n        } else {\n            if stack.len() == 0 {\n      \
    \          return false;\n            }\n            stack.pop();\n          \
    \  stack.push(c);\n        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\">\", \"\");\n    brackets.replace(\"<<\", \"\");\n    brackets.replace(\"\
    >>\", \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpfpfabilx.rs:82:56\n\
    \   |\n82 |       assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    \   |  ________________________________________________________^\n83 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_iter = brackets.char_indices();\n    let mut close_brackets_iter\
    \ = brackets.char_indices();\n    let mut open_brackets_next = open_brackets_iter.next();\n\
    \    let mut close_brackets_next = close_brackets_iter.next();\n    while let\
    \ Some(next) = open_brackets_next {\n        if let Some(prev) = close_brackets_next\
    \ {\n            if open_brackets.is_empty() {\n                open_brackets\
    \ = String::from(next.0);\n                close_brackets = String::from(prev.0);\n\
    \            } else {\n                if open_brackets.chars().last().unwrap()\
    \ == next.0 {\n                    open_brackets = open_brackets.chars().take_last().unwrap()\
    \ + next.0;\n                } else {\n                    open_brackets = open_brackets.chars().take_last().unwrap()\
    \ + next.0;\n                }\n            }\n        } else {\n            open_brackets\
    \ = open_brackets.chars().take_last().unwrap() + next.0;\n        }\n        open_brackets_next\
    \ = open_brackets_iter.next();\n        close_brackets_next = close_brackets_iter.next();\n\
    \    }\n    open_brackets == close_brackets\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<usize>` is not satisfied\n\
    \   --> /tmp/tmppcvosat7.rs:21:33\n    |\n21  |                 open_brackets\
    \ = String::from(next.0);\n    |                                 ^^^^^^^^^^^^\
    \ the trait `From<usize>` is not implemented for `String`\n    |\n    = help:\
    \ the following implementations were found:\n              <String as From<&String>>\n\
    \              <String as From<&mut str>>\n              <String as From<&str>>\n\
    \              <String as From<Box<str>>>\n            and 2 others\nnote: required\
    \ by `from`\n\nerror[E0277]: the trait bound `String: From<usize>` is not satisfied\n\
    \   --> /tmp/tmppcvosat7.rs:22:34\n    |\n22  |                 close_brackets\
    \ = String::from(prev.0);\n    |                                  ^^^^^^^^^^^^\
    \ the trait `From<usize>` is not implemented for `String`\n    |\n    = help:\
    \ the following implementations were found:\n              <String as From<&String>>\n\
    \              <String as From<&mut str>>\n              <String as From<&str>>\n\
    \              <String as From<Box<str>>>\n            and 2 others\nnote: required\
    \ by `from`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppcvosat7.rs:24:61\n\
    \   |\n24 |                 if open_brackets.chars().last().unwrap() == next.0\
    \ {\n   |                                                             ^^^^^^ expected\
    \ `char`, found `usize`\n\nerror[E0599]: no method named `take_last` found for\
    \ struct `Chars` in the current scope\n  --> /tmp/tmppcvosat7.rs:25:59\n   |\n\
    25 |                     open_brackets = open_brackets.chars().take_last().unwrap()\
    \ + next.0;\n   |                                                           ^^^^^^^^^\
    \ method not found in `Chars<'_>`\n\nerror[E0599]: no method named `take_last`\
    \ found for struct `Chars` in the current scope\n  --> /tmp/tmppcvosat7.rs:27:59\n\
    \   |\n27 |                     open_brackets = open_brackets.chars().take_last().unwrap()\
    \ + next.0;\n   |                                                           ^^^^^^^^^\
    \ method not found in `Chars<'_>`\n\nerror[E0599]: no method named `take_last`\
    \ found for struct `"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \n    for bracket in brackets.chars() {\n        if bracket == '<' {\n       \
    \     open_brackets.push('>');\n            close_brackets.push('<');\n      \
    \  } else if bracket == '>' {\n            open_brackets.push('<');\n        \
    \    close_brackets.push('>');\n        } else if bracket == '{' {\n         \
    \   open_brackets.push('}');\n            close_brackets.push('{');\n        }\
    \ else if bracket == '}' {\n            open_brackets.push('{');\n           \
    \ close_brackets.push('}');\n        } else if bracket == '(' { // TODO: handle\
    \ nested parens\n            open_brackets.push(')');\n            close_brackets.push('(');\n\
    \        } else if bracket == ')' {\n            open_brackets.push('(');\n  \
    \          close_brackets.push(')');\n        } else if bracket == '[' {\n   \
    \         open_brackets.push(']');\n            close_brackets.push('[');\n  \
    \      } else if bracket == ']' {\n            open_brackets.push('[');\n    \
    \        close_brackets.push(']');\n        } else if bracket == '\"' {\n    \
    \        open_brackets.push('\"');\n            close_brackets.push('\"');\n \
    \       } else if bracket == '\\'' {\n            open_brackets.push('\\'');\n\
    \            close_brackets.push('\\'');\n        } else {\n            return\
    \ false;\n        }\n    }\n\n    if open_brackets.len() != close_brackets.len()\
    \ {\n        return false;\n    }\n\n    for open_bracket in open_brackets.chars()\
    \ {\n        if close_brackets.contains(&open_bracket) {\n            return false;\n\
    \        }\n    }\n\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n  --> /tmp/tmpg665q74f.rs:56:36\n\
    \   |\n56 |         if close_brackets.contains(&open_bracket) {\n   |        \
    \                            ^^^^^^^^^^^^^ expected an `Fn<(char,)>` closure,\
    \ found `char`\n   |\n   = help: the trait `Fn<(char,)>` is not implemented for\
    \ `char`\n   = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n   = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&char`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut open_brackets = Vec::new();\n    let mut\
    \ close_brackets = Vec::new();\n    stack.push(brackets);\n    while !stack.is_empty()\
    \ {\n        let mut current = stack.pop();\n        if current.len() == 0 {\n\
    \            continue;\n        }\n        if current.chars().any(|c| c == '<')\
    \ {\n            open_brackets.push(current);\n        }\n        if current.chars().any(|c|\
    \ c == '>') {\n            close_brackets.push(current);\n        }\n        for\
    \ c in current {\n            if c == '<' {\n                stack.push(&current[1..]);\n\
    \            }\n            if c == '>' {\n                let mut current = stack.pop();\n\
    \                let mut open = open_brackets.last();\n                let mut\
    \ close = close_brackets.last();\n                if open == close {\n       \
    \             open_brackets.pop();\n                    close_brackets.pop();\n\
    \                } else {\n                    return false;\n               \
    \ }\n            }\n        }\n    }\n    open_brackets.len() == close_brackets.len()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmp_zruo5ey.rs:18:20\n   |\n18 |         if current.len()\
    \ == 0 {\n   |                    ^^^ method not found in `Option<String>`\n\n\
    error[E0599]: no method named `chars` found for enum `Option` in the current scope\n\
    \  --> /tmp/tmp_zruo5ey.rs:21:20\n   |\n21 |         if current.chars().any(|c|\
    \ c == '<') {\n   |                    ^^^^^ method not found in `Option<String>`\n\
    \nerror[E0599]: no method named `chars` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmp_zruo5ey.rs:24:20\n   |\n24 |         if current.chars().any(|c|\
    \ c == '>') {\n   |                    ^^^^^ method not found in `Option<String>`\n\
    \nerror[E0277]: can't compare `String` with `char`\n  --> /tmp/tmp_zruo5ey.rs:28:18\n\
    \   |\n28 |             if c == '<' {\n   |                  ^^ no implementation\
    \ for `String == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `String`\n\nerror[E0608]: cannot index into a value of type `Option<String>`\n\
    \  --> /tmp/tmp_zruo5ey.rs:29:29\n   |\n29 |                 stack.push(&current[1..]);\n\
    \   |                             ^^^^^^^^^^^^\n\nerror[E0277]: can't compare\
    \ `String` with `char`\n  --> /tmp/tmp_zruo5ey.rs:31:18\n   |\n31 |          \
    \   if c == '>' {\n   |                  ^^ no implementation for `String == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `String`\n\
    \nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599, E0608.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = vec![];\n    for c in brackets.chars() {\n        if c == '<' {\n\
    \            stack.push(c);\n        } else if c == '>' {\n            if stack.is_empty()\
    \ {\n                return false;\n            }\n            stack.pop();\n\
    \        } else {\n            if stack.len() != 0 {\n                return false;\n\
    \            }\n        }\n    }\n    stack.len() == 0 && true\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().skip_while(|c| !c.is_ascii_letter()).collect::<String>());\n\
    \    loop {\n        if stack.len() == 0 {\n            return false;\n      \
    \  }\n        let top = stack.pop().unwrap();\n        if top == \">\" || top\
    \ == \"<\" {\n            stack.push(top);\n        } else {\n            return\
    \ false;\n        }\n    }\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpocnq383u.rs:13:51\n   |\n13 |     stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).collect::<String>());\n   |                          \
    \                         ^^^^^^^^^^^^^^^ method not found in `&char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\"\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmp9wbzn1cu.rs:75:21\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - closing delimiter possibly meant for\
    \ this\n...\n75 |     brackets.replace(\"<\", \"\"\n   |                     ^\
    \ unclosed delimiter\n76 | }\n   | ^ mismatched closing delimiter\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9wbzn1cu.rs:75:5\n   |\n11 |   fn correct_bracketing(brackets:\
    \ String) -> bool {\n   |                                              ---- expected\
    \ `bool` because of return type\n...\n75 | /     brackets.replace(\"<\", \"\"\n\
    76 | | }\n   | |_^ expected `bool`, found struct `String`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for c in brackets {\n        if c == '<' {\n  \
    \          stack.push(c);\n        } else if c == '>' {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.pop();\n\
    \        } else {\n            if stack.len() != 0 {\n                return false;\n\
    \            }\n        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n   \
    \ let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmprh1locet.rs:13:14\n\
    \   |\n13 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut opening_brackets = Vec::new();\n    let\
    \ mut closing_brackets = Vec::new();\n    for c in brackets {\n        if c ==\
    \ '<' {\n            stack.push(c);\n            opening_brackets.push(c);\n \
    \       } else if c == '>' {\n            if stack.len() > 0 {\n             \
    \   let opening_bracket = opening_brackets.pop();\n                let closing_bracket\
    \ = stack.pop();\n                if opening_bracket == closing_bracket {\n  \
    \                  closing_brackets.push(c);\n                } else {\n     \
    \               return false;\n                }\n            } else {\n     \
    \           return false;\n            }\n        } else {\n            stack.push(c);\n\
    \        }\n    }\n    stack.len() == 0 && closing_brackets.len() == 0\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n   --> /tmp/tmpflwf13zd.rs:15:14\n\
    \    |\n15  |     for c in brackets {\n    |              ^^^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help: the\
    \ trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut open_brackets = Vec::new();\n    let mut\
    \ close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n  \
    \  let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = \n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp7fm40r46.rs:52:1\n\
    \   |\n52 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659749137
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = vec![];\n    for c in brackets.chars() {\n        if c == '<' {\n\
    \            stack.push(c);\n        } else if c == '>' {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            let top =\
    \ stack.pop();\n            if top != c {\n                return false;\n   \
    \         }\n        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk0dtd1h5.rs:21:23\n   |\n\
    21 |             if top != c {\n   |                       ^\n   |           \
    \            |\n   |                       expected enum `Option`, found `char`\n\
    \   |                       help: try using a variant of the expected enum: `Some(c)`\n\
    \   |\n   = note: expected enum `Option<char>`\n              found type `char`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\">\", \"\");\n    brackets.replace(\"<<\", \"\");\n    brackets.replace(\"\
    >>\", \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpxq21qjci.rs:65:1\n   |\n65\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxq21qjci.rs:64:5\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                  ---- expected `bool` because of return type\n\
    ...\n64 |     brackets.\n   |     ^^^^^^^^ expected `bool`, found struct `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_iter = brackets.char_indices();\n    let mut close_brackets_iter\
    \ = brackets.char_indices();\n    let mut open_brackets_next = open_brackets_iter.next();\n\
    \    let mut close_brackets_next = close_brackets_iter.next();\n    while open_brackets_next.is_some()\
    \ && close_brackets_next.is_some() {\n        if open_brackets_next.unwrap() ==\
    \ close_brackets_next.unwrap() {\n            open_brackets.push_str(open_brackets_next.unwrap());\n\
    \            close_brackets.push_str(close_brackets_next.unwrap());\n        \
    \    open_brackets_next = open_brackets_iter.next();\n            close_brackets_next\
    \ = close_brackets_iter.next();\n        } else {\n            open_brackets.push_str(open_brackets_next.unwrap());\n\
    \            close_brackets.push_str(\"</>\");\n            open_brackets_next\
    \ = open_brackets_iter.next();\n            close_brackets_next = close_brackets_iter.next();\n\
    \        }\n    }\n    open_brackets.len() == close_brackets.len()\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp93h1970m.rs:20:36\n   |\n\
    20 |             open_brackets.push_str(open_brackets_next.unwrap());\n   |  \
    \                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`,\
    \ found tuple\n   |\n   = note: expected reference `&str`\n                  found\
    \ tuple `(usize, char)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp93h1970m.rs:21:37\n\
    \   |\n21 |             close_brackets.push_str(close_brackets_next.unwrap());\n\
    \   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `&str`, found tuple\n   |\n   = note: expected reference `&str`\n          \
    \        found tuple `(usize, char)`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp93h1970m.rs:25:36\n   |\n25 |             open_brackets.push_str(open_brackets_next.unwrap());\n\
    \   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `&str`, found tuple\n   |\n   = note: expected reference `&str`\n          \
    \        found tuple `(usize, char)`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\"\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmp9wbzn1cu.rs:75:21\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - closing delimiter possibly meant for\
    \ this\n...\n75 |     brackets.replace(\"<\", \"\"\n   |                     ^\
    \ unclosed delimiter\n76 | }\n   | ^ mismatched closing delimiter\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9wbzn1cu.rs:75:5\n   |\n11 |   fn correct_bracketing(brackets:\
    \ String) -> bool {\n   |                                              ---- expected\
    \ `bool` because of return type\n...\n75 | /     brackets.replace(\"<\", \"\"\n\
    76 | | }\n   | |_^ expected `bool`, found struct `String`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    for bracket in brackets.chars() {\n        if bracket == '<' {\n        \
    \    open_brackets.push('>');\n            close_brackets.push('<');\n       \
    \ } else if bracket == '>' {\n            open_brackets.push('<');\n         \
    \   close_brackets.push('>');\n        } else {\n            open_brackets.push(bracket);\n\
    \            close_brackets.push(bracket);\n        }\n    }\n    open_brackets.chars().all(|c|\
    \ close_brackets.chars().any(|c| c == c))\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqjuq_pv_.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().skip_while(|c| !c.is_ascii_letter()).collect());\n\
    \    while let Some(mut c) = stack.pop() {\n        if let Some(mut c2) = stack.pop()\
    \ {\n            if c == c2 {\n                stack.push(c);\n            } else\
    \ {\n                return false;\n            }\n        } else {\n        \
    \    return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpmga4opu7.rs:13:51\n   |\n13 |     stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).collect());\n   |                                    \
    \               ^^^^^^^^^^^^^^^ method not found in `&char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    while !brackets.is_empty() {\n   \
    \     let mut open_bracket = brackets.chars().next().unwrap();\n        if open_bracket\
    \ != '<' {\n            return false;\n        }\n        brackets = &brackets[1..];\n\
    \        let mut close_bracket = brackets.chars().next().unwrap();\n        if\
    \ close_bracket != '>' {\n            return false;\n        }\n        brackets\
    \ = &brackets[1..];\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe_ive2cr.rs:18:20\n   |\n\
    18 |         brackets = &brackets[1..];\n   |                    ^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n18 |         brackets = (&brackets[1..]).to_string();\n   |           \
    \         +              +++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpe_ive2cr.rs:23:20\n   |\n23 |         brackets = &brackets[1..];\n \
    \  |                    ^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n\
    \   |\nhelp: try using a conversion method\n   |\n23 |         brackets = (&brackets[1..]).to_string();\n\
    \   |                    +              +++++++++++++\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_brackets_iter = brackets.char_indices();\n    let mut closed_brackets_iter\
    \ = brackets.char_indices();\n    let mut open_brackets_end = open_brackets.char_indices();\n\
    \    let mut closed_brackets_end = closed_brackets.char_indices();\n    let mut\
    \ open_brackets_iter = open_brackets_iter.next_back();\n    let mut closed_brackets_iter\
    \ = closed_brackets_iter.next_back();\n    let mut open_brackets_end = open_brackets_end.next_back();\n\
    \    let mut closed_brackets_end = closed_brackets_end.next_back();\n    let mut\
    \ open_brackets_iter = open_brackets_iter.next_back();\n    let mut closed_brackets_iter\
    \ = closed_brackets_iter.next_back();\n    let mut open_brackets_end = open_brackets_end.next_back();\n\
    \    let mut closed_brackets_end = closed_brackets_end.next_back();\n    let mut\
    \ open_brackets_iter = open_brackets_iter.next_back();\n    let mut closed_brackets_iter\
    \ = closed_brackets_iter.next_back();\n    let mut open_brackets_end = open_brackets_end.next_back();\n\
    \    let mut closed_brackets_end = closed_brackets_end.next_back();\n    let mut\
    \ open_brackets_iter = open_brackets_iter.next_back();\n    let mut closed_brackets_iter\
    \ = closed_brackets_iter.next_back();\n    let mut open_brackets_end = open_brackets_end.next_back();\n\
    \    let mut closed_brackets_end = closed_brackets_end.next_back();\n    let mut\
    \ open_brackets_iter = open_brackets_iter.next_back();\n    let mut closed_brackets_iter\
    \ = closed_brackets_iter.next_back();\n    let mut open_brackets_end = open_brackets_end.next_back();\n\
    \    let mut closed_brackets_end = closed_brackets_end.next_back();\n    let mut\
    \ open_brackets_iter = open_brackets_iter.next_back();\n    let mut closed_brackets_iter\
    \ = closed_brackets_iter.next_back();\n    let mut open_brackets_end = open_brackets_end.next_back();\n\
    \    let mut closed_brackets_end = close\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp19ph4733.rs:41:40\n   |\n\
    41 |     let mut closed_brackets_end = close\n   |                           \
    \             ^ help: add `;` here\n42 | }\n   | - unexpected token\n\nerror[E0425]:\
    \ cannot find value `close` in this scope\n  --> /tmp/tmp19ph4733.rs:41:35\n \
    \  |\n41 |     let mut closed_brackets_end = close\n   |                     \
    \              ^^^^^ not found in this scope\n\nerror[E0599]: no method named\
    \ `next_back` found for enum `Option` in the current scope\n  --> /tmp/tmp19ph4733.rs:22:53\n\
    \   |\n22 |     let mut open_brackets_iter = open_brackets_iter.next_back();\n\
    \   |                                                     ^^^^^^^^^ method not\
    \ found in `Option<(usize, char)>`\n\nerror[E0599]: no method named `next_back`\
    \ found for enum `Option` in the current scope\n  --> /tmp/tmp19ph4733.rs:23:57\n\
    \   |\n23 |     let mut closed_brackets_iter = closed_brackets_iter.next_back();\n\
    \   |                                                         ^^^^^^^^^ method\
    \ not found in `Option<(usize, char)>`\n\nerror[E0599]: no method named `next_back`\
    \ found for enum `Option` in the current scope\n  --> /tmp/tmp19ph4733.rs:24:51\n\
    \   |\n24 |     let mut open_brackets_end = open_brackets_end.next_back();\n \
    \  |                                                   ^^^^^^^^^ method not found\
    \ in `Option<(usize, char)>`\n\nerror[E0599]: no method named `next_back` found\
    \ for enum `Option` in the current scope\n  --> /tmp/tmp19ph4733.rs:25:55\n  \
    \ |\n25 |     let mut closed_brackets_end = closed_brackets_end.next_back();\n\
    \   |                                                       ^^^^^^^^^ method not\
    \ found in `Option<(usize, char)>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp19ph4733.rs:11:44\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425,\
    \ E0599.\nFor"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\">\", \"\");\n    brackets.replace(\"<<\", \"\");\n    brackets.replace(\"\
    >>\", \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\"\
    , \"\");\n    brackets.replace(\"<>>\", \"\");\n    brackets.replace(\"<<>>\"\
    , \"\");\n    brackets.replace(\"<<><\", \"\");\n    brackets.replace(\"<><>\"\
    , \"\");\n    brackets.replace(\"<<>><\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>><\", \"\");\n    brackets.replace(\"<<><>><><\"\
    , \"\");\n    brackets.replace(\"<<><>><><><\", \"\");\n    brackets.replace(\"\
    <<><>><><><><\", \"\");\n    brackets.replace(\"<<><>><><><><><\", \"\");\n  \
    \  brackets.replace(\"<<><>><><><><><><\", \"\");\n    brackets.replace(\"<<><>><><><><><><><\"\
    , \"\");\n    brackets.replace(\"<<><>><><><><><><><><\", \"\");\n    brackets.replace(\"\
    <<><>><><><><><><><><><\", \"\");\n    brackets.replace(\"<<><>><><><><><><><><><><\"\
    , \"\");\n    brackets.replace(\"<<><>><><><><><><><><><><><\", \"\");\n    brackets.replace(\"\
    <<><>><><><><><><><><><><><\", \"\");\n    brackets.replace(\"<<><>><><><><><><><><><><><><\"\
    , \"\");\n    brackets.replace(\"<<><>><><><><><><><><><><><><\", \"\");\n   \
    \ brackets.replace(\"<<><>><><><><><><><><><><><><><\", \"\");\n    brackets.replace(\"\
    <<><>><><><><><><><><><><><><><\", \"\");\n    brackets.replace(\"<<><>><><><><><><><><><><><><><\"\
    , \"\");\n    brackets.replace(\"<<><>><><><><><><><><><><><><><\", \"\");\n \
    \   brackets.replace(\"<<><>><><><><><><><><><><><><><\", \"\");\n    brackets.replace(\"\
    <<><>><><><><><><><><><><><><><\", \"\");\n    brackets.replace(\"<<><>><><><><><><><><><><\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp1u5htfqu.rs:61:56\n\
    \   |\n61 |       assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    \   |  ________________________________________________________^\n62 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for c in brackets.chars() {\n        if c == '<'\
    \ {\n            stack.push(c);\n        } else if c == '>' {\n            if\
    \ stack.len() == 0 {\n                return false;\n            }\n         \
    \   stack.pop();\n        } else {\n            if stack.len() != 0 {\n      \
    \          return false;\n            }\n        }\n    }\n    stack.len() ==\
    \ 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749138
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == '<' || c == '>')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp2pvnwbzp.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \n    for bracket in brackets.chars() {\n        if bracket == '<' {\n       \
    \     open_brackets.push('>');\n            close_brackets.push('<');\n      \
    \  } else if bracket == '>' {\n            open_brackets.push('<');\n        \
    \    close_brackets.push('>');\n        } else {\n            open_brackets.push(bracket);\n\
    \            close_brackets.push(bracket);\n        }\n    }\n\n    open_brackets.chars().all(|c|\
    \ close_brackets.chars().any(|c| c == c))\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpebnsnlo6.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749139
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    while brackets.len() > 0 {\n\
    \        let mut open_bracket = String::new();\n        let mut close_bracket\
    \ = String::new();\n        let mut open_brackets = String::new();\n        let\
    \ mut close_brackets = String::new();\n        while brackets.len() > 0 {\n  \
    \          if brackets.starts_with(\"<<\") {\n                open_bracket.push(brackets.trim_left_matches(\"\
    <<\"));\n                open_brackets.push(open_bracket);\n                brackets\
    \ = brackets.trim_left_matches(\"<<\");\n            } else if brackets.starts_with(\"\
    >>\") {\n                close_bracket.push(brackets.trim_left_matches(\">>\"\
    ));\n                close_brackets.push(close_bracket);\n                brackets\
    \ = brackets.trim_left_matches(\">>\");\n            } else {\n              \
    \  open_bracket.push(brackets.trim_left_matches(\"<\"));\n                open_brackets.push(open_bracket);\n\
    \                brackets = brackets.trim_left_matches(\"<\");\n            }\n\
    \        }\n        if open_brackets.len() != close_brackets.len() {\n       \
    \     return false;\n        }\n        for open_bracket in open_brackets {\n\
    \            for close_bracket in close_brackets {\n                if open_bracket\
    \ != close_bracket {\n                    return false;\n                }\n \
    \           }\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "warning: use of deprecated associated function `core::str::<impl str>::trim_left_matches`:\
    \ superseded by `trim_start_matches`\n  --> /tmp/tmp9m7ckxag.rs:22:44\n   |\n\
    22 |                 open_bracket.push(brackets.trim_left_matches(\"<<\"));\n\
    \   |                                            ^^^^^^^^^^^^^^^^^ help: replace\
    \ the use of the deprecated associated function: `trim_start_matches`\n   |\n\
    \   = note: `#[warn(deprecated)]` on by default\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9m7ckxag.rs:22:35\n   |\n22 |                 open_bracket.push(brackets.trim_left_matches(\"\
    <<\"));\n   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9m7ckxag.rs:23:36\n\
    \   |\n23 |                 open_brackets.push(open_bracket);\n   |          \
    \                          ^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \nwarning: use of deprecated associated function `core::str::<impl str>::trim_left_matches`:\
    \ superseded by `trim_start_matches`\n  --> /tmp/tmp9m7ckxag.rs:24:37\n   |\n\
    24 |                 brackets = brackets.trim_left_matches(\"<<\");\n   |    \
    \                                 ^^^^^^^^^^^^^^^^^ help: replace the use of the\
    \ deprecated associated function: `trim_start_matches`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9m7ckxag.rs:24:28\n   |\n24 |                 brackets\
    \ = brackets.trim_left_matches(\"<<\");\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \          |\n   |                            expected struct `String`, found\
    \ `&str`\n\nwarning: use of deprecated associated function `core::str::<impl str>::trim_left_matches`:\
    \ superseded by `trim_start_matches`\n  --> /tmp/tmp9m7ckxag.rs:26:45\n   |\n\
    26 |                 close_bracket.push(brackets.trim_left_matches(\">>\"));\n\
    \   |                                             ^^^^^^^^^^^^^^^^^ help: replace\
    \ the use of the deprecated associated function: `trim_start_matches`\n\nerror[E0308]:\
    \ mismatched types\n "
  stdout: ''
  timestamp: 1659749139
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    for bracket in brackets.chars() {\n        if bracket == '<' {\n        \
    \    open_brackets.push('>');\n            closed_brackets.push('<');\n      \
    \  } else if bracket == '>' {\n            open_brackets.push('<');\n        \
    \    closed_brackets.push('>');\n        } else {\n            open_brackets.push(bracket);\n\
    \            closed_brackets.push(bracket);\n        }\n    }\n    open_brackets\
    \ == closed_brackets\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpt04we33m.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749139
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    for c in brackets.chars() {\n        if\
    \ c == '<' {\n            stack.push(0);\n        } else {\n            assert!(stack.pop()\
    \ != 0, \"unbalanced brackets\");\n        }\n    }\n    stack.is_empty()\n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwumt7tlp.rs:17:36\n   |\n\
    17 |             assert!(stack.pop() != 0, \"unbalanced brackets\");\n   |   \
    \                                 ^\n   |                                    |\n\
    \   |                                    expected enum `Option`, found integer\n\
    \   |                                    help: try using a variant of the expected\
    \ enum: `Some(0)`\n   |\n   = note: expected enum `Option<usize>`\n          \
    \    found type `{integer}`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749139
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\">\", \"\");\n    brackets.replace(\"<<\", \"\");\n    brackets.replace(\"\
    >>\", \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    bracket\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `bracket` in this scope\n  --> /tmp/tmpqqz_o7zx.rs:72:5\n\
    \   |\n72 |     bracket\n   |     ^^^^^^^ help: a local variable with a similar\
    \ name exists: `brackets`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\">\", \"\");\n    brackets.replace(\"<<\", \"\");\n    brackets.replace(\"\
    >>\", \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpxq21qjci.rs:65:1\n   |\n65\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxq21qjci.rs:64:5\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                  ---- expected `bool` because of return type\n\
    ...\n64 |     brackets.\n   |     ^^^^^^^^ expected `bool`, found struct `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_brackets_stack = Vec::new();\n    let mut closed_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack_size = open_brackets_stack.len();\n\
    \    let mut closed_brackets_stack_size = closed_brackets_stack.len();\n    let\
    \ mut open_brackets_stack_ptr = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut closed_brackets_stack_ptr = &mut closed_brackets_stack[closed_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_next = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut closed_brackets_stack_ptr_next = &mut closed_brackets_stack[closed_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_next_next = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut closed_brackets_stack_ptr_next_next = &mut closed_brackets_stack[closed_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_next_next_next = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut closed_brackets_stack_ptr_next_next_next = &mut closed_brackets_stack[closed_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_next_next_next_next = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut closed_brackets_stack_ptr_next_next_next_next = &mut closed_brackets_stack[closed_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_next_next_next_next_next = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut closed_brackets_stack_ptr_next_next_next_next_next = &mut closed_brackets_stack[closed_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_next_next_next_next_next_next = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut closed_brackets_stack_ptr_next_next_next_next_\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpleg6w34y.rs:31:59\n   |\n\
    31 |     let mut closed_brackets_stack_ptr_next_next_next_next_\n   |        \
    \                                                   ^ help: add `;` here\n32 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpleg6w34y.rs:11:44\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    while brackets.len() > 0 {\n     \
    \   let mut opening = brackets.chars().nth(0).unwrap();\n        let mut closing\
    \ = brackets.chars().nth(1).unwrap();\n        if opening != closing {\n     \
    \       return false;\n        }\n        brackets = brackets.chars().nth(2).unwrap();\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdhs_za7a.rs:19:20\n   |\n\
    19 |         brackets = brackets.chars().nth(2).unwrap();\n   |              \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                    |\n   |                    expected\
    \ struct `String`, found `char`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749139
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    for bracket in brackets.chars() {\n        if bracket == '<' {\n        \
    \    open_brackets.push('>');\n            close_brackets.push('<');\n       \
    \ } else if bracket == '>' {\n            open_brackets.push('<');\n         \
    \   close_brackets.push('>');\n        } else {\n            open_brackets.push(bracket);\n\
    \            close_brackets.push(bracket);\n        }\n    }\n    open_brackets\
    \ == close_brackets\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpfl7zrlyv.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\">\", \"\");\n    brackets.replace(\"<<\", \"\");\n    brackets.replace(\"\
    >>\", \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\"\
    , \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\"\
    );\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpxoozl9vw.rs:91:56\n\
    \   |\n91 |       assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    \   |  ________________________________________________________^\n92 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    while brackets.len() > 0 {\n\
    \        let mut open_bracket = String::new();\n        let mut close_bracket\
    \ = String::new();\n        if brackets.starts_with(\"<<\") {\n            open_bracket\
    \ = brackets.split_off(1).unwrap();\n            close_bracket = brackets.split_off(1).unwrap();\n\
    \            brackets = brackets.split_off(1).unwrap();\n        } else if brackets.starts_with(\"\
    <<<\") {\n            open_bracket = brackets.split_off(2).unwrap();\n       \
    \     close_bracket = brackets.split_off(2).unwrap();\n            brackets =\
    \ brackets.split_off(2).unwrap();\n        } else if brackets.starts_with(\"<<<\"\
    ) {\n            open_bracket = brackets.split_off(3).unwrap();\n            close_bracket\
    \ = brackets.split_off(3).unwrap();\n            brackets = brackets.split_off(3).unwrap();\n\
    \        } else if brackets.starts_with(\"<<<\") {\n            open_bracket =\
    \ brackets.split_off(4).unwrap();\n            close_bracket = brackets.split_off(4).unwrap();\n\
    \            brackets = brackets.split_off(4).unwrap();\n        } else if brackets.starts_with(\"\
    <<<\") {\n            open_bracket = brackets.split_off(5).unwrap();\n       \
    \     close_bracket = brackets.split_off(5).unwrap();\n            brackets =\
    \ brackets.split_off(5).unwrap();\n        } else if brackets.starts_with(\"<<<\"\
    ) {\n            open_bracket = brackets.split_off(6).unwrap();\n            close_bracket\
    \ = brackets.split_off(6).unwrap();\n            brackets = brackets.split_off(6).unwrap();\n\
    \        } else if brackets.starts_with(\"<<<\") {\n            open_bracket =\
    \ brackets.split_off(7).unwrap();\n            close_bracket = brackets.split_off(7).unwrap();\n\
    \            brackets = brackets.split_off(7).unwrap();\n        } else if brackets.starts_with(\"\
    <<<\") {\n            open_bracket = brackets.split_off(8).unwrap();\n       \
    \     close_bracket = brackets.split_off(8).unwrap();\n            brackets =\
    \ brackets.split_off\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpcm7vqgrh.rs:66:3\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - unclosed delimiter\n...\n15 |     while\
    \ brackets.len() > 0 {\n   |                              - unclosed delimiter\n\
    ...\n46 |         } else if brackets.starts_with(\"<<<\") {\n   |            \
    \                                   - this delimiter might not be properly closed...\n\
    ...\n50 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    66 | }\n   |   ^\n\nerror[E0599]: no method named `unwrap` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpcm7vqgrh.rs:19:50\n   |\n19 |          \
    \   open_bracket = brackets.split_off(1).unwrap();\n   |                     \
    \                             ^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `unwrap` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpcm7vqgrh.rs:20:51\n   |\n20 |             close_bracket = brackets.split_off(1).unwrap();\n\
    \   |                                                   ^^^^^^ method not found\
    \ in `String`\n\nerror[E0599]: no method named `unwrap` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpcm7vqgrh.rs:21:46\n   |\n21 |          \
    \   brackets = brackets.split_off(1).unwrap();\n   |                         \
    \                     ^^^^^^ method not found in `String`\n\nerror[E0599]: no\
    \ method named `unwrap` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpcm7vqgrh.rs:23:50\n   |\n23 |             open_bracket = brackets.split_off(2).unwrap();\n\
    \   |                                                  ^^^^^^ method not found\
    \ in `String`\n\nerror[E0599]: no method named `unwrap` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpcm7vqgrh.rs:24:51\n   |\n24 |          \
    \   close_bracket = brackets.split_off(2).unwrap();\n   |                    \
    \                               ^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `unwrap` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpcm7"
  stdout: ''
  timestamp: 1659749139
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    for bracket in brackets.chars() {\n        if bracket == '<' {\n        \
    \    open_brackets.push('>');\n            close_brackets.push('<');\n       \
    \ } else if bracket == '>' {\n            open_brackets.push('<');\n         \
    \   close_brackets.push('>');\n        } else {\n            open_brackets.push(bracket);\n\
    \            close_brackets.push(bracket);\n        }\n    }\n    open_brackets.chars().all(|c|\
    \ close_brackets.chars().any(|c| c == c))\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqjuq_pv_.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    let mut opening_brackets_iter = brackets.char_indices();\n    let mut closing_brackets_iter\
    \ = brackets.char_indices();\n    let mut opening_brackets_next = opening_brackets_iter.next();\n\
    \    let mut closing_brackets_next = closing_brackets_iter.next();\n    while\
    \ opening_brackets_next.is_some() && closing_brackets_next.is_some() {\n     \
    \   if opening_brackets_next.unwrap() == closing_brackets_next.unwrap() {\n  \
    \          opening_brackets.push_str(opening_brackets_next.unwrap());\n      \
    \      closing_brackets.push_str(closing_brackets_next.unwrap());\n          \
    \  opening_brackets_next = opening_brackets_iter.next();\n            closing_brackets_next\
    \ = closing_brackets_iter.next();\n        } else {\n            opening_brackets.push_str(opening_brackets_next.unwrap());\n\
    \            closing_brackets.push_str(\"</>\");\n            opening_brackets_next\
    \ = opening_brackets_iter.next();\n            closing_brackets_next = closing_brackets_iter.next();\n\
    \        }\n    }\n    opening_brackets.len() == closing_brackets.len()\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2fkn1ug4.rs:20:39\n   |\n\
    20 |             opening_brackets.push_str(opening_brackets_next.unwrap());\n\
    \   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `&str`, found tuple\n   |\n   = note: expected reference `&str`\n          \
    \        found tuple `(usize, char)`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp2fkn1ug4.rs:21:39\n   |\n21 |             closing_brackets.push_str(closing_brackets_next.unwrap());\n\
    \   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `&str`, found tuple\n   |\n   = note: expected reference `&str`\n          \
    \        found tuple `(usize, char)`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp2fkn1ug4.rs:25:39\n   |\n25 |             opening_brackets.push_str(opening_brackets_next.unwrap());\n\
    \   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `&str`, found tuple\n   |\n   = note: expected reference `&str`\n          \
    \        found tuple `(usize, char)`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749139
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().skip_while(|c| !c.is_ascii_letter()).collect());\n\
    \    loop {\n        if stack.len() == 0 {\n            return false;\n      \
    \  }\n        let mut current = stack.pop().unwrap();\n        if current == \"\
    >\" {\n            stack.push(brackets.chars().skip_while(|c| !c.is_ascii_letter()).collect());\n\
    \        } else if current == \"<\" {\n            stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).collect());\n        } else {\n            return false;\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmp8bn5_5o7.rs:13:51\n   |\n13 |     stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).collect());\n   |                                    \
    \               ^^^^^^^^^^^^^^^ method not found in `&char`\n\nerror[E0599]: no\
    \ method named `is_ascii_letter` found for reference `&char` in the current scope\n\
    \  --> /tmp/tmp8bn5_5o7.rs:20:59\n   |\n20 |             stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).collect());\n   |                                    \
    \                       ^^^^^^^^^^^^^^^ method not found in `&char`\n\nerror[E0599]:\
    \ no method named `is_ascii_letter` found for reference `&char` in the current\
    \ scope\n  --> /tmp/tmp8bn5_5o7.rs:22:59\n   |\n22 |             stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).collect());\n   |                                    \
    \                       ^^^^^^^^^^^^^^^ method not found in `&char`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659749139
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut open_brackets = Vec::new();\n    let mut\
    \ close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n  \
    \  let mut close_bracket = String::new();\n    let mut open_brackets_size = brackets.chars().filter(|c|\
    \ c == '<').count();\n    let mut close_brackets_size = brackets.chars().filter(|c|\
    \ c == '>').count();\n    let mut open_brackets_count = open_brackets_size;\n\
    \    let mut close_brackets_count = close_brackets_size;\n    let mut open_brackets_index\
    \ = -1;\n    let mut close_brackets_index = -1;\n    let mut open_brackets_index2\
    \ = -1;\n    let mut close_brackets_index2 = -1;\n    let mut open_brackets_index3\
    \ = -1;\n    let mut close_brackets_index3 = -1;\n    let mut open_brackets_index4\
    \ = -1;\n    let mut close_brackets_index4 = -1;\n    let mut open_brackets_index5\
    \ = -1;\n    let mut close_brackets_index5 = -1;\n    let mut open_brackets_index6\
    \ = -1;\n    let mut close_brackets_index6 = -1;\n    let mut open_brackets_index7\
    \ = -1;\n    let mut close_brackets_index7 = -1;\n    let mut open_brackets_index8\
    \ = -1;\n    let mut close_brackets_index8 = -1;\n    let mut open_brackets_index9\
    \ = -1;\n    let mut close_brackets_index9 = -1;\n    let mut open_brackets_index10\
    \ = -1;\n    let mut close_brackets_index10 = -1;\n    let mut open_brackets_index11\
    \ = -1;\n    let mut close_brackets_index11 = -1;\n    let mut open_brackets_index12\
    \ = -1;\n    let mut close_brackets_index12 = -1;\n    let mut open_brackets_index13\
    \ = -1;\n    let mut close_brackets_index13 = -1;\n    let mut open_brackets_index14\
    \ = -1;\n    let mut close_brackets_index14 = -1;\n    let mut open_brackets_index15\
    \ = -1;\n    let mut close_brackets_index15 = -1;\n    let mut open_bra\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp35bzywih.rs:51:21\n   |\n\
    51 |     let mut open_bra\n   |                     ^ help: add `;` here\n52 |\
    \ }\n   | - unexpected token\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmp35bzywih.rs:17:64\n   |\n17 |     let mut open_brackets_size =\
    \ brackets.chars().filter(|c| c == '<').count();\n   |                       \
    \                                         ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp35bzywih.rs:18:65\n\
    \   |\n18 |     let mut close_brackets_size = brackets.chars().filter(|c| c ==\
    \ '>').count();\n   |                                                        \
    \         ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp35bzywih.rs:11:44\n   |\n11 | fn correct_bracketing(brackets:\
    \ String) -> bool {\n   |    ------------------                      ^^^^ expected\
    \ `bool`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749139
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut open_brackets = Vec::new();\n    let mut\
    \ close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n  \
    \  let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = \n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpuvzjqssy.rs:52:1\n\
    \   |\n52 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == \">\" || c == \"<\")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7ex5o_2k.rs:12:35\n   |\n\
    12 |     brackets.chars().all(|c| c == \">\" || c == \"<\")\n   |            \
    \                       ^^^ expected `char`, found `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7ex5o_2k.rs:12:47\n   |\n12 |     brackets.chars().all(|c|\
    \ c == \">\" || c == \"<\")\n   |                                            \
    \   ^^^ expected `char`, found `&str`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749139
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for c in brackets.chars() {\n        if c == '<'\
    \ {\n            stack.push(c);\n        } else if c == '>' {\n            if\
    \ stack.len() == 0 {\n                return false;\n            }\n         \
    \   stack.pop();\n        } else {\n            if stack.len() != 0 {\n      \
    \          return false;\n            }\n        }\n    }\n    stack.len() ==\
    \ 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749138
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    for ch in brackets.chars() {\n        if\
    \ ch == '<' {\n            stack.push(brackets.len());\n        } else if ch ==\
    \ '>' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ != 0 {\n                return false;\n            }\n        }\n    }\n   \
    \ stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749139
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    for bracket in brackets.chars() {\n        if bracket == '<' {\n        \
    \    open_brackets.push('>');\n            close_brackets.push('<');\n       \
    \ } else if bracket == '>' {\n            open_brackets.push('<');\n         \
    \   close_brackets.push('>');\n        } else {\n            open_brackets.push(bracket);\n\
    \            close_brackets.push(bracket);\n        }\n    }\n    open_brackets.chars().all(|c|\
    \ close_brackets.chars().any(|c| c == c))\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqjuq_pv_.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\">\", \"\");\n    brackets.replace(\"<<\", \"\");\n    brackets.replace(\"\
    >>\", \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    bracket\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `bracket` in this scope\n  --> /tmp/tmpqqz_o7zx.rs:72:5\n\
    \   |\n72 |     bracket\n   |     ^^^^^^^ help: a local variable with a similar\
    \ name exists: `brackets`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\">\", \"\");\n    brackets.replace(\"<<\", \"\");\n    brackets.replace(\"\
    >>\", \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\"\
    , \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\"\
    );\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpxoozl9vw.rs:91:56\n\
    \   |\n91 |       assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    \   |  ________________________________________________________^\n92 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\">\", \"\");\n    brackets.replace(\"<<\", \"\");\n    brackets.replace(\"\
    >>\", \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    \n}\n\nfn main() {\n    let candidate = correct_bracketing;\n  \
    \  assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnc10of1h.rs:11:44\n   |\n\
    11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749139
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for c in brackets {\n        if c == '<' {\n  \
    \          stack.push(c);\n        } else if c == '>' {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            let top =\
    \ stack.pop();\n            if top != '<' {\n                return false;\n \
    \           }\n        } else {\n            if stack.len() == 0 {\n         \
    \       return false;\n            }\n            let top = stack.pop();\n   \
    \         if top != c {\n                return false;\n            }\n      \
    \  }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n   --> /tmp/tmp3lim63xs.rs:13:14\n\
    \    |\n13  |     for c in brackets {\n    |              ^^^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help: the\
    \ trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3lim63xs.rs:21:23\n\
    \   |\n21 |             if top != '<' {\n   |                       ^^^\n   |\
    \                       |\n   |                       expected enum `Option`,\
    \ found `char`\n   |                       help: try using a variant of the expected\
    \ enum: `Some('<')`\n   |\n   = note: expected enum `Option<_>`\n            \
    \  found type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3lim63xs.rs:29:23\n\
    \   |\n29 |             if top != c {\n   |                       ^\n   |    \
    \                   |\n   |                       cyclic type of infinite size\n\
    \   |                       help: try using a variant of the expected enum: `Some(c)`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749139
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_iter = brackets.char_indices();\n    let mut close_brackets_iter\
    \ = brackets.char_indices();\n    let mut open_brackets_end = open_brackets_iter.end();\n\
    \    let mut close_brackets_end = close_brackets_iter.end();\n    let mut open_brackets_cur\
    \ = open_brackets_iter.next();\n    let mut close_brackets_cur = close_brackets_iter.next();\n\
    \    while open_brackets_cur != open_brackets_end {\n        open_brackets.push_str(&open_brackets_cur);\n\
    \        open_brackets_cur = open_brackets_iter.next();\n    }\n    while close_brackets_cur\
    \ != close_brackets_end {\n        close_brackets.push_str(&close_brackets_cur);\n\
    \        close_brackets_cur = close_brackets_iter.next();\n    }\n    open_brackets.chars().all(|c|\
    \ close_brackets.chars().any(|c| c == c))\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `end` found for struct `CharIndices` in the\
    \ current scope\n  --> /tmp/tmp9dz3j80x.rs:16:52\n   |\n16 |     let mut open_brackets_end\
    \ = open_brackets_iter.end();\n   |                                          \
    \          ^^^ method not found in `CharIndices<'_>`\n\nerror[E0599]: no method\
    \ named `end` found for struct `CharIndices` in the current scope\n  --> /tmp/tmp9dz3j80x.rs:17:54\n\
    \   |\n17 |     let mut close_brackets_end = close_brackets_iter.end();\n   |\
    \                                                      ^^^ method not found in\
    \ `CharIndices<'_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9dz3j80x.rs:21:32\n\
    \   |\n21 |         open_brackets.push_str(&open_brackets_cur);\n   |        \
    \                        ^^^^^^^^^^^^^^^^^^ expected `str`, found enum `Option`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&Option<(usize,\
    \ char)>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9dz3j80x.rs:25:33\n\
    \   |\n25 |         close_brackets.push_str(&close_brackets_cur);\n   |      \
    \                           ^^^^^^^^^^^^^^^^^^^ expected `str`, found enum `Option`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&Option<(usize,\
    \ char)>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749139
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiapp5l8z.rs:11:44\n   |\n\
    11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    loop {\n        if stack.len() == 0 {\n            return false;\n      \
    \  }\n        let mut current = stack.last().unwrap();\n        if current ==\
    \ '<' {\n            stack.push(brackets.chars().next().unwrap());\n        }\
    \ else if current == '>' {\n            stack.pop();\n        } else {\n     \
    \       return false;\n        }\n    }\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpv_cbfll6.rs:19:20\n\
    \   |\n19 |         if current == '<' {\n   |                    ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpv_cbfll6.rs:21:27\n\
    \   |\n21 |         } else if current == '>' {\n   |                         \
    \  ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749139
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack_size = open_brackets_stack.len();\n\
    \    let mut close_brackets_stack_size = close_brackets_stack.len();\n    let\
    \ mut open_brackets_stack_ptr = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut close_brackets_stack_ptr = &mut close_brackets_stack[close_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_next = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut close_brackets_stack_ptr_next = &mut close_brackets_stack[close_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_next_next = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut close_brackets_stack_ptr_next_next = &mut close_brackets_stack[close_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_next_next_next = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut close_brackets_stack_ptr_next_next_next = &mut close_brackets_stack[close_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_next_next_next_next = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut close_brackets_stack_ptr_next_next_next_next = &mut close_brackets_stack[close_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_next_next_next_next_next = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut close_brackets_stack_ptr_next_next_next_next_next = &mut close_brackets_stack[close_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_next_next_next_next_next_next = &mut open_brackets_stack[open\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmp2loctukd.rs:31:1\n   |\n31 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmp2loctukd.rs:30:93\n   |\n11 | fn correct_bracketing(brackets: String)\
    \ -> bool {\n   |                                                 - closing delimiter\
    \ possibly meant for this\n...\n30 |     let mut open_brackets_stack_ptr_next_next_next_next_next_next\
    \ = &mut open_brackets_stack[open\n   |                                      \
    \                                                       ^ unclosed delimiter\n\
    31 | }\n   | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous\
    \ errors\n\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    let mut open_brackets: Vec<usize> = vec![];\n\
    \    let mut close_brackets: Vec<usize> = vec![];\n    let mut open_brackets_idx:\
    \ usize = 0;\n    let mut close_brackets_idx: usize = 0;\n    let mut open_brackets_idx2:\
    \ usize = 0;\n    let mut close_brackets_idx2: usize = 0;\n    let mut open_brackets_idx3:\
    \ usize = 0;\n    let mut close_brackets_idx3: usize = 0;\n    let mut open_brackets_idx4:\
    \ usize = 0;\n    let mut close_brackets_idx4: usize = 0;\n    let mut open_brackets_idx5:\
    \ usize = 0;\n    let mut close_brackets_idx5: usize = 0;\n    let mut open_brackets_idx6:\
    \ usize = 0;\n    let mut close_brackets_idx6: usize = 0;\n    let mut open_brackets_idx7:\
    \ usize = 0;\n    let mut close_brackets_idx7: usize = 0;\n    let mut open_brackets_idx8:\
    \ usize = 0;\n    let mut close_brackets_idx8: usize = 0;\n    let mut open_brackets_idx9:\
    \ usize = 0;\n    let mut close_brackets_idx9: usize = 0;\n    let mut open_brackets_idx10:\
    \ usize = 0;\n    let mut close_brackets_idx10: usize = 0;\n    let mut open_brackets_idx11:\
    \ usize = 0;\n    let mut close_brackets_idx11: usize = 0;\n    let mut open_brackets_idx12:\
    \ usize = 0;\n    let mut close_brackets_idx12: usize = 0;\n    let mut open_brackets_idx13:\
    \ usize = 0;\n    let mut close_brackets_idx13: usize = 0;\n    let mut open_brackets_idx14:\
    \ usize = 0;\n    let mut close_brackets_idx14: usize = 0;\n    let mut open_brackets_idx15:\
    \ usize = 0;\n    let mut close_brackets_idx15: usize = 0;\n    let mut open_brackets_idx16:\
    \ usize = 0;\n    let mut close_bra\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpflb3a61q.rs:46:22\n   |\n\
    46 |     let mut close_bra\n   |                      ^ help: add `;` here\n47\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpflb3a61q.rs:11:44\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749139
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = Vec::new();\n    stack.push(0);\n    let mut open_brackets:\
    \ Vec<usize> = Vec::new();\n    open_brackets.push(0);\n    let mut close_brackets:\
    \ Vec<usize> = Vec::new();\n    close_brackets.push(0);\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpc6lq1iou.rs:51:28\n   |\n\
    51 |     let mut close_brackets_\n   |                            ^ help: add\
    \ `;` here\n52 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpc6lq1iou.rs:11:44\n   |\n11 | fn correct_bracketing(brackets: String)\
    \ -> bool {\n   |    ------------------                      ^^^^ expected `bool`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749139
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == '>' || c == '<')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmptrk6cdso.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_brackets_stack = Vec::new();\n    let mut closed_brackets_stack\
    \ = Vec::new();\n    for bracket in brackets.chars() {\n        if bracket ==\
    \ '<' {\n            open_brackets.push(bracket);\n            open_brackets_stack.push(bracket);\n\
    \        } else if bracket == '>' {\n            closed_brackets.push(bracket);\n\
    \            closed_brackets_stack.push(bracket);\n        } else {\n        \
    \    if open_brackets_stack.len() == 0 {\n                return false;\n    \
    \        }\n            if closed_brackets_stack.len() == 0 {\n              \
    \  return false;\n            }\n            if open_brackets_stack.len() > closed_brackets_stack.len()\
    \ {\n                return false;\n            }\n            if open_brackets_stack.pop()\
    \ != closed_brackets_stack.pop() {\n                return false;\n          \
    \  }\n        }\n    }\n    open_brackets.len() == 0 && closed_brackets.len()\
    \ == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpr2tlwtx0.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749139
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_brackets_iter = brackets.char_indices();\n    let mut closed_brackets_iter\
    \ = brackets.char_indices();\n    let mut open_brackets_next = open_brackets_iter.next();\n\
    \    let mut closed_brackets_next = closed_brackets_iter.next();\n    while let\
    \ Some(open_bracket) = open_brackets_next {\n        if let Some(closed_bracket)\
    \ = closed_brackets_next {\n            if open_bracket.0 != closed_bracket.0\
    \ {\n                open_brackets += open_bracket.0;\n                closed_brackets\
    \ += closed_bracket.0;\n            }\n            open_brackets_next = open_brackets_iter.next();\n\
    \            closed_brackets_next = closed_brackets_iter.next();\n        } else\
    \ {\n            open_brackets += open_bracket.0;\n            closed_brackets\
    \ += '<';\n            open_brackets_next = open_brackets_iter.next();\n     \
    \   }\n    }\n    open_brackets == closed_brackets\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps1vthd3a.rs:21:34\n   |\n\
    21 |                 open_brackets += open_bracket.0;\n   |                  \
    \                ^^^^^^^^^^^^^^ expected `&str`, found `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmps1vthd3a.rs:22:36\n   |\n22 |              \
    \   closed_brackets += closed_bracket.0;\n   |                               \
    \     ^^^^^^^^^^^^^^^^ expected `&str`, found `usize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmps1vthd3a.rs:27:30\n   |\n27 |             open_brackets\
    \ += open_bracket.0;\n   |                              ^^^^^^^^^^^^^^ expected\
    \ `&str`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps1vthd3a.rs:28:32\n\
    \   |\n28 |             closed_brackets += '<';\n   |                        \
    \        ^^^ expected `&str`, found `char`\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749139
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ {\n        c >= '<' && c <= '>'\n    })\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp97buwhrr.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\">\", \"\");\n    brackets.replace(\"<<\", \"\");\n    brackets.replace(\"\
    >>\", \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpe5dbyfzj.rs:80:56\n\
    \   |\n80 |       assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    \   |  ________________________________________________________^\n81 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\">\", \"\");\n    brackets.replace(\"<<\", \"\");\n    brackets.replace(\"\
    >>\", \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    bracket\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `bracket` in this scope\n  --> /tmp/tmprwdx4ycb.rs:72:5\n\
    \   |\n72 |     bracket\n   |     ^^^^^^^ help: a local variable with a similar\
    \ name exists: `brackets`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659749139
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().collect::<Vec<_>>());\n\
    \    while stack.len() > 0 {\n        let mut last = stack.last().unwrap();\n\
    \        if last.len() == 1 {\n            stack.pop();\n            continue;\n\
    \        }\n        let mut first = last.clone();\n        while !first.is_empty()\
    \ {\n            let mut next = stack.last().unwrap();\n            if next.len()\
    \ == 1 {\n                stack.pop();\n                continue;\n          \
    \  }\n            if first[0] == next[0] {\n                stack.pop();\n   \
    \             stack.push(next.clone());\n                first.pop();\n      \
    \      } else {\n                break;\n            }\n        }\n    }\n   \
    \ stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpcab2wuwz.rs:15:13\n\
    \   |\n15 |         let mut last = stack.last().unwrap();\n   |             ----^^^^\n\
    \   |             |\n   |             help: remove this `mut`\n   |\n   = note:\
    \ `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be\
    \ mutable\n  --> /tmp/tmpcab2wuwz.rs:22:17\n   |\n22 |             let mut next\
    \ = stack.last().unwrap();\n   |                 ----^^^^\n   |              \
    \   |\n   |                 help: remove this `mut`\n\nwarning: cannot borrow\
    \ `stack` as mutable because it is also borrowed as immutable\n  --> /tmp/tmpcab2wuwz.rs:29:17\n\
    \   |\n22 |             let mut next = stack.last().unwrap();\n   |          \
    \                  ----- immutable borrow occurs here\n...\n29 |             \
    \    stack.push(next.clone());\n   |                 ^^^^^      ---- immutable\
    \ borrow later used here\n   |                 |\n   |                 mutable\
    \ borrow occurs here\n   |\n   = note: `#[warn(mutable_borrow_reservation_conflict)]`\
    \ on by default\n   = warning: this borrowing pattern was not meant to be accepted,\
    \ and may become a hard error in the future\n   = note: for more information,\
    \ see issue #59159 <https://github.com/rust-lang/rust/issues/59159>\n\nerror[E0502]:\
    \ cannot borrow `stack` as mutable because it is also borrowed as immutable\n\
    \  --> /tmp/tmpcab2wuwz.rs:28:17\n   |\n22 |             let mut next = stack.last().unwrap();\n\
    \   |                            ----- immutable borrow occurs here\n...\n28 |\
    \                 stack.pop();\n   |                 ^^^^^^^^^^^ mutable borrow\
    \ occurs here\n29 |                 stack.push(next.clone());\n   |          \
    \                  ---- immutable borrow later used here\n\nerror: aborting due\
    \ to previous error; 3 warnings emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1659749139
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for c in brackets.chars() {\n        if c == '<'\
    \ {\n            stack.push(c);\n        } else if c == '>' {\n            if\
    \ stack.is_empty() {\n                return false;\n            }\n         \
    \   stack.pop();\n        } else {\n            if stack.is_empty() {\n      \
    \          return false;\n            }\n            stack.pop();\n          \
    \  stack.push(c);\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749138
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == '<' || c == '>')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp2pvnwbzp.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ {\n        c >= '<' && c <= '>'\n    })\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp97buwhrr.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == '<' || c == '>')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp2pvnwbzp.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for ch in brackets {\n        if ch == '<' {\n\
    \            stack.push('<');\n        } else if ch == '>' {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.pop();\n\
    \        } else {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n            stack.push(ch);\n      \
    \  }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n   --> /tmp/tmpva0zvo9a.rs:13:15\n\
    \    |\n13  |     for ch in brackets {\n    |               ^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help:\
    \ the trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749139
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\">\", \"\");\n    brackets.replace(\"<<\", \"\");\n    brackets.replace(\"\
    >>\", \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpxq21qjci.rs:65:1\n   |\n65\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxq21qjci.rs:64:5\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                  ---- expected `bool` because of return type\n\
    ...\n64 |     brackets.\n   |     ^^^^^^^^ expected `bool`, found struct `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == '<' || c == '>')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp2pvnwbzp.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for c in brackets.chars() {\n        if c == '<'\
    \ {\n            stack.push(c);\n        } else if c == '>' {\n            if\
    \ stack.len() == 0 {\n                return false;\n            }\n         \
    \   stack.pop();\n        } else {\n            if stack.len() != 0 {\n      \
    \          return false;\n            }\n        }\n    }\n    stack.len() ==\
    \ 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659749138
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    for bracket in brackets.chars() {\n        if bracket == '<' {\n        \
    \    open_brackets.push('>');\n            close_brackets.push('<');\n       \
    \ } else if bracket == '>' {\n            open_brackets.push('<');\n         \
    \   close_brackets.push('>');\n        } else {\n            open_brackets.push(bracket);\n\
    \            close_brackets.push(bracket);\n        }\n    }\n    open_brackets.chars().all(|c|\
    \ close_brackets.chars().any(|c| c == c))\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqjuq_pv_.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == '<' || c == '>')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp2pvnwbzp.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    for bracket in brackets.chars() {\n        if bracket == '<' {\n        \
    \    opening_brackets.push('>');\n            closing_brackets.push('<');\n  \
    \      } else if bracket == '>' {\n            opening_brackets.push('<');\n \
    \           closing_brackets.push('>');\n        } else {\n            opening_brackets.push(bracket);\n\
    \            closing_brackets.push(bracket);\n        }\n    }\n    opening_brackets.chars().all(|c|\
    \ closing_brackets.chars().any(|c| c == c))\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp7ubu4u_q.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749139
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\">\", \"\");\n    brackets.replace(\"<<\", \"\");\n    brackets.replace(\"\
    >>\", \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpfpfabilx.rs:82:56\n\
    \   |\n82 |       assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    \   |  ________________________________________________________^\n83 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\">\", \"\");\n    brackets.replace(\"<<\", \"\");\n    brackets.replace(\"\
    >>\", \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpxq21qjci.rs:65:1\n   |\n65\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxq21qjci.rs:64:5\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                  ---- expected `bool` because of return type\n\
    ...\n64 |     brackets.\n   |     ^^^^^^^^ expected `bool`, found struct `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    for c in brackets {\n        if c == '<' {\n            opening_brackets.push(c);\n\
    \        } else if c == '>' {\n            closing_brackets.push(c);\n       \
    \ } else {\n            return false;\n        }\n    }\n    if opening_brackets.len()\
    \ != closing_brackets.len() {\n        return false;\n    }\n    let mut opening_brackets_iter\
    \ = opening_brackets.chars().enumerate();\n    let mut closing_brackets_iter =\
    \ closing_brackets.chars().enumerate();\n    let mut opening_brackets_end = opening_brackets_iter.next();\n\
    \    let mut closing_brackets_end = closing_brackets_iter.next();\n    while opening_brackets_end\
    \ != None && closing_brackets_end != None {\n        let (opening_brackets_index,\
    \ opening_brackets_char) = opening_brackets_end;\n        let (closing_brackets_index,\
    \ closing_brackets_char) = closing_brackets_end;\n        if opening_brackets_char\
    \ == closing_brackets_char {\n            opening_brackets_end = opening_brackets_iter.next();\n\
    \            closing_brackets_end = closing_brackets_iter.next();\n        } else\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n   --> /tmp/tmpu79jzy3a.rs:14:14\n\
    \    |\n14  |     for c in brackets {\n    |              ^^^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help: the\
    \ trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu79jzy3a.rs:31:13\n\
    \   |\n31 |         let (opening_brackets_index, opening_brackets_char) = opening_brackets_end;\n\
    \   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   --------------------\
    \ this expression has type `Option<(usize, char)>`\n   |             |\n   | \
    \            expected enum `Option`, found tuple\n   |\n   = note: expected enum\
    \ `Option<(usize, char)>`\n             found tuple `(_, _)`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpu79jzy3a.rs:32:13\n   |\n32 |         let (closing_brackets_index,\
    \ closing_brackets_char) = closing_brackets_end;\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \   -------------------- this expression has type `Option<(usize, char)>`\n  \
    \ |             |\n   |             expected enum `Option`, found tuple\n   |\n\
    \   = note: expected enum `Option<(usize, char)>`\n             found tuple `(_,\
    \ _)`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749139
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_count = String::new();\n    let mut close_brackets_count\
    \ = String::new();\n    let mut open_brackets_count_map = String::new();\n   \
    \ let mut close_brackets_count_map = String::new();\n\n    for bracket in brackets.chars()\
    \ {\n        if bracket == '<' {\n            open_brackets += &bracket + &bracket\
    \ + &bracket;\n            open_brackets_count += &bracket + &bracket + &bracket;\n\
    \            open_brackets_count_map += &bracket + &bracket + &bracket;\n    \
    \    }\n        if bracket == '>' {\n            close_brackets += &bracket +\
    \ &bracket + &bracket;\n            close_brackets_count += &bracket + &bracket\
    \ + &bracket;\n            close_brackets_count_map += &bracket + &bracket + &bracket;\n\
    \        }\n    }\n\n    if open_brackets.len() != close_brackets.len() {\n  \
    \      return false;\n    }\n\n    if open_brackets_count != close_brackets_count\
    \ {\n        return false;\n    }\n\n    if open_brackets_count_map != close_brackets_count_map\
    \ {\n        return false;\n    }\n\n    return true;\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot add `&char` to `&char`\n  --> /tmp/tmp3a2bj659.rs:21:39\n\
    \   |\n21 |             open_brackets += &bracket + &bracket + &bracket;\n   |\
    \                              -------- ^ -------- &char\n   |               \
    \               |\n   |                              &char\n\nerror[E0369]: cannot\
    \ add `&char` to `&char`\n  --> /tmp/tmp3a2bj659.rs:22:45\n   |\n22 |        \
    \     open_brackets_count += &bracket + &bracket + &bracket;\n   |           \
    \                         -------- ^ -------- &char\n   |                    \
    \                |\n   |                                    &char\n\nerror[E0369]:\
    \ cannot add `&char` to `&char`\n  --> /tmp/tmp3a2bj659.rs:23:49\n   |\n23 | \
    \            open_brackets_count_map += &bracket + &bracket + &bracket;\n   |\
    \                                        -------- ^ -------- &char\n   |     \
    \                                   |\n   |                                  \
    \      &char\n\nerror[E0369]: cannot add `&char` to `&char`\n  --> /tmp/tmp3a2bj659.rs:26:40\n\
    \   |\n26 |             close_brackets += &bracket + &bracket + &bracket;\n  \
    \ |                               -------- ^ -------- &char\n   |            \
    \                   |\n   |                               &char\n\nerror[E0369]:\
    \ cannot add `&char` to `&char`\n  --> /tmp/tmp3a2bj659.rs:27:46\n   |\n27 | \
    \            close_brackets_count += &bracket + &bracket + &bracket;\n   |   \
    \                                  -------- ^ -------- &char\n   |           \
    \                          |\n   |                                     &char\n\
    \nerror[E0369]: cannot add `&char` to `&char`\n  --> /tmp/tmp3a2bj659.rs:28:50\n\
    \   |\n28 |             close_brackets_count_map += &bracket + &bracket + &bracket;\n\
    \   |                                         -------- ^ -------- &char\n   |\
    \                                         |\n   |                            \
    \             &char\n\nerror: aborting due to 6 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659749139
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\"\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmp9wbzn1cu.rs:75:21\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - closing delimiter possibly meant for\
    \ this\n...\n75 |     brackets.replace(\"<\", \"\"\n   |                     ^\
    \ unclosed delimiter\n76 | }\n   | ^ mismatched closing delimiter\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9wbzn1cu.rs:75:5\n   |\n11 |   fn correct_bracketing(brackets:\
    \ String) -> bool {\n   |                                              ---- expected\
    \ `bool` because of return type\n...\n75 | /     brackets.replace(\"<\", \"\"\n\
    76 | | }\n   | |_^ expected `bool`, found struct `String`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    let mut open_brackets = String::new();\n\
    \    let mut closed_brackets = String::new();\n    while brackets.len() > 0 {\n\
    \        let mut open_bracket = String::new();\n        let mut closed_bracket\
    \ = String::new();\n        if brackets.starts_with(\"<<\") {\n            open_bracket\
    \ = \"<\";\n            closed_bracket = \">\";\n        } else if brackets.starts_with(\"\
    <>\") {\n            open_bracket = \"<\";\n            closed_bracket = \">\"\
    ;\n        } else if brackets.starts_with(\"<\") {\n            open_bracket =\
    \ \"<\";\n            closed_bracket = \">\";\n        } else if brackets.starts_with(\"\
    >\") {\n            open_bracket = \">\";\n            closed_bracket = \"<\"\
    ;\n        } else {\n            return false;\n        }\n        open_brackets\
    \ += open_bracket;\n        closed_brackets += closed_bracket;\n        brackets\
    \ = brackets.split_off(open_bracket);\n    }\n    open_brackets == closed_brackets\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptqvhzsm4.rs:19:28\n   |\n\
    19 |             open_bracket = \"<\";\n   |                            ^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                        \
    \    |\n   |                            expected struct `String`, found `&str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptqvhzsm4.rs:20:30\n   |\n20 |\
    \             closed_bracket = \">\";\n   |                              ^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \            |\n   |                              expected struct `String`, found\
    \ `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptqvhzsm4.rs:22:28\n\
    \   |\n22 |             open_bracket = \"<\";\n   |                          \
    \  ^^^- help: try using a conversion method: `.to_string()`\n   |            \
    \                |\n   |                            expected struct `String`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptqvhzsm4.rs:23:30\n\
    \   |\n23 |             closed_bracket = \">\";\n   |                        \
    \      ^^^- help: try using a conversion method: `.to_string()`\n   |        \
    \                      |\n   |                              expected struct `String`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptqvhzsm4.rs:25:28\n\
    \   |\n25 |             open_bracket = \"<\";\n   |                          \
    \  ^^^- help: try using a conversion method: `.to_string()`\n   |            \
    \                |\n   |                            expected struct `String`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptqvhzsm4.rs:26:30\n\
    \   |\n26 |             closed_bracket = \">\";\n   |                        \
    \      ^^^- help: try using a conversion method: `.to_string()`\n   |        \
    \                      |\n   |                              expected struct `String`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptqvhzsm4.rs:28:28\n\
    \   |\n28 |             open_bracket = \">\";\n   |                          \
    \  ^^^- help: try using a conversion method: `.to_string()`\n   |            \
    \              "
  stdout: ''
  timestamp: 1659749139
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().collect::<Vec<_>>());\n\
    \    while let Some(mut stack) = stack.pop() {\n        if stack.len() == 0 {\n\
    \            return false;\n        }\n        let mut current = stack.pop().unwrap();\n\
    \        let mut next = stack.pop().unwrap();\n        if current != next {\n\
    \            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n   \
    \ let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4txkwsst.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749139
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    for ch in brackets.chars() {\n        if\
    \ ch == '<' {\n            stack.push(0);\n        } else {\n            assert!(stack.pop()\
    \ == 0);\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp44aicdlp.rs:17:36\n   |\n\
    17 |             assert!(stack.pop() == 0);\n   |                            \
    \        ^\n   |                                    |\n   |                  \
    \                  expected enum `Option`, found integer\n   |               \
    \                     help: try using a variant of the expected enum: `Some(0)`\n\
    \   |\n   = note: expected enum `Option<usize>`\n              found type `{integer}`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749139
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == '>' || c == '<')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmptrk6cdso.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    for bracket in brackets.chars() {\n        if bracket == '<' {\n        \
    \    open_brackets.push('>');\n            close_brackets.push('<');\n       \
    \ } else if bracket == '>' {\n            open_brackets.push('<');\n         \
    \   close_brackets.push('>');\n        } else {\n            open_brackets.push(bracket);\n\
    \        }\n    }\n    open_brackets == close_brackets\n}\n\nfn main() {\n   \
    \ let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpb358qqag.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749139
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\">\", \"\");\n    brackets.replace(\"<<\", \"\");\n    brackets.replace(\"\
    >>\", \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    bracket\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `bracket` in this scope\n  --> /tmp/tmpqqz_o7zx.rs:72:5\n\
    \   |\n72 |     bracket\n   |     ^^^^^^^ help: a local variable with a similar\
    \ name exists: `brackets`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_count = String::new();\n    let mut\
    \ close_brackets_count = String::new();\n    let mut open_brackets_count_stack\
    \ = Vec::new();\n    let mut close_brackets_count_stack = Vec::new();\n    let\
    \ mut open_brackets_count_stack = Vec::new();\n    let mut close_brackets_count_stack\
    \ = Vec::new();\n    let mut open_brackets_count_stack = Vec::new();\n    let\
    \ mut close_brackets_count_stack = Vec::new();\n    let mut open_brackets_count_stack\
    \ = Vec::new();\n    let mut close_brackets_count_stack = Vec::new();\n    let\
    \ mut open_brackets_count_stack = Vec::new();\n    let mut close_brackets_count_stack\
    \ = Vec::new();\n    let mut open_brackets_count_stack = Vec::new();\n    let\
    \ mut close_brackets_count_stack = Vec::new();\n    let mut open_brackets_count_stack\
    \ = Vec::new();\n    let mut close_brackets_count_stack = Vec::new();\n    let\
    \ mut open_brackets_count_stack = Vec::new();\n    let mut close_brackets_count_stack\
    \ = Vec::new();\n    let mut open_brackets_count_stack = Vec::new();\n    let\
    \ mut close_brackets_count_stack = Vec::new();\n    let mut open_brackets_count_stack\
    \ = Vec::new();\n    let mut close_brackets_count_stack = Vec::new();\n    let\
    \ mut open_brackets_count_stack = Vec::new();\n    let mut close_brackets_count_stack\
    \ = Vec::new();\n    let mut open_brackets_count_stack = Vec::new();\n    let\
    \ mut close_brackets_count_stack = Vec::new();\n    let mut open_brackets_count_stack\
    \ = Vec::new();\n    let mut close_brackets_count_stack = Vec::new();\n    let\
    \ mut open_brackets_count_stack = Vec\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_abrri8y.rs:44:44\n   |\n\
    44 |     let mut open_brackets_count_stack = Vec\n   |                       \
    \                     ^ help: add `;` here\n45 | }\n   | - unexpected token\n\n\
    error[E0423]: expected value, found struct `Vec`\n   --> /tmp/tmp_abrri8y.rs:44:41\n\
    \    |\n44  |       let mut open_brackets_count_stack = Vec\n    |           \
    \                                ^^^ help: use struct literal syntax instead:\
    \ `Vec { buf: val, len: val }`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_abrri8y.rs:11:44\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0423.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749139
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    for ch in brackets.chars() {\n        if\
    \ ch == '<' {\n            stack.push(0);\n        } else if ch == '>' {\n   \
    \         stack.pop();\n        } else {\n            stack.push((stack.len()\
    \ - 1) * 2 + 1);\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n \
    \   let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp1c454pl6.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749139
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    while brackets.len() > 0 {\n\
    \        let mut open_bracket = String::new();\n        let mut close_bracket\
    \ = String::new();\n        let mut open_brackets = String::new();\n        let\
    \ mut close_brackets = String::new();\n        while brackets.len() > 0 {\n  \
    \          if brackets.starts_with(\"<<\") {\n                open_brackets.push('>');\n\
    \                open_brackets.push(brackets.substr_from(2));\n              \
    \  brackets = brackets.substr_from(3);\n            } else if brackets.starts_with(\"\
    >>\") {\n                close_brackets.push('<');\n                close_brackets.push(brackets.substr_from(2));\n\
    \                brackets = brackets.substr_from(3);\n            } else if brackets.starts_with(\"\
    <>\") {\n                open_brackets.push('<');\n                open_brackets.push(brackets.substr_from(2));\n\
    \                close_brackets.push('>');\n                close_brackets.push(brackets.substr_from(3));\n\
    \                brackets = brackets.substr_from(4);\n            } else if brackets.starts_with(\"\
    >>\") {\n                close_brackets.push('>');\n                close_brackets.push(brackets.substr_from(2));\n\
    \                brackets = brackets.substr_from(3);\n            } else {\n \
    \               open_brackets.push(brackets.substr_from(2));\n               \
    \ brackets = brackets.substr_from(3);\n            }\n        }\n        if open_brackets.len()\
    \ == 0 {\n            open_brackets.push('>');\n        }\n        if close_brackets.len()\
    \ == 0 {\n            close_brackets.push('<');\n        }\n        if open_brackets.len()\
    \ != close_brackets.len() {\n            return false;\n        }\n        if\
    \ open_brackets.len() > 0 {\n            open_brackets = open_brackets.to_string();\n\
    \        }\n        if close_brackets.len() > 0 {\n            close_brackets\
    \ = close_brackets.to_string();\n        }\n    }\n    open_brackets == close_brackets\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `substr_from` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpgnhdlwol.rs:23:45\n   |\n23 |             \
    \    open_brackets.push(brackets.substr_from(2));\n   |                      \
    \                       ^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `substr_from` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpgnhdlwol.rs:24:37\n   |\n24 |                 brackets = brackets.substr_from(3);\n\
    \   |                                     ^^^^^^^^^^^ method not found in `String`\n\
    \nerror[E0599]: no method named `substr_from` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpgnhdlwol.rs:27:46\n   |\n27 |                 close_brackets.push(brackets.substr_from(2));\n\
    \   |                                              ^^^^^^^^^^^ method not found\
    \ in `String`\n\nerror[E0599]: no method named `substr_from` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpgnhdlwol.rs:28:37\n   |\n28 | \
    \                brackets = brackets.substr_from(3);\n   |                   \
    \                  ^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no\
    \ method named `substr_from` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpgnhdlwol.rs:31:45\n   |\n31 |                 open_brackets.push(brackets.substr_from(2));\n\
    \   |                                             ^^^^^^^^^^^ method not found\
    \ in `String`\n\nerror[E0599]: no method named `substr_from` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpgnhdlwol.rs:33:46\n   |\n33 | \
    \                close_brackets.push(brackets.substr_from(3));\n   |         \
    \                                     ^^^^^^^^^^^ method not found in `String`\n\
    \nerror[E0599]: no method named `substr_from` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpgnhdlwol.rs:34:37\n   |\n34 |                 brackets\
    \ = brackets.substr_from(4);\n   |                                     ^^^^^^^^^^^\
    \ method not found in `String`\n\nerror[E0599]: no method named `substr_from`\
    \ found for struct `String` in the current scope\n  --> /tm"
  stdout: ''
  timestamp: 1659749139
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for c in brackets {\n        if c == '<' {\n  \
    \          stack.push(c);\n        } else if c == '>' {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            let top =\
    \ stack.pop();\n            if top != '<' {\n                return false;\n \
    \           }\n        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n   --> /tmp/tmp18u99_os.rs:13:14\n\
    \    |\n13  |     for c in brackets {\n    |              ^^^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help: the\
    \ trait `Iterator` is not implemented for `String`\n    = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\nnote: required\
    \ by `into_iter`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp18u99_os.rs:21:23\n\
    \   |\n21 |             if top != '<' {\n   |                       ^^^\n   |\
    \                       |\n   |                       expected enum `Option`,\
    \ found `char`\n   |                       help: try using a variant of the expected\
    \ enum: `Some('<')`\n   |\n   = note: expected enum `Option<_>`\n            \
    \  found type `char`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749139
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    let mut opening_bracket = String::new();\n    let mut closing_bracket = String::new();\n\
    \    let mut opening_brackets = String::new();\n    let mut closing_brackets =\
    \ String::new();\n    let mut opening_bracket = String::new();\n    let mut closing_bracket\
    \ = String::new();\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_brackets = String::new();\n    let mut opening_bracket = String::new();\n\
    \    let mut closing_bracket = String::new();\n    let mut opening_brackets =\
    \ String::new();\n    let mut closing_brackets = String::new();\n    let mut opening_bracket\
    \ = String::new();\n    let mut closing_bracket = String::new();\n    let mut\
    \ opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    let mut opening_bracket = String::new();\n    let mut closing_bracket = String::new();\n\
    \    let mut opening_brackets = String::new();\n    let mut closing_brackets =\
    \ String::new();\n    let mut opening_bracket = String::new();\n    let mut closing_bracket\
    \ = String::new();\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_brackets = String::new();\n    let mut opening_bracket = String::new();\n\
    \    let mut closing_bracket = String::new();\n    let mut opening_brackets =\
    \ String::new();\n    let mut closing_brackets = String::new();\n    let mut opening_bracket\
    \ = String::new();\n    let mut closing_bracket = String::new();\n    let mut\
    \ opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    let mut opening_bracket = String::new();\n    let mut closing_bracket = String::new();\n\
    \    let mut opening_brackets = String::new();\n    let mut closing_brackets =\
    \ String::new();\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvxb4ya5q.rs:11:44\n   |\n\
    11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    for bracket in brackets.chars() {\n        if bracket == '<' {\n        \
    \    open_brackets.push('>');\n        } else if bracket == '>' {\n          \
    \  close_brackets.push('<');\n        } else {\n            open_brackets.push(bracket);\n\
    \            close_brackets.push(bracket);\n        }\n    }\n    open_brackets\
    \ == close_brackets\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbhxx82r2.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749139
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().skip_while(|c| !c.is_ascii_letter()).collect::<Vec<_>>());\n\
    \    loop {\n        if stack.is_empty() {\n            return false;\n      \
    \  }\n        let mut open = stack.pop().unwrap();\n        if open == \">\" ||\
    \ open == \"<\" {\n            stack.push(open);\n        } else {\n         \
    \   return false;\n        }\n    }\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmp_5_f4rew.rs:13:51\n   |\n13 |     stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).collect::<Vec<_>>());\n   |                          \
    \                         ^^^^^^^^^^^^^^^ method not found in `&char`\n\nerror[E0277]:\
    \ can't compare `Vec<char>` with `&str`\n  --> /tmp/tmp_5_f4rew.rs:19:17\n   |\n\
    19 |         if open == \">\" || open == \"<\" {\n   |                 ^^ no implementation\
    \ for `Vec<char> == &str`\n   |\n   = help: the trait `PartialEq<&str>` is not\
    \ implemented for `Vec<char>`\n\nerror[E0277]: can't compare `Vec<char>` with\
    \ `&str`\n  --> /tmp/tmp_5_f4rew.rs:19:32\n   |\n19 |         if open == \">\"\
    \ || open == \"<\" {\n   |                                ^^ no implementation\
    \ for `Vec<char> == &str`\n   |\n   = help: the trait `PartialEq<&str>` is not\
    \ implemented for `Vec<char>`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749139
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack_size = open_brackets_stack.len();\n\
    \    let mut close_brackets_stack_size = close_brackets_stack.len();\n    let\
    \ mut open_brackets_stack_ptr = open_brackets_stack.as_mut_ptr();\n    let mut\
    \ close_brackets_stack_ptr = close_brackets_stack.as_mut_ptr();\n    let mut open_brackets_stack_ptr_end\
    \ = open_brackets_stack_ptr.sub(open_brackets_stack_size);\n    let mut close_brackets_stack_ptr_end\
    \ = close_brackets_stack_ptr.sub(close_brackets_stack_size);\n    let mut open_brackets_stack_ptr_end_ptr\
    \ = open_brackets_stack_ptr_end.sub(1);\n    let mut close_brackets_stack_ptr_end_ptr\
    \ = close_brackets_stack_ptr_end.sub(1);\n    let mut open_brackets_stack_ptr_end_ptr_end\
    \ = open_brackets_stack_ptr_end_ptr.sub(1);\n    let mut close_brackets_stack_ptr_end_ptr_end\
    \ = close_brackets_stack_ptr_end_ptr.sub(1);\n    let mut open_brackets_stack_ptr_end_ptr_end_ptr\
    \ = open_brackets_stack_ptr_end_ptr_end.sub(1);\n    let mut close_brackets_stack_ptr_end_ptr_end_ptr\
    \ = close_brackets_stack_ptr_end_ptr_end.sub(1);\n    let mut open_brackets_stack_ptr_end_ptr_end_ptr_end\
    \ = open_brackets_stack_ptr_end_ptr_end_ptr.sub(1);\n    let mut close_brackets_stack_ptr_end_ptr_end_ptr_end\
    \ = close_brackets_stack_ptr_end_ptr_end_ptr.sub(1);\n    let mut open_brackets_stack_ptr_end_ptr_end_ptr_end_ptr\
    \ = open_brackets_stack_ptr_end_ptr_end_ptr_end.sub(1);\n    let mut close_brackets_stack_ptr_end_ptr_end_ptr_end_ptr\
    \ = close_brackets_stack_ptr_end_ptr\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9dbo8p2_.rs:31:96\n   |\n\
    31 |     let mut close_brackets_stack_ptr_end_ptr_end_ptr_end_ptr = close_brackets_stack_ptr_end_ptr\n\
    \   |                                                                        \
    \                        ^ help: add `;` here\n32 | }\n   | - unexpected token\n\
    \nwarning: type annotations needed\n  --> /tmp/tmp9dbo8p2_.rs:20:67\n   |\n20\
    \ |     let mut open_brackets_stack_ptr_end = open_brackets_stack_ptr.sub(open_brackets_stack_size);\n\
    \   |                                                                   ^^^\n\
    \   |\n   = note: `#[warn(tyvar_behind_raw_pointer)]` on by default\n   = warning:\
    \ this is accepted in the current edition (Rust 2015) but is a hard error in Rust\
    \ 2018!\n   = note: for more information, see issue #46906 <https://github.com/rust-lang/rust/issues/46906>\n\
    \nwarning: type annotations needed\n  --> /tmp/tmp9dbo8p2_.rs:21:69\n   |\n21\
    \ |     let mut close_brackets_stack_ptr_end = close_brackets_stack_ptr.sub(close_brackets_stack_size);\n\
    \   |                                                                     ^^^\n\
    \   |\n   = warning: this is accepted in the current edition (Rust 2015) but is\
    \ a hard error in Rust 2018!\n   = note: for more information, see issue #46906\
    \ <https://github.com/rust-lang/rust/issues/46906>\n\nwarning: type annotations\
    \ needed\n  --> /tmp/tmp9dbo8p2_.rs:22:75\n   |\n22 |     let mut open_brackets_stack_ptr_end_ptr\
    \ = open_brackets_stack_ptr_end.sub(1);\n   |                                \
    \                                           ^^^\n   |\n   = warning: this is accepted\
    \ in the current edition (Rust 2015) but is a hard error in Rust 2018!\n   = note:\
    \ for more information, see issue #46906 <https://github.com/rust-lang/rust/issues/46906>\n\
    \nwarning: type annotations needed\n  --> /tmp/tmp9dbo8p2_.rs:23:77\n   |\n23\
    \ |     let mut close_brackets_stack_ptr_end_ptr = close_brackets_stack_ptr_end.sub(1);\n\
    \   |                                                                        \
    \     ^^^\n   |\n   = warning: this is accepted in the current edition (Rust 20"
  stdout: ''
  timestamp: 1659749139
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    for bracket in brackets.chars() {\n        if bracket == '<' {\n        \
    \    opening_brackets.push('>');\n            closing_brackets.push('<');\n  \
    \      } else if bracket == '>' {\n            opening_brackets.push('<');\n \
    \           closing_brackets.push('>');\n        } else {\n            opening_brackets.push(bracket);\n\
    \            closing_brackets.push(bracket);\n        }\n    }\n    opening_brackets.chars().all(|c|\
    \ closing_brackets.chars().any(|c| c == c))\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp7ubu4u_q.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749139
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for c in brackets {\n        if c == '<' {\n  \
    \          stack.push(c);\n        } else if c == '>' {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.pop();\n\
    \        } else {\n            if stack.len() != 0 {\n                return false;\n\
    \            }\n        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n   \
    \ let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmprh1locet.rs:13:14\n\
    \   |\n13 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == '<' || c == '>')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp2pvnwbzp.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    let mut opening_brackets_stack = Vec::new();\n    let mut closing_brackets_stack\
    \ = Vec::new();\n    let mut opening_brackets_stack_size = opening_brackets_stack.len();\n\
    \    let mut closing_brackets_stack_size = closing_brackets_stack.len();\n   \
    \ let mut opening_brackets_stack_pos = 0;\n    let mut closing_brackets_stack_pos\
    \ = 0;\n    let mut opening_brackets_stack_end = opening_brackets_stack_size;\n\
    \    let mut closing_brackets_stack_end = closing_brackets_stack_size;\n    let\
    \ mut opening_brackets_stack_pos = 0;\n    let mut closing_brackets_stack_pos\
    \ = 0;\n    let mut opening_brackets_stack_end = opening_brackets_stack_size;\n\
    \    let mut closing_brackets_stack_end = closing_brackets_stack_size;\n    let\
    \ mut opening_brackets_stack_pos = 0;\n    let mut closing_brackets_stack_pos\
    \ = 0;\n    let mut opening_brackets_stack_end = opening_brackets_stack_size;\n\
    \    let mut closing_brackets_stack_end = closing_brackets_stack_size;\n    let\
    \ mut opening_brackets_stack_pos = 0;\n    let mut closing_brackets_stack_pos\
    \ = 0;\n    let mut opening_brackets_stack_end = opening_brackets_stack_size;\n\
    \    let mut closing_brackets_stack_end = closing_brackets_stack_size;\n    let\
    \ mut opening_brackets_stack_pos = 0;\n    let mut closing_brackets_stack_pos\
    \ = 0;\n    let mut opening_brackets_stack_end = opening_brackets_stack_size;\n\
    \    let mut closing_brackets_stack_end = closing_brackets_stack_size;\n    let\
    \ mut opening_brackets_stack_pos = 0;\n    let mut closing_brackets_stack_pos\
    \ = 0;\n    let mut opening_brackets_stack_end = opening_brackets_stack_size;\n\
    \    let mut closing_brackets_stack_end = closing_brackets_stack_size;\n    let\
    \ mut opening_brackets_stack_pos = 0;\n    let mut closing_brackets_stack_pos\
    \ = 0;\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa9ae7ebd.rs:11:44\n   |\n\
    11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659749139
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    loop {\n        if stack.len() == 0 {\n            return false;\n      \
    \  }\n        let mut last = stack.last().unwrap();\n        if last == '<' {\n\
    \            stack.push(brackets.chars().next().unwrap());\n        } else if\
    \ last == '>' {\n            stack.pop();\n        } else {\n            return\
    \ false;\n        }\n    }\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpenguux3a.rs:19:17\n\
    \   |\n19 |         if last == '<' {\n   |                 ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpenguux3a.rs:21:24\n\
    \   |\n21 |         } else if last == '>' {\n   |                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749139
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    for bracket in brackets.chars() {\n        if bracket == '<' {\n        \
    \    open_brackets.push('>');\n            close_brackets.push('<');\n       \
    \ } else if bracket == '>' {\n            open_brackets.push('<');\n         \
    \   close_brackets.push('>');\n        } else if bracket == '{' {\n          \
    \  open_brackets.push('}');\n            close_brackets.push('{');\n        }\
    \ else if bracket == '}' {\n            open_brackets.push('{');\n           \
    \ close_brackets.push('}');\n        } else if bracket == '(' {\n            open_brackets.push(')');\n\
    \            close_brackets.push('(');\n        } else if bracket == ')' {\n \
    \           open_brackets.push('(');\n            close_brackets.push(')');\n\
    \        } else if bracket == '[' {\n            open_brackets.push(']');\n  \
    \          close_brackets.push('[');\n        } else if bracket == ']' {\n   \
    \         open_brackets.push('[');\n            close_brackets.push(']');\n  \
    \      } else {\n            open_brackets.push(bracket);\n            close_brackets.push(bracket);\n\
    \        }\n    }\n    open_brackets == close_brackets\n}\n\nfn main() {\n   \
    \ let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpig1ackv0.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749139
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_iter = brackets.chars().enumerate().filter(|&(_, c)|\
    \ c != '<');\n    let mut close_brackets_iter = brackets.chars().enumerate().filter(|&(_,\
    \ c)| c != '>');\n    let mut open_brackets_next = open_brackets_iter.next();\n\
    \    let mut close_brackets_next = close_brackets_iter.next();\n    while open_brackets_next.is_some()\
    \ && close_brackets_next.is_some() {\n        if open_brackets_next.unwrap() ==\
    \ '<' {\n            open_brackets += open_brackets_next.unwrap();\n         \
    \   open_brackets_next = open_brackets_iter.next();\n        } else {\n      \
    \      close_brackets += close_brackets_next.unwrap();\n            close_brackets_next\
    \ = close_brackets_iter.next();\n        }\n    }\n    open_brackets.chars().all(|c|\
    \ close_brackets.chars().any(|c| c == c))\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmmb0wez4.rs:19:43\n   |\n\
    19 |         if open_brackets_next.unwrap() == '<' {\n   |                   \
    \                        ^^^ expected tuple, found `char`\n   |\n   = note: expected\
    \ tuple `(usize, char)`\n               found type `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpmmb0wez4.rs:20:30\n   |\n20 |             open_brackets\
    \ += open_brackets_next.unwrap();\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found tuple\n   |\n   = note: expected reference `&str`\n \
    \                 found tuple `(usize, char)`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmmb0wez4.rs:23:31\n   |\n23 |             close_brackets += close_brackets_next.unwrap();\n\
    \   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`,\
    \ found tuple\n   |\n   = note: expected reference `&str`\n                  found\
    \ tuple `(usize, char)`\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749139
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    while brackets.len() > 0 {\n\
    \        let mut open_bracket = String::new();\n        let mut close_bracket\
    \ = String::new();\n        let mut open_brackets = String::new();\n        let\
    \ mut close_brackets = String::new();\n        while brackets.len() > 0 {\n  \
    \          let mut open_bracket = String::new();\n            let mut close_bracket\
    \ = String::new();\n            let mut open_brackets = String::new();\n     \
    \       let mut close_brackets = String::new();\n            if brackets.len()\
    \ > 0 {\n                if brackets.starts_with(\"<<\") {\n                 \
    \   open_bracket = brackets.split_off(1).unwrap();\n                    open_brackets\
    \ = open_bracket.trim_left_matches('>').to_string();\n                    open_brackets\
    \ = open_brackets.trim_right_matches('<').to_string();\n                } else\
    \ if brackets.starts_with(\"<\") {\n                    open_bracket = brackets.split_off(1).unwrap();\n\
    \                    open_brackets = open_bracket.trim_left_matches('<').to_string();\n\
    \                    open_brackets = open_brackets.trim_right_matches('>').to_string();\n\
    \                } else if brackets.starts_with(\">\") {\n                   \
    \ open_bracket = brackets.split_off(1).unwrap();\n                    open_brackets\
    \ = open_bracket.trim_left_matches('>').to_string();\n                    open_brackets\
    \ = open_brackets.trim_right_matches('<').to_string();\n                } else\
    \ if brackets.starts_with(\"<<<\") {\n                    open_bracket = brackets.split_off(2).unwrap();\n\
    \                    open_brackets = open_bracket.trim_left_matches('>').to_string();\n\
    \                    open_brackets = open_brackets.trim_right_matches('<').to_string();\n\
    \                } else if brackets.starts_with(\"<>>>\") {\n                \
    \    open_bracket = brackets.split_off(3).unwrap();\n                    open_brackets\
    \ = open_bracket.trim_left_matches('>').to_string();\n                    open_brackets\
    \ = open_brackets.trim_right_matches('<').to_string();\n                } else\
    \ if brackets.starts_with(\"<<<\") {\n                    open_bracket = \n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmplocbwo81.rs:64:3\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - unclosed delimiter\n...\n15 |     while\
    \ brackets.len() > 0 {\n   |                              - unclosed delimiter\n\
    ...\n20 |         while brackets.len() > 0 {\n   |                           \
    \       - unclosed delimiter\n...\n25 |             if brackets.len() > 0 {\n\
    \   |                                   - unclosed delimiter\n...\n46 |      \
    \           } else if brackets.starts_with(\"<<<\") {\n   |                  \
    \                                     - this delimiter might not be properly closed...\n\
    47 |                     open_bracket = \n48 | }\n   | - ...as it matches this\
    \ but it has different indentation\n...\n64 | }\n   |   ^\n\nerror: expected expression,\
    \ found `}`\n  --> /tmp/tmplocbwo81.rs:48:1\n   |\n48 | }\n   | ^ expected expression\n\
    \nerror[E0599]: no method named `unwrap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmplocbwo81.rs:27:58\n   |\n27 |                     open_bracket\
    \ = brackets.split_off(1).unwrap();\n   |                                    \
    \                      ^^^^^^ method not found in `String`\n\nwarning: use of\
    \ deprecated associated function `core::str::<impl str>::trim_left_matches`: superseded\
    \ by `trim_start_matches`\n  --> /tmp/tmplocbwo81.rs:28:50\n   |\n28 |       \
    \              open_brackets = open_bracket.trim_left_matches('>').to_string();\n\
    \   |                                                  ^^^^^^^^^^^^^^^^^ help:\
    \ replace the use of the deprecated associated function: `trim_start_matches`\n\
    \   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated\
    \ associated function `core::str::<impl str>::trim_right_matches`: superseded\
    \ by `trim_end_matches`\n  --> /tmp/tmplocbwo81.rs:29:51\n   |\n29 |         \
    \            open_brackets = open_brackets.trim_right_matches('<').to_string();\n\
    \   |                                                   ^^^^^^^^^^^^^^^^^^ help:\
    \ replace the use of the deprecat"
  stdout: ''
  timestamp: 1659749139
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = Vec::new();\n    let mut open_brackets: Vec<usize> =\
    \ Vec::new();\n    let mut close_brackets: Vec<usize> = Vec::new();\n    let mut\
    \ open_brackets_size: usize = 0;\n    let mut close_brackets_size: usize = 0;\n\
    \    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut \n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmplu57kvcv.rs:51:1\n\
    \   |\n51 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut open_brackets = Vec::new();\n    let mut\
    \ close_brackets = Vec::new();\n    let mut open_brackets_count = Vec::new();\n\
    \    let mut close_brackets_count = Vec::new();\n    let mut open_brackets_count_max\
    \ = Vec::new();\n    let mut close_brackets_count_max = Vec::new();\n    let mut\
    \ open_brackets_count_min = Vec::new();\n    let mut close_brackets_count_min\
    \ = Vec::new();\n    let mut open_brackets_count_min = Vec::new();\n    let mut\
    \ close_brackets_count_min = Vec::new();\n    let mut open_brackets_count_max\
    \ = Vec::new();\n    let mut close_brackets_count_max = Vec::new();\n    let mut\
    \ open_brackets_count_min = Vec::new();\n    let mut close_brackets_count_min\
    \ = Vec::new();\n    let mut open_brackets_count_max = Vec::new();\n    let mut\
    \ close_brackets_count_max = Vec::new();\n    let mut open_brackets_count_min\
    \ = Vec::new();\n    let mut close_brackets_count_min = Vec::new();\n    let mut\
    \ open_brackets_count_max = Vec::new();\n    let mut close_brackets_count_max\
    \ = Vec::new();\n    let mut open_brackets_count_min = Vec::new();\n    let mut\
    \ close_brackets_count_min = Vec::new();\n    let mut open_brackets_count_max\
    \ = Vec::new();\n    let mut close_brackets_count_max = Vec::new();\n    let mut\
    \ open_brackets_count_min = Vec::new();\n    let mut close_brackets_count_min\
    \ = Vec::new();\n    let mut open_brackets_count_max = Vec::new();\n    let mut\
    \ close_brackets_count_max = Vec::new();\n    let mut open_brackets_count_min\
    \ = Vec::new();\n    let mut close_brackets_count_min = Vec::new();\n    let mut\
    \ open_brackets_count_max = Vec::new();\n    let mut close_brackets_count_max\
    \ = Vec::new();\n    let mut open_brackets_count_min = Vec::new();\n    let mut\
    \ close_brackets_count_min = Vec::new\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp81o1ru1d.rs:46:48\n   |\n\
    46 |     let mut close_brackets_count_min = Vec::new\n   |                   \
    \                             ^ help: add `;` here\n47 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp81o1ru1d.rs:11:44\n \
    \  |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659749139
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\">\", \"\");\n    brackets.replace(\"<<\", \"\");\n    brackets.replace(\"\
    >>\", \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    bracket\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `bracket` in this scope\n  --> /tmp/tmpqqz_o7zx.rs:72:5\n\
    \   |\n72 |     bracket\n   |     ^^^^^^^ help: a local variable with a similar\
    \ name exists: `brackets`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    for bracket in brackets.chars() {\n        if bracket == '<' {\n        \
    \    open_brackets.push('>');\n            close_brackets.push('<');\n       \
    \ } else if bracket == '>' {\n            open_brackets.push('<');\n         \
    \   close_brackets.push('>');\n        } else {\n            open_brackets.push(bracket);\n\
    \            close_brackets.push(bracket);\n        }\n    }\n    open_brackets.chars().all(|c|\
    \ close_brackets.chars().any(|c| c == c))\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqjuq_pv_.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == '<' || c == '>')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp2pvnwbzp.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659749138
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_size = brackets.chars().filter(|c| c == '<').count();\n\
    \    let mut close_brackets_size = brackets.chars().filter(|c| c == '>').count();\n\
    \    let mut open_brackets_pos = 0;\n    let mut close_brackets_pos = 0;\n   \
    \ let mut open_brackets_end = open_brackets_size;\n    let mut close_brackets_end\
    \ = close_brackets_size;\n    let mut open_brackets_char = String::new();\n  \
    \  let mut close_brackets_char = String::new();\n    let mut open_brackets_char_pos\
    \ = 0;\n    let mut close_brackets_char_pos = 0;\n    let mut open_brackets_char_end\
    \ = open_brackets_size;\n    let mut close_brackets_char_end = close_brackets_size;\n\
    \    let mut open_brackets_char_char = String::new();\n    let mut close_brackets_char_char\
    \ = String::new();\n    let mut open_brackets_char_char_pos = 0;\n    let mut\
    \ close_brackets_char_char_pos = 0;\n    let mut open_brackets_char_char_end =\
    \ open_brackets_size;\n    let mut close_brackets_char_char_end = close_brackets_size;\n\
    \    let mut open_brackets_char_char_char = String::new();\n    let mut close_brackets_char_char_char\
    \ = String::new();\n    let mut open_brackets_char_char_char_pos = 0;\n    let\
    \ mut close_brackets_char_char_char_pos = 0;\n    let mut open_brackets_char_char_char_end\
    \ = open_brackets_size;\n    let mut close_brackets_char_char_char_end = close_brackets_size;\n\
    \    let mut open_brackets_char_char_char_char = String::new();\n    let mut close_brackets_char_char_char_char\
    \ = String::new();\n    let mut open_brackets_char_char_char_char_pos = 0;\n \
    \   let mut close_brackets_char_char_char_char_pos = 0;\n    let mut open_brackets_char_char_char_char_end\
    \ = open_brackets_size;\n    let mut close_brackets_char_char_char_char_end =\
    \ close_brackets_size;\n    let mut open\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpuu1rivf4.rs:44:17\n   |\n\
    44 |     let mut open\n   |                 ^ help: add `;` here\n45 | }\n   |\
    \ - unexpected token\n\nerror[E0277]: can't compare `&char` with `char`\n  -->\
    \ /tmp/tmpuu1rivf4.rs:14:64\n   |\n14 |     let mut open_brackets_size = brackets.chars().filter(|c|\
    \ c == '<').count();\n   |                                                   \
    \             ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmpuu1rivf4.rs:15:65\n   |\n15 |     let mut\
    \ close_brackets_size = brackets.chars().filter(|c| c == '>').count();\n   | \
    \                                                                ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuu1rivf4.rs:11:44\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659749139
