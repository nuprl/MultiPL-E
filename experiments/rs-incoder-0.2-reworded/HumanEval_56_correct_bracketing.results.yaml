name: HumanEval_56_correct_bracketing
language: rs
results:
- program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    while brackets.len() > 0 {\n\
    \        let mut open_bracket = String::new();\n        let mut close_bracket\
    \ = String::new();\n        let mut open_brackets = String::new();\n        let\
    \ mut close_brackets = String::new();\n        while brackets.len() > 0 {\n  \
    \          if brackets.starts_with(\"<<\") {\n                open_bracket = brackets.split_off(1).unwrap();\n\
    \                open_brackets = open_brackets + open_bracket;\n             \
    \   brackets = brackets.split_off(1).unwrap();\n            } else if brackets.starts_with(\"\
    >>\") {\n                close_bracket = brackets.split_off(1).unwrap();\n   \
    \             close_brackets = close_brackets + close_bracket;\n             \
    \   brackets = brackets.split_off(1).unwrap();\n            } else {\n       \
    \         break;\n            }\n        }\n        if open_brackets.len() ==\
    \ close_brackets.len() {\n            if open_brackets.is_empty() {\n        \
    \        return true;\n            }\n            if close_brackets.is_empty()\
    \ {\n                return false;\n            }\n            if open_brackets.starts_with(close_brackets)\
    \ {\n                open_brackets = open_brackets.split_off(close_brackets.len()).unwrap();\n\
    \                close_brackets = close_brackets.split_off(open_brackets.len()).unwrap();\n\
    \            } else {\n                return false;\n            }\n        }\
    \ else {\n            return false;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `unwrap` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpa5ydzntl.rs:22:54\n   |\n22 |                 open_bracket\
    \ = brackets.split_off(1).unwrap();\n   |                                    \
    \                  ^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpa5ydzntl.rs:23:49\n   |\n23 |                 open_brackets\
    \ = open_brackets + open_bracket;\n   |                                      \
    \           ^^^^^^^^^^^^\n   |                                               \
    \  |\n   |                                                 expected `&str`, found\
    \ struct `String`\n   |                                                 help:\
    \ consider borrowing here: `&open_bracket`\n\nerror[E0599]: no method named `unwrap`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpa5ydzntl.rs:24:50\n\
    \   |\n24 |                 brackets = brackets.split_off(1).unwrap();\n   | \
    \                                                 ^^^^^^ method not found in `String`\n\
    \nerror[E0599]: no method named `unwrap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpa5ydzntl.rs:26:55\n   |\n26 |                 close_bracket\
    \ = brackets.split_off(1).unwrap();\n   |                                    \
    \                   ^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpa5ydzntl.rs:27:51\n   |\n27 |                 close_brackets\
    \ = close_brackets + close_bracket;\n   |                                    \
    \               ^^^^^^^^^^^^^\n   |                                          \
    \         |\n   |                                                   expected `&str`,\
    \ found struct `String`\n   |                                                \
    \   help: consider borrowing here: `&close_bracket`\n\nerror[E0599]: no method\
    \ named `unwrap` found for struct `String` in the current scope\n  --> /tmp/tmpa5ydzntl.rs:28:50\n\
    \   |\n28 |                 brackets = brackets.split_off(1).unwrap();\n   | \
    \                                                 ^^^^^^ method not found in `String`\n\
    \nerror[E"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut opening_brackets = Vec::new();\n    let\
    \ mut closing_brackets = Vec::new();\n\n    for c in brackets {\n        if c\
    \ == '<' {\n            stack.push(c);\n            opening_brackets.push(c);\n\
    \        }\n        if c == '>' {\n            if stack.len() == 0 {\n       \
    \         return false;\n            }\n            closing_brackets.push(stack.last().unwrap());\n\
    \            stack.pop();\n        }\n    }\n    if stack.len() != 0 {\n     \
    \   return false;\n    }\n    if opening_brackets.len() != closing_brackets.len()\
    \ {\n        return false;\n    }\n    for c in opening_brackets {\n        if\
    \ c != closing_brackets.last() {\n            return false;\n        }\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpv6iznvai.rs:16:14\n\
    \   |\n16 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    while brackets.len() > 0 {\n\
    \        let mut open_bracket = String::new();\n        let mut close_bracket\
    \ = String::new();\n        let mut open_brackets = String::new();\n        let\
    \ mut close_brackets = String::new();\n        while brackets.len() > 0 {\n  \
    \          let mut open_bracket = String::new();\n            let mut close_bracket\
    \ = String::new();\n            let mut open_brackets = String::new();\n     \
    \       let mut close_brackets = String::new();\n            if brackets.starts_with(\"\
    <<\") {\n                open_bracket = brackets.split_off(1).unwrap();\n    \
    \            open_brackets = open_bracket.trim_left_matches('>').trim_left_matches('<');\n\
    \                open_brackets = open_brackets.trim_left_matches('>').trim_left_matches('<');\n\
    \                open_brackets = open_brackets.trim_left_matches('>').trim_left_matches('<');\n\
    \                open_brackets = open_brackets.trim_left_matches('>').trim_left_matches('<');\n\
    \                open_brackets = open_brackets.trim_left_matches('>').trim_left_matches('<');\n\
    \                open_brackets = open_brackets.trim_left_matches('>').trim_left_matches('<');\n\
    \                open_brackets = open_brackets.trim_left_matches('>').trim_left_matches('<');\n\
    \                open_brackets = open_brackets.trim_left_matches('>').trim_left_matches('<');\n\
    \                open_brackets = open_brackets.trim_left_matches('>').trim_left_matches('<');\n\
    \                open_brackets = open_brackets.trim_left_matches('>').trim_left_matches('<');\n\
    \                open_brackets = open_brackets.trim_left_matches('>').trim_left_matches('<');\n\
    \                open_brackets = open_brackets.trim_left_matches('>').trim_left_matches('<');\n\
    \                open_brackets = open_brackets.trim_left_matches('>').trim_left_matches('<');\n\
    \                open_brackets = open_brackets.trim_left_matches('>').trim_left_matches('\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmplade58qf.rs:40:88\n\
    \   |\n40 |                 open_brackets = open_brackets.trim_left_matches('>').trim_left_matches('\n\
    \   |                                                                        \
    \                ^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0762`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_brackets_stack = Vec::new();\n    let mut closed_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack_size = open_brackets_stack.len();\n\
    \    let mut closed_brackets_stack_size = closed_brackets_stack.len();\n    let\
    \ mut open_brackets_stack_ptr = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut closed_brackets_stack_ptr = &mut closed_brackets_stack[closed_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_end = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut closed_brackets_stack_ptr_end = &mut closed_brackets_stack[closed_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_end_ptr = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut closed_brackets_stack_ptr_end_ptr = &mut closed_brackets_stack[closed_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_end_ptr_end = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut closed_brackets_stack_ptr_end_ptr_end = &mut closed_brackets_stack[closed_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_end_ptr_end_ptr = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut closed_brackets_stack_ptr_end_ptr_end_ptr = &mut closed_brackets_stack[closed_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_end_ptr_end_ptr_end = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut closed_brackets_stack_ptr_end_ptr_end_ptr_end = &mut closed_brackets_stack[closed_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_end_ptr_end_ptr_end_ptr = &mut open_brackets_stack[open_brackets_stack_size];\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptbc7efq5.rs:11:44\n   |\n\
    11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\">\", \"\");\n    brackets.replace(\"<<\", \"\");\n    brackets.replace(\"\
    >>\", \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    bracket\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `bracket` in this scope\n  --> /tmp/tmpqqz_o7zx.rs:72:5\n\
    \   |\n72 |     bracket\n   |     ^^^^^^^ help: a local variable with a similar\
    \ name exists: `brackets`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    for bracket in brackets.chars() {\n        if bracket == '<' {\n        \
    \    open_brackets.push('>');\n            closed_brackets.push('<');\n      \
    \  } else if bracket == '>' {\n            open_brackets.push('<');\n        \
    \    closed_brackets.push('>');\n        } else {\n            open_brackets.push(bracket);\n\
    \        }\n    }\n    open_brackets.chars().all(|c| closed_brackets.chars().any(|c|\
    \ c == c))\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmphv1quxrr.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().skip_while(|c| !c.is_ascii_letter()).collect());\n\
    \    while stack.len() > 0 {\n        let mut open = stack.pop();\n        let\
    \ mut close = stack.pop();\n        if open == close {\n            continue;\n\
    \        }\n        if open == \">\" && close == \"<\" {\n            stack.push(\"\
    <<\");\n            stack.push(\"<<\");\n            stack.push(\"<<\");\n   \
    \         stack.push(\"<<\");\n            stack.push(\"<<\");\n            stack.push(\"\
    <<\");\n            stack.push(\"<<\");\n            stack.push(\"<<\");\n   \
    \         stack.push(\"<<\");\n            stack.push(\"<<\");\n            stack.push(\"\
    <<\");\n            stack.push(\"<<\");\n            stack.push(\"<<\");\n   \
    \         stack.push(\"<<\");\n            stack.push(\"<<\");\n            stack.push(\"\
    <<\");\n            stack.push(\"<<\");\n            stack.push(\"<<\");\n   \
    \         stack.push(\"<<\");\n            stack.push(\"<<\");\n            stack.push(\"\
    <<\");\n            stack.push(\"<<\");\n            stack.push(\"<<\");\n   \
    \         stack.push(\"<<\");\n            stack.push(\"<<\");\n            stack.push(\"\
    <<\");\n            stack.push(\"<<\");\n            stack.push(\"<<\");\n   \
    \         stack.push(\"<<\");\n            stack.push(\"<<\");\n            stack.push(\"\
    <<\");\n            stack.push(\"<<\");\n            stack.push(\"<<\");\n   \
    \         stack.push(\"<<\");\n            stack.push(\"<<\");\n            stack.push(\"\
    <<\");\n            stack.push(\"<<\");\n            stack.push(\"<<\");\n   \
    \         stack.push(\"<<\");\n            stack.push(\"<<\");\n            stack.push(\"\
    <<\");\n            stack.push(\"<<\");\n            stack.push(\"<<\");\n   \
    \         stack.push(\"<<\");\n            stack.push(\"<<\");\n            stack.push(\"\
    <<\");\n            stack.push(\"<<\");\n            stack.push(\"<<\");\n   \
    \         stack.push(\"<<\");\n            stack.push(\"<<\");\n            stack.push(\"\
    <<\");\n            stack.push(\"<<\");\n            stack.push(\"<<\");\n   \
    \         stack.push(\"<<\");\n            stack.push(\"<<\");\n            stack.push(\"\
    <<\");\n            stack.push(\"<<\");\n            stack.push(\"<<\");\n   \
    \         stack.push(\"<<\");\n            stack.push(\"<<\");\n            stack.push(\"\
    <<\");\n            stack.push(\"<<\");\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpu6pcnxvh.rs:99:3\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - unclosed delimiter\n...\n14 |     while\
    \ stack.len() > 0 {\n   |                           - unclosed delimiter\n...\n\
    20 |         if open == \">\" && close == \"<\" {\n   |                      \
    \                  - this delimiter might not be properly closed...\n...\n83 |\
    \ }\n   | - ...as it matches this but it has different indentation\n...\n99 |\
    \ }\n   |   ^\n\nerror[E0599]: no method named `is_ascii_letter` found for reference\
    \ `&char` in the current scope\n  --> /tmp/tmpu6pcnxvh.rs:13:51\n   |\n13 |  \
    \   stack.push(brackets.chars().skip_while(|c| !c.is_ascii_letter()).collect());\n\
    \   |                                                   ^^^^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `is_ascii`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpu6pcnxvh.rs:20:20\n   |\n20 |         if open\
    \ == \">\" && close == \"<\" {\n   |                    ^^^ expected enum `Option`,\
    \ found `&str`\n   |\n   = note:   expected enum `Option<_>`\n           found\
    \ reference `&'static str`\nhelp: try wrapping the expression in `Some`\n   |\n\
    20 |         if open == Some(\">\") && close == \"<\" {\n   |                \
    \    +++++   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu6pcnxvh.rs:20:36\n\
    \   |\n20 |         if open == \">\" && close == \"<\" {\n   |               \
    \                     ^^^ expected enum `Option`, found `&str`\n   |\n   = note:\
    \   expected enum `Option<_>`\n           found reference `&'static str`\nhelp:\
    \ try wrapping the expression in `Some`\n   |\n20 |         if open == \">\" &&\
    \ close == Some(\"<\") {\n   |                                    +++++   +\n\n\
    error[E0277]: a value of type `&str` cannot be built from an iterator over elements\
    \ of type `char`\n    --> /tmp/tmpu6pcnxvh.rs:13:70\n     |\n13   |     stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).collect());\n     |                                  \
    \                                    ^^^^^^^ v"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = Vec::new();\n    let mut open_brackets: Vec<usize> =\
    \ Vec::new();\n    let mut close_brackets: Vec<usize> = Vec::new();\n    let mut\
    \ open_brackets_size: usize = 0;\n    let mut close_brackets_size: usize = 0;\n\
    \    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut \n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmplu57kvcv.rs:51:1\n\
    \   |\n51 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack_size = open_brackets_stack.len();\n\
    \    let mut close_brackets_stack_size = close_brackets_stack.len();\n    let\
    \ mut open_brackets_stack_ptr = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut close_brackets_stack_ptr = &mut close_brackets_stack[close_brackets_stack_size];\n\
    \    let mut open_brackets_ptr = &mut open_brackets[open_brackets_stack_ptr];\n\
    \    let mut close_brackets_ptr = &mut close_brackets[close_brackets_stack_ptr];\n\
    \    let mut open_brackets_ptr_end = &mut open_brackets[open_brackets_stack_ptr];\n\
    \    let mut close_brackets_ptr_end = &mut close_brackets[close_brackets_stack_ptr];\n\
    \    let mut open_brackets_ptr_end_ptr = &mut open_brackets_ptr_end;\n    let\
    \ mut close_brackets_ptr_end_ptr = &mut close_brackets_ptr_end;\n    let mut open_brackets_ptr_end_ptr_end\
    \ = &mut open_brackets_ptr_end;\n    let mut close_brackets_ptr_end_ptr_end =\
    \ &mut close_brackets_ptr_end;\n    let mut open_brackets_ptr_end_ptr_end_ptr\
    \ = &mut open_brackets_ptr_end_ptr_end;\n    let mut close_brackets_ptr_end_ptr_end_ptr\
    \ = &mut close_brackets_ptr_end_ptr_end;\n    let mut open_brackets_ptr_end_ptr_end_ptr_end\
    \ = &mut open_brackets_ptr_end_ptr_end_ptr;\n    let mut close_brackets_ptr_end_ptr_end_ptr_end\
    \ = &mut close_brackets_ptr_end_ptr_end_ptr;\n    let mut open_brackets_ptr_end_ptr_end_ptr_\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9wnvsse4.rs:32:47\n   |\n\
    32 |     let mut open_brackets_ptr_end_ptr_end_ptr_\n   |                    \
    \                           ^ help: add `;` here\n33 | }\n   | - unexpected token\n\
    \nerror[E0277]: the type `String` cannot be indexed by `&mut _`\n  --> /tmp/tmp9wnvsse4.rs:20:38\n\
    \   |\n20 |     let mut open_brackets_ptr = &mut open_brackets[open_brackets_stack_ptr];\n\
    \   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `&mut _`\n   |\n   = help: the trait `Index<&mut\
    \ _>` is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `&mut _`\n\
    \  --> /tmp/tmp9wnvsse4.rs:21:39\n   |\n21 |     let mut close_brackets_ptr =\
    \ &mut close_brackets[close_brackets_stack_ptr];\n   |                       \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `&mut _`\n   |\n   = help: the trait `Index<&mut _>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `&mut _`\n\
    \  --> /tmp/tmp9wnvsse4.rs:22:42\n   |\n22 |     let mut open_brackets_ptr_end\
    \ = &mut open_brackets[open_brackets_stack_ptr];\n   |                       \
    \                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    for c in brackets {\n        if c == '<' {\n            opening_brackets.push(c);\n\
    \        } else {\n            closing_brackets.push(c);\n        }\n    }\n \
    \   opening_brackets.chars().all(|c| closing_brackets.chars().any(|c| c == c))\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp2n4qbnn7.rs:14:14\n\
    \   |\n14 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiapp5l8z.rs:11:44\n   |\n\
    11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_brackets_stack = Vec::new();\n    let mut closed_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack_size = open_brackets_stack.len();\n\
    \    let mut closed_brackets_stack_size = closed_brackets_stack.len();\n    let\
    \ mut open_brackets_stack_pos = 0;\n    let mut closed_brackets_stack_pos = 0;\n\
    \    let mut open_brackets_stack_end = open_brackets_stack_size;\n    let mut\
    \ closed_brackets_stack_end = closed_brackets_stack_size;\n    let mut open_brackets_stack_last_pos\
    \ = 0;\n    let mut closed_brackets_stack_last_pos = 0;\n    let mut open_brackets_stack_last_end\
    \ = open_brackets_stack_size;\n    let mut closed_brackets_stack_last_end = closed_brackets_stack_size;\n\
    \    let mut open_brackets_stack_last_size = open_brackets_stack_size;\n    let\
    \ mut closed_brackets_stack_last_size = closed_brackets_stack_size;\n    let mut\
    \ open_brackets_stack_last_pos = 0;\n    let mut closed_brackets_stack_last_pos\
    \ = 0;\n    let mut open_brackets_stack_last_end = open_brackets_stack_size;\n\
    \    let mut closed_brackets_stack_last_end = closed_brackets_stack_size;\n  \
    \  let mut open_brackets_stack_last_size = open_brackets_stack_size;\n    let\
    \ mut closed_brackets_stack_last_size = closed_brackets_stack_size;\n    let mut\
    \ open_brackets_stack_last_pos = 0;\n    let mut closed_brackets_stack_last_pos\
    \ = 0;\n    let mut open_brackets_stack_last_end = open_brackets_stack_size;\n\
    \    let mut closed_brackets_stack_last_end = closed_brackets_stack_size;\n  \
    \  let mut open_brackets_stack_last_size = open_brackets_stack_size;\n    let\
    \ mut closed_brackets_stack_last_size = closed_brackets_stack_size;\n    let mut\
    \ open_brackets_stack_last_pos = 0;\n    let mut closed_brackets_stack_last_pos\
    \ = 0;\n    let mut open_brackets_stack_last_end = open_brackets_stack_size;\n\
    \    let mut closed_brackets_stack_last_end = closed_brackets_stack\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmps7ccqijp.rs:43:67\n   |\n\
    43 |     let mut closed_brackets_stack_last_end = closed_brackets_stack\n   |\
    \                                                                   ^ help: add\
    \ `;` here\n44 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmps7ccqijp.rs:11:44\n   |\n11 | fn correct_bracketing(brackets: String)\
    \ -> bool {\n   |    ------------------                      ^^^^ expected `bool`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_brackets_stack = Vec::new();\n    let mut closed_brackets_stack\
    \ = Vec::new();\n    let mut i = 0;\n    while i < brackets.len() {\n        let\
    \ c = brackets[i];\n        if c == '<' {\n            if open_brackets_stack.len()\
    \ == 0 {\n                open_brackets_stack.push(i);\n            }\n      \
    \      open_brackets.push(c);\n        } else if c == '>' {\n            if closed_brackets_stack.len()\
    \ == 0 {\n                closed_brackets_stack.push(i);\n            }\n    \
    \        closed_brackets.push(c);\n        } else {\n            if open_brackets_stack.len()\
    \ > 0 {\n                open_brackets_stack.pop();\n            }\n         \
    \   if closed_brackets_stack.len() > 0 {\n                closed_brackets_stack.pop();\n\
    \            }\n        }\n        i += 1;\n    }\n    if open_brackets.len()\
    \ != closed_brackets.len() {\n        return false;\n    }\n    let mut i = 0;\n\
    \    while i < open_brackets.len() {\n        if open_brackets[i] != closed_brackets[i]\
    \ {\n            return false;\n        }\n        i += 1;\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp0ol5um2w.rs:18:17\n\
    \   |\n18 |         let c = brackets[i];\n   |                 ^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp0ol5um2w.rs:44:12\n   |\n44 |         if open_brackets[i] != closed_brackets[i]\
    \ {\n   |            ^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp0ol5um2w.rs:44:32\n   |\n44 |         if open_brackets[i] != closed_brackets[i]\
    \ {\n   |                                ^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for c in brackets {\n        if c == '<' {\n  \
    \          stack.push(c);\n        } else if c == '>' {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.pop();\n\
    \        } else {\n            if stack.len() != 0 {\n                return false;\n\
    \            }\n        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n   \
    \ let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmprh1locet.rs:13:14\n\
    \   |\n13 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    let mut opening_bracket = String::new();\n    let mut closing_bracket = String::new();\n\
    \    let mut opening_brackets = String::new();\n    let mut closing_brackets =\
    \ String::new();\n    let mut opening_bracket = String::new();\n    let mut closing_bracket\
    \ = String::new();\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_brackets = String::new();\n    let mut opening_bracket = String::new();\n\
    \    let mut closing_bracket = String::new();\n    let mut opening_brackets =\
    \ String::new();\n    let mut closing_brackets = String::new();\n    let mut opening_bracket\
    \ = String::new();\n    let mut closing_bracket = String::new();\n    let mut\
    \ opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    let mut opening_bracket = String::new();\n    let mut closing_bracket = String::new();\n\
    \    let mut opening_brackets = String::new();\n    let mut closing_brackets =\
    \ String::new();\n    let mut opening_bracket = String::new();\n    let mut closing_bracket\
    \ = String::new();\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_brackets = String::new();\n    let mut opening_bracket = String::new();\n\
    \    let mut closing_bracket = String::new();\n    let mut opening_brackets =\
    \ String::new();\n    let mut closing_brackets = String::new();\n    let mut opening_bracket\
    \ = String::new();\n    let mut closing_bracket = String::new();\n    let mut\
    \ opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    let mut opening_bracket = String::new();\n    let mut closing_bracket = String::new();\n\
    \    let mut opening_brackets = String::new();\n    let mut closing_brackets =\
    \ String::new();\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvxb4ya5q.rs:11:44\n   |\n\
    11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    for bracket in brackets.chars() {\n        if bracket == '<' {\n        \
    \    open_brackets.push('>');\n            close_brackets.push('<');\n       \
    \ } else if bracket == '>' {\n            open_brackets.push('<');\n         \
    \   close_brackets.push('>');\n        } else {\n            open_brackets.push(bracket);\n\
    \            close_brackets.push(bracket);\n        }\n    }\n    open_brackets\
    \ == close_brackets\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpfl7zrlyv.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = vec![];\n    for c in brackets.chars() {\n        if c == '<' {\n\
    \            stack.push(c);\n        } else if c == '>' {\n            if stack.is_empty()\
    \ {\n                return false;\n            }\n            stack.pop();\n\
    \        } else {\n            return false;\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_iter = brackets.chars().enumerate().filter(|(_, c)|\
    \ c != '<').collect::<Vec<_>>();\n    let mut close_brackets_iter = brackets.chars().enumerate().filter(|(_,\
    \ c)| c != '>').collect::<Vec<_>>();\n    let mut open_brackets_iter = open_brackets_iter.into_iter().map(|(_,\
    \ c)| c as char);\n    let mut close_brackets_iter = close_brackets_iter.into_iter().map(|(_,\
    \ c)| c as char);\n    let mut open_brackets_iter = open_brackets_iter.filter(|c|\
    \ !open_brackets.contains(&c));\n    let mut close_brackets_iter = close_brackets_iter.filter(|c|\
    \ !close_brackets.contains(&c));\n    let mut open_brackets_iter = open_brackets_iter.collect::<Vec<_>>();\n\
    \    let mut close_brackets_iter = close_brackets_iter.collect::<Vec<_>>();\n\
    \    let mut open_brackets_iter = open_brackets_iter.into_iter().map(|c| c as\
    \ char);\n    let mut close_brackets_iter = close_brackets_iter.into_iter().map(|c|\
    \ c as char);\n    let mut open_brackets_iter = open_brackets_iter.filter(|c|\
    \ !open_brackets.contains(&c));\n    let mut close_brackets_iter = close_brackets_iter.filter(|c|\
    \ !close_brackets.contains(&c));\n    let mut open_brackets_iter = open_brackets_iter.collect::<Vec<_>>();\n\
    \    let mut close_brackets_iter = close_brackets_iter.collect::<Vec<_>>();\n\
    \    let mut open_brackets_iter = open_brackets_iter.into_iter().map(|c| c as\
    \ char);\n    let mut close_brackets_iter = close_brackets_iter.into_iter().map(|c|\
    \ c as char);\n    let mut open_brackets_iter = open_brackets_iter.filter(|c|\
    \ !open_brackets.contains(&c));\n    let mut close_bra\n}\n\nfn main() {\n   \
    \ let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpjq836bjc.rs:31:22\n   |\n\
    31 |     let mut close_bra\n   |                      ^ help: add `;` here\n32\
    \ | }\n   | - unexpected token\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpjq836bjc.rs:14:81\n   |\n14 |     let mut open_brackets_iter =\
    \ brackets.chars().enumerate().filter(|(_, c)| c != '<').collect::<Vec<_>>();\n\
    \   |                                                                        \
    \         ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpjq836bjc.rs:15:82\n   |\n15 |     let mut close_brackets_iter =\
    \ brackets.chars().enumerate().filter(|(_, c)| c != '>').collect::<Vec<_>>();\n\
    \   |                                                                        \
    \          ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: expected a `Fn<(char,)>` closure,\
    \ found `char`\n    --> /tmp/tmpjq836bjc.rs:18:88\n     |\n18   |     let mut\
    \ open_brackets_iter = open_brackets_iter.filter(|c| !open_brackets.contains(&c));\n\
    \     |                                                                      \
    \         -------- ^^ expected an `Fn<(char,)>` closure, found `char`\n     |\
    \                                                                            \
    \   |\n     |                                                                \
    \               required by a bound introduced by this call\n     |\n     = help:\
    \ the trait `Fn<(char,)>` is not implemented for `char`\n     = help: the trait\
    \ `Pattern<'a>` is implemented for `char`\n     = note: required because of the\
    \ requirements on the impl of `FnOnce<(char,)>` for `&char`\n     = note: required\
    \ because of the requirements on the impl of `Pattern<'_>` for `&&char`\nnote:\
    \ required by a bound in `core::str::<impl str>::contains`\n\ne"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_count = String::new();\n    let mut close_brackets_count\
    \ = String::new();\n    let mut open_brackets_count_map = HashMap::new();\n  \
    \  let mut close_brackets_count_map = HashMap::new();\n    let mut open_brackets_count_map_sorted\
    \ = HashMap::new();\n    let mut close_brackets_count_map_sorted = HashMap::new();\n\
    \    let mut open_brackets_count_map_sorted_reverse = HashMap::new();\n    let\
    \ mut close_brackets_count_map_sorted_reverse = HashMap::new();\n    let mut open_brackets_count_map_sorted_reverse_sorted\
    \ = HashMap::new();\n    let mut close_brackets_count_map_sorted_reverse_sorted\
    \ = HashMap::new();\n    let mut open_brackets_count_map_sorted_reverse_sorted_reverse\
    \ = HashMap::new();\n    let mut close_brackets_count_map_sorted_reverse_sorted_reverse\
    \ = HashMap::new();\n    let mut open_brackets_count_map_sorted_reverse_sorted_reverse_sorted\
    \ = HashMap::new();\n    let mut close_brackets_count_map_sorted_reverse_sorted_reverse_sorted\
    \ = HashMap::new();\n    let mut open_brackets_count_map_sorted_reverse_sorted_reverse_sorted_reverse\
    \ = HashMap::new();\n    let mut close_brackets_count_map_sorted_reverse_sorted_reverse_sorted_reverse\
    \ = HashMap::new();\n    let mut open_brackets_count_map_sorted_reverse_sorted_reverse_sorted_reverse_sorted\
    \ = HashMap::new();\n    let mut close_brackets_count_map_sorted_reverse_sorted_reverse_sorted_reverse_sorted\
    \ = HashMap::new();\n    let mut open_brackets_count_map_sorted_reverse_sorted_reverse_sorted_reverse_sorted_reverse\
    \ = HashMap::new();\n    let mut close_brackets_count_map_sorted_reverse_sorted_reverse_sorted_reverse_sorted_reverse\
    \ = HashMap::new();\n    let mut open_brackets_count_map_sorted_reverse_sorted_reverse_sorted_reverse_sorted_reverse_sorted\
    \ = HashMap::new();\n    let mut close_brackets_count_map_sorted_reverse_sorted_reverse_sorted_reverse_sorted_reverse_sorted\
    \ = HashMap::new();\n    let mut open_brackets_count_map_sorted_reverse_sorted_reverse_sorted_reverse_sorted_reverse_sorted_reverse\
    \ = HashMap::new();\n    let mut \n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp8gbph9e8.rs:38:1\n\
    \   |\n38 | }\n   | ^ expected identifier\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmp8gbph9e8.rs:16:39\n   |\n16\
    \ |     let mut open_brackets_count_map = HashMap::new();\n   |              \
    \                         ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp8gbph9e8.rs:17:40\n\
    \   |\n17 |     let mut close_brackets_count_map = HashMap::new();\n   |     \
    \                                   ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmp8gbph9e8.rs:18:46\n   |\n18 |     let mut open_brackets_count_map_sorted\
    \ = HashMap::new();\n   |                                              ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmp8gbph9e8.rs:19:47\n   |\n19\
    \ |     let mut close_brackets_count_map_sorted = HashMap::new();\n   |      \
    \                                         ^^^^^^^ not found in this scope\n  \
    \ |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmp8gbph9e8.rs:20:54\n   |\n20 |     let mut open_brackets_count_map_sorted_reverse\
    \ = HashMap::new();\n   |                                                    \
    \  ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmp8gbph9e8.rs:21:55\n   |\n21\
    \ |     let mut close_brackets_count_map_sorted_reverse = HashMap::new();\n  \
    \ |                                                       ^^^^^^^ no"
  exit_code: 1
  status: SyntaxError
- program: "/// brackets is a string of \"<\" and \">\".\n/// return true if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_brackets_iter = brackets.char_indices();\n    let mut closed_brackets_iter\
    \ = brackets.char_indices();\n    let mut open_brackets_next = open_brackets_iter.next();\n\
    \    let mut closed_brackets_next = closed_brackets_iter.next();\n    while let\
    \ Some(open_bracket) = open_brackets_next {\n        if let Some(closed_bracket)\
    \ = closed_brackets_next {\n            if open_bracket.0 != closed_bracket.0\
    \ {\n                open_brackets += open_bracket;\n                closed_brackets\
    \ += closed_bracket;\n            }\n            open_brackets_next = open_brackets_iter.next();\n\
    \            closed_brackets_next = closed_brackets_iter.next();\n        } else\
    \ {\n            open_brackets += open_bracket;\n            closed_brackets_next\
    \ = closed_brackets_iter.next();\n        }\n    }\n    open_brackets == closed_brackets\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph_goy0gb.rs:21:34\n   |\n\
    21 |                 open_brackets += open_bracket;\n   |                    \
    \              ^^^^^^^^^^^^ expected `&str`, found tuple\n   |\n   = note: expected\
    \ reference `&str`\n                  found tuple `(usize, char)`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmph_goy0gb.rs:22:36\n   |\n22 |              \
    \   closed_brackets += closed_bracket;\n   |                                 \
    \   ^^^^^^^^^^^^^^ expected `&str`, found tuple\n   |\n   = note: expected reference\
    \ `&str`\n                  found tuple `(usize, char)`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmph_goy0gb.rs:27:30\n   |\n27 |             open_brackets\
    \ += open_bracket;\n   |                              ^^^^^^^^^^^^ expected `&str`,\
    \ found tuple\n   |\n   = note: expected reference `&str`\n                  found\
    \ tuple `(usize, char)`\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
