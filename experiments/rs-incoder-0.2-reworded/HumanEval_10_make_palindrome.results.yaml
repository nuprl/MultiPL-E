language: rs
name: HumanEval_10_make_palindrome
results:
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut reverse_length = 0;\n    let\
    \ mut longest_postfix_length = 0;\n    let mut longest_postfix_start = -1;\n \
    \   for pos in string.char_indices() {\n        let mut postfix_length = pos;\n\
    \        let mut postfix_start = pos;\n        while postfix_start < postfix_length\
    \ {\n            let c = string.chars()[postfix_start];\n            if c != string[postfix_start\
    \ + 1] {\n                break;\n            }\n            postfix_start +=\
    \ 1;\n        }\n        if postfix_start > reverse_length {\n            longest_postfix_length\
    \ = postfix_length;\n            longest_postfix_start = postfix_start;\n    \
    \    }\n        reverse_length += postfix_length;\n    }\n    let mut postfix_start\
    \ = longest_postfix_start;\n    let mut postfix_length = longest_postfix_length;\n\
    \    let mut postfix_end = -1;\n    while postfix_end < postfix_length {\n   \
    \     let c = string.chars()[postfix_end];\n        if c != string[postfix_end\
    \ - 1] {\n            break;\n        }\n        postfix_end += 1;\n    }\n  \
    \  let mut postfix_start = longest_postfix_start;\n    let mut postfix_length\
    \ = longest_postfix_length;\n    let mut postfix_end = -1;\n    while postfix_end\
    \ < postfix_length {\n        let c = string.chars()[postfix_end];\n        if\
    \ c != string[postfix_end - 1] {\n            break;\n        }\n        postfix_end\
    \ += 1;\n    }\n    let mut postfix_start = longest_postfix_start;\n    let mut\
    \ postfix_length = longest_postfix_length;\n    let mut postfix_end = -1;\n  \
    \  while postfix_end < postfix_length {\n        let c = string.chars()[postfix_end];\n\
    \        if c != string[postfix_end - 1] {\n            break;\n        }\n  \
    \      postfix_end += 1;\n    }\n    let mut postfix_start = longest_postfix_start;\n\
    \    let mut postfix_length = longest_postfix_length;\n    let mut postfix_end\
    \ = -1;\n    while postfix_end < postfix_length {\n        let c = string.chars()[postfix_end];\n\
    \        if c != string[postfix_end - 1] {\n            break;\n        }\n  \
    \      postfix_end += 1;\n    }\n    let mut postfix_start = longest_postfix_start;\n\
    \    let mut postfix_length = longest_postfix_length;\n    let mut postfix_end\
    \ = -1;\n    while postfix_end < postfix_length {\n        let c = string.chars()[postfix_end];\n\
    \        if c != string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpr3nm56gt.rs:87:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n75 |     while postfix_end\
    \ < postfix_length {\n   |                                        - this delimiter\
    \ might not be properly closed...\n...\n78 | }\n   | - ...as it matches this but\
    \ it has different indentation\n...\n87 | }\n   |   ^\n\nerror: expected `{`,\
    \ found `}`\n  --> /tmp/tmpr3nm56gt.rs:78:1\n   |\n77 |         if c != string\n\
    \   |         -- this `if` expression has a condition, but no block\n78 | }\n\
    \   | ^ expected `{`\n\nerror[E0608]: cannot index into a value of type `Chars<'_>`\n\
    \  --> /tmp/tmpr3nm56gt.rs:20:21\n   |\n20 |             let c = string.chars()[postfix_start];\n\
    \   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0369]: cannot\
    \ add `{integer}` to `(usize, char)`\n  --> /tmp/tmpr3nm56gt.rs:21:42\n   |\n\
    21 |             if c != string[postfix_start + 1] {\n   |                   \
    \         ------------- ^ - {integer}\n   |                            |\n   |\
    \                            (usize, char)\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `(usize, char)`\n  --> /tmp/tmpr3nm56gt.rs:24:13\n\
    \   |\n24 |             postfix_start += 1;\n   |             -------------^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `(usize, char)`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpr3nm56gt.rs:26:28\n   |\n26 |\
    \         if postfix_start > reverse_length {\n   |                          \
    \  ^^^^^^^^^^^^^^ expected tuple, found integer\n   |\n   = note: expected tuple\
    \ `(usize, char)`\n               found type `{integer}`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpr3nm56gt.rs:27:38\n   |\n14 |     let mut longest_postfix_length\
    \ = 0;\n   |                                      - expected due to this value\n\
    ...\n27 |             longest_postfix_length = postfix_length;\n   |         \
    \                             ^^^^^^^^^^^^^^ expected integer, found tuple\n \
    \  |\n   = note: expected type"
  stdout: ''
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_postfix_length = 0;\n\
    \    let mut longest_postfix_index = 0;\n    for index in 0..string.len() {\n\
    \        let mut postfix_length = string.len() - index;\n        let mut postfix_char\
    \ = string[index];\n        while postfix_length >= longest_postfix_length {\n\
    \            longest_postfix_length = longest_postfix_length + longest_postfix_length;\n\
    \            longest_postfix_index += 1;\n            postfix_length -= 1;\n \
    \           postfix_char = string[longest_postfix_index];\n        }\n       \
    \ reversed_string.push_str(&postfix_char);\n    }\n    reversed_string\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpx86m5dx7.rs:17:32\n\
    \   |\n17 |         let mut postfix_char = string[index];\n   |              \
    \                  ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpx86m5dx7.rs:22:28\n\
    \   |\n22 |             postfix_char = string[longest_postfix_index];\n   |  \
    \                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the size for values of type `str` cannot be known\
    \ at compilation time\n  --> /tmp/tmpx86m5dx7.rs:17:13\n   |\n17 |         let\
    \ mut postfix_char = string[index];\n   |             ^^^^^^^^^^^^^^^^ doesn't\
    \ have a size known at compile-time\n   |\n   = help: the trait `Sized` is not\
    \ implemented for `str`\n   = note: all local variables must have a statically\
    \ known size\n   = help: unsized locals are gated as an unstable feature\nhelp:\
    \ consider borrowing here\n   |\n17 |         let mut postfix_char = &string[index];\n\
    \   |                                +\n\nerror: aborting due to 3 pr"
  stdout: ''
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut reversed_string_len = 0;\n\
    \    let mut longest_palindrome = string;\n    let mut longest_palindrome_len\
    \ = 0;\n    while !reversed_string.is_empty() {\n        let mut current_char\
    \ = reversed_string[0];\n        reversed_string = &reversed_string[1..];\n  \
    \      reversed_string_len -= 1;\n        while !reversed_string.is_empty() {\n\
    \            let mut next_char = reversed_string[0];\n            reversed_string\
    \ = &reversed_string[1..];\n            reversed_string_len -= 1;\n          \
    \  if current_char == next_char {\n                longest_palindrome_len += 1;\n\
    \                longest_palindrome = longest_palindrome.to_owned() + &current_char;\n\
    \                break;\n            }\n            current_char = next_char;\n\
    \        }\n    }\n    longest_palindrome = longest_palindrome.to_owned() + &string[reversed_string_len..];\n\
    \    longest_palindrome_len += 1;\n    longest_palindrome\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpdu297ptv.rs:17:32\n   |\n17 |         let mut current_char = reversed_string[0];\n\
    \   |                                ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdu297ptv.rs:18:27\n\
    \   |\n12 |     let mut reversed_string = string;\n   |                      \
    \         ------ expected due to this value\n...\n18 |         reversed_string\
    \ = &reversed_string[1..];\n   |                           ^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n18 |         reversed_string = (&reversed_string[1..]).to_string();\n \
    \  |                           +                     +++++++++++++\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpdu297ptv.rs:21:33\n\
    \   |\n21 |             let mut next_char = reversed_string[0];\n   |        \
    \                         ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdu297ptv.rs:22:31\n\
    \   "
  stdout: ''
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = string;\n    let\
    \ mut i = 0;\n    while i < string.len() {\n        let mut j = i;\n        while\
    \ j + 1 < string.len() && string[j] == string[j + 1] {\n            j += 1\n \
    \       }\n        reversed_string.push((&string[i..j]).to_lowercase());\n   \
    \     i = j;\n    }\n    reversed_string\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpzp42t55t.rs:17:39\n\
    \   |\n17 |         while j + 1 < string.len() && string[j] == string[j + 1] {\n\
    \   |                                       ^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpzp42t55t.rs:17:52\n   |\n17 |         while j + 1 < string.len()\
    \ && string[j] == string[j + 1] {\n   |                                      \
    \              ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzp42t55t.rs:20:30\n   |\n20 |         reversed_string.push((&string[i..j]).to_lowercase());\n\
    \   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found struct `String`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_length_index = 0;\n\
    \    let mut longest_postfix_length_palindrome = 0;\n    let mut longest_postfix_length_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length = 0;\n    let mut\
    \ longest_postfix_length_palindrome_length_index = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_palindrome\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpo842343v.rs:35:53\n   |\n\
    35 |     let mut longest_postfix_length_palindrome_length\n   |              \
    \                                       ^ help: add `;` here\n36 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo842343v.rs:11:39\n \
    \  |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut palindrome = string;\n   \
    \ let mut suffix_length = 0;\n    let mut prefix_length = 0;\n    while !reversed_string.starts_with(palindrome)\
    \ {\n        let mut suffix_start = suffix_length;\n        let mut prefix_start\
    \ = prefix_length;\n        while suffix_start < palindrome.len() && palindrome[suffix_start]\
    \ == reversed_string[prefix_start] {\n            suffix_start += 1;\n       \
    \     prefix_start += 1;\n        }\n        if suffix_start == palindrome.len()\
    \ {\n            break;\n        }\n        palindrome = palindrome.clone();\n\
    \        reversed_string = reversed_string.clone();\n        suffix_length = suffix_start;\n\
    \        prefix_length = prefix_start;\n    }\n    palindrome\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmpig5fjy3z.rs:16:40\n     |\n16   |     while !reversed_string.starts_with(palindrome)\
    \ {\n     |                            ----------- ^^^^^^^^^^ expected an implementor\
    \ of trait `Pattern<'_>`\n     |                            |\n     |        \
    \                    required by a bound introduced by this call\n     |\n   \
    \  = note: the trait bound `String: Pattern<'_>` is not satisfied\n     = note:\
    \ required because of the requirements on the impl of `Pattern<'_>` for `String`\n\
    note: required by a bound in `core::str::<impl str>::starts_with`\nhelp: consider\
    \ borrowing here\n     |\n16   |     while !reversed_string.starts_with(&palindrome)\
    \ {\n     |                                        +\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmpig5fjy3z.rs:19:50\n   |\n\
    19 |         while suffix_start < palindrome.len() && palindrome[suffix_start]\
    \ == reversed_string[prefix_start] {\n   |                                   \
    \               ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpig5fjy3z.rs:19:78\n   |\n19 |         while suffix_start < palindrome.len()\
    \ && palindrome[suffix_start] == reversed_string[prefix_start] {\n   |       \
    \                                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other t"
  stdout: ''
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    let\
    \ mut longest_postfix_index2 = 0;\n    let mut longest_postfix_index3 = 0;\n \
    \   let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5 =\
    \ 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut longest_postfix_index44 = 0;\n    let mut longest_postfix_index45\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp07tycyg2.rs:59:36\n   |\n\
    59 |     let mut longest_postfix_index45\n   |                               \
    \     ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp07tycyg2.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed = string;\n    let mut prefix = string;\n    let mut suffix\
    \ = string;\n    let mut i = 0;\n    while i < prefix.len() {\n        let mut\
    \ j = i;\n        while j + 1 < prefix.len() && prefix[j] == prefix[j + 1] {\n\
    \            j += 1\n        }\n        if j == i {\n            break;\n    \
    \    }\n        reversed.push_str(&prefix[j..i]);\n        i += j - i;\n    }\n\
    \    reversed.push_str(&suffix[i..]);\n    reversed\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmptezy1__y.rs:18:39\n\
    \   |\n18 |         while j + 1 < prefix.len() && prefix[j] == prefix[j + 1] {\n\
    \   |                                       ^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmptezy1__y.rs:18:52\n   |\n18 |         while j + 1 < prefix.len()\
    \ && prefix[j] == prefix[j + 1] {\n   |                                      \
    \              ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut prefix_length = 0;\n    let\
    \ mut suffix_length = 0;\n    while !reversed_string.is_empty() {\n        let\
    \ mut current_char = reversed_string.chars().next();\n        if current_char.is_none()\
    \ {\n            break;\n        }\n        let mut current_char = current_char.unwrap();\n\
    \        if current_char == &'a' {\n            prefix_length += 1;\n        }\n\
    \        if current_char == &'z' {\n            suffix_length += 1;\n        }\n\
    \        if current_char == &'A' {\n            prefix_length += 1;\n        }\n\
    \        if current_char == &'Z' {\n            suffix_length += 1;\n        }\n\
    \        if current_char == &'0' {\n            suffix_length += 1;\n        }\n\
    \        if current_char == &'9' {\n            suffix_length += 1;\n        }\n\
    \        if current_char == &'-' {\n            suffix_length += 1;\n        }\n\
    \        if current_char == &'_' {\n            suffix_length += 1;\n        }\n\
    \        if current_char == &'.' {\n            suffix_length += 1;\n        }\n\
    \        if current_char == &'$' {\n            suffix_length += 1;\n        }\n\
    \        if current_char == &'@' {\n            suffix_length += 1;\n        }\n\
    \        if current_char == &'!' {\n            suffix_length += 1;\n        }\n\
    \        if current_char == &'&' {\n            suffix_length += 1;\n        }\n\
    \        if current_char == &'(' {\n            suffix_length += 1;\n        }\n\
    \        if current_char == &')' {\n            suffix_length += 1;\n        }\n\
    \        if current_char == &'*' {\n            suffix_length += 1;\n        }\n\
    \        if current_char == &'+' {\n            suffix_length += 1;\n        }\n\
    \        if current_char == &',' {\n            suffix_length += 1;\n        }\n\
    \        if current_char == &'-' {\n            suffix_length += 1;\n        }\n\
    \        if current_char == &'/' {\n            suffix_length += 1;\n        }\n\
    \        if current_char == &':' {\n            suffix_length += 1;\n        }\n\
    \        if current_char == &';' {\n            suffix_length += 1;\n        }\n\
    \        if current_char == &'<' {\n            suffix_length += 1;\n        }\n\
    \        if current_char == &'>' {\n            suffix_length += 1;\n        }\n\
    \        if current_char == \n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp_fsq4ukj.rs:103:3\n\
    \    |\n11  | fn make_palindrome(string: String) -> String {\n    |          \
    \                                    - unclosed delimiter\n...\n15  |     while\
    \ !reversed_string.is_empty() {\n    |                                       -\
    \ this delimiter might not be properly closed...\n...\n94  | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n103 | }\n    |   ^\n\n\
    error: expected expression, found `}`\n  --> /tmp/tmp_fsq4ukj.rs:94:1\n   |\n\
    94 | }\n   | ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_fsq4ukj.rs:21:28\n\
    \   |\n21 |         if current_char == &'a' {\n   |                          \
    \  ^^^^ expected `char`, found `&char`\n   |\nhelp: consider removing the borrow\n\
    \   |\n21 -         if current_char == &'a' {\n21 +         if current_char ==\
    \ 'a' {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_fsq4ukj.rs:24:28\n\
    \   |\n24 |         if current_char == &'z' {\n   |                          \
    \  ^^^^ expected `char`, found `&char`\n   |\nhelp: consider removing the borrow\n\
    \   |\n24 -         if current_char == &'z' {\n24 +         if current_char ==\
    \ 'z' {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_fsq4ukj.rs:27:28\n\
    \   |\n27 |         if current_char == &'A' {\n   |                          \
    \  ^^^^ expected `char`, found `&char`\n   |\nhelp: consider removing the borrow\n\
    \   |\n27 -         if current_char == &'A' {\n27 +         if current_char ==\
    \ 'A' {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_fsq4ukj.rs:30:28\n\
    \   |\n30 |         if current_char == &'Z' {\n   |                          \
    \  ^^^^ expected `char`, found `&char`\n   |\nhelp: consider removing the borrow\n\
    \   |\n30 -         if current_char == &'Z' {\n30 +         if current_char ==\
    \ 'Z' {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_fsq4ukj.rs:33:28\n\
    \   |\n33 |         if current_char == &'0' {\n   |                          \
    \  ^^^^ expected `char`, found `&char`\n   |\nhelp: consider removing the borrow\n\
    \   |\n33 -         if current_char == &'0' {\n33 +       "
  stdout: ''
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    let\
    \ mut longest_postfix_index2 = 0;\n    let mut longest_postfix_index3 = 0;\n \
    \   let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5 =\
    \ 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut longest_postfix_index44 = 0;\n    let mut longest_postfix_index45\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpv8y2p1u1.rs:59:36\n   |\n\
    59 |     let mut longest_postfix_index45\n   |                               \
    \     ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpv8y2p1u1.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut palindrome = string;\n    let mut reversed_string\
    \ = string;\n    let mut reversed_palindrome = string;\n    let mut index = 0;\n\
    \    while index < string.len() {\n        let mut index = index;\n        while\
    \ index < string.len() {\n            if string[index] != string[string.len()\
    \ - index - 1] {\n                break;\n            }\n            index = index\
    \ + 1;\n        }\n        if index == 0 {\n            break;\n        }\n  \
    \      let mut index = index;\n        while index < string.len() {\n        \
    \    if string[index] != string[string.len() - index - 1] {\n                break;\n\
    \            }\n            index = index + 1;\n        }\n        let mut index\
    \ = index;\n        while index < string.len() {\n            if string[index]\
    \ != string[string.len() - index - 1] {\n                break;\n            }\n\
    \            index = index + 1;\n        }\n        let mut index = index;\n \
    \       while index < string.len() {\n            if string[index] != string[string.len()\
    \ - index - 1] {\n                break;\n            }\n            index = index\
    \ + 1;\n        }\n        let mut index = index;\n        while index < string.len()\
    \ {\n            if string[index] != string[string.len() - index - 1] {\n    \
    \            break;\n            }\n            index = index + 1;\n        }\n\
    \        let mut index = index;\n        while index < string.len() {\n      \
    \      if string[index] != string[string.len() - index - 1] {\n              \
    \  break;\n            }\n            index = index + 1;\n        }\n        let\
    \ mut index = index;\n        while index < string.len() {\n            if string[index]\
    \ != string[string.len() - index - 1] {\n                break;\n            }\n\
    \            index = index + 1;\n        }\n        let mut index = index;\n \
    \       while index < string.len() {\n            if string[index] != string[string.len()\
    \ - index - 1] {\n                break;\n            }\n            index = index\
    \ + 1;\n        }\n        let mut index = index;\n        while index < string.len()\
    \ {\n            if string[index] != string[string.len() - index - 1] {\n    \
    \            break;\n            }\n            index = index + 1;\n        }\n\
    \        let mut index = index;\n        while index < string.len() {\n      \
    \      if string[index] != string[string.len() - index - 1] {\n              \
    \  break;\n            }\n            index = index + 1;\n        }\n        let\
    \ mut index = index;\n        while index < string.len() {\n            if string[index]\
    \ != string[string.len() - index - 1] {\n                break;\n            }\n\
    \            index = index + 1;\n        }\n        let mut index = index;\n \
    \       while index < string.len() {\n            if string[index] != string[string.len()\
    \ - index - 1] {\n                break;\n            }\n            index = index\
    \ + 1;\n        }\n        let mut index = index;\n        while index < string.len()\
    \ {\n            if string[index] != string[string.len() - index - 1]\n}\n\nfn\
    \ main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp0i121u0g.rs:117:3\n\
    \    |\n11  | fn make_palindrome(string: String) -> String {\n    |          \
    \                                    - unclosed delimiter\n...\n17  |     while\
    \ index < string.len() {\n    |                                - unclosed delimiter\n\
    ...\n106 |         while index < string.len() {\n    |                       \
    \             - this delimiter might not be properly closed...\n107 |        \
    \     if string[index] != string[string.len() - index - 1]\n108 | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n117 | }\n    |   ^\n\n\
    error: expected `{`, found `}`\n   --> /tmp/tmp0i121u0g.rs:108:1\n    |\n107 |\
    \             if string[index] != string[string.len() - index - 1]\n    |    \
    \         -- this `if` expression has a condition, but no block\n108 | }\n   \
    \ | ^ expected `{`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp0i121u0g.rs:20:16\n   |\n20 |             if string[index] != string[string.len()\
    \ - index - 1] {\n   |                ^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp0i121u0g.rs:20:33\n   |\n20 |             if string[index] != string[string.len()\
    \ - index - 1] {\n   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \  "
  stdout: ''
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut palindrome = string;\n   \
    \ let mut prefix_length = 0;\n    let mut suffix_length = 0;\n    while palindrome.len()\
    \ > 0 {\n        let mut current_char = String::new();\n        let mut current_char_length\
    \ = 0;\n        while palindrome.len() > 0 {\n            current_char.push(palindrome[prefix_length]);\n\
    \            current_char_length += 1;\n            prefix_length += 1;\n    \
    \        palindrome = &palindrome[current_char_length..];\n        }\n       \
    \ if current_char == reversed_string {\n            palindrome = &palindrome[suffix_length..];\n\
    \            suffix_length += 1;\n        } else {\n            palindrome = &palindrome[prefix_length..];\n\
    \            prefix_length += 1;\n        }\n        reversed_string = &reversed_string[current_char_length..];\n\
    \    }\n    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpb8gxeet3.rs:20:31\n   |\n20 |             current_char.push(palindrome[prefix_length]);\n\
    \   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb8gxeet3.rs:23:26\n\
    \   |\n13 |     let mut palindrome = string;\n   |                          ------\
    \ expected due to this value\n...\n23 |             palindrome = &palindrome[current_char_length..];\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found `&str`\n   |\nhelp: try using a conversion method\n   |\n23\
    \ |             palindrome = (&palindrome[current_char_length..]).to_string();\n\
    \   |                          +                                  +++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpb8gxeet3.rs:26:26\n   |\n13 |\
    \     let mut palindrome = string;\n   |                          ------ expected\
    \ due to this value\n...\n26 |             palindrome = &palindrome[suffix_length..];\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\nhelp: try using a conversion method\n   |\n26 |        \
    \     palindrome = (&palindrome[suffix_length..]).to_string();\n   |         \
    \                 +                            +++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpb8gxeet3.rs:29:26\n   |\n13 |     let mut palindrome\
    \ = string;\n   |                          ------ expected due to this value\n\
    ...\n29 |             palindrome = &palindrome[prefix_le"
  stdout: ''
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reverse = string;\n    let mut i =\
    \ 0;\n    while i < string.len() {\n        let mut j = i;\n        while j +\
    \ 1 < string.len() {\n            if string[j] != string[j + 1] {\n          \
    \      break;\n            }\n            j += 1;\n        }\n        if j ==\
    \ i {\n            break;\n        }\n        reverse.push_str(&string[i..j]);\n\
    \        i = j;\n    }\n    reverse.push_str(&string[i..]);\n    reverse\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmptyvxp6z9.rs:18:16\n\
    \   |\n18 |             if string[j] != string[j + 1] {\n   |                ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmptyvxp6z9.rs:18:29\n   |\n18 |             if string[j] != string[j\
    \ + 1] {\n   |                             ^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut prefix_length = 0;\n    while\
    \ !reversed_string.starts_with(string) {\n        reversed_string = reversed_string[..prefix_length].to_string();\n\
    \        prefix_length += 1;\n    }\n    let mut suffix_length = 0;\n    while\
    \ !string.ends_with(reversed_string) {\n        suffix_length += 1;\n        reversed_string\
    \ = reversed_string[..suffix_length].to_string();\n    }\n    prefix_length +=\
    \ 1;\n    reversed_string[..prefix_length].to_string()\n}\n\nfn main() {\n   \
    \ let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmpyzjfo863.rs:14:40\n     |\n14   |     while !reversed_string.starts_with(string)\
    \ {\n     |                            ----------- ^^^^^^ expected an implementor\
    \ of trait `Pattern<'_>`\n     |                            |\n     |        \
    \                    required by a bound introduced by this call\n     |\n   \
    \  = note: the trait bound `String: Pattern<'_>` is not satisfied\n     = note:\
    \ required because of the requirements on the impl of `Pattern<'_>` for `String`\n\
    note: required by a bound in `core::str::<impl str>::starts_with`\nhelp: consider\
    \ borrowing here\n     |\n14   |     while !reversed_string.starts_with(&string)\
    \ {\n     |                                        +\n\nerror[E0277]: expected\
    \ a `FnMut<(char,)>` closure, found `String`\n  --> /tmp/tmpyzjfo863.rs:19:29\n\
    \   |\n19 |     while !string.ends_with(reversed_string) {\n   |             \
    \      --------- ^^^^^^^^^^^^^^^ expected an implementor of trait `Pattern<'_>`\n\
    \   |                   |\n   |                   required by a bound introduced\
    \ by this call\n   |\n   = note: the trait bound `String: Pattern<'_>` is not\
    \ satisfied\n   = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `String`\nhelp: consider borrowing here\n   |\n19 |     while !string.ends_with(&reversed_string)\
    \ {\n   |                             +\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut suffix_index = string.len();\n\
    \    let mut prefix_index = 0;\n    while suffix_index >= 0 {\n        let mut\
    \ suffix_char = string[suffix_index];\n        let mut prefix_char = string[prefix_index];\n\
    \        while suffix_char == prefix_char {\n            suffix_index -= 1;\n\
    \            prefix_index += 1;\n            suffix_char = string[suffix_index];\n\
    \            prefix_char = string[prefix_index];\n        }\n        reversed_string.push((suffix_char,\
    \ prefix_char));\n    }\n    reversed_string\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp0czkjve8.rs:16:31\n\
    \   |\n16 |         let mut suffix_char = string[suffix_index];\n   |        \
    \                       ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmp0czkjve8.rs:17:31\n   |\n17 |         let mut prefix_char = string[prefix_index];\n\
    \   |                               ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp0czkjve8.rs:21:27\n   |\n21 |             suffix_char = string[suffix_index];\n\
    \   |                           ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <S"
  stdout: ''
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reverse = string;\n    let mut longest\
    \ = 0;\n    while !string.is_empty() {\n        let mut i = 0;\n        while\
    \ i < string.len() {\n            if string[i] != string[string.len() - 1 - i]\
    \ {\n                break;\n            }\n            i += 1;\n        }\n \
    \       if i == 0 {\n            break;\n        }\n        let mut j = string.len()\
    \ - 1;\n        while j > 0 {\n            if string[j] != string[string.len()\
    \ - 1 - j] {\n                break;\n            }\n            j -= 1;\n   \
    \     }\n        if j == 0 {\n            break;\n        }\n        if i > j\
    \ {\n            longest = i;\n            reverse = &string[j..];\n        }\
    \ else {\n            longest = j;\n            reverse = &string[i..];\n    \
    \    }\n        string = &string[longest..];\n    }\n    string\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmph98yxnkt.rs:18:16\n\
    \   |\n18 |             if string[i] != string[string.len() - 1 - i] {\n   | \
    \               ^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmph98yxnkt.rs:18:29\n   |\n18 |             if string[i] != string[string.len()\
    \ - 1 - i] {\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmph98yxnkt.rs:28:16\n   |\n28 |             if string[j] != string[string.len()\
    \ - 1 - j] {\n   |                ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusi"
  stdout: ''
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut palindrome = string;\n    let mut reversed_string\
    \ = string;\n    let mut reversed_palindrome = string;\n    let mut i = 0;\n \
    \   while i < string.len() {\n        let mut j = i;\n        while j + 1 < string.len()\
    \ {\n            if string[j] != string[j + 1] {\n                break;\n   \
    \         }\n            j += 1;\n        }\n        if j == i {\n           \
    \ palindrome = &string[i..];\n            reversed_palindrome = &string[i..j];\n\
    \            i += j - i;\n        } else {\n            i += j - i;\n        }\n\
    \    }\n    string = &palindrome;\n    reversed_string = &reversed_palindrome;\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpq6vdnevk.rs:20:16\n\
    \   |\n20 |             if string[j] != string[j + 1] {\n   |                ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpq6vdnevk.rs:20:29\n   |\n20 |             if string[j] != string[j\
    \ + 1] {\n   |                             ^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq6vdnevk.rs:26:26\n\
    \   |\n13 |     let mut palindrome = string;\n   |                          ------\
    \ expected due to this value\n...\n26 |             palindrome = &string[i..];\n\
    \   |                          ^^^^^^^^^^^^ expected struct `String`, found `&str`\n\
    \   |\nhelp: try using a conversion method\n   |\n26 |             palindrome\
    \ = (&string[i..]).to_string();\n   |                          +            +++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpq6vdnevk.rs:27:35\n   |\n15 |\
    \     let mut reversed_palindrome = string;\n   |                            \
    \       ------ expected due to this value\n."
  stdout: ''
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    let\
    \ mut longest_postfix_index2 = 0;\n    let mut longest_postfix_index3 = 0;\n \
    \   let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5 =\
    \ 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut longest_postfix_index44 = 0;\n    let mut longest_postfix_index45\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp3v9v9aes.rs:59:36\n   |\n\
    59 |     let mut longest_postfix_index45\n   |                               \
    \     ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3v9v9aes.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n\n    while\
    \ !string.is_empty() {\n        let mut index = string.len() - 1;\n\n        while\
    \ index >= 0 {\n            let char = string[index];\n            let mut reversed_char\
    \ = char.to_string();\n\n            while !reversed_char.chars().next().unwrap()\
    \ == char {\n                reversed_char += reversed_char.chars().next().unwrap();\n\
    \            }\n\n            reversed_string += reversed_char;\n            index\
    \ -= 1;\n        }\n\n        string += &reversed_string[..];\n        reversed_string\
    \ = \"\";\n    }\n\n    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpywv8x05e.rs:19:24\n\
    \   |\n19 |             let char = string[index];\n   |                      \
    \  ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut reversed_string_index = 0;\n\
    \    let mut longest_postfix_index = 0;\n    let mut longest_postfix = \"\";\n\
    \    while reversed_string_index < string.len() {\n        let mut postfix_index\
    \ = longest_postfix_index;\n        while postfix_index < reversed_string_index\
    \ {\n            if string[postfix_index] != string[reversed_string_index] {\n\
    \                break;\n            }\n            postfix_index += 1;\n    \
    \    }\n        if postfix_index == reversed_string_index {\n            longest_postfix_index\
    \ = postfix_index;\n            longest_postfix += string[postfix_index];\n  \
    \      }\n        reversed_string_index += 1;\n    }\n    longest_postfix.reverse();\n\
    \    longest_postfix.append(&string[reversed_string_index..]);\n    longest_postfix\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpoeq2clmm.rs:19:16\n\
    \   |\n19 |             if string[postfix_index] != string[reversed_string_index]\
    \ {\n   |                ^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpoeq2clmm.rs:19:41\n   |\n19 |             if string[postfix_index]\
    \ != string[reversed_string_index] {\n   |                                   \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n  \
    \ = help: the following other types implement trait `Index<Idx>`:\n          \
    \   <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpoeq2clmm.rs:26:32\n   |\n26 |             longest_postfix += string[postfix_index];\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <Str"
  stdout: ''
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_palindrome = string;\n\
    \    let mut longest_palindrome_length = 0;\n    let mut longest_palindrome_length_index\
    \ = 0;\n    let mut longest_palindrome_length_index_index = 0;\n    let mut longest_palindrome_length_index_index_index\
    \ = 0;\n    while longest_palindrome_length_index < longest_palindrome_length_index_index\
    \ {\n        let mut longest_palindrome_length_index_index_index = 0;\n      \
    \  while longest_palindrome_length_index_index_index < longest_palindrome_length_index_index_index\
    \ {\n            let mut longest_palindrome_length_index_index_index_index = 0;\n\
    \            while longest_palindrome_length_index_index_index_index < longest_palindrome_length_index_index_index_index\
    \ {\n                let mut longest_palindrome_length_index_index_index_index_index\
    \ = 0;\n                while longest_palindrome_length_index_index_index_index_index\
    \ < longest_palindrome_length_index_index_index_index_index {\n              \
    \      let mut longest_palindrome_length_index_index_index_index_index_index =\
    \ 0;\n                    while longest_palindrome_length_index_index_index_index_index_index\
    \ < longest_palindrome_length_index_index_index_index_index_index {\n        \
    \                let mut longest_palindrome_length_index_index_index_index_index_index_index\
    \ = 0;\n                        while longest_palindrome_length_index_index_index_index_index_index_index\
    \ < longest_palindrome_length_index_index_index_index_index_index_index {\n  \
    \                          let mut longest_palindrome_length_index_index_index_index_index_index_index_index\
    \ = 0;\n                            while longest_palindrome_length_index_index_index_index_index_index_index_index\
    \ < longest_palindrome_length_index_index_index_index_index_index_index_index\
    \ {\n                                let mut longest_palindrome_length_index_index_index_index_index_index_index_index_index\
    \ = 0;\n                                while longest_palindrome_length_index_index_index_index_index_index_index_index_index_index\
    \ < longest_palindrome_length_index_index_index_index_index_index_index_index_index\
    \ {\n                                    let mut longest_palindrome_length_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n                                    while longest_palindrome_length_index_index_index_index_index_index_index_index_index_index_index_index\
    \ < longest_palindrome_length_index_index_index_index_index_index_index_index_index_index_index\
    \ {\n                                        let mut longest_palindrome_length_index_index_\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp9pzdfme2.rs:45:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n18 |     while longest_palindrome_length_index\
    \ < longest_palindrome_length_index_index {\n   |                            \
    \                                                       - unclosed delimiter\n\
    19 |         let mut longest_palindrome_length_index_index_index = 0;\n20 |  \
    \       while longest_palindrome_length_index_index_index < longest_palindrome_length_index_index_index\
    \ {\n   |                                                                    \
    \                                     - unclosed delimiter\n21 |             let\
    \ mut longest_palindrome_length_index_index_index_index = 0;\n22 |           \
    \  while longest_palindrome_length_index_index_index_index < longest_palindrome_length_index_index_index_index\
    \ {\n   |                                                                    \
    \                                                     - unclosed delimiter\n23\
    \ |                 let mut longest_palindrome_length_index_index_index_index_index\
    \ = 0;\n24 |                 while longest_palindrome_length_index_index_index_index_index\
    \ < longest_palindrome_length_index_index_index_index_index {\n   |          \
    \                                                                            \
    \                                                   - unclosed delimiter\n25 |\
    \                     let mut longest_palindrome_length_index_index_index_index_index_index\
    \ = 0;\n26 |                     while longest_palindrome_length_index_index_index_index_index_index\
    \ < longest_palindrome_length_index_index_index_index_index_index {\n   |    \
    \                                                                            \
    \                                                                         - unclosed\
    \ delimiter\n27 |                         let mut longest_palindrome_length_index_index_index_index_index_index_index\
    \ = 0;\n28 |                         while"
  stdout: ''
  timestamp: 1659805824
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = string;\n    let\
    \ mut longest_postfix_length = 0;\n    let mut longest_postfix_start = -1;\n \
    \   let mut longest_postfix_end = -1;\n    let mut longest_postfix_postfix = \"\
    \";\n    let mut longest_postfix_postfix_length = 0;\n    let mut longest_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = \"\";\n    while !string.is_empty() {\n        let mut postfix_length = longest_postfix_length;\n\
    \        let mut postfix_start = longest_postfix_start;\n        let mut postfix_end\
    \ = longest_postfix_end;\n        let mut postfix_postfix = longest_postfix_postfix;\n\
    \        let mut postfix_postfix_length = longest_postfix_postfix_length;\n  \
    \      let mut postfix_postfix_start = longest_postfix_postfix_start;\n      \
    \  let mut postfix_postfix_end = longest_postfix_postfix_end;\n        let mut\
    \ postfix_postfix_postfix = longest_postfix_postfix_postfix;\n        let mut\
    \ postfix_postfix_postfix_length = longest_postfix_postfix_postfix_length;\n \
    \       let mut postfix_postfix_postfix_start = longest_postfix_postfix_start;\n\
    \        let mut postfix_postfix_postfix_end = longest_postfix_postfix_end;\n\
    \        let mut postfix_postfix_postfix_postfix = longest_postfix_postfix_postfix;\n\
    \        let mut postfix_postfix_postfix_postfix_length = longest_postfix_postfix_postfix_length;\n\
    \        let mut postfix_postfix_postfix_postfix_start = longest_postfix_postfix_start;\n\
    \        let mut postfix_postfix_postfix_postfix_end = longest_postfix_postfix_end;\n\
    \        let mut postfix_postfix_postfix_postfix_postfix = longest_postfix_postfix_postfix;\n\
    \        let mut postfix_postfix_postfix_postfix_length = longest_postfix_postfix_postfix_length;\n\
    \        let mut postfix_postfix_postfix_postfix_start = longest_postfix_postfix_start;\n\
    \        let mut postfix_postfix_postfix_postfix_end = longest_postfix_postfix_end;\n\
    \        let mut postfix_postfix_postfix_postfix_postfix = longest_postfix_postfix_postfix;\n\
    \        let mut postfix_postfix_postfix_postfix_length = longest_postfix_postfix_postfix_length;\n\
    \        let mut postfix_postfix_postfix_postfix_start = \n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpfj30jc4h.rs:54:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n22 |     while !string.is_empty()\
    \ {\n   |                              - this delimiter might not be properly\
    \ closed...\n...\n45 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n54 | }\n   |   ^\n\nerror: expected expression, found `}`\n  --> /tmp/tmpfj30jc4h.rs:45:1\n\
    \   |\n45 | }\n   | ^ expected expression\n\nerror[E0425]: cannot find value `longest_postfix_postfix_postfix_length`\
    \ in this scope\n  --> /tmp/tmpfj30jc4h.rs:31:50\n   |\n31 |         let mut postfix_postfix_postfix_length\
    \ = longest_postfix_postfix_postfix_length;\n   |                            \
    \                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `longest_postfix_postfix_postfix`\n\nerror[E0425]:\
    \ cannot find value `longest_postfix_postfix_postfix_length` in this scope\n \
    \ --> /tmp/tmpfj30jc4h.rs:35:58\n   |\n35 |         let mut postfix_postfix_postfix_postfix_length\
    \ = longest_postfix_postfix_postfix_length;\n   |                            \
    \                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a\
    \ local variable with a similar name exists: `longest_postfix_postfix_postfix`\n\
    \nerror[E0425]: cannot find value `longest_postfix_postfix_postfix_length` in\
    \ this scope\n  --> /tmp/tmpfj30jc4h.rs:39:58\n   |\n39 |         let mut postfix_postfix_postfix_postfix_length\
    \ = longest_postfix_postfix_postfix_length;\n   |                            \
    \                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a\
    \ local variable with a similar name exists: `postfix_postfix_postfix_postfix_length`\n\
    \nerror[E0425]: cannot find value `longest_postfix_postfix_postfix_length` in\
    \ this scope\n  --> /tmp/tmpfj30jc4h.rs:43:58\n   |\n43 |         let mut postfix_postfix_postfix_postfix_length\
    \ = longest_postfix_postfix_postfix_length;\n   |                            \
    \                           "
  stdout: ''
  timestamp: 1659805824
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = string;\n    let\
    \ mut reverse_length = 0;\n    let mut longest_postfix_length = 0;\n    let mut\
    \ longest_postfix_index = 0;\n    let mut longest_postfix_index2 = 0;\n    let\
    \ mut longest_postfix_index3 = 0;\n    let mut longest_postfix_index4 = 0;\n \
    \   let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_index6 =\
    \ 0;\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_index23 = 0;\n    let mut longest_postfix_index24\
    \ = 0;\n    let mut longest_postfix_index25 = 0;\n    let mut longest_postfix_index26\
    \ = 0;\n    let mut longest_postfix_index27 = 0;\n    let mut longest_postfix_index28\
    \ = 0;\n    let mut longest_postfix_index29 = 0;\n    let mut longest_postfix_index30\
    \ = 0;\n    let mut longest_postfix_index31 = 0;\n    let mut longest_postfix_index32\
    \ = 0;\n    let mut longest_postfix_index33 = 0;\n    let mut longest_postfix_index34\
    \ = 0;\n    let mut longest_postfix_index35 = 0;\n    let mut longest_postfix_index36\
    \ = 0;\n    let mut longest_postfix_index37 = 0;\n    let mut longest_postfix_index38\
    \ = 0;\n    let mut longest_postfix_index39 = 0;\n    let mut longest_postfix_index40\
    \ = 0;\n    let mut longest_postfix_index41 = 0;\n    let mut longest_postfix_index42\
    \ = 0;\n    let mut longest_postfix_index43 = 0;\n    let mut longest_postfix_index44\
    \ = 0;\n    let mu\n}\n\nfn main() {\n    let candidate = make_palindrome;\n \
    \   assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpi0e6dp9m.rs:60:11\n   |\n\
    60 |     let mu\n   |           ^ help: add `;` here\n61 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi0e6dp9m.rs:11:39\n \
    \  |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805824
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed = string;\n    let mut longest = 0;\n    for pos in string.char_indices()\
    \ {\n        let mut start = pos;\n        let mut end = pos;\n        while start\
    \ < string.len() && string[start] == string[end] {\n            start += 1;\n\
    \            end += 1;\n        }\n        if end - start > longest {\n      \
    \      longest = end - start;\n        }\n        reversed = reversed.chars().collect::<String>().reverse().collect::<String>().append(&string[start..end]);\n\
    \    }\n    reversed\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8l39pdwh.rs:17:23\n   |\n\
    17 |         while start < string.len() && string[start] == string[end] {\n  \
    \ |                       ^^^^^^^^^^^^ expected tuple, found `usize`\n   |\n \
    \  = note: expected tuple `(usize, char)`\n               found type `usize`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `(usize, char)`\n  -->\
    \ /tmp/tmp8l39pdwh.rs:17:39\n   |\n17 |         while start < string.len() &&\
    \ string[start] == string[end] {\n   |                                       ^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `(usize, char)`\n   |\n   = help: the trait `Index<(usize,\
    \ char)>` is not implemented for `String`\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `(usize, char)`\n  --> /tmp/tmp8l39pdwh.rs:17:56\n   |\n17 | \
    \        while start < string.len() && string[start] == string[end] {\n   |  \
    \                                                      ^^^^^^^^^^^ `String` cannot\
    \ be indexed by `(usize, char)`\n   |\n   = help: the trait `Index<(usize, char)>`\
    \ is not implemented for `String`\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `(usize, char)`\n  --> /tmp/tmp8l39pdwh.rs:18:13\n\
    \   |\n18 |             start += 1;\n   |             -----^^^^^\n   |       \
    \      |\n   |             cannot use `+=` on type `(usize, char)`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `(usize, char)`\n\
    \  --> /tmp/tmp8l39pdwh.rs:19:13\n   |\n19 |             end += 1;\n   |     \
    \        ---^^^^^\n   |             |\n   |             cannot use `+=` on type\
    \ `(usize, char)`\n\nerror[E0369]: cannot subtract `(usize, char)` from `(usize,\
    \ char)`\n  --> /tmp/tmp8l39pdwh.rs:21:16\n   |\n21 |         if end - start >\
    \ longest {\n   |            --- ^ ----- (usize, char)\n   |            |\n  \
    \ |            (usize, char)\n\nerror[E0369]: cannot subtract `(usize, char)`\
    \ from `(usize, char)`\n  --> /tmp/tmp8l39pdwh.rs:22:27\n   |\n22 |          \
    \   longest = end - start;\n   |                       --- ^ ----- (usize, char)\n\
    \   |                       |\n   |                       (usiz"
  stdout: ''
  timestamp: 1659805824
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = string;\n    let\
    \ mut suffix = 0;\n    let mut prefix_length = 0;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length\
    \ = 0;\n    let mut longest_postfix_index = 0;\n    let mut longest_\n}\n\nfn\
    \ main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpee6rv_x2.rs:64:21\n   |\n\
    64 |     let mut longest_\n   |                     ^ help: add `;` here\n65 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpee6rv_x2.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805824
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut suffix_length = 0;\n    let\
    \ mut prefix_length = 0;\n    while suffix_length != string.length() {\n     \
    \   let mut suffix_postfix = string;\n        let mut suffix_postfix_length =\
    \ suffix_postfix.length();\n        while suffix_postfix_length != suffix_length\
    \ {\n            suffix_postfix_length -= 1;\n            suffix_postfix = suffix_postfix.chars().next().unwrap();\n\
    \        }\n        let mut prefix_postfix = string;\n        let mut prefix_postfix_length\
    \ = prefix_postfix.length();\n        while prefix_postfix_length != prefix_length\
    \ {\n            prefix_postfix_length -= 1;\n            prefix_postfix = prefix_postfix.chars().next().unwrap();\n\
    \        }\n        if suffix_postfix.chars().next().unwrap() != prefix_postfix.chars().next().unwrap()\
    \ {\n            break;\n        }\n        reversed_string = suffix_postfix.chars().rev().collect::<String>().to_owned();\n\
    \        suffix_length -= 1;\n        prefix_length += 1;\n    }\n    reversed_string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpfasz3b3t.rs:15:35\n   |\n15 |     while suffix_length\
    \ != string.length() {\n   |                                   ^^^^^^ method not\
    \ found in `String`\n\nerror[E0599]: no method named `length` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpfasz3b3t.rs:17:56\n   |\n17 | \
    \        let mut suffix_postfix_length = suffix_postfix.length();\n   |      \
    \                                                  ^^^^^^ method not found in\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfasz3b3t.rs:20:30\n\
    \   |\n20 |             suffix_postfix = suffix_postfix.chars().next().unwrap();\n\
    \   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                        \
    \      |\n   |                              expected struct `String`, found `char`\n\
    \nerror[E0599]: no method named `length` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpfasz3b3t.rs:23:56\n   |\n23 |         let mut prefix_postfix_length\
    \ = prefix_postfix.length();\n   |                                           \
    \             ^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfasz3b3t.rs:26:30\n   |\n26 |             prefix_postfix\
    \ = prefix_postfix.chars().next().unwrap();\n   |                            \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                              |\n   |                  \
    \            expected struct `String`, found `char`\n\nerror: aborting due to\
    \ 5 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805824
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut reversed_string_index = string.len()\
    \ - 1;\n    while reversed_string_index >= 0 {\n        let mut char = reversed_string[reversed_string_index];\n\
    \        reversed_string[reversed_string_index] = char;\n        reversed_string_index\
    \ -= 1;\n    }\n    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp9y4jy28k.rs:15:24\n\
    \   |\n15 |         let mut char = reversed_string[reversed_string_index];\n \
    \  |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp9y4jy28k.rs:16:9\n   |\n16 |         reversed_string[reversed_string_index]\
    \ = char;\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805824
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut palindrome = string;\n    let mut reversed_string\
    \ = string;\n    let mut reversed_palindrome = string;\n    let mut i = 0;\n \
    \   while i < string.len() {\n        let mut j = i;\n        while j < string.len()\
    \ {\n            if string[j] != string[i] {\n                break;\n       \
    \     }\n            j = j + 1;\n        }\n        if j == i {\n            palindrome\
    \ = palindrome[..i];\n            reversed_palindrome = reversed_palindrome[..i];\n\
    \            i = i + 1;\n        } else {\n            palindrome = palindrome[..j];\n\
    \            reversed_palindrome = reversed_palindrome[..j];\n            i =\
    \ j + 1;\n        }\n    }\n    string = reversed_palindrome;\n    palindrome\
    \ = reversed_string;\n    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmppubcyt3l.rs:20:16\n\
    \   |\n20 |             if string[j] != string[i] {\n   |                ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmppubcyt3l.rs:20:29\n   |\n20 |            \
    \ if string[j] != string[i] {\n   |                             ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppubcyt3l.rs:26:26\n\
    \   |\n26 |             palindrome = palindrome[..i];\n   |                  \
    \        ^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                          |\n   |                          expected struct\
    \ `String`, found `str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppubcyt3l.rs:27:35\n\
    \   |\n27 |             reversed_palindrome = reversed_palindrome[..i];\n   |\
    \                                   ^^^^^^^^^^^^^^^^^^^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                                  \
    \ |\n   |                                   expected struct `String`, found `str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmppubcyt3l.rs:30:26\n   |\n30 |\
    \             palindrome = palindrome[..j];\n   |                          ^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \        |\n   |                          expected struct `String`, found `str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmppubcyt3l.rs:31:35\n   |\n31 |\
    \             reversed_palindrome = reversed_palindrome[..j];\n   |          \
    \                         ^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                                   |\n   |     \
    \                              expected struct `String`, found `str`\n\nerror:\
    \ aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nF"
  stdout: ''
  timestamp: 1659805824
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut reverse_length = 0;\n    let\
    \ mut longest_postfix_length = 0;\n    let mut longest_postfix_start = -1;\n \
    \   let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_\n}\n\nfn\
    \ main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmphu0id2jv.rs:63:29\n   |\n\
    63 |     let mut longest_postfix_\n   |                             ^ help: add\
    \ `;` here\n64 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmphu0id2jv.rs:11:39\n   |\n11 | fn make_palindrome(string: String)\
    \ -> String {\n   |    ---------------                    ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805824
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    while\
    \ let Some(index) = string.rfind('a') {\n        reversed_string += &string[index..];\n\
    \        longest_postfix_length = index;\n        longest_postfix_index = index;\n\
    \    }\n    let mut longest_postfix_string = &string[longest_postfix_index..];\n\
    \    while let Some(index) = longest_postfix_string.rfind('a') {\n        longest_postfix_string\
    \ += &longest_postfix_string[index..];\n    }\n    longest_postfix_string += &reversed_string[longest_postfix_length..];\n\
    \    longest_postfix_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&str`\n  --> /tmp/tmpiojf9_36.rs:17:9\n   |\n17 |         reversed_string +=\
    \ &string[index..];\n   |         ---------------^^^^^^^^^^^^^^^^^^^^\n   |  \
    \       |\n   |         cannot use `+=` on type `&str`\n\nerror[E0368]: binary\
    \ assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpiojf9_36.rs:23:9\n\
    \   |\n23 |         longest_postfix_string += &longest_postfix_string[index..];\n\
    \   |         ----------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\
    \         |\n   |         cannot use `+=` on type `&str`\n\nerror[E0368]: binary\
    \ assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpiojf9_36.rs:25:5\n\
    \   |\n25 |     longest_postfix_string += &reversed_string[longest_postfix_length..];\n\
    \   |     ----------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |     |\n   |     cannot use `+=` on type `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpiojf9_36.rs:26:5\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |                                       ------ expected\
    \ `String` because of return type\n...\n26 |     longest_postfix_string\n   |\
    \     ^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |     |\n   |     expected struct `String`, found `&str`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0368.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805824
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut prefix_length = 0;\n    while\
    \ !reversed_string.is_empty() {\n        let mut suffix_length = 0;\n        while\
    \ !reversed_string.is_empty() && reversed_string[suffix_length] == reversed_string[suffix_length]\
    \ {\n            suffix_length += 1;\n        }\n        reversed_string = reversed_string.split_off(suffix_length).collect();\n\
    \        prefix_length += suffix_length;\n    }\n    string + &reversed_string[prefix_length..]\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpvfuh17ph.rs:16:46\n   |\n16 |         while !reversed_string.is_empty()\
    \ && reversed_string[suffix_length] == reversed_string[suffix_length] {\n   |\
    \                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `{integer}`\n  --> /tmp/tmpvfuh17ph.rs:16:80\n   |\n16 |        \
    \ while !reversed_string.is_empty() && reversed_string[suffix_length] == reversed_string[suffix_length]\
    \ {\n   |                                                                    \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \nerror[E0599]: the method `collect` exists for struct `String`, but its trait\
    \ bounds were not satisfied\n   --> /tmp/tmpvfuh17ph.rs:19:68\n    |\n19  |  \
    \         reversed_string = reversed_string.split_off(suffix_length).collect();\n\
    \    |                                                                      ^^^^^^^\
    \ method cannot be called on `String` due to unsatisfied trait bounds\n    |\n\
    \    = note: the following trait bounds were not satisfied:\n            `String:\
    \ Iterator`\n            which is required by `&mut String: Iterator`\n      \
    \      `str: Iterator`\n            which is required by `&mut str: Iterator`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805824
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_postfix_index = 0;\n\
    \    let mut longest_postfix_length = 0;\n    for index in 0..string.len() {\n\
    \        let mut postfix_length = index;\n        let mut postfix_char = string[index];\n\
    \        while postfix_length >= 0 {\n            let mut postfix_char = string[postfix_length];\n\
    \            postfix_length -= 1;\n            longest_postfix_length = std::cmp::max(longest_postfix_length,\
    \ postfix_length);\n        }\n        if longest_postfix_length >= 0 {\n    \
    \        longest_postfix_index = index;\n        }\n    }\n    let mut postfix_length\
    \ = longest_postfix_index;\n    let mut postfix_char = string[longest_postfix_index];\n\
    \    while postfix_length >= 0 {\n        let mut postfix_char = string[postfix_length];\n\
    \        postfix_length -= 1;\n        reversed_string += &postfix_char;\n   \
    \ }\n    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpz_bcs0pg.rs:17:32\n\
    \   |\n17 |         let mut postfix_char = string[index];\n   |              \
    \                  ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpz_bcs0pg.rs:19:36\n\
    \   |\n19 |             let mut postfix_char = string[postfix_length];\n   | \
    \                                   ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpz_bcs0pg.rs:28:28\n   |\n28 |     let mut postfix_char = string[longest_postfix_index];\n\
    \   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpz_bcs0pg.rs:30:32\n   |\n30 |         let mut postfix_char = string[postfix_length];\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the size for values of type `str` cannot be known\
    \ at compilation time\n  --> /tmp/tmpz_bcs0pg.rs:30:13\n   |\n30 |         let\
    \ mut postfix_char = string[postfix_length];\n   |             ^^^^^^^^^^^^^^^^\
    \ doesn't have a size known at compile-time\n   |\n   = help: the trait `Sized`\
    \ is not implemented for `str`\n   = note: all local variables must have a statically\
    \ known size\n   = help: unsized locals are gated as an unstable feature\nhelp:\
    \ consider borrowing here\n   |\n30 |         let mut postfix_char = &string[postfix_length];\n\
    \   |                                +\n\nerror: aborting due to 5 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805824
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut suffix_length = 0;\n    let\
    \ mut prefix_length = 0;\n    while suffix_length < string.len() && prefix_length\
    \ < string.len() {\n        let mut suffix_char = string.chars().nth(suffix_length).unwrap();\n\
    \        let mut prefix_char = string.chars().nth(prefix_length).unwrap();\n \
    \       if suffix_char == prefix_char {\n            suffix_length += 1;\n   \
    \         prefix_length += 1;\n        } else {\n            suffix_length +=\
    \ 1;\n            prefix_length += 1;\n            reversed_string.push((suffix_char\
    \ as char).to_string());\n            suffix_char = string.chars().nth(suffix_length).unwrap();\n\
    \            prefix_char = string.chars().nth(prefix_length).unwrap();\n     \
    \   }\n    }\n    reversed_string.push((suffix_char as char).to_string());\n \
    \   reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `suffix_char` in this scope\n  --> /tmp/tmpd6fwcerz.rs:29:27\n\
    \   |\n29 |     reversed_string.push((suffix_char as char).to_string());\n   |\
    \                           ^^^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpd6fwcerz.rs:24:34\n   |\n24 |             reversed_string.push((suffix_char\
    \ as char).to_string());\n   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805824
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut palindrome = string;\n    let mut reversed_string = string;\n   \
    \ let mut suffix_length = 0;\n    let mut prefix_length = 0;\n    while !palindrome.is_empty()\
    \ {\n        let mut suffix_length = 0;\n        let mut prefix_length = 0;\n\
    \        while !reversed_string.is_empty() {\n            let mut suffix_length\
    \ = 0;\n            let mut prefix_length = 0;\n            if palindrome.len()\
    \ > reversed_string.len() {\n                suffix_length = palindrome.len()\
    \ - reversed_string.len();\n                prefix_length = suffix_length;\n \
    \           } else {\n                prefix_length = reversed_string.len() -\
    \ palindrome.len();\n                suffix_length = prefix_length;\n        \
    \    }\n            if suffix_length == prefix_length {\n                suffix_length\
    \ = 0;\n                prefix_length = 0;\n            }\n            if suffix_length\
    \ == 0 {\n                reversed_string = reversed_string[..prefix_length];\n\
    \            } else {\n                reversed_string = reversed_string[..prefix_length].concat(reversed_string[prefix_length..]);\n\
    \            }\n        }\n        palindrome = palindrome.chars().collect::<String>().reverse().collect::<String>();\n\
    \    }\n    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj_8or3o7.rs:34:35\n   |\n\
    34 |                 reversed_string = reversed_string[..prefix_length];\n   |\
    \                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                            \
    \       |\n   |                                   expected struct `String`, found\
    \ `str`\n\nerror[E0599]: no method named `concat` found for type `str` in the\
    \ current scope\n  --> /tmp/tmpj_8or3o7.rs:36:68\n   |\n36 |                 reversed_string\
    \ = reversed_string[..prefix_length].concat(reversed_string[prefix_length..]);\n\
    \   |                                                                    ^^^^^^\
    \ method not found in `str`\n\nerror[E0599]: no method named `reverse` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmpj_8or3o7.rs:39:61\n   |\n\
    39 |         palindrome = palindrome.chars().collect::<String>().reverse().collect::<String>();\n\
    \   |                                                             ^^^^^^^ help:\
    \ there is an associated function with a similar name: `reserve`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805824
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed = string;\n    let mut prefix_length = 0;\n    while !reversed.is_empty()\
    \ {\n        let mut suffix_length = 0;\n        while !reversed.is_empty() {\n\
    \            if reversed.len() > prefix_length {\n                suffix_length\
    \ = reversed.len() - prefix_length;\n                break;\n            }\n \
    \           suffix_length += 1;\n            reversed.pop();\n        }\n    \
    \    if suffix_length == 0 {\n            break;\n        }\n        reversed.push(reversed[suffix_length..].chars().collect::<String>().rev().collect());\n\
    \        prefix_length += suffix_length;\n    }\n    reversed\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `rev` exists for struct `String`, but its trait\
    \ bounds were not satisfied\n   --> /tmp/tmptolmikz6.rs:27:77\n    |\n27  |  \
    \         reversed.push(reversed[suffix_length..].chars().collect::<String>().rev().collect());\n\
    \    |                                                                       \
    \        ^^^ method cannot be called on `String` due to unsatisfied trait bounds\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `String: Iterator`\n            which is required by `&mut String: Iterator`\n\
    \            `str: Iterator`\n            which is required by `&mut str: Iterator`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659805824
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    let\
    \ mut longest_postfix_index2 = 0;\n    let mut longest_postfix_index3 = 0;\n \
    \   while let Some(index) = string.rfind('a') {\n        let mut postfix_length\
    \ = index;\n        let mut postfix_index = 0;\n        while let Some(index)\
    \ = string.rfind('a', index + 1) {\n            postfix_length += 1;\n       \
    \     postfix_index += 1;\n        }\n        if postfix_length > longest_postfix_length\
    \ {\n            longest_postfix_length = postfix_length;\n            longest_postfix_index\
    \ = index;\n        }\n    }\n    while let Some(index) = string.rfind('a') {\n\
    \        let mut postfix_length = index;\n        let mut postfix_index = 0;\n\
    \        while let Some(index) = string.rfind('a', index + 1) {\n            postfix_length\
    \ += 1;\n            postfix_index += 1;\n        }\n        if postfix_length\
    \ > longest_postfix_length {\n            longest_postfix_length = postfix_length;\n\
    \            longest_postfix_index2 = index;\n        }\n    }\n    while let\
    \ Some(index) = string.rfind('a') {\n        let mut postfix_length = index;\n\
    \        let mut postfix_index = 0;\n        while let Some(index) = string.rfind('a',\
    \ index + 1) {\n            postfix_length += 1;\n            postfix_index +=\
    \ 1;\n        }\n        if postfix_length > longest_postfix_length {\n      \
    \      longest_postfix_length = postfix_length;\n            longest_postfix_index3\
    \ = index;\n        }\n    }\n    string[longest_postfix_index..longest_postfix_index\
    \ + longest_postfix_length]\n        .iter()\n        .cloned()\n        .chain(\n\
    \            string[longest_postfix_index2..longest_postfix_index2 + longest_postfix_length]\n\
    \                .iter()\n                .cloned()\n                .chain(\n\
    \                    string[longest_postfix_index3..longest_postfix_index3 + longest_postfix_length]\n\
    \                        .iter()\n                        .cloned()\n        \
    \                .chain(\n                            string\n               \
    \                 .iter()\n                                .cloned()\n       \
    \                         .chain(\n                                    string\n\
    \                                        .rfind('a')\n                       \
    \                 .cloned()\n                                        .chain(\n\
    \                                            string\n                        \
    \                        .rfind('a')\n                                       \
    \         .cloned()\n                                                .chain(\n\
    \                                                    string\n                \
    \                                        .rfind('a')\n                       \
    \                                 .cloned()\n                                \
    \                        .chain(\n                                           \
    \                 string\n                                                   \
    \             .\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `)`\n  --> /tmp/tmp4u8ppura.rs:84:1\n   |\n84\
    \ | }\n   | ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp4u8ppura.rs:81:63\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - closing delimiter possibly meant for this\n\
    ...\n81 |                                                         .chain(\n  \
    \ |                                                               ^ unclosed delimiter\n\
    ...\n84 | }\n   | ^ mismatched closing delimiter\n\nerror[E0061]: this function\
    \ takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmp4u8ppura.rs:21:40\n\
    \     |\n21   |         while let Some(index) = string.rfind('a', index + 1) {\n\
    \     |                                        ^^^^^ ---  --------- supplied 2\
    \ arguments\n     |                                        |\n     |         \
    \                               expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror[E0061]: this function takes 1 argument but 2\
    \ arguments were supplied\n    --> /tmp/tmp4u8ppura.rs:33:40\n     |\n33   | \
    \        while let Some(index) = string.rfind('a', index + 1) {\n     |      \
    \                                  ^^^^^ ---  --------- supplied 2 arguments\n\
    \     |                                        |\n     |                     \
    \                   expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmp4u8ppura.rs:45:40\n     |\n45   |         while let Some(index)\
    \ = string.rfind('a', index + 1) {\n     |                                   \
    \     ^^^^^ ---  --------- supplied 2 arguments\n     |                      \
    \                  |\n     |                                        expected 1\
    \ argument\n     |\nnote: associated function defined here\n\nerror[E0599]: no\
    \ method named `iter` found for type `str` in the current scope\n  --> /tmp/tmp4u8ppura.rs:55:10\n\
    \   |\n55 |         .iter()\n   |          ^^^^ method not found in `str`\n\n\
    error[E0599]: no method named `iter` found for "
  stdout: ''
  timestamp: 1659805824
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n\n    while\
    \ !string.is_empty() {\n        let mut index = string.len();\n        while index\
    \ >= 0 {\n            let char = string[index];\n            reversed_string.insert(0,\
    \ char);\n            index -= 1;\n        }\n        string = reversed_string;\n\
    \        reversed_string = \"\";\n    }\n    string\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpjlb_c33e.rs:18:24\n\
    \   |\n18 |             let char = string[index];\n   |                      \
    \  ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0599]: no method named\
    \ `insert` found for reference `&str` in the current scope\n  --> /tmp/tmpjlb_c33e.rs:19:29\n\
    \   |\n19 |             reversed_string.insert(0, char);\n   |               \
    \              ^^^^^^ method not found in `&str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpjlb_c33e.rs:22:18\n   |\n22 |         string = reversed_string;\n\
    \   |                  ^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                  |\n   |                  expected struct `String`, found\
    \ `&str`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805824
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut last_index = string.len();\n\
    \    while last_index > 0 {\n        let mut index = last_index - 1;\n       \
    \ while index >= 0 {\n            if reversed_string[index] != string[index] {\n\
    \                break;\n            }\n            index -= 1;\n        }\n \
    \       reversed_string.push(reversed_string[index]);\n        last_index -= 1;\n\
    \    }\n    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpjv4c0gm7.rs:17:16\n\
    \   |\n17 |             if reversed_string[index] != string[index] {\n   |   \
    \             ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpjv4c0gm7.rs:17:42\n\
    \   |\n17 |             if reversed_string[index] != string[index] {\n   |   \
    \                                       ^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n \
    \ --> /tmp/tmpjv4c0gm7.rs:22:30\n   |\n22 |         reversed_string.push(reversed_string[index]);\n\
    \   |                              ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805824
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix = \"\";\n    let mut longest_postfix_len = 0;\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_index2 = 0;\n    let mut longest_postfix_index3\
    \ = 0;\n    let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5\
    \ = 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut longest_postfix_index44 = 0;\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt0n0hdrg.rs:11:39\n   |\n\
    11 | fn make_palindrome(string: String) -> String {\n   |    --------------- \
    \                   ^^^^^^ expected struct `String`, found `()`\n   |    |\n \
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805824
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reverse = String::from(\"\");\n    let mut postfix = String::from(\"\
    \");\n    let mut start = String::from(\"\");\n    let mut end = String::from(\"\
    \");\n    let mut i = 0;\n    while i < string.len() {\n        postfix = postfix.push_str(&string[i..]);\n\
    \        start = start.push_str(&string[i..]);\n        end = end.push_str(&string[i..]);\n\
    \        i += 1;\n    }\n    let mut i = 0;\n    while i < postfix.len() {\n \
    \       if postfix.chars().nth(i).unwrap() != start.chars().nth(i).unwrap() {\n\
    \            break;\n        }\n        i += 1;\n    }\n    let mut j = i;\n \
    \   while j + 1 < postfix.len() {\n        if postfix.chars().nth(j + 1).unwrap()\
    \ != end.chars().nth(j).unwrap() {\n            break;\n        }\n        j +=\
    \ 1;\n    }\n    let mut result = String::from(\"\");\n    while i < postfix.len()\
    \ {\n        result = result.push_str(&postfix.chars().nth(i).unwrap());\n   \
    \     i += 1;\n    }\n    result = result.push_str(&start.chars().nth(j).unwrap());\n\
    \    result = result.push_str(&end.chars().nth(j).unwrap());\n    result\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprkhj75pc.rs:18:19\n   |\n\
    18 |         postfix = postfix.push_str(&string[i..]);\n   |                 \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found `()`\n   |\n\
    note: method `push_str` modifies its receiver in-place\n  --> /tmp/tmprkhj75pc.rs:18:27\n\
    \   |\n18 |         postfix = postfix.push_str(&string[i..]);\n   |          \
    \         ------- ^^^^^^^^ this call modifies `postfix` in-place\n   |       \
    \            |\n   |                   you probably want to use this value after\
    \ calling the method...\n   = note: ...instead of the `()` output of method `push_str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmprkhj75pc.rs:19:17\n   |\n19 |\
    \         start = start.push_str(&string[i..]);\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `()`\n   |\nnote: method `push_str` modifies\
    \ its receiver in-place\n  --> /tmp/tmprkhj75pc.rs:19:23\n   |\n19 |         start\
    \ = start.push_str(&string[i..]);\n   |                 ----- ^^^^^^^^ this call\
    \ modifies `start` in-place\n   |                 |\n   |                 you\
    \ probably want to use this value after calling the method...\n   = note: ...instead\
    \ of the `()` output of method `push_str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmprkhj75pc.rs:20:15\n   |\n20 |         end = end.push_str(&string[i..]);\n\
    \   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found\
    \ `()`\n   |\nnote: method `push_str` modifies its receiver in-place\n  --> /tmp/tmprkhj75pc.rs:20:19\n\
    \   |\n20 |         end = end.push_str(&string[i..]);\n   |               ---\
    \ ^^^^^^^^ this call modifies `end` in-place\n   |               |\n   |     \
    \          you probably want to use this value after calling the method...\n \
    \  = note: ...instead of the `()` output of method `push_str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprkhj75pc.rs:39:34\n   |\n39 |         result\
    \ = result.push_str(&postfix.chars().nth(i).unwrap());\n   |                 \
    \                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n\
    \   |\n   = note: "
  stdout: ''
  timestamp: 1659805824
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut reversed_string_len = string.len();\n\
    \    while reversed_string_len > 0 {\n        let mut reversed_string_start =\
    \ reversed_string.len() - 1;\n        while reversed_string_start >= 0 && reversed_string[reversed_string_start]\
    \ != string[reversed_string_start] {\n            reversed_string_start -= 1;\n\
    \        }\n        reversed_string_len -= reversed_string_start + 1;\n      \
    \  reversed_string = &string[reversed_string_start..];\n    }\n    reversed_string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp2hw0xv4j.rs:16:45\n\
    \   |\n16 |         while reversed_string_start >= 0 && reversed_string[reversed_string_start]\
    \ != string[reversed_string_start] {\n   |                                   \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp2hw0xv4j.rs:16:87\n\
    \   |\n16 |         while reversed_string_start >= 0 && reversed_string[reversed_string_start]\
    \ != string[reversed_string_start] {\n   |                                   \
    \                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2hw0xv4j.rs:20:27\n\
    \   |\n20 |         reversed_string = &string[reversed_string_start..];\n   |\
    \                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\nhelp: try using a conversion method\n   |\n20 |        \
    \ reversed_string = (&string[reversed_string_start..]).to_string();\n   |    \
    \                       +                                +++++++++++++\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805824
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut palindrome = string;\n   \
    \ let mut last_char = 0;\n    while !reversed_string.is_empty() {\n        let\
    \ mut current_char = reversed_string[0];\n        reversed_string = reversed_string.chars().skip_while(|c|\
    \ c != current_char).collect();\n        palindrome = palindrome.append(&current_char);\n\
    \        last_char = current_char;\n    }\n    palindrome = palindrome.append(&last_char);\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmp72fqb__u.rs:16:32\n   |\n16 |         let mut current_char = reversed_string[0];\n\
    \   |                                ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n\nerror[E0599]: no method named `append` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp72fqb__u.rs:18:33\n   |\n18 |         palindrome\
    \ = palindrome.append(&current_char);\n   |                                 ^^^^^^\
    \ method not found in `String`\n\nerror[E0599]: no method named `append` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmp72fqb__u.rs:21:29\n\
    \   |\n21 |     palindrome = palindrome.append(&last_char);\n   |            \
    \                 ^^^^^^ method not found in `String`\n\nerror[E0277]: can't compare\
    \ `&char` with `{integer}`\n  --> /tmp/tmp72fqb__u.rs:17:68\n   |\n17 |      \
    \   reversed_string = reversed_string.chars().skip_while(|c| c != current_char).collect();\n\
    \   |                                                                    ^^ no\
    \ implementation for `&char == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&char`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805824
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = string;\n    let\
    \ mut palindrome = string;\n    let mut prefix_length = 0;\n    let mut suffix_length\
    \ = 0;\n    while !string.is_empty() {\n        let mut index = string.len();\n\
    \        while index > 0 {\n            let mut char = string[index - 1];\n  \
    \          reversed_string.insert(0, char);\n            palindrome.insert(0,\
    \ char);\n            index -= 1;\n        }\n        let mut index = string.len();\n\
    \        while index > 0 {\n            let char = string[index - 1];\n      \
    \      string.insert(0, char);\n            palindrome.insert(0, char);\n    \
    \        index -= 1;\n        }\n        let mut index = string.len();\n     \
    \   while index > 0 {\n            let char = string[index - 1];\n           \
    \ reversed_string.insert(0, char);\n            string.insert(0, char);\n    \
    \        palindrome.insert(0, char);\n            index -= 1;\n        }\n   \
    \     let mut index = string.len();\n        while index > 0 {\n            let\
    \ char = string[index - 1];\n            reversed_string.insert(0, char);\n  \
    \          string.insert(0, char);\n            palindrome.insert(0, char);\n\
    \            index -= 1;\n        }\n        let mut index = string.len();\n \
    \       while index > 0 {\n            let char = string[index - 1];\n       \
    \     reversed_string.insert(0, char);\n            string.insert(0, char);\n\
    \            palindrome.insert(0, char);\n            index -= 1;\n        }\n\
    \        let mut index = string.len();\n        while index > 0 {\n          \
    \  let char = string[index - 1];\n            reversed_string.insert(0, char);\n\
    \            string.insert(0, char);\n            palindrome.insert(0, char);\n\
    \            index -= 1;\n        }\n        let mut index = string.len();\n \
    \       while index > 0 {\n            let char = string[index - 1];\n       \
    \     reversed_string.insert(0, char);\n            string.insert(0, char);\n\
    \            palindrome.insert(0, char);\n            index -= 1;\n        }\n\
    \        let mut index = string.len();\n        while index > 0 {\n          \
    \  let char = string[index - 1];\n            reversed_string.insert(0, char);\n\
    \            string.insert(0, char);\n            palindrome.insert(0, char);\n\
    \            index -= 1;\n        }\n        let mut index = string.len();\n \
    \       while index > 0 {\n            let char = string[index - 1];\n       \
    \     reversed_string.insert(0, char);\n            string.insert(0, char);\n\
    \            palindrome.insert(0, char);\n            index -= 1;\n        }\n\
    \        let mut index = string.len();\n        while index > 0 {\n          \
    \  let char = string[index - 1];\n            reversed_string.insert(0, char);\n\
    \            string.insert(0, char);\n            palindrome.insert(0, char);\n\
    \            index -= 1;\n\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpgwtuhit4.rs:105:3\n\
    \    |\n11  | fn make_palindrome(string: String) -> String {\n    |          \
    \                                    - unclosed delimiter\n...\n17  |     while\
    \ !string.is_empty() {\n    |                              - unclosed delimiter\n\
    ...\n89  |         while index > 0 {\n    |                         - this delimiter\
    \ might not be properly closed...\n...\n96  | }\n    | - ...as it matches this\
    \ but it has different indentation\n...\n105 | }\n    |   ^\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmpgwtuhit4.rs:20:28\n\
    \   |\n20 |             let mut char = string[index - 1];\n   |              \
    \              ^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpgwtuhit4.rs:27:24\n\
    \   |\n27 |             let char = string[index - 1];\n   |                  \
    \      ^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmpgwtuhit4.rs:34:24\n\
    \   |\n34 |             let char = string[index - 1];\n   |                  \
    \      ^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmpgwtuhit4.rs:42:24\n\
    \   |\n42 |             let char = string[index - 1];\n   |                  \
    \      ^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmpgwtuhit4.rs:50:24\n\
    \   |\n50 |             let char = string[index - 1];\n   |                  \
    \      ^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerr"
  stdout: ''
  timestamp: 1659805824
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_postfix_length = 0;\n\
    \    for c in string.chars() {\n        if longest_postfix_length < c.len() {\n\
    \            longest_postfix_length = c.len();\n        }\n    }\n    let mut\
    \ postfix_length = longest_postfix_length;\n    while postfix_length >= 1 {\n\
    \        let mut postfix = &string[..postfix_length];\n        let mut reversed_postfix\
    \ = &reversed_string[..postfix_length];\n        let mut is_palindrome = true;\n\
    \        for c in postfix.chars() {\n            if !reversed_postfix.contains(&c)\
    \ {\n                is_palindrome = false;\n                break;\n        \
    \    }\n        }\n        if is_palindrome {\n            reversed_postfix.reverse();\n\
    \            postfix_length -= 1;\n        }\n        reversed_string += &reversed_postfix;\n\
    \    }\n    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp3awwnwbz.rs:15:39\n   |\n15 |         if longest_postfix_length\
    \ < c.len() {\n   |                                       ^^^ method not found\
    \ in `char`\n\nerror[E0599]: no method named `len` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp3awwnwbz.rs:16:40\n   |\n16 |             longest_postfix_length\
    \ = c.len();\n   |                                        ^^^ method not found\
    \ in `char`\n\nerror[E0277]: expected a `Fn<(char,)>` closure, found `char`\n\
    \  --> /tmp/tmp3awwnwbz.rs:25:43\n   |\n25 |             if !reversed_postfix.contains(&c)\
    \ {\n   |                                           ^^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n   |\n   = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n   = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n   = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&char`\n\nerror[E0599]: no method named `reverse` found for\
    \ reference `&str` in the current scope\n  --> /tmp/tmp3awwnwbz.rs:31:30\n   |\n\
    31 |             reversed_postfix.reverse();\n   |                           \
    \   ^^^^^^^ method not found in `&str`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805824
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut prefix_length = 0;\n    let\
    \ mut suffix_length = 0;\n    while !reversed_string.is_empty() {\n        let\
    \ mut current_char = reversed_string[0];\n        reversed_string = reversed_string.split_off(1).collect();\n\
    \        if current_char == current_char.rev() {\n            suffix_length +=\
    \ 1;\n        } else {\n            prefix_length += 1;\n        }\n    }\n  \
    \  prefix_length\n        .checked_add(suffix_length)\n        .and_then(|length|\
    \ {\n            let mut reversed_string = string;\n            let mut prefix_length\
    \ = 0;\n            let mut suffix_length = 0;\n            while !reversed_string.is_empty()\
    \ {\n                let mut current_char = reversed_string[0];\n            \
    \    reversed_string = reversed_string.split_off(1).collect();\n             \
    \   if current_char == current_char.rev() {\n                    suffix_length\
    \ += 1;\n                } else {\n                    prefix_length += 1;\n \
    \               }\n            }\n            prefix_length\n                .checked_add(suffix_length)\n\
    \                .and_then(|length| {\n                    let mut reversed_string\
    \ = string;\n                    let mut prefix_length = 0;\n                \
    \    let mut suffix_length = 0;\n                    while !reversed_string.is_empty()\
    \ {\n                        let mut current_char = reversed_string[0];\n    \
    \                    reversed_string = reversed_string.split_off(1).collect();\n\
    \                        if current_char == current_char.rev() {\n           \
    \                 suffix_length += 1;\n                        } else {\n    \
    \                        prefix_length += 1;\n                        }\n    \
    \                }\n                    prefix_length\n                      \
    \  .checked_add(suffix_length)\n                        .and_then(|length| {\n\
    \                            let mut reversed_string = string;\n             \
    \               let mut prefix_length = 0;\n                            let mut\
    \ suffix_length = 0;\n                            while !reversed_string.is_empty()\
    \ {\n                                let mut current_char = reversed_string[0];\n\
    \                                reversed_string = reversed_string.split_off(1).collect();\n\
    \                                if current_char == current_char.rev() {\n   \
    \                                 suffix_length += 1;\n                      \
    \          } else {\n                                    prefix_length += 1;\n\
    \                                }\n                            }\n          \
    \                  prefix_length\n                                .checked_add(suffix_length)\n\
    \                                .and_then(|length| {\n                      \
    \              let mut reversed_string = string;\n                           \
    \         let mut prefix_length = 0;\n                                    let\
    \ mut suffix_length = 0;\n                                    while !reversed_string.is_empty()\
    \ {\n                                        let mut current_char = reversed_string[0];\n\
    \                                        reversed_string = reversed_string.split_off(1).collect();\n\
    \                                        if current_char == current_char.rev()\
    \ {\n                                            suffix_length\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpbcr18d3b.rs:89:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n26 |         .and_then(|length|\
    \ {\n   |                  -         - unclosed delimiter\n   |              \
    \    |\n   |                  unclosed delimiter\n...\n41 |                 .and_then(|length|\
    \ {\n   |                          -         - unclosed delimiter\n   |      \
    \                    |\n   |                          unclosed delimiter\n...\n\
    56 |                         .and_then(|length| {\n   |                      \
    \            -         - unclosed delimiter\n   |                            \
    \      |\n   |                                  unclosed delimiter\n...\n71 |\
    \                                 .and_then(|length| {\n   |                 \
    \                         -         - unclosed delimiter\n   |               \
    \                           |\n   |                                          unclosed\
    \ delimiter\n...\n75 |                                     while !reversed_string.is_empty()\
    \ {\n   |                                                                    \
    \   - unclosed delimiter\n...\n78 |                                         if\
    \ current_char == current_char.rev() {\n   |                                 \
    \                                              - this delimiter might not be properly\
    \ closed...\n79 |                                             suffix_length\n\
    80 | }\n   | - ...as it matches this but it has different indentation\n...\n89\
    \ | }\n   |   ^\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpbcr18d3b.rs:16:32\n   |\n16 |         let mut current_char = reversed_string[0];\n\
    \   |                                ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n\nerror[E0599]: the method `collect` exists for struct `String`,\
    \ but its trait bounds were not satisfied\n   --> /tmp/tmpbcr18d3b.rs:17:56\n\
    \    |"
  stdout: ''
  timestamp: 1659805824
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut reverse_length = 0;\n    let\
    \ mut longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n  \
    \  let mut longest_postfix_char: char;\n    let mut longest_postfix_char_length\
    \ = 0;\n    let mut longest_postfix_char_length_index = 0;\n    let mut longest_postfix_char_length_index2\
    \ = 0;\n    let mut longest_postfix_char_length_index3 = 0;\n    let mut longest_postfix_char_length_index4\
    \ = 0;\n    let mut longest_postfix_char_length_index5 = 0;\n    let mut longest_postfix_char_length_index6\
    \ = 0;\n    let mut longest_postfix_char_length_index7 = 0;\n    let mut longest_postfix_char_length_index8\
    \ = 0;\n    let mut longest_postfix_char_length_index9 = 0;\n    let mut longest_postfix_char_length_index10\
    \ = 0;\n    let mut longest_postfix_char_length_index11 = 0;\n    let mut longest_postfix_char_length_index12\
    \ = 0;\n    let mut longest_postfix_char_length_index13 = 0;\n    let mut longest_postfix_char_length_index14\
    \ = 0;\n    let mut longest_postfix_char_length_index15 = 0;\n    let mut longest_postfix_char_length_index16\
    \ = 0;\n    let mut longest_postfix_char_length_index17 = 0;\n    let mut longest_postfix_char_length_index18\
    \ = 0;\n    let mut longest_postfix_char_length_index19 = 0;\n    let mut longest_postfix_char_length_index20\
    \ = 0;\n    let mut longest_postfix_char_length_index21 = 0;\n    let mut longest_postfix_char_length_index22\
    \ = 0;\n    let mut longest_postfix_char_length_index23 = 0;\n    let mut longest_postfix_char_length_index24\
    \ = 0;\n    let mut longest_postfix_char_length_index25 = 0;\n    let mut longest_postfix_char_length_index26\
    \ = 0;\n    let mut longest_postfix_char_length_index27 = 0;\n    let mut longest_postfix_char_length_index28\
    \ = 0;\n    let mut longest_postfix_char_length_index29 = 0;\n    let mut longest_postfix_char_length_index30\
    \ = 0;\n    let mut longest_postfix_char_length_index31 = 0;\n    let mut longest_postfix_char_length_index32\
    \ = 0;\n    let mut longest_postfix_char_length_index33 = 0;\n    let mut longest_postfix_char_length_index34\
    \ = 0;\n    let mut longest_postfix_char_length_index35 = 0;\n    let mut lon\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmps7y_6h84.rs:53:16\n   |\n\
    53 |     let mut lon\n   |                ^ help: add `;` here\n54 | }\n   | -\
    \ unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps7y_6h84.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805824
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix = \"\";\n    let mut longest_postfix_length = 0;\n    let mut\
    \ longest_postfix_index = 0;\n    while string.len() > 0 {\n        let mut postfix\
    \ = string;\n        let mut postfix_length = 0;\n        let mut postfix_index\
    \ = 0;\n        while postfix.len() > 0 {\n            let mut postfix_char =\
    \ postfix.chars().nth(postfix_index).unwrap();\n            if postfix_char ==\
    \ &mut 'a' {\n                postfix_char = 'b';\n            } else if postfix_char\
    \ == &mut 'b' {\n                postfix_char = 'a';\n            }\n        \
    \    postfix_index += 1;\n            postfix_length += 1;\n            postfix\
    \ = postfix.chars().nth(postfix_index).unwrap();\n        }\n        if postfix_length\
    \ >= longest_postfix_length {\n            longest_postfix_length = postfix_length;\n\
    \            longest_postfix = postfix;\n            longest_postfix_index = postfix_index;\n\
    \        }\n        string = &string[postfix_length..];\n    }\n    longest_postfix\
    \ = longest_postfix.chars().nth(longest_postfix_index).unwrap();\n    reversed_string\
    \ += longest_postfix;\n    reversed_string += &string[longest_postfix_length..];\n\
    \    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9tbhfbm9.rs:23:32\n   |\n\
    23 |             if postfix_char == &mut 'a' {\n   |                         \
    \       ^^^^^^^^ expected `char`, found `&mut char`\n   |\nhelp: consider removing\
    \ the borrow\n   |\n23 -             if postfix_char == &mut 'a' {\n23 +     \
    \        if postfix_char == 'a' {\n   | \n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp9tbhfbm9.rs:25:39\n   |\n25 |             } else if postfix_char\
    \ == &mut 'b' {\n   |                                       ^^^^^^^^ expected\
    \ `char`, found `&mut char`\n   |\nhelp: consider removing the borrow\n   |\n\
    25 -             } else if postfix_char == &mut 'b' {\n25 +             } else\
    \ if postfix_char == 'b' {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9tbhfbm9.rs:30:23\n\
    \   |\n30 |             postfix = postfix.chars().nth(postfix_index).unwrap();\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                       |\n\
    \   |                       expected struct `String`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9tbhfbm9.rs:34:31\n   |\n34 |             longest_postfix\
    \ = postfix;\n   |                               ^^^^^^^\n   |               \
    \                |\n   |                               expected `&str`, found\
    \ struct `String`\n   |                               help: consider borrowing\
    \ here: `&postfix`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9tbhfbm9.rs:37:18\n\
    \   |\n37 |         string = &string[postfix_length..];\n   |                \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n   |\nhelp:\
    \ try using a conversion method\n   |\n37 |         string = (&string[postfix_length..]).to_string();\n\
    \   |                  +                         +++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9tbhfbm9.rs:39:23\n   |\n39 |     longest_postfix\
    \ = longest_postfix.chars().nth(longest_postfix_index).unwrap();\n   |       \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `&str`, found `c"
  stdout: ''
  timestamp: 1659805824
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_postfix = string;\n\
    \    let mut longest_postfix_len = 0;\n    let mut longest_postfix_index = 0;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut lon\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpjr0qsuvw.rs:63:16\n   |\n\
    63 |     let mut lon\n   |                ^ help: add `;` here\n64 | }\n   | -\
    \ unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjr0qsuvw.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805824
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix = \"\";\n    let mut longest_postfix_len = 0;\n    let mut longest_postfix_pos\
    \ = 0;\n    let mut longest_postfix_len2 = 0;\n    let mut longest_postfix_pos2\
    \ = 0;\n    while let Some(pos) = string.rfind('a') {\n        longest_postfix_len\
    \ += 1;\n        longest_postfix_len2 += 1;\n        longest_postfix_pos += 1;\n\
    \        longest_postfix_pos2 += 1;\n        longest_postfix = &string[..pos];\n\
    \        longest_postfix_len = longest_postfix_len2;\n        longest_postfix_pos\
    \ = longest_postfix_pos2;\n        string = &string[pos..];\n    }\n    let mut\
    \ longest_postfix_len = longest_postfix_len2;\n    let mut longest_postfix_pos\
    \ = longest_postfix_pos2;\n    while let Some(pos) = string.rfind('a') {\n   \
    \     longest_postfix_len += 1;\n        longest_postfix_len2 += 1;\n        longest_postfix_pos\
    \ += 1;\n        longest_postfix_pos2 += 1;\n        longest_postfix = &string[..pos];\n\
    \        longest_postfix_len = longest_postfix_len2;\n        longest_postfix_pos\
    \ = longest_postfix_pos2;\n        string = &string[pos..];\n    }\n    while\
    \ let Some(pos) = string.rfind('a') {\n        longest_postfix_len += 1;\n   \
    \     longest_postfix_len2 += 1;\n        longest_postfix_pos += 1;\n        longest_postfix_pos2\
    \ += 1;\n        longest_postfix = &string[..pos];\n        longest_postfix_len\
    \ = longest_postfix_len2;\n        longest_postfix_pos = longest_postfix_pos2;\n\
    \        string = &string[pos..];\n    }\n    while let Some(pos) = string.rfind('a')\
    \ {\n        longest_postfix_len += 1;\n        longest_postfix_len2 += 1;\n \
    \       longest_postfix_pos += 1;\n        longest_postfix_pos2 += 1;\n      \
    \  longest_postfix = &string[..pos];\n        longest_postfix_len = longest_postfix_len2;\n\
    \        longest_postfix_pos = longest_postfix_pos2;\n        string = &string[pos..];\n\
    \    }\n    while let Some(pos) = string.rfind('a') {\n        longest_postfix_len\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpp8ykt0s1.rs:72:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n61 |     while let\
    \ Some(pos) = string.rfind('a') {\n   |                                      \
    \       - this delimiter might not be properly closed...\n62 |         longest_postfix_len\n\
    63 | }\n   | - ...as it matches this but it has different indentation\n...\n72\
    \ | }\n   |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp8ykt0s1.rs:27:18\n\
    \   |\n27 |         string = &string[pos..];\n   |                  ^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n27 |         string = (&string[pos..]).to_string();\n   |             \
    \     +              +++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp8ykt0s1.rs:39:18\n\
    \   |\n39 |         string = &string[pos..];\n   |                  ^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n39 |         string = (&string[pos..]).to_string();\n   |             \
    \     +              +++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp8ykt0s1.rs:49:18\n\
    \   |\n49 |         string = &string[pos..];\n   |                  ^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n49 |         string = (&string[pos..]).to_string();\n   |             \
    \     +              +++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp8ykt0s1.rs:59:18\n\
    \   |\n59 |         string = &string[pos..];\n   |                  ^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n59 |         string = (&string[pos..]).to_string();\n   |             \
    \     +              +++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp8ykt0s1.rs:62:9\n\
    \   |\n61 | /     while let Some(pos) = string.rfind('a') {\n62 | |         longest_postfix_len\n\
    \   | |         ^^^^^^^^^^^^^^^^^^^ expected `()`, found integer\n63 | | }\n \
    \  | |_- "
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = string;\n    let\
    \ mut i = 0;\n    while i < string.len() {\n        let mut j = string.len() -\
    \ 1;\n        while j >= i {\n            if string[j] != string[j].to_lowercase().rev()\
    \ {\n                break;\n            }\n            j -= 1;\n        }\n \
    \       if j >= i {\n            reversed_string.push((string[i..j + 1]).rev());\n\
    \            i += j - i + 1;\n        }\n    }\n    string\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp495jjs5i.rs:18:16\n\
    \   |\n18 |             if string[j] != string[j].to_lowercase().rev() {\n   |\
    \                ^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmp495jjs5i.rs:18:29\n\
    \   |\n18 |             if string[j] != string[j].to_lowercase().rev() {\n   |\
    \                             ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0599]: the method `rev` exists for type `str`, but its trait bounds were\
    \ not satisfied\n  --> /tmp/tmp495jjs5i.rs:24:53\n   |\n24 |             reversed_string.push((string[i..j\
    \ + 1]).rev());\n   |                                                     ^^^\
    \ method cannot be called on `str` due to unsatisfied trait bounds\n   |\n   =\
    \ note: the following trait bounds were not satisfied:\n           `str: Iterator`\n\
    \           which is required by `&mut str: Iterator`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805824
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = string;\n    let\
    \ mut i = 0;\n    while i < string.len() {\n        let mut j = i;\n        while\
    \ j + 1 < string.len() && string[j] == string[j + 1] {\n            j += 1\n \
    \       }\n        reversed_string.push_str(&string[i..j]);\n        i = j;\n\
    \    }\n    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_8ancjgn.rs:17:39\n\
    \   |\n17 |         while j + 1 < string.len() && string[j] == string[j + 1] {\n\
    \   |                                       ^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n \
    \ --> /tmp/tmp_8ancjgn.rs:17:52\n   |\n17 |         while j + 1 < string.len()\
    \ && string[j] == string[j + 1] {\n   |                                      \
    \              ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805824
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    let\
    \ mut longest_postfix_string = \"\";\n    let mut longest_postfix_index2 = 0;\n\
    \    let mut longest_postfix_string2 = \"\";\n    let mut longest_postfix_index3\
    \ = 0;\n    let mut longest_postfix_string3 = \"\";\n    let mut longest_postfix_index4\
    \ = 0;\n    let mut longest_postfix_string4 = \"\";\n    let mut longest_postfix_index5\
    \ = 0;\n    let mut longest_postfix_string5 = \"\";\n    let mut longest_postfix_index6\
    \ = 0;\n    let mut longest_postfix_string6 = \"\";\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_string7 = \"\";\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_string8 = \"\";\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_string9 = \"\";\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_string10 = \"\";\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_string11 = \"\";\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_string12 = \"\";\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_string13 = \"\";\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_string14 = \"\";\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_string15 = \"\";\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_string16 = \"\";\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_string17 = \"\";\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_string18 = \"\";\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_string19 = \"\";\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_string20 = \"\";\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_string21 = \"\";\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_string22 = \"\";\n    let mut longest_postfix_index23\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpqw0q_a7y.rs:59:36\n   |\n\
    59 |     let mut longest_postfix_index23\n   |                               \
    \     ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqw0q_a7y.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805824
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reverse = string;\n    let mut postfix = string;\n    let mut i =\
    \ 0;\n    while i < reverse.len() {\n        if reverse[i] != postfix[i] {\n \
    \           break;\n        }\n        i += 1;\n    }\n    postfix.push_str(&reverse[i..]);\n\
    \    postfix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpi7lcrzu_.rs:16:12\n\
    \   |\n16 |         if reverse[i] != postfix[i] {\n   |            ^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpi7lcrzu_.rs:16:26\n   |\n16 |         if reverse[i]\
    \ != postfix[i] {\n   |                          ^^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805824
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reverse = string;\n    let mut suffix\
    \ = 0;\n    while let Some(pos) = string.rfind(&reverse) {\n        suffix = pos;\n\
    \        reverse = &string[..pos];\n    }\n    string = &string[..suffix];\n \
    \   string.reverse();\n    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb57_cht0.rs:17:19\n   |\n\
    17 |         reverse = &string[..pos];\n   |                   ^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n17 |         reverse = (&string[..pos]).to_string();\n   |            \
    \       +              +++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpb57_cht0.rs:19:14\n   |\n19 |     string = &string[..suffix];\n   |\
    \              ^^^^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n   |\n\
    help: try using a conversion method\n   |\n19 |     string = (&string[..suffix]).to_string();\n\
    \   |              +                 +++++++++++++\n\nerror[E0599]: no method\
    \ named `reverse` found for struct `String` in the current scope\n  --> /tmp/tmpb57_cht0.rs:20:12\n\
    \   |\n20 |     string.reverse();\n   |            ^^^^^^^ help: there is an associated\
    \ function with a similar name: `reserve`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    while\
    \ !string.is_empty() {\n        let mut postfix_length = 0;\n        let mut postfix_index\
    \ = 0;\n        while !string.is_empty() {\n            let c = string.chars().next().unwrap();\n\
    \            if c != string[postfix_index] {\n                break;\n       \
    \     }\n            postfix_index += 1;\n            postfix_length += 1;\n \
    \       }\n        if postfix_length > longest_postfix_length {\n            longest_postfix_length\
    \ = postfix_length;\n            longest_postfix_index = postfix_index;\n    \
    \    }\n        string = &string[longest_postfix_index..];\n        reversed_string\
    \ += &string[longest_postfix_index..];\n    }\n    string + &reversed_string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmphspyhjp0.rs:21:21\n   |\n21 |             if c != string[postfix_index]\
    \ {\n   |                     ^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphspyhjp0.rs:31:18\n\
    \   |\n31 |         string = &string[longest_postfix_index..];\n   |         \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n\
    \   |\nhelp: try using a conversion method\n   |\n31 |         string = (&string[longest_postfix_index..]).to_string();\n\
    \   |                  +                                +++++++++++++\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmphspyhjp0.rs:32:9\n\
    \   |\n32 |         reversed_string += &string[longest_postfix_index..];\n   |\
    \         ---------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |         |\n\
    \   |         cannot use `+=` on type `&str`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0368.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix = \"\";\n    let mut longest_postfix_len = 0;\n    let mut longest_prefix_len\
    \ = 0;\n    while !string.is_empty() {\n        let mut postfix = string;\n  \
    \      let mut postfix_len = 0;\n        while !postfix.is_empty() {\n       \
    \     if postfix.chars().next().unwrap() == postfix.chars().last().unwrap() {\n\
    \                postfix.pop();\n                postfix_len += 1;\n         \
    \   } else {\n                break;\n            }\n        }\n        if postfix_len\
    \ > longest_postfix_len {\n            longest_postfix_len = postfix_len;\n  \
    \          longest_postfix = postfix;\n        }\n        let mut prefix = string;\n\
    \        let mut prefix_len = 0;\n        while !prefix.is_empty() {\n       \
    \     if prefix.chars().next().unwrap() == prefix.chars().last().unwrap() {\n\
    \                prefix.pop();\n                prefix_len += 1;\n           \
    \ } else {\n                break;\n            }\n        }\n        if prefix_len\
    \ > longest_prefix_len {\n            longest_prefix_len = prefix_len;\n     \
    \       longest_prefix = prefix;\n        }\n        string = prefix.clone();\n\
    \    }\n    longest_postfix.append(&reversed_string[longest_prefix_len..]);\n\
    \    longest_postfix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `longest_prefix` in this scope\n  --> /tmp/tmpgxizmrku.rs:44:13\n\
    \   |\n44 |             longest_prefix = prefix;\n   |             ^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `longest_postfix`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgxizmrku.rs:30:31\n   |\n30 |             longest_postfix\
    \ = postfix;\n   |                               ^^^^^^^\n   |               \
    \                |\n   |                               expected `&str`, found\
    \ struct `String`\n   |                               help: consider borrowing\
    \ here: `&postfix`\n\nerror[E0599]: no method named `append` found for reference\
    \ `&str` in the current scope\n  --> /tmp/tmpgxizmrku.rs:48:21\n   |\n48 |   \
    \  longest_postfix.append(&reversed_string[longest_prefix_len..]);\n   |     \
    \                ^^^^^^ method not found in `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpgxizmrku.rs:49:5\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |                                       ------ expected\
    \ `String` because of return type\n...\n49 |     longest_postfix\n   |     ^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix = \"\";\n    let mut longest_postfix_len = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index2\
    \ = 0;\n    let mut longest_postfix_end_index2 = 0;\n    let mut longest_postfix_start_index3\
    \ = 0;\n    let mut longest_postfix_end_index3 = 0;\n    let mut longest_postfix_start_index4\
    \ = 0;\n    let mut longest_postfix_end_index4 = 0;\n    let mut longest_postfix_start_index5\
    \ = 0;\n    let mut longest_postfix_end_index5 = 0;\n    let mut longest_postfix_start_index6\
    \ = 0;\n    let mut longest_postfix_end_index6 = 0;\n    let mut longest_postfix_start_index7\
    \ = 0;\n    let mut longest_postfix_end_index7 = 0;\n    let mut longest_postfix_start_index8\
    \ = 0;\n    let mut longest_postfix_end_index8 = 0;\n    let mut longest_postfix_start_index9\
    \ = 0;\n    let mut longest_postfix_end_index9 = 0;\n    let mut longest_postfix_start_index10\
    \ = 0;\n    let mut longest_postfix_end_index10 = 0;\n    let mut longest_postfix_start_index11\
    \ = 0;\n    let mut longest_postfix_end_index11 = 0;\n    let mut longest_postfix_start_index12\
    \ = 0;\n    let mut longest_postfix_end_index12 = 0;\n    let mut longest_postfix_start_index13\
    \ = 0;\n    let mut longest_postfix_end_index13 = 0;\n    let mut longest_postfix_start_index14\
    \ = 0;\n    let mut longest_postfix_end_index14 = 0;\n    let mut longest_postfix_start_index15\
    \ = 0;\n    let mut longest_postfix_end_index15 = 0;\n    let mut longest_postfix_start_index16\
    \ = 0;\n    let mut longest_postfix_end_index16 = 0;\n    let mut longest_postfix_start_index17\
    \ = 0;\n    let mut longest_postfix_end_index17 = 0;\n    let mut longest_postfix_start_index18\
    \ = 0;\n    let mut longest_postfix_end_index18 = 0;\n    let mut longest_postfix_start_index19\
    \ = 0;\n    let mut longest_postfix_end_index19 = 0;\n    let mut longest_postfix_start_index20\
    \ = 0;\n\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5ttx609o.rs:11:39\n   |\n\
    11 | fn make_palindrome(string: String) -> String {\n   |    --------------- \
    \                   ^^^^^^ expected struct `String`, found `()`\n   |    |\n \
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reverse = string;\n    let mut i =\
    \ 0;\n    while i < string.len() {\n        let mut j = i;\n        while j <\
    \ string.len() && string[j] != string[string.len() - j] {\n            j = j +\
    \ 1;\n        }\n        reverse.push_str(&string[i..j]);\n        i = j;\n  \
    \  }\n    reverse\n}\n\nfn main() {\n    let candidate = make_palindrome;\n  \
    \  assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_quj7oe4.rs:17:35\n\
    \   |\n17 |         while j < string.len() && string[j] != string[string.len()\
    \ - j] {\n   |                                   ^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp_quj7oe4.rs:17:48\n   |\n17 |         while j < string.len() &&\
    \ string[j] != string[string.len() - j] {\n   |                              \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut palindrome = string;\n   \
    \ let mut postfix = string.clone();\n    while !postfix.is_empty() {\n       \
    \ let mut postfix_char = postfix.chars().nth(postfix.len() - 1);\n        let\
    \ mut postfix_char_str = String::from(postfix_char);\n        while !postfix_char_str.is_empty()\
    \ {\n            if postfix_char_str == reversed_string {\n                palindrome\
    \ = palindrome.append(postfix_char_str);\n                break;\n           \
    \ }\n            postfix_char_str = postfix_char_str.chars().nth(postfix_char_str.len()\
    \ - 1);\n        }\n        postfix = postfix.chars().nth(postfix.len() - 1);\n\
    \    }\n    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<Option<char>>` is not satisfied\n\
    \   --> /tmp/tmp0s38iim2.rs:17:36\n    |\n17  |         let mut postfix_char_str\
    \ = String::from(postfix_char);\n    |                                    ^^^^^^^^^^^^\
    \ the trait `From<Option<char>>` is not implemented for `String`\n    |\n    =\
    \ help: the following implementations were found:\n              <String as From<&String>>\n\
    \              <String as From<&mut str>>\n              <String as From<&str>>\n\
    \              <String as From<Box<str>>>\n            and 2 others\nnote: required\
    \ by `from`\n\nerror[E0599]: no method named `append` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp0s38iim2.rs:20:41\n   |\n20 |          \
    \       palindrome = palindrome.append(postfix_char_str);\n   |              \
    \                           ^^^^^^ method not found in `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0s38iim2.rs:23:32\n   |\n23 |             postfix_char_str\
    \ = postfix_char_str.chars().nth(postfix_char_str.len() - 1);\n   |          \
    \                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found enum `Option`\n   |\n   = note: expected struct\
    \ `String`\n                found enum `Option<char>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0s38iim2.rs:25:19\n   |\n25 |         postfix = postfix.chars().nth(postfix.len()\
    \ - 1);\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found enum `Option`\n   |\n   = note: expected struct `String`\n\
    \                found enum `Option<char>`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix = \"\";\n    let mut longest_postfix_length = 0;\n    let mut\
    \ longest_postfix_index = 0;\n    let mut longest_postfix_length_index = 0;\n\
    \    while let Some(index) = string.rfind('a') {\n        let postfix = &string[index..];\n\
    \        let postfix_length = postfix.len();\n        if longest_postfix_length\
    \ < postfix_length {\n            longest_postfix_length = postfix_length;\n \
    \           longest_postfix_index = index;\n        }\n        if longest_postfix_length\
    \ == postfix_length {\n            longest_postfix_length_index = index;\n   \
    \     }\n        if longest_postfix_length == postfix_length {\n            reversed_string\
    \ += &postfix[longest_postfix_length_index..];\n        }\n        string = &string[index..];\n\
    \    }\n    longest_postfix += &string[longest_postfix_index..];\n    reversed_string\
    \ += &string[longest_postfix_length_index..];\n    reversed_string\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&str`\n  --> /tmp/tmpwp22uo4j.rs:29:13\n   |\n29 |             reversed_string\
    \ += &postfix[longest_postfix_length_index..];\n   |             ---------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwp22uo4j.rs:31:18\n   |\n31 |         string\
    \ = &string[index..];\n   |                  ^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found `&str`\n   |\nhelp: try using a conversion method\n   |\n31\
    \ |         string = (&string[index..]).to_string();\n   |                  +\
    \                +++++++++++++\n\nerror[E0368]: binary assignment operation `+=`\
    \ cannot be applied to type `&str`\n  --> /tmp/tmpwp22uo4j.rs:33:5\n   |\n33 |\
    \     longest_postfix += &string[longest_postfix_index..];\n   |     ---------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |     |\n   |     cannot use `+=` on type `&str`\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpwp22uo4j.rs:34:5\n\
    \   |\n34 |     reversed_string += &string[longest_postfix_length_index..];\n\
    \   |     ---------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |   \
    \  |\n   |     cannot use `+=` on type `&str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwp22uo4j.rs:35:5\n   |\n11 | fn make_palindrome(string: String)\
    \ -> String {\n   |                                       ------ expected `String`\
    \ because of return type\n...\n35 |     reversed_string\n   |     ^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 5 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0368.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut prefix_length = 0;\n    let\
    \ mut suffix_length = 0;\n    while !reversed_string.is_empty() {\n        let\
    \ mut current_char = reversed_string[0];\n        reversed_string = reversed_string.chars().skip(1).collect();\n\
    \        if current_char == current_char.to_string().rev() {\n            suffix_length\
    \ += 1;\n        } else {\n            prefix_length += 1;\n        }\n    }\n\
    \    let mut palindrome = string;\n    palindrome.push_str(&string[prefix_length..suffix_length]);\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpv5n_132d.rs:16:32\n   |\n16 |         let mut current_char = reversed_string[0];\n\
    \   |                                ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix = \"\";\n    let mut longest_postfix_length = 0;\n    let mut\
    \ longest_postfix_index = 0;\n    let mut longest_postfix_length_index = 0;\n\
    \    while string.len() > 0 {\n        let mut postfix_length = 0;\n        let\
    \ mut postfix_index = 0;\n        while postfix_index < string.len() {\n     \
    \       let mut postfix_char = string[postfix_index];\n            while postfix_char\
    \ == string[postfix_index] {\n                postfix_index += 1;\n          \
    \      postfix_char += 1;\n            }\n            postfix_length += 1;\n \
    \       }\n        if postfix_length > longest_postfix_length {\n            longest_postfix_length\
    \ = postfix_length;\n            longest_postfix_index = postfix_index;\n    \
    \    }\n        let mut postfix_char = string[postfix_index];\n        while postfix_char\
    \ == string[postfix_index] {\n            postfix_index += 1;\n            postfix_char\
    \ += 1;\n        }\n        if postfix_char == string[postfix_index] {\n     \
    \       postfix_index += 1;\n        }\n        reversed_string += string[postfix_index];\n\
    \        string = &string[postfix_index..];\n    }\n    longest_postfix_length_index\
    \ += 1;\n    longest_postfix_length += 1;\n    longest_postfix_index += 1;\n \
    \   longest_postfix += &string[longest_postfix_index..];\n    longest_postfix\
    \ += &reversed_string[longest_postfix_length_index..];\n    longest_postfix\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpttllvlie.rs:22:36\n\
    \   |\n22 |             let mut postfix_char = string[postfix_index];\n   |  \
    \                                  ^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n \
    \ --> /tmp/tmpttllvlie.rs:23:35\n   |\n23 |             while postfix_char ==\
    \ string[postfix_index] {\n   |                                   ^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpttllvlie.rs:33:32\n   |\n33 |         let\
    \ mut postfix_char = string[postfix_index];\n   |                            \
    \    ^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmpttllvlie.rs:34:31\n\
    \   |\n34 |         while postfix_char == string[postfix_index] {\n   |      \
    \                         ^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpttllvlie.rs:38:28\n\
    \   |\n38 |         if postfix_char == string[postfix_index] {\n   |         \
    \                   ^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpttllvlie.rs:41:28\n\
    \   |\n41 |         reversed_string += string[postfix_index];\n   |          \
    \                  ^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n\
    \  --> /"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut palindrome = string;\n    let mut reversed_string\
    \ = string;\n    let mut reversed_palindrome = string;\n    while !string.is_empty()\
    \ {\n        let mut current_char = string.chars().next().unwrap();\n        while\
    \ !string.is_empty() && current_char == string.chars().next().unwrap() {\n   \
    \         current_char = string.chars().next().unwrap();\n        }\n        palindrome\
    \ = current_char + palindrome;\n        reversed_palindrome = palindrome.rev().to_string();\n\
    \        reversed_string = reversed_string + reversed_palindrome;\n        string\
    \ = string.chars().next().unwrap();\n    }\n    reversed_string\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot add `String` to `char`\n  --> /tmp/tmpj4dxav_c.rs:21:35\n\
    \   |\n21 |         palindrome = current_char + palindrome;\n   |            \
    \          ------------ ^ ---------- String\n   |                      |\n   |\
    \                      char\n\nerror[E0599]: the method `rev` exists for struct\
    \ `String`, but its trait bounds were not satisfied\n   --> /tmp/tmpj4dxav_c.rs:22:42\n\
    \    |\n22  |           reversed_palindrome = palindrome.rev().to_string();\n\
    \    |                                            ^^^ method cannot be called\
    \ on `String` due to unsatisfied trait bounds\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `String: Iterator`\n         \
    \   which is required by `&mut String: Iterator`\n            `str: Iterator`\n\
    \            which is required by `&mut str: Iterator`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpj4dxav_c.rs:23:45\n   |\n23 |         reversed_string =\
    \ reversed_string + reversed_palindrome;\n   |                               \
    \              ^^^^^^^^^^^^^^^^^^^\n   |                                     \
    \        |\n   |                                             expected `&str`,\
    \ found struct `String`\n   |                                             help:\
    \ consider borrowing here: `&reversed_palindrome`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpj4dxav_c.rs:24:18\n   |\n24 |         string = string.chars().next().unwrap();\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                  |\n   |                  expected\
    \ struct `String`, found `char`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0369, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reverse = string;\n    let mut suffix\
    \ = 0;\n    let mut prefix = 0;\n    while !string.is_empty() {\n        let mut\
    \ i = suffix;\n        while i >= 0 {\n            if string[i] != string[i -\
    \ suffix] {\n                break;\n            }\n            i -= 1;\n    \
    \    }\n        if i == -1 {\n            break;\n        }\n        suffix +=\
    \ 1;\n        let mut j = prefix;\n        while j > 0 {\n            if string[j]\
    \ != string[j - prefix] {\n                break;\n            }\n           \
    \ j -= 1;\n        }\n        if j == -1 {\n            break;\n        }\n  \
    \      prefix += 1;\n        reverse.push_str(&string[..j]);\n        reverse.push_str(&string[j..]);\n\
    \    }\n    reverse.push_str(&string[..prefix]);\n    reverse\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpgfb_do8r.rs:19:16\n   |\n19 |             if string[i] != string[i -\
    \ suffix] {\n   |                ^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpgfb_do8r.rs:19:29\n\
    \   |\n19 |             if string[i] != string[i - suffix] {\n   |           \
    \                  ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpgfb_do8r.rs:30:16\n\
    \   |\n30 |             if string[j] != string[j - prefix] {\n   |           \
    \     ^^^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the\
    \ trait `Index<{integer}>` is not implemented for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpgfb_do8r.rs:30:29\n\
    \   |\n30 |             if string[j] != string[j - prefix] {\n   |           \
    \                  ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpgfb_do8r.rs:35:17\n\
    \   |\n35 |         if j == -1 {\n   |                 ^^ the trait `Neg` is not\
    \ implemented for `usize`\n\nerror: aborting due to 5 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix = \"\";\n    let mut longest_postfix_len = 0;\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_index2 = 0;\n    let mut longest_postfix_index3\
    \ = 0;\n    let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5\
    \ = 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut longest_postfix_index44 = 0;\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt0n0hdrg.rs:11:39\n   |\n\
    11 | fn make_palindrome(string: String) -> String {\n   |    --------------- \
    \                   ^^^^^^ expected struct `String`, found `()`\n   |    |\n \
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805824
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    let\
    \ mut longest_postfix_char: char;\n    let mut longest_postfix_char_length = 0;\n\
    \    let mut longest_postfix_char_length_index = 0;\n    let mut longest_postfix_char_length_index2\
    \ = 0;\n    let mut longest_postfix_char_length_index3 = 0;\n    let mut longest_postfix_char_length_index4\
    \ = 0;\n    let mut longest_postfix_char_length_index5 = 0;\n    let mut longest_postfix_char_length_index6\
    \ = 0;\n    let mut longest_postfix_char_length_index7 = 0;\n    let mut longest_postfix_char_length_index8\
    \ = 0;\n    let mut longest_postfix_char_length_index9 = 0;\n    let mut longest_postfix_char_length_index10\
    \ = 0;\n    let mut longest_postfix_char_length_index11 = 0;\n    let mut longest_postfix_char_length_index12\
    \ = 0;\n    let mut longest_postfix_char_length_index13 = 0;\n    let mut longest_postfix_char_length_index14\
    \ = 0;\n    let mut longest_postfix_char_length_index15 = 0;\n    let mut longest_postfix_char_length_index16\
    \ = 0;\n    let mut longest_postfix_char_length_index17 = 0;\n    let mut longest_postfix_char_length_index18\
    \ = 0;\n    let mut longest_postfix_char_length_index19 = 0;\n    let mut longest_postfix_char_length_index20\
    \ = 0;\n    let mut longest_postfix_char_length_index21 = 0;\n    let mut longest_postfix_char_length_index22\
    \ = 0;\n    let mut longest_postfix_char_length_index23 = 0;\n    let mut longest_postfix_char_length_index24\
    \ = 0;\n    let mut longest_postfix_char_length_index25 = 0;\n    let mut longest_postfix_char_length_index26\
    \ = 0;\n    let mut longest_postfix_char_length_index27 = 0;\n    let mut longest_postfix_char_length_index28\
    \ = 0;\n    let mut longest_postfix_char_length_index29 = 0;\n    let mut longest_postfix_char_length_index30\
    \ = 0;\n    let mut longest_postfix_char_length_index31 = 0;\n    let mut longest_postfix_char_length_index32\
    \ = 0;\n    let mut longest_postfix_char_length_index33 = 0;\n    let mut longest_postfix_char_length_index34\
    \ = 0;\n    let mut longest_postfix_char_length_index35 = 0;\n    let mut longest_\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp3n82f11x.rs:53:21\n   |\n\
    53 |     let mut longest_\n   |                     ^ help: add `;` here\n54 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3n82f11x.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    while !string.is_empty() {\n        let mut\
    \ postfix_length = 0;\n        for c in string.chars() {\n            if c ==\
    \ c.to_ascii_lowercase() {\n                postfix_length += 1;\n           \
    \ }\n        }\n        if postfix_length > longest_postfix_length {\n       \
    \     longest_postfix_length = postfix_length;\n        }\n        string = &string[postfix_length..];\n\
    \        reversed_string += &string[..postfix_length];\n    }\n    string + &reversed_string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpds8fg9go.rs:25:18\n   |\n\
    25 |         string = &string[postfix_length..];\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n25 |         string = (&string[postfix_length..]).to_string();\n   |  \
    \                +                         +++++++++++++\n\nerror[E0368]: binary\
    \ assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpds8fg9go.rs:26:9\n\
    \   |\n26 |         reversed_string += &string[..postfix_length];\n   |      \
    \   ---------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |         |\n   |       \
    \  cannot use `+=` on type `&str`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed = string;\n    let mut palindrome = string;\n    let mut\
    \ i = 0;\n    while i < reversed.len() {\n        if palindrome.chars().nth(i).unwrap()\
    \ != reversed.chars().nth(i).unwrap() {\n            palindrome = &palindrome[..i]\
    \ + &reversed[i..];\n            break;\n        }\n        i += 1;\n    }\n \
    \   palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot add `&str` to `&str`\n  --> /tmp/tmpn1sfw7to.rs:17:43\n\
    \   |\n17 |             palindrome = &palindrome[..i] + &reversed[i..];\n   |\
    \                          ---------------- ^ -------------- &str\n   |      \
    \                    |                |\n   |                          |     \
    \           `+` cannot be used to concatenate two `&str` strings\n   |       \
    \                   &str\n   |\nhelp: String concatenation appends the string\
    \ on the right to the string on the left and may require reallocation. This requires\
    \ ownership of the string on the left\n   |\n17 |             palindrome = palindrome[..i]\
    \ + &reversed[i..];\n   |                          ~~~~~~~~~~~~~~~\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0369`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut palindrome = string;\n    let mut suffix = 0;\n    let mut prefix_len\
    \ = 0;\n    while palindrome.len() > 0 {\n        let mut i = palindrome.len()\
    \ - 1;\n        while i >= 0 {\n            if palindrome[i] == palindrome[prefix_len]\
    \ {\n                suffix += 1;\n                i -= 1;\n            } else\
    \ {\n                break;\n            }\n        }\n        prefix_len += 1;\n\
    \        palindrome = &palindrome[..i];\n    }\n    palindrome += &palindrome[prefix_len..];\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp3if9bvzm.rs:18:16\n\
    \   |\n18 |             if palindrome[i] == palindrome[prefix_len] {\n   |   \
    \             ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp3if9bvzm.rs:18:33\n\
    \   |\n18 |             if palindrome[i] == palindrome[prefix_len] {\n   |   \
    \                              ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3if9bvzm.rs:26:22\n\
    \   |\n26 |         palindrome = &palindrome[..i];\n   |                     \
    \ ^^^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n   |\nhelp: try using\
    \ a conversion method\n   |\n26 |         palindrome = (&palindrome[..i]).to_string();\n\
    \   |                      +                +++++++++++++\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_postfix = string;\n\
    \    let mut longest_postfix_len = string.len();\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_index2 = 0;\n    let mut longest_postfix_index3\
    \ = 0;\n    let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5\
    \ = 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut longest_postfix_index44 = 0;\n    let mut \n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpu_066mlg.rs:60:1\n\
    \   |\n60 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_postfix = string;\n\
    \    let mut longest_postfix_len = string.len();\n\n    while longest_postfix_len\
    \ > 0 {\n        let mut postfix = reversed_string.clone();\n        let mut postfix_len\
    \ = longest_postfix_len;\n\n        while postfix_len > 0 {\n            let mut\
    \ c = postfix[postfix_len - 1];\n            postfix_len -= 1;\n            postfix.push(c);\n\
    \        }\n\n        if longest_postfix_len < postfix.len() {\n            longest_postfix\
    \ = postfix.clone();\n            longest_postfix_len = postfix.len();\n     \
    \   }\n    }\n\n    longest_postfix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpfu0e5vtz.rs:21:25\n\
    \   |\n21 |             let mut c = postfix[postfix_len - 1];\n   |          \
    \               ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut prefix_length = 0;\n    let\
    \ mut suffix_length = 0;\n    let mut suffix_start = 0;\n    let mut suffix_end\
    \ = 0;\n    while suffix_end < string.len() {\n        let mut suffix_length =\
    \ string.len() - suffix_end;\n        let mut suffix_start = suffix_end;\n   \
    \     let mut suffix_end = suffix_start + suffix_length;\n        while suffix_start\
    \ > 0 && suffix_end < string.len() {\n            let mut suffix_length = string.len()\
    \ - suffix_end;\n            let mut suffix_start = suffix_end;\n            let\
    \ mut suffix_end = suffix_start + suffix_length;\n            if suffix_start\
    \ > suffix_end {\n                suffix_length = suffix_end - suffix_start;\n\
    \                suffix_start = suffix_end;\n            }\n            if suffix_start\
    \ == suffix_end {\n                suffix_length = 0;\n            }\n       \
    \     if suffix_start < suffix_end {\n                let mut prefix_length =\
    \ suffix_end - suffix_start;\n                let mut prefix_start = suffix_start;\n\
    \                let mut prefix_end = suffix_start + prefix_length;\n        \
    \        while prefix_start > 0 && prefix_end < string.len() {\n             \
    \       let mut prefix_length = string.len() - prefix_end;\n                 \
    \   let mut prefix_start = prefix_end;\n                    let mut prefix_end\
    \ = prefix_start + prefix_length;\n                    if prefix_start > prefix_end\
    \ {\n                        prefix_length = prefix_end - prefix_start;\n    \
    \                    prefix_start = prefix_end;\n                    }\n     \
    \               if prefix_start == prefix_end {\n                        prefix_length\
    \ = 0;\n                    }\n                    if prefix_start < prefix_end\
    \ {\n                        break;\n                    }\n                }\n\
    \                if prefix_start == prefix_end {\n                    prefix_length\
    \ = 0;\n                }\n                if prefix_start < prefix_end {\n  \
    \                  suffix_length -= prefix_length;\n                    suffix_start\
    \ = prefix_start;\n                    suffix_end = prefix_end;\n            \
    \    }\n            }\n        }\n        if suffix_start == suffix_end {\n  \
    \          suffix_length = 0;\n        }\n        if suffix_start < suffix_end\
    \ {\n            break;\n        }\n    }\n    if suffix_start == suffix_end {\n\
    \        suffix_length = 0;\n    }\n    if suffix_start < suffix_end {\n     \
    \   reversed_string = reversed_string[..suffix_start].to_string();\n    }\n  \
    \  reversed_string += &string[suffix_start..suffix_end];\n    reversed_string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `prefix_length`\n  --> /tmp/tmp0563jhd2.rs:13:13\n\
    \   |\n13 |     let mut prefix_length = 0;\n   |             ^^^^^^^^^^^^^ help:\
    \ if this is intentional, prefix it with an underscore: `_prefix_length`\n   |\n\
    \   = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable `suffix_length`\
    \ is assigned to, but never used\n  --> /tmp/tmp0563jhd2.rs:14:13\n   |\n14 |\
    \     let mut suffix_length = 0;\n   |             ^^^^^^^^^^^^^\n   |\n   = note:\
    \ consider using `_suffix_length` instead\n\nwarning: value assigned to `prefix_length`\
    \ is never read\n  --> /tmp/tmp0563jhd2.rs:41:25\n   |\n41 |                 \
    \        prefix_length = prefix_end - prefix_start;\n   |                    \
    \     ^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_assignments)]` on by default\n\
    \   = help: maybe it is overwritten before being read?\n\nwarning: value assigned\
    \ to `prefix_length` is never read\n  --> /tmp/tmp0563jhd2.rs:45:25\n   |\n45\
    \ |                         prefix_length = 0;\n   |                         ^^^^^^^^^^^^^\n\
    \   |\n   = help: maybe it is overwritten before being read?\n\nwarning: value\
    \ assigned to `suffix_length` is never read\n  --> /tmp/tmp0563jhd2.rs:55:21\n\
    \   |\n55 |                     suffix_length -= prefix_length;\n   |        \
    \             ^^^^^^^^^^^^^\n   |\n   = help: maybe it is overwritten before being\
    \ read?\n\nwarning: value assigned to `suffix_start` is never read\n  --> /tmp/tmp0563jhd2.rs:56:21\n\
    \   |\n56 |                     suffix_start = prefix_start;\n   |           \
    \          ^^^^^^^^^^^^\n   |\n   = help: maybe it is overwritten before being\
    \ read?\n\nwarning: value assigned to `suffix_end` is never read\n  --> /tmp/tmp0563jhd2.rs:57:21\n\
    \   |\n57 |                     suffix_end = prefix_end;\n   |               \
    \      ^^^^^^^^^^\n   |\n   = help: maybe it is overwritten before being read?\n\
    \nwarning: value assigned to `suffix_length` is never read\n  --> /tmp/tmp0563jhd2.rs:62:13\n\
    \   |\n62 |             suffix_length = 0;\n   |             ^^^^^^^^^^^^^\n \
    \  |\n   = help: maybe it is overwritten before being read?\n\nwarning: value\
    \ ass"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reverse = string;\n    let mut prefix:\
    \ String = string;\n    let mut suffix: String = string;\n    let mut longest_postfix\
    \ = string;\n    let mut longest_postfix_len = 0;\n    let mut longest_postfix_suffix:\
    \ String = string;\n    let mut longest_postfix_suffix_len = 0;\n    let mut longest_postfix_suffix_reverse:\
    \ String = string;\n    let mut longest_postfix_suffix_reverse_len = 0;\n    let\
    \ mut longest_postfix_suffix_reverse_reverse: String = string;\n    let mut longest_postfix_suffix_reverse_reverse_len\
    \ = 0;\n    let mut longest_postfix_suffix_reverse_reverse_suffix: String = string;\n\
    \    let mut longest_postfix_suffix_reverse_reverse_suffix_len = 0;\n    let mut\
    \ longest_postfix_suffix_reverse_reverse_suffix_reverse: String = string;\n  \
    \  let mut longest_postfix_suffix_reverse_reverse_suffix_reverse_len = 0;\n  \
    \  let mut longest_postfix_suffix_reverse_reverse_suffix_reverse_reverse: String\
    \ = string;\n    let mut longest_postfix_suffix_reverse_reverse_suffix_reverse_reverse_len\
    \ = 0;\n    let mut longest_postfix_suffix_reverse_reverse_suffix_reverse_reverse_suffix:\
    \ String = string;\n    let mut longest_postfix_suffix_reverse_reverse_suffix_reverse_reverse_suffix_len\
    \ = 0;\n    let mut longest_postfix_suffix_reverse_reverse_suffix_reverse_reverse_suffix_reverse:\
    \ String = string;\n    let mut longest_postfix_suffix_reverse_reverse_suffix_reverse_reverse_suffix_reverse_len\
    \ = 0;\n    let mut longest_postfix_suffix_reverse_reverse_suffix_reverse_reverse_suffix_reverse_reverse:\
    \ String = string;\n    let mut longest_postfix_suffix_reverse_reverse_suffix_reverse_reverse_suffix_reverse_reverse_len\
    \ = 0;\n    let mut longest_postfix_suffix_reverse_reverse_suffix_reverse_reverse_suffix_reverse_reverse_suffix:\
    \ String = string;\n    let mut longest_postfix_suffix_reverse_reverse_suffix_reverse_reverse_suffix_reverse_reverse_suffix_len\
    \ = 0;\n    let mut longest_postfix_suffix_reverse_reverse_suffix_reverse_reverse_suffix_reverse_reverse_suffix_reverse:\
    \ String = string;\n    let mut longest_postfix_suffix_reverse_reverse_suffix_reverse_reverse_suffix_reverse_reverse_suffix_reverse_reverse_len\
    \ = 0;\n    let mut longest_postfix_suffix_reverse_reverse_suffix_\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpfj4cp55k.rs:40:59\n   |\n\
    40 |     let mut longest_postfix_suffix_reverse_reverse_suffix_\n   |        \
    \                                                   ^ help: add `;` here\n41 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfj4cp55k.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reverse = string;\n    let mut longest\
    \ = 0;\n    while !string.is_empty() {\n        let mut i = 0;\n        while\
    \ i < string.len() {\n            if string[i] != string[string.len() - 1 - i]\
    \ {\n                break;\n            }\n            i += 1;\n        }\n \
    \       if i == 0 {\n            break;\n        }\n        let mut j = i;\n \
    \       while j > 0 {\n            if string[j] != string[string.len() - 1 - j]\
    \ {\n                break;\n            }\n            j -= 1;\n        }\n \
    \       if j == 0 {\n            break;\n        }\n        if j > i {\n     \
    \       longest = i;\n            reverse.push_str(&string[i..j]);\n        }\n\
    \        i += 1;\n        j -= 1;\n    }\n    reverse.push_str(&string[longest..]);\n\
    \    reverse\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp07dhirns.rs:18:16\n\
    \   |\n18 |             if string[i] != string[string.len() - 1 - i] {\n   | \
    \               ^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmp07dhirns.rs:18:29\n\
    \   |\n18 |             if string[i] != string[string.len() - 1 - i] {\n   | \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n \
    \ --> /tmp/tmp07dhirns.rs:28:16\n   |\n28 |             if string[j] != string[string.len()\
    \ - 1 - j] {\n   |                ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp07dhirns.rs:28:29\n\
    \   |\n28 |             if string[j] != string[string.len() - 1 - j] {\n   | \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut reverse_length = 0;\n    let\
    \ mut longest_postfix_length = 0;\n    let mut longest_postfix_start = -1;\n \
    \   let mut longest_postfix_end = -1;\n    let mut longest_postfix_postfix = \"\
    \";\n    let mut longest_postfix_postfix_length = 0;\n    let mut longest_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_length = 0;\n    let mut longest_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_length = 0;\n    let mut longest_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_length = 0;\n    let mut longest_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_length = 0;\n    let mut longest_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_length = 0;\n    let mut longest_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_length = 0;\n    let mut longest_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_length = 0;\n    let mut longest_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_length = 0;\n    let mut longest_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp40id6jgx.rs:54:21\n   |\n\
    54 |     let mut longest_\n   |                     ^ help: add `;` here\n55 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp40id6jgx.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ i = 0;\n    while i < string.len() {\n        let mut j = i;\n        while\
    \ j < string.len() {\n            if string[j] != string[i] {\n              \
    \  break;\n            }\n            i += 1;\n            j += 1;\n        }\n\
    \        reversed_string.push((string[..j]).rev());\n        i = j;\n    }\n \
    \   string.push((reversed_string).rev());\n    string\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpvk42_n1e.rs:18:16\n\
    \   |\n18 |             if string[j] != string[i] {\n   |                ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpvk42_n1e.rs:18:29\n   |\n18 |            \
    \ if string[j] != string[i] {\n   |                             ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0599]: no method named `push` found for reference\
    \ `&str` in the current scope\n  --> /tmp/tmpvk42_n1e.rs:24:25\n   |\n24 |   \
    \      reversed_string.push((string[..j]).rev());\n   |                      \
    \   ^^^^ method not found in `&str`\n\nerror[E0599]: the method `rev` exists for\
    \ type `str`, but its trait bounds were not satisfied\n  --> /tmp/tmpvk42_n1e.rs:24:44\n\
    \   |\n24 |         reversed_string.push((string[..j]).rev());\n   |         \
    \                                   ^^^ method cannot be called on `str` due to\
    \ unsatisfied trait bounds\n   |\n   = note: the following trait bounds were not\
    \ satisfied:\n           `str: Iterator`\n           which is required by `&mut\
    \ str: Iterator`\n\nerror[E0599]: the method `rev` exists for reference `&str`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmpvk42_n1e.rs:27:35\n \
    \  |\n27 |     string.push((reversed_string).rev());\n   |                   \
    \                ^^^ method cannot be called on `&str` due to unsatisfied trait\
    \ bounds\n   |\n   = note: the following trait bounds were not satisfied:\n  \
    \         `&str: Iterator`\n           which is required by `&mut &str: Iterator`\n\
    \           `str: Iterator`\n           which is required by `&mut str: Iterator`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_postfix_length = 0;\n\
    \    for pos in string.rfind('a') {\n        if pos == 0 {\n            break;\n\
    \        }\n        let mut current_length = pos - 1;\n        while current_length\
    \ >= 0 && reversed_string[current_length] != string[pos] {\n            current_length\
    \ -= 1;\n        }\n        if current_length < longest_postfix_length {\n   \
    \         longest_postfix_length = current_length;\n        }\n    }\n    let\
    \ mut reversed_string = string;\n    let mut longest_postfix_length = 0;\n   \
    \ for pos in string.rfind('a') {\n        if pos == 0 {\n            break;\n\
    \        }\n        let mut current_length = pos - 1;\n        while current_length\
    \ >= 0 && reversed_string[current_length] != string[pos] {\n            current_length\
    \ -= 1;\n        }\n        if current_length < longest_postfix_length {\n   \
    \         longest_postfix_length = current_length;\n        }\n    }\n    let\
    \ mut reversed_string = string;\n    let mut longest_postfix_length = 0;\n   \
    \ for pos in string.rfind('a') {\n        if pos == 0 {\n            break;\n\
    \        }\n        let mut current_length = pos - 1;\n        while current_length\
    \ >= 0 && reversed_string[current_length] != string[pos] {\n            current_length\
    \ -= 1;\n        }\n        if current_length < longest_postfix_length {\n   \
    \         longest_postfix_length = current_length;\n        }\n    }\n    let\
    \ mut reversed_string = string;\n    let mut longest_postfix_length = 0;\n   \
    \ for pos in string.rfind('a') {\n        if pos == 0 {\n            break;\n\
    \        }\n        let mut current_length = pos - 1;\n        while current_length\
    \ >= 0 && reversed_string[current_length] != string[pos] {\n            current_length\
    \ -= 1;\n        }\n        if current_length < longest_postfix_length {\n   \
    \         longest_postfix_length = current_length;\n        }\n    }\n    let\
    \ mut reversed_string = string;\n    let mut longest_postfix_length = 0;\n   \
    \ for pos in string.rfind('a') {\n        if pos == 0 {\n            break;\n\
    \        }\n        let mut current_length = pos - 1;\n        while current_length\
    \ >= 0 && reversed_string[current_length] != string[pos] {\n            current_length\
    \ -= 1;\n        }\n        if current_length < longest_postfix_length {\n   \
    \         longest_postfix_length = current_length;\n        }\n    }\n    let\
    \ mut reversed_string = string;\n    let mut longest_postfix_length = 0;\n   \
    \ for pos in string.rfind('a') {\n        if pos == 0 {\n            break;\n\
    \        }\n        let mut current_length = pos - 1;\n        while current_\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpoekg0bhw.rs:99:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n84 |     for pos\
    \ in string.rfind('a') {\n   |                                  - this delimiter\
    \ might not be properly closed...\n...\n90 | }\n   | - ...as it matches this but\
    \ it has different indentation\n...\n99 | }\n   |   ^\n\nerror: expected `{`,\
    \ found `}`\n  --> /tmp/tmpoekg0bhw.rs:90:1\n   |\n90 | }\n   | ^ expected `{`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpoekg0bhw.rs:19:38\n\
    \   |\n19 |         while current_length >= 0 && reversed_string[current_length]\
    \ != string[pos] {\n   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpoekg0bhw.rs:19:73\n   |\n19 |         while\
    \ current_length >= 0 && reversed_string[current_length] != string[pos] {\n  \
    \ |                                                                         ^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpoekg0bhw.rs:33:38\n   |\n33 |         while\
    \ current_length >= 0 && reversed_string[current_length] != string[pos] {\n  \
    \ |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpoekg0bhw.rs:33:73\n   |\n33 |         while current_length\
    \ >= 0 && reversed_string[current_length] != string[pos] {\n   |             \
    \                                                            ^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = string;\n    let\
    \ mut reversed_string_size = string.len();\n    let mut palindrome = string;\n\
    \    let mut palindrome_size = string.len();\n    while palindrome_size != 0 {\n\
    \        let mut i = 0;\n        let mut j = 0;\n        while i < palindrome_size\
    \ && j < reversed_string_size {\n            if palindrome[i] == reversed_string[j]\
    \ {\n                i += 1;\n                j += 1;\n            } else {\n\
    \                break;\n            }\n        }\n        if i == palindrome_size\
    \ {\n            palindrome += &reversed_string[j..];\n            palindrome_size\
    \ -= 1;\n        }\n        if j == reversed_string_size {\n            reversed_string\
    \ += &palindrome[i..];\n            reversed_string_size -= 1;\n        }\n  \
    \  }\n    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpbfbvugk8.rs:21:16\n\
    \   |\n21 |             if palindrome[i] == reversed_string[j] {\n   |       \
    \         ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmpbfbvugk8.rs:21:33\n\
    \   |\n21 |             if palindrome[i] == reversed_string[j] {\n   |       \
    \                          ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_index = 0;\n    let mut longest_postfix_length = 0;\n    while\
    \ !string.is_empty() {\n        let mut postfix_index = 0;\n        while postfix_index\
    \ < longest_postfix_index {\n            if string[postfix_index] != string[longest_postfix_index]\
    \ {\n                break;\n            }\n            postfix_index += 1;\n\
    \        }\n        if postfix_index == longest_postfix_index {\n            longest_postfix_length\
    \ += 1;\n            longest_postfix_index += 1;\n        }\n        let mut postfix_length\
    \ = longest_postfix_length;\n        while postfix_length >= 2 {\n           \
    \ let mut postfix_index = 0;\n            while postfix_index < postfix_length\
    \ {\n                if string[postfix_index] != string[postfix_length - postfix_index]\
    \ {\n                    break;\n                }\n                postfix_index\
    \ += 1;\n            }\n            if postfix_index == postfix_length {\n   \
    \             postfix_length -= 1;\n            } else {\n                break;\n\
    \            }\n        }\n        reversed_string += &string[longest_postfix_index..postfix_index];\n\
    \        string = &string[postfix_index..];\n    }\n    reversed_string\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmp9wf3xvj1.rs:19:16\n   |\n19 |             if string[postfix_index] !=\
    \ string[longest_postfix_index] {\n   |                ^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `{integer}`\n  --> /tmp/tmp9wf3xvj1.rs:19:41\n   |\n19 |        \
    \     if string[postfix_index] != string[longest_postfix_index] {\n   |      \
    \                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `{integer}`\n  --> /tmp/tmp9wf3xvj1.rs:32:20\n   |\n32 |                \
    \ if string[postfix_index] != string[postfix_length - postfix_index] {\n   | \
    \                   ^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp9wf3xvj1.rs:32:45\n\
    \   |\n32 |                 if string[postfix_index] != string[postfix_length\
    \ - postfix_index] {\n   |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `&str`\n  --> /tmp/tmp9wf3xvj1.rs:43:9\n   |\n\
    43 |         reversed_string += &string[longest_postfix_index..postfix_index];\n\
    \   |         ---------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |         |\n   |         cannot use `+=` on type `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9wf3xvj1.rs:44:18\n   |\n44 |         string\
    \ = &string[postfix_index..];\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    let\
    \ mut longest_postfix_index2 = 0;\n    let mut longest_postfix_index3 = 0;\n \
    \   let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5 =\
    \ 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut longest_postfix_index44 = 0;\n    let mut longest_postfix_index45\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp3v9v9aes.rs:59:36\n   |\n\
    59 |     let mut longest_postfix_index45\n   |                               \
    \     ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3v9v9aes.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut palindrome = string;\n    let mut reversed_string = \"\";\n\n   \
    \ while palindrome.len() > 0 {\n        let mut index = palindrome.len() - 1;\n\
    \        let mut char = String::new();\n\n        while index >= 0 {\n       \
    \     char = char.to_string() + palindrome[index];\n            index -= 1;\n\
    \        }\n\n        reversed_string += char;\n        palindrome = reversed_string;\n\
    \        reversed_string = \"\";\n    }\n\n    palindrome\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpn12zwcsz.rs:20:39\n\
    \   |\n20 |             char = char.to_string() + palindrome[index];\n   |   \
    \                                    ^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `&str`\n  --> /tmp/tmpn12zwcsz.rs:24:9\n   |\n24 |         reversed_string\
    \ += char;\n   |         ---------------^--^^^^^\n   |         |             \
    \  |\n   |         |               `+` cannot be used to concatenate a `&str`\
    \ with a `String`\n   |         cannot use `+=` on type `&str`\n   |\n   = help:\
    \ `to_owned()` can be used to create an owned `String` from a string reference.\
    \ String concatenation appends the string on the right to the string on the left\
    \ and may require reallocation. This requires ownership of the string on the left\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpn12zwcsz.rs:25:22\n   |\n25 |\
    \         palindrome = reversed_string;\n   |                      ^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \    |\n   |                      expected struct `String`, found `&str`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0368.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut prefix_length = 0;\n    let\
    \ mut suffix_length = 0;\n    while suffix_length < string.len() {\n        let\
    \ mut suffix_start = suffix_length;\n        let mut suffix_end = suffix_length;\n\
    \        while suffix_start < string.len() && suffix_end < string.len() {\n  \
    \          if string[suffix_end - 1] != string[suffix_start] {\n             \
    \   break;\n            }\n            suffix_end += 1;\n        }\n        let\
    \ mut prefix_start = prefix_length;\n        let mut prefix_end = prefix_length;\n\
    \        while prefix_start < suffix_start && prefix_end < suffix_end {\n    \
    \        if string[prefix_end - 1] != string[prefix_start] {\n               \
    \ break;\n            }\n            prefix_end += 1;\n        }\n        if suffix_start\
    \ == suffix_end {\n            break;\n        }\n        reversed_string = string\n\
    \            .chars()\n            .skip(suffix_start)\n            .take(suffix_end\
    \ - suffix_start)\n            .join(\"\").to_string();\n        suffix_length\
    \ = suffix_end - suffix_start + 1;\n        prefix_length = prefix_end - prefix_start\
    \ + 1;\n    }\n    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp892ygjy9.rs:19:16\n\
    \   |\n19 |             if string[suffix_end - 1] != string[suffix_start] {\n\
    \   |                ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp892ygjy9.rs:19:42\n\
    \   |\n19 |             if string[suffix_end - 1] != string[suffix_start] {\n\
    \   |                                          ^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp892ygjy9.rs:27:16\n   |\n27 |             if string[prefix_end\
    \ - 1] != string[prefix_start] {\n   |                ^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmp892ygjy9.rs:27:42\n   |\n27 |             if string[prefix_end\
    \ - 1] != string[prefix_start] {\n   |                                       \
    \   ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0599]: no\
    \ method named `join` found for struct `std::iter::Take` in the current scope\n\
    \  --> /tmp/tmp892ygjy9.rs:39:14\n   |\n39 |             .join(\"\").to_string();\n\
    \   |              ^^^^ method not found in `std::iter::Take<Skip<Chars<'_>>>`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed = string;\n    let mut prefix = string;\n    let mut suffix_length\
    \ = 0;\n    while !reversed.is_empty() {\n        let mut suffix_length = suffix_length\
    \ + 1;\n        if suffix_length > reversed.len() {\n            suffix_length\
    \ = reversed.len();\n        }\n        let mut suffix_char = reversed[suffix_length\
    \ - 1];\n        for _ in 0..suffix_length {\n            suffix_char = suffix_char.chars().next().unwrap();\n\
    \        }\n        if suffix_char == &suffix_char {\n            suffix_length\
    \ -= 1;\n        }\n        if suffix_length == 0 {\n            break;\n    \
    \    }\n        prefix.push_str(&suffix_char);\n        reversed.pop();\n    }\n\
    \    prefix.push_str(&suffix_char);\n    prefix\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `suffix_char` in this scope\n  --> /tmp/tmppky6ibtx.rs:33:22\n\
    \   |\n33 |     prefix.push_str(&suffix_char);\n   |                      ^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmppky6ibtx.rs:20:31\n   |\n20 |         let mut suffix_char\
    \ = reversed[suffix_length - 1];\n   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut prefix_length = 0;\n    while\
    \ !reversed_string.starts_with(string) {\n        reversed_string = reversed_string[..prefix_length];\n\
    \        prefix_length += 1;\n    }\n    let mut suffix_length = 0;\n    while\
    \ !reversed_string.ends_with(string) {\n        reversed_string = reversed_string[..suffix_length];\n\
    \        suffix_length += 1;\n    }\n    reversed_string += &string[prefix_length..suffix_length];\n\
    \    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n  -->\
    \ /tmp/tmpz7zy4to1.rs:14:40\n   |\n14 |     while !reversed_string.starts_with(string)\
    \ {\n   |                                        ^^^^^^\n   |                \
    \                        |\n   |                                        expected\
    \ an implementor of trait `Pattern<'_>`\n   |                                \
    \        help: consider borrowing here: `&string`\n   |\n   = note: the trait\
    \ bound `String: Pattern<'_>` is not satisfied\n   = note: required because of\
    \ the requirements on the impl of `Pattern<'_>` for `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpz7zy4to1.rs:15:27\n   |\n15 |         reversed_string\
    \ = reversed_string[..prefix_length];\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \         |\n   |                           expected struct `String`, found `str`\n\
    \nerror[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n  --> /tmp/tmpz7zy4to1.rs:19:38\n\
    \   |\n19 |     while !reversed_string.ends_with(string) {\n   |             \
    \                         ^^^^^^\n   |                                      |\n\
    \   |                                      expected an implementor of trait `Pattern<'_>`\n\
    \   |                                      help: consider borrowing here: `&string`\n\
    \   |\n   = note: the trait bound `String: Pattern<'_>` is not satisfied\n   =\
    \ note: required because of the requirements on the impl of `Pattern<'_>` for\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz7zy4to1.rs:20:27\n\
    \   |\n20 |         reversed_string = reversed_string[..suffix_length];\n   |\
    \                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                           |\n   |\
    \                           expected struct `String`, found `str`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reverse = string;\n    let mut suffix\
    \ = 0;\n    while let Some(pos) = string.rfind('a', 0) {\n        reverse.push_str(&string[..pos]);\n\
    \        suffix += pos - 1;\n        string = &string[pos + 1..];\n    }\n   \
    \ reverse.push_str(&string[..suffix]);\n    reverse\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpgzl4cn4w.rs:15:34\n     |\n15   |     while let Some(pos) = string.rfind('a',\
    \ 0) {\n     |                                  ^^^^^ ---  - supplied 2 arguments\n\
    \     |                                  |\n     |                           \
    \       expected 1 argument\n     |\nnote: associated function defined here\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpgzl4cn4w.rs:18:18\n   |\n18 |  \
    \       string = &string[pos + 1..];\n   |                  ^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n18 |         string = (&string[pos + 1..]).to_string();\n   |         \
    \         +                  +++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    let\
    \ mut longest_postfix_index2 = 0;\n    let mut longest_postfix_index3 = 0;\n \
    \   let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5 =\
    \ 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut longest_postfix_index44 = 0;\n    let mut longest_postfix_index45\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp3v9v9aes.rs:59:36\n   |\n\
    59 |     let mut longest_postfix_index45\n   |                               \
    \     ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3v9v9aes.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut postfix = string;\n    let\
    \ mut prefix_len = 0;\n    while !postfix.is_empty() {\n        let mut postfix_len\
    \ = postfix.len();\n        let mut i = 0;\n        while i < postfix_len {\n\
    \            if postfix[i] != reversed_string[prefix_len + i] {\n            \
    \    break;\n            }\n            i += 1;\n        }\n        if i == postfix_len\
    \ {\n            break;\n        }\n        postfix.truncate(i);\n        prefix_len\
    \ += i;\n    }\n    reversed_string.push_str(&postfix);\n    reversed_string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpijup2o7i.rs:19:16\n\
    \   |\n19 |             if postfix[i] != reversed_string[prefix_len + i] {\n \
    \  |                ^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpijup2o7i.rs:19:30\n\
    \   |\n19 |             if postfix[i] != reversed_string[prefix_len + i] {\n \
    \  |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    while !string.is_empty() {\n        let mut\
    \ postfix_length = 0;\n        for ch in string.chars() {\n            if ch !=\
    \ string[postfix_length] {\n                break;\n            }\n          \
    \  postfix_length += 1;\n        }\n        if postfix_length > longest_postfix_length\
    \ {\n            longest_postfix_length = postfix_length;\n        }\n       \
    \ string = &string[postfix_length..];\n        reversed_string += &string[..postfix_length];\n\
    \    }\n    string += &reversed_string[..longest_postfix_length];\n    string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmplyqf2lkx.rs:18:22\n   |\n18 |             if ch != string[postfix_length]\
    \ {\n   |                      ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplyqf2lkx.rs:26:18\n\
    \   |\n26 |         string = &string[postfix_length..];\n   |                \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n   |\nhelp:\
    \ try using a conversion method\n   |\n26 |         string = (&string[postfix_length..]).to_string();\n\
    \   |                  +                         +++++++++++++\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmplyqf2lkx.rs:27:9\n\
    \   |\n27 |         reversed_string += &string[..postfix_length];\n   |      \
    \   ---------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |         |\n   |       \
    \  cannot use `+=` on type `&str`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reverse = string;\n    let mut i =\
    \ 0;\n    while i < string.len() {\n        let mut j = i;\n        while j +\
    \ 1 < string.len() && string[j] == string[j + 1] {\n            j += 1\n     \
    \   }\n        if j - i > 1 {\n            reverse.push_str(&string[i..j]);\n\
    \            i += j - i;\n        }\n    }\n    reverse\n}\n\nfn main() {\n  \
    \  let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpp7yb4ja2.rs:17:39\n\
    \   |\n17 |         while j + 1 < string.len() && string[j] == string[j + 1] {\n\
    \   |                                       ^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n \
    \ --> /tmp/tmpp7yb4ja2.rs:17:52\n   |\n17 |         while j + 1 < string.len()\
    \ && string[j] == string[j + 1] {\n   |                                      \
    \              ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    let\
    \ mut longest_postfix_length_index = 0;\n    let mut longest_postfix_string =\
    \ \"\";\n    let mut longest_postfix_string_index = 0;\n    let mut longest_postfix_string_length\
    \ = 0;\n    let mut longest_postfix_string_length_index = 0;\n    let mut longest_postfix_string_length_string\
    \ = \"\";\n    let mut longest_postfix_string_length_string_index = 0;\n    let\
    \ mut longest_postfix_string_length_string_length = 0;\n    let mut longest_postfix_string_length_string_length_index\
    \ = 0;\n    let mut longest_postfix_string_length_string_length_string = \"\"\
    ;\n    let mut longest_postfix_string_length_string_length_string_index = 0;\n\
    \    let mut longest_postfix_string_length_string_length_string_length = 0;\n\
    \    let mut longest_postfix_string_length_string_length_string_length_index =\
    \ 0;\n    let mut longest_postfix_string_length_string_length_string_length_string\
    \ = \"\";\n    let mut longest_postfix_string_length_string_length_string_length_string_index\
    \ = 0;\n    let mut longest_postfix_string_length_string_length_string_length_string_length\
    \ = 0;\n    let mut longest_postfix_string_length_string_length_string_length_string_length_index\
    \ = 0;\n    let mut longest_postfix_string_length_string_length_string_length_string_length_string\
    \ = \"\";\n    let mut longest_postfix_string_length_string_length_string_length_string_length_string_index\
    \ = 0;\n    let mut longest_postfix_string_length_string_length_string_length_string_length_string_length\
    \ = 0;\n    let mut longest_postfix_string_length_string_length_string_length_string_length_string_length_index\
    \ = 0;\n    let mut longest_postfix_string_length_string_length_string_length_string_length_string_length_string\
    \ = \"\";\n    let mut longest_postfix_string_length_string_length_string_length_string_length_string_length_string_index\
    \ = 0;\n    let mut longest_postfix_string_length_string_length_string_length_string_length_string_length_string_length\
    \ = 0;\n    let mut longest_postfix_string_length_string_length_string_length_string_length_string_length_string_length_index\
    \ = 0;\n    let mut longest_postfix_string_length_string_length_string_length_string_length_string_length_string_length_string\
    \ = \"\";\n    let mut longest_postfix_string_length_string_length_string_length_string_length_string_length_string_length_string_index\
    \ = 0;\n    let mut longest_postfix_string_length_string_length_string_length_string_length_string_length_string_length_string_length\
    \ = 0;\n    let mut longest_postfix_string_length_string_length_string_length_string_length\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_1dn0utu.rs:44:84\n   |\n\
    44 |     let mut longest_postfix_string_length_string_length_string_length_string_length\n\
    \   |                                                                        \
    \            ^ help: add `;` here\n45 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_1dn0utu.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    let\
    \ mut longest_postfix_index2 = 0;\n    let mut longest_postfix_index3 = 0;\n \
    \   let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5 =\
    \ 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut longest_postfix_index44 = 0;\n    let mut longest_postfix_index45\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp3v9v9aes.rs:59:36\n   |\n\
    59 |     let mut longest_postfix_index45\n   |                               \
    \     ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3v9v9aes.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reverse = string;\n    let mut prefix;\n\
    \    let mut suffix;\n    while !string.is_empty() {\n        prefix = &string[0..string.len()\
    \ - 1];\n        suffix = &string[string.len() - 1..string.len()];\n        if\
    \ suffix.iter().cloned().rev().collect::<String>().is_equal(&prefix) {\n     \
    \       string = &string[1..string.len() - 1];\n        } else {\n           \
    \ string = &string[1..string.len() - 1];\n            reverse = &reverse[..reverse.len()\
    \ - 1];\n        }\n    }\n    string + reverse\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for reference `&str` in the\
    \ current scope\n  --> /tmp/tmpbw7syok3.rs:19:19\n   |\n19 |         if suffix.iter().cloned().rev().collect::<String>().is_equal(&prefix)\
    \ {\n   |                   ^^^^ method not found in `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbw7syok3.rs:20:22\n   |\n20 |             string = &string[1..string.len()\
    \ - 1];\n   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found `&str`\n   |\nhelp: try using a conversion method\n   |\n20\
    \ |             string = (&string[1..string.len() - 1]).to_string();\n   |   \
    \                   +                            +++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbw7syok3.rs:22:22\n   |\n22 |             string\
    \ = &string[1..string.len() - 1];\n   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n22 |             string = (&string[1..string.len() - 1]).to_string();\n\
    \   |                      +                            +++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbw7syok3.rs:23:23\n   |\n23 |             reverse\
    \ = &reverse[..reverse.len() - 1];\n   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n23 |             reverse = (&reverse[..reverse.len() - 1]).to_string();\n\
    \   |                       +                             +++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbw7syok3.rs:26:14\n   |\n26 |     string + reverse\n\
    \   |              ^^^^^^^\n   |              |\n   |              expected `&str`,\
    \ found struct `String`\n   |              help: consider borrowing here: `&reverse`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_postfix_length = 0;\n\
    \    let mut longest_postfix_start = -1;\n    for pos in string.char_indices()\
    \ {\n        let mut postfix_length = pos;\n        let mut postfix_start = pos;\n\
    \        while postfix_start < longest_postfix_length && postfix_start < string.len()\
    \ {\n            let c = string[postfix_start];\n            if c != string[postfix_start\
    \ - 1] {\n                postfix_length += 1;\n            }\n            postfix_start\
    \ += 1;\n        }\n        if postfix_length > longest_postfix_length {\n   \
    \         longest_postfix_length = postfix_length;\n            longest_postfix_start\
    \ = postfix_start;\n        }\n    }\n    if longest_postfix_start == -1 {\n \
    \       return string;\n    }\n    let mut postfix_start = longest_postfix_start;\n\
    \    let mut postfix_length = longest_postfix_length;\n    while postfix_start\
    \ < string.len() {\n        let c = string[postfix_start];\n        if c != string[postfix_start\
    \ - 1] {\n            postfix_length += 1;\n        }\n        postfix_start +=\
    \ 1;\n    }\n    let mut postfix_end = postfix_start + postfix_length;\n    while\
    \ postfix_end > 0 && string[postfix_end - 1] == string[postfix_end] {\n      \
    \  postfix_end -= 1;\n    }\n    let mut postfix_start = postfix_end - 1;\n  \
    \  let mut postfix_length = longest_postfix_length;\n    while postfix_start >\
    \ 0 && string[postfix_start - 1] == string[postfix_start] {\n        postfix_start\
    \ -= 1;\n    }\n    let mut postfix_end = postfix_start + postfix_length;\n  \
    \  while postfix_end > 0 && string[postfix_end - 1] == string[postfix_end] {\n\
    \        postfix_end -= 1;\n    }\n    let mut postfix_start = postfix_end - 1;\n\
    \    let mut postfix_length = longest_postfix_length;\n    while postfix_start\
    \ > 0 && string[postfix_start - 1] == string[postfix_start] {\n        postfix_start\
    \ -= 1;\n    }\n    let mut postfix_end = postfix_start + postfix_length;\n  \
    \  while postfix_end > 0 && string[postfix_end - 1] == string[postfix_end] {\n\
    \        postfix_end -= 1;\n    }\n    let mut postfix_start = postfix_end - 1;\n\
    \    let mut postfix_length = longest_postfix_length;\n    while postfix_start\
    \ > 0 && string[postfix_start - 1] == string[postfix_start] {\n        postfix_\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpp_akjvbe.rs:77:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n66 |     while postfix_start\
    \ > 0 && string[postfix_start - 1] == string[postfix_start] {\n   |          \
    \                                                                         - this\
    \ delimiter might not be properly closed...\n67 |         postfix_\n68 | }\n \
    \  | - ...as it matches this but it has different indentation\n...\n77 | }\n \
    \  |   ^\n\nerror[E0425]: cannot find value `postfix_` in this scope\n  --> /tmp/tmpp_akjvbe.rs:67:9\n\
    \   |\n67 |         postfix_\n   |         ^^^^^^^^ not found in this scope\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpp_akjvbe.rs:18:31\n   |\n18 |  \
    \       while postfix_start < longest_postfix_length && postfix_start < string.len()\
    \ {\n   |                               ^^^^^^^^^^^^^^^^^^^^^^ expected tuple,\
    \ found integer\n   |\n   = note: expected tuple `(usize, char)`\n           \
    \    found type `{integer}`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp_akjvbe.rs:18:73\n\
    \   |\n18 |         while postfix_start < longest_postfix_length && postfix_start\
    \ < string.len() {\n   |                                                     \
    \                    ^^^^^^^^^^^^ expected tuple, found `usize`\n   |\n   = note:\
    \ expected tuple `(usize, char)`\n               found type `usize`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `(usize, char)`\n  --> /tmp/tmpp_akjvbe.rs:19:21\n\
    \   |\n19 |             let c = string[postfix_start];\n   |                 \
    \    ^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `(usize, char)`\n   |\n\
    \   = help: the trait `Index<(usize, char)>` is not implemented for `String`\n\
    \nerror[E0369]: cannot subtract `{integer}` from `(usize, char)`\n  --> /tmp/tmpp_akjvbe.rs:20:42\n\
    \   |\n20 |             if c != string[postfix_start - 1] {\n   |            \
    \                ------------- ^ - {integer}\n   |                           \
    \ |\n   |                            (usize, char)\n\nerror[E0368]: binar"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut prefix_length = 0;\n    let\
    \ mut suffix_length = 0;\n    while !reversed_string.is_empty() {\n        let\
    \ mut current_char = reversed_string[0];\n        let mut current_char_length\
    \ = 1;\n        while !current_char.is_ascii_lowercase() {\n            current_char\
    \ += current_char_length;\n            current_char_length += 1;\n        }\n\
    \        if current_char_length == 1 {\n            suffix_length += 1;\n    \
    \    }\n        if suffix_length == 0 {\n            prefix_length += 1;\n   \
    \     }\n        if prefix_length == 0 {\n            break;\n        }\n    \
    \    reversed_string = reversed_string.chars().take(prefix_length).collect();\n\
    \    }\n    String::from(string.chars().skip(suffix_length).collect())\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmp6mwal47t.rs:16:32\n   |\n16 |         let mut current_char = reversed_string[0];\n\
    \   |                                ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut prefix_length = 0;\n    while\
    \ !reversed_string.is_empty() {\n        let mut suffix_length = 0;\n        while\
    \ !reversed_string.is_empty() && reversed_string[suffix_length] == reversed_string[suffix_length]\
    \ {\n            suffix_length += 1;\n        }\n        reversed_string = reversed_string[..suffix_length].to_string();\n\
    \        prefix_length += suffix_length;\n    }\n    string + &reversed_string[..prefix_length]\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpi7n5wy_6.rs:16:46\n   |\n16 |         while !reversed_string.is_empty()\
    \ && reversed_string[suffix_length] == reversed_string[suffix_length] {\n   |\
    \                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `{integer}`\n  --> /tmp/tmpi7n5wy_6.rs:16:80\n   |\n16 |        \
    \ while !reversed_string.is_empty() && reversed_string[suffix_length] == reversed_string[suffix_length]\
    \ {\n   |                                                                    \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    let\
    \ mut longest_postfix_index2 = 0;\n    let mut longest_postfix_index3 = 0;\n \
    \   let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5 =\
    \ 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut longest_postfix_index44 = 0;\n    let mut longest_postfix_index45\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp3v9v9aes.rs:59:36\n   |\n\
    59 |     let mut longest_postfix_index45\n   |                               \
    \     ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3v9v9aes.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut palindrome = string;\n    let mut reversed_string\
    \ = \"\";\n    let mut last_index = 0;\n    while !string.is_empty() {\n     \
    \   let index = string.len() - 1;\n        let char = string[index];\n       \
    \ if char == string[last_index] {\n            palindrome = &string[..last_index];\n\
    \            reversed_string = &string[last_index..];\n            break;\n  \
    \      }\n        last_index = index;\n    }\n    palindrome += &reversed_string;\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp1p5clodo.rs:18:20\n\
    \   |\n18 |         let char = string[index];\n   |                    ^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `{integer}`\n  --> /tmp/tmp1p5clodo.rs:19:20\n   |\n19 |        \
    \ if char == string[last_index] {\n   |                    ^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1p5clodo.rs:20:26\n\
    \   |\n20 |             palindrome = &string[..last_index];\n   |            \
    \              ^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n\
    \   |\nhelp: try using a conversion method\n   |\n20 |             palindrome\
    \ = (&string[..last_index]).to_string();\n   |                          +    \
    \                 +++++++++++++\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = string;\n    let\
    \ mut longest_postfix = string;\n    let mut longest_postfix_index = -1;\n   \
    \ let mut longest_postfix_length = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_post\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9dd11k9t.rs:59:25\n   |\n\
    59 |     let mut longest_post\n   |                         ^ help: add `;` here\n\
    60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9dd11k9t.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reverse = String::new();\n    let mut prefix = String::new();\n \
    \   let mut suffix = String::new();\n    let mut longest_postfix = String::new();\n\
    \    let mut longest_postfix_len = String::new();\n    let mut longest_postfix_pos\
    \ = String::new();\n    let mut longest_postfix_pos_len = String::new();\n   \
    \ let mut longest_postfix_pos_start = String::new();\n    let mut longest_postfix_pos_start_len\
    \ = String::new();\n    let mut longest_postfix_pos_end = String::new();\n   \
    \ let mut longest_postfix_pos_end_len = String::new();\n    let mut longest_postfix_pos_start_end\
    \ = String::new();\n    let mut longest_postfix_pos_start_end_len = String::new();\n\
    \    let mut longest_postfix_pos_start_end_start = String::new();\n    let mut\
    \ longest_postfix_pos_start_end_start_len = String::new();\n    let mut longest_postfix_pos_start_end_start_start_len\
    \ = String::new();\n    let mut longest_postfix_pos_start_end_start_start_start_len\
    \ = String::new();\n    let mut longest_postfix_pos_start_end_start_start_start_start_len\
    \ = String::new();\n    let mut longest_postfix_pos_start_end_start_start_start_start_len_len\
    \ = String::new();\n    let mut longest_postfix_pos_start_end_start_start_start_start_len_len_len\
    \ = String::new();\n    let mut longest_postfix_pos_start_end_start_start_start_start_len_len_len_len\
    \ = String::new();\n    let mut longest_postfix_pos_start_end_start_start_start_start_len_len_len_len_len\
    \ = String::new();\n    let mut longest_postfix_pos_start_end_start_start_start_start_len_len_len_len_len_len\
    \ = String::new();\n    let mut longest_postfix_pos_start_end_start_start_start_start_len_len_len_len_len_len_len\
    \ = String::new();\n    let mut longest_postfix_pos_start_end_start_start_start_start_len_len_len_len_len_len_len_len\
    \ = String::new();\n    let mut longest_postfix_pos_start_end_start_start_start_start_len_len_len_len_len_len_len_len_len\
    \ = String::new();\n    let mut longest_postfix_pos_start_end_start_start_start_start_len_len_len_len_len_len_len_len_len_len_len\
    \ = String::new();\n    let mut longest_postfix_pos_start_end_start_start_start_start_len_len_len_len_len_len_len_len_len_len_len_len\
    \ = \n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmprjxuiqs2.rs:40:1\n\
    \   |\n40 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reverse = string;\n    let mut prefix = string;\n    let mut suffix\
    \ = string;\n    let mut suffix_pos = 0;\n    let mut suffix_len = string.len();\n\
    \    let mut suffix_reverse = string;\n    let mut suffix_reverse_pos = 0;\n \
    \   let mut suffix_reverse_len = string.len();\n    let mut prefix_pos = 0;\n\
    \    let mut prefix_len = string.len();\n    let mut prefix_reverse = string;\n\
    \    let mut prefix_reverse_pos = 0;\n    let mut prefix_reverse_len = string.len();\n\
    \    while suffix_pos < suffix_len {\n        let mut suffix_char = suffix[suffix_pos];\n\
    \        let mut suffix_char_pos = 0;\n        while suffix_char_pos < suffix_len\
    \ {\n            suffix_char = suffix_char.chars().next().unwrap();\n        \
    \    suffix_char_pos += 1;\n        }\n        let mut suffix_char_len = suffix_char.len();\n\
    \        let mut suffix_char_pos_reverse = 0;\n        let mut suffix_char_len_reverse\
    \ = 0;\n        while suffix_char_pos_reverse < suffix_char_len {\n          \
    \  suffix_char_pos_reverse += 1;\n            suffix_char_len_reverse += 1;\n\
    \        }\n        let mut suffix_char_pos_reverse_pos = 0;\n        let mut\
    \ suffix_char_len_reverse_pos = 0;\n        while suffix_char_pos_reverse_pos\
    \ < suffix_char_len_reverse {\n            suffix_char_pos_reverse_pos += 1;\n\
    \            suffix_char_len_reverse_pos += 1;\n        }\n        let mut suffix_char_pos_reverse_reverse\
    \ = 0;\n        let mut suffix_char_len_reverse_reverse = 0;\n        while suffix_char_pos_reverse_reverse\
    \ < suffix_char_len_reverse_pos {\n            suffix_char_pos_reverse_reverse\
    \ += 1;\n            suffix_char_len_reverse_reverse += 1;\n        }\n      \
    \  let mut suffix_char_pos_reverse_reverse_pos = 0;\n        let mut suffix_char_len_reverse_reverse_pos\
    \ = 0;\n        while suffix_char_pos_reverse_reverse_pos < suffix_char_len_reverse_reverse\
    \ {\n            suffix_char_pos_reverse_reverse_pos += 1;\n            suffix_char_len_reverse_reverse_pos\
    \ += 1;\n        }\n        let mut suffix_char_pos_reverse_reverse_reverse =\
    \ 0;\n        let mut suffix_char_len_reverse_reverse_reverse = 0;\n        while\
    \ suffix_char_pos_reverse_reverse_reverse < suffix_char_len_reverse_reverse_pos\
    \ {\n            suffix_char_pos_reverse_reverse_reverse += 1;\n\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpsrd09aah.rs:71:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n25 |     while suffix_pos\
    \ < suffix_len {\n   |                                   - unclosed delimiter\n\
    ...\n59 |         while suffix_char_pos_reverse_reverse_reverse < suffix_char_len_reverse_reverse_pos\
    \ {\n   |                                                                    \
    \                         - this delimiter might not be properly closed...\n...\n\
    62 | }\n   | - ...as it matches this but it has different indentation\n...\n71\
    \ | }\n   |   ^\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsrd09aah.rs:26:31\n   |\n26 |         let mut suffix_char = suffix[suffix_pos];\n\
    \   |                               ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsrd09aah.rs:25:5\n\
    \   |\n11 |   fn make_palindrome(string: String) -> String {\n   |           \
    \                              ------ expected `String` because of return type\n\
    ...\n25 | /     while suffix_pos < suffix_len {\n26 | |         let mut suffix_char\
    \ = suffix[suffix_pos];\n27 | |         let mut suffix_char_pos = 0;\n28 | | \
    \        while suffix_char_pos < suffix_len {\n...  |\n70 | |     assert_eq!(candidate(String::from(\"\
    jerry\")), String::from(\"jerryrrej\"));\n71 | | }\n   | |__^ expected struct\
    \ `String`, found `()`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    while !string.is_empty() {\n        let mut\
    \ postfix_length = string.len();\n        while postfix_length >= longest_postfix_length\
    \ {\n            let mut postfix = &string[..postfix_length];\n            let\
    \ mut reversed_postfix = &reversed_string[..postfix_length];\n            while\
    \ postfix.len() > 0 {\n                let mut char = postfix.remove(0);\n   \
    \             reversed_postfix.push(char);\n            }\n            longest_postfix_length\
    \ = postfix_length;\n        }\n        let mut postfix = &string[..longest_postfix_length];\n\
    \        let mut reversed_postfix = &reversed_string[..longest_postfix_length];\n\
    \        while postfix.len() > 0 {\n            let mut char = postfix.remove(0);\n\
    \            reversed_postfix.push(char);\n        }\n        string = &string[longest_postfix_length..];\n\
    \        reversed_string = &reversed_string[longest_postfix_length..];\n    }\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `remove` found for reference `&str` in the\
    \ current scope\n  --> /tmp/tmpjc_00xiy.rs:21:40\n   |\n21 |                 let\
    \ mut char = postfix.remove(0);\n   |                                        ^^^^^^\
    \ method not found in `&str`\n\nerror[E0599]: no method named `push` found for\
    \ reference `&str` in the current scope\n  --> /tmp/tmpjc_00xiy.rs:22:34\n   |\n\
    22 |                 reversed_postfix.push(char);\n   |                      \
    \            ^^^^ method not found in `&str`\n\nerror[E0599]: no method named\
    \ `remove` found for reference `&str` in the current scope\n  --> /tmp/tmpjc_00xiy.rs:29:36\n\
    \   |\n29 |             let mut char = postfix.remove(0);\n   |              \
    \                      ^^^^^^ method not found in `&str`\n\nerror[E0599]: no method\
    \ named `push` found for reference `&str` in the current scope\n  --> /tmp/tmpjc_00xiy.rs:30:30\n\
    \   |\n30 |             reversed_postfix.push(char);\n   |                   \
    \           ^^^^ method not found in `&str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpjc_00xiy.rs:32:18\n   |\n32 |         string = &string[longest_postfix_length..];\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\nhelp: try using a conversion method\n   |\n32 |        \
    \ string = (&string[longest_postfix_length..]).to_string();\n   |            \
    \      +                                 +++++++++++++\n\nerror: aborting due\
    \ to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reverse = string;\n    let mut prefix = string;\n    let mut suffix_length\
    \ = 0;\n    while suffix_length < string.len() {\n        let mut suffix_length\
    \ = prefix.len();\n        for _ in 0..suffix_length {\n            reverse =\
    \ reverse.chars().next().unwrap().to_string();\n        }\n        prefix = prefix.chars().next().unwrap().to_string();\n\
    \        if reverse == prefix {\n            break;\n        }\n    }\n    prefix\
    \ + &reverse[..suffix_length]\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmps4hrdofg.rs:14:9\n\
    \   |\n14 |     let mut suffix_length = 0;\n   |         ----^^^^^^^^^^^^^\n \
    \  |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nwarning: variable does not need to be mutable\n  --> /tmp/tmps4hrdofg.rs:16:13\n\
    \   |\n16 |         let mut suffix_length = prefix.len();\n   |             ----^^^^^^^^^^^^^\n\
    \   |             |\n   |             help: remove this `mut`\n\nerror[E0382]:\
    \ use of moved value: `string`\n  --> /tmp/tmps4hrdofg.rs:13:22\n   |\n11 | fn\
    \ make_palindrome(string: String) -> String {\n   |                    ------\
    \ move occurs because `string` has type `String`, which does not implement the\
    \ `Copy` trait\n12 |     let mut reverse = string;\n   |                     \
    \  ------ value moved here\n13 |     let mut prefix = string;\n   |          \
    \            ^^^^^^ value used here after move\n\nerror[E0382]: borrow of moved\
    \ value: `string`\n  --> /tmp/tmps4hrdofg.rs:15:27\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |                    ------ move occurs because `string`\
    \ has type `String`, which does not implement the `Copy` trait\n12 |     let mut\
    \ reverse = string;\n13 |     let mut prefix = string;\n   |                 \
    \     ------ value moved here\n14 |     let mut suffix_length = 0;\n15 |     while\
    \ suffix_length < string.len() {\n   |                           ^^^^^^ value\
    \ borrowed here after move\n\nerror: aborting due to 2 previous errors; 2 warnings\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut prefix_length = 0;\n    let\
    \ mut suffix_length = 0;\n    let mut suffix_index = 0;\n    let mut prefix_index\
    \ = 0;\n    let mut suffix_char: char;\n    let mut prefix_char: char;\n    let\
    \ mut suffix_length = 0;\n    let mut prefix_length = 0;\n    let mut suffix_length\
    \ = 0;\n    let mut suffix_index = 0;\n    let mut prefix_index = 0;\n    let\
    \ mut suffix_char: char;\n    let mut prefix_char: char;\n    let mut suffix_length\
    \ = 0;\n    let mut prefix_length = 0;\n    let mut suffix_length = 0;\n    let\
    \ mut suffix_index = 0;\n    let mut prefix_index = 0;\n    let mut suffix_char:\
    \ char;\n    let mut prefix_char: char;\n    let mut suffix_length = 0;\n    let\
    \ mut prefix_length = 0;\n    let mut suffix_length = 0;\n    let mut suffix_index\
    \ = 0;\n    let mut prefix_index = 0;\n    let mut suffix_char: char;\n    let\
    \ mut prefix_char: char;\n    let mut suffix_length = 0;\n    let mut prefix_length\
    \ = 0;\n    let mut suffix_length = 0;\n    let mut suffix_index = 0;\n    let\
    \ mut prefix_index = 0;\n    let mut suffix_char: char;\n    let mut prefix_char:\
    \ char;\n    let mut suffix_length = 0;\n    let mut prefix_length = 0;\n    let\
    \ mut suffix_length = 0;\n    let mut suffix_index = 0;\n    let mut prefix_index\
    \ = 0;\n    let mut suffix_char: char;\n    let mut prefix_char: char;\n    let\
    \ mut suffix_length = 0;\n    let mut prefix_length = 0;\n    let mut suffix_length\
    \ = 0;\n    let mut suffix_index = 0;\n    let mut prefix_index = 0;\n    let\
    \ mut suffix_char: char;\n    let mut prefix_char: char;\n    let mut suffix_length\
    \ = 0;\n    let mut prefix_length = 0;\n    let mut suffix_length = 0;\n    let\
    \ mut suffix_index = 0;\n    let mut prefix_index = 0;\n    let mut suffix_char:\
    \ char;\n    let mut prefix_char: char;\n    let mut suffix_length = 0;\n    let\
    \ mut prefix_length = 0;\n    let mut suffix_length = 0;\n    let mut suffix_index\
    \ = 0;\n    let mut prefix_index = 0;\n    let mut suffix_char: char;\n    let\
    \ mut prefix_char: char;\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf84sfszs.rs:11:39\n   |\n\
    11 | fn make_palindrome(string: String) -> String {\n   |    --------------- \
    \                   ^^^^^^ expected struct `String`, found `()`\n   |    |\n \
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    while\
    \ string.len() > 0 {\n        let mut index = string.len() - 1;\n        while\
    \ index >= 0 {\n            let char = string[index];\n            if char ==\
    \ string[index].to_ascii_lowercase() {\n                longest_postfix_length\
    \ = index;\n                longest_postfix_index = index;\n                break;\n\
    \            }\n            index -= 1;\n        }\n        let mut reversed_char\
    \ = string[longest_postfix_length];\n        while reversed_char != string[longest_postfix_length\
    \ - 1].to_ascii_lowercase() {\n            reversed_string += reversed_char;\n\
    \            longest_postfix_length -= 1;\n            longest_postfix_index +=\
    \ 1;\n        }\n        string = &string[longest_postfix_length..];\n    }\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpmohd3i5v.rs:19:24\n\
    \   |\n19 |             let char = string[index];\n   |                      \
    \  ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpmohd3i5v.rs:20:24\n   |\n20 |  \
    \           if char == string[index].to_ascii_lowercase() {\n   |            \
    \            ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmpmohd3i5v.rs:27:33\n\
    \   |\n27 |         let mut reversed_char = string[longest_postfix_length];\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpmohd3i5v.rs:28:32\n   |\n28 |         while reversed_char\
    \ != string[longest_postfix_length - 1].to_ascii_lowercase() {\n   |         \
    \                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `&str`\n  --> /tmp/tmpmohd3i5v.rs:29:13\n   |\n29 |             reversed_string\
    \ += reversed_char;\n   |             ---------------^^^^^^^^^^^^^^^^^\n   | \
    \            |\n   |             cannot use `+=` on type `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmohd3i5v.rs:33:18\n   |\n33 |         string\
    \ = &string[longest_postfix_length..];\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n33 |         string = (&string[longest_postfix_length..]).to_string();\n\
    \   |                  +                                 +++++++++++++\n\nerror:\
    \ aborting due "
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut palindrome = string;\n    let mut palindrome_len = palindrome.len();\n\
    \    let mut palindrome_postfix = palindrome;\n    while palindrome_len > 0 {\n\
    \        let mut palindrome_postfix = palindrome_postfix.chars().collect::<String>();\n\
    \        palindrome_postfix.reverse();\n        if palindrome_postfix.starts_with(&palindrome)\
    \ {\n            palindrome = palindrome_postfix.clone();\n            palindrome_len\
    \ = palindrome.len();\n        }\n    }\n    palindrome\n}\n\nfn main() {\n  \
    \  let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpjq_5m_wm.rs:17:28\n   |\n17 |         palindrome_postfix.reverse();\n\
    \   |                            ^^^^^^^ help: there is an associated function\
    \ with a similar name: `reserve`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reverse = string;\n    let mut suffix = 0;\n    while reverse !=\
    \ reverse {\n        reverse = reverse.chars().nth(suffix).unwrap();\n       \
    \ suffix += 1;\n    }\n    string + &reverse.reverse()\n}\n\nfn main() {\n   \
    \ let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf0r4fadr.rs:15:19\n   |\n\
    15 |         reverse = reverse.chars().nth(suffix).unwrap();\n   |           \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                   |\n   |                   expected struct\
    \ `String`, found `char`\n\nerror[E0599]: no method named `reverse` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmpf0r4fadr.rs:18:23\n   |\n\
    18 |     string + &reverse.reverse()\n   |                       ^^^^^^^ help:\
    \ there is an associated function with a similar name: `reserve`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_postfix_length = 0;\n\
    \    let mut longest_postfix_length_index = 0;\n    for pos in string.rfind('a')\
    \ {\n        if pos == string.len() - 1 {\n            break;\n        }\n   \
    \     let mut postfix = &string[..pos];\n        let mut reversed_postfix = &string[..pos];\n\
    \        for _ in 0..pos {\n            reversed_postfix = reversed_postfix.chars().next().unwrap().to_string();\n\
    \        }\n        if reversed_postfix.chars().any(|c| !c.is_alphanumeric())\
    \ {\n            break;\n        }\n        if reversed_postfix.chars().any(|c|\
    \ !c.is_ascii_lowercase()) {\n            break;\n        }\n        if reversed_postfix.chars().any(|c|\
    \ !c.is_ascii_uppercase()) {\n            break;\n        }\n        if reversed_postfix.chars().any(|c|\
    \ !c.is_ascii_letter()) {\n            break;\n        }\n        if reversed_postfix.chars().any(|c|\
    \ !c.is_ascii_digit()) {\n            break;\n        }\n        if reversed_postfix.chars().any(|c|\
    \ !c.is_ascii_symbol()) {\n            break;\n        }\n        if reversed_postfix.chars().any(|c|\
    \ !c.is_ascii_whitespace()) {\n            break;\n        }\n        if reversed_postfix.chars().any(|c|\
    \ !c.is_ascii_control()) {\n            break;\n        }\n        if reversed_postfix.chars().any(|c|\
    \ !c.is_ascii_graph()) {\n            break;\n        }\n        if reversed_postfix.chars().any(|c|\
    \ !c.is_ascii_print()) {\n            break;\n        }\n        if reversed_postfix.chars().any(|c|\
    \ !c.is_ascii_ascii_graph()) {\n            break;\n        }\n        if reversed_postfix.chars().any(|c|\
    \ !c.is_ascii_ascii_print()) {\n            break;\n        }\n        if reversed_postfix.chars().any(|c|\
    \ !c.is_ascii_ascii_symbol()) {\n            break;\n        }\n        if reversed_postfix.chars().any(|c|\
    \ !c.is_ascii_ascii_whitespace()) {\n            break;\n        }\n        if\
    \ reversed_postfix.chars().any(|c| !c.is_ascii_ascii_control()) {\n          \
    \  break;\n        }\n        if reversed_postfix.chars().any(|c| !c.is_ascii_ascii_letter())\
    \ {\n            break;\n        }\n        if reversed_postfix.chars().any(|c|\
    \ !c.is_ascii_ascii_digit()) {\n            break;\n        }\n        if reversed_postfix.char\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp8y6e8cj1.rs:85:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n15 |     for pos\
    \ in string.rfind('a') {\n   |                                  - this delimiter\
    \ might not be properly closed...\n...\n76 | }\n   | - ...as it matches this but\
    \ it has different indentation\n...\n85 | }\n   |   ^\n\nerror: expected `{`,\
    \ found `}`\n  --> /tmp/tmp8y6e8cj1.rs:76:1\n   |\n75 |         if reversed_postfix.char\n\
    \   |         -- this `if` expression has a condition, but no block\n76 | }\n\
    \   | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8y6e8cj1.rs:22:32\n\
    \   |\n22 |             reversed_postfix = reversed_postfix.chars().next().unwrap().to_string();\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                                |\n   |                                expected\
    \ `&str`, found struct `String`\n   |                                help: consider\
    \ borrowing here: `&reversed_postfix.chars().next().unwrap().to_string()`\n\n\
    error[E0599]: no method named `is_ascii_letter` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp8y6e8cj1.rs:33:48\n   |\n33 |         if reversed_postfix.chars().any(|c|\
    \ !c.is_ascii_letter()) {\n   |                                              \
    \  ^^^^^^^^^^^^^^^ method not found in `char`\n\nerror[E0599]: no method named\
    \ `is_ascii_symbol` found for type `char` in the current scope\n  --> /tmp/tmp8y6e8cj1.rs:39:48\n\
    \   |\n39 |         if reversed_postfix.chars().any(|c| !c.is_ascii_symbol())\
    \ {\n   |                                                ^^^^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `is_ascii_control`\n\n\
    error[E0599]: no method named `is_ascii_graph` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp8y6e8cj1.rs:48:48\n   |\n48 |         if reversed_postfix.chars().any(|c|\
    \ !c.is_ascii_graph()) {\n   |                                               \
    \ ^^^^^^^^^^^^^^ help: there is an ass"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n\n    while\
    \ !string.is_empty() {\n        let mut index = string.len();\n        let mut\
    \ char = string[string.len() - 1];\n\n        while index >= 0 {\n           \
    \ reversed_string.insert(0, char);\n            string.swap_remove(0);\n     \
    \       index -= 1;\n            char = string[string.len() - 1];\n        }\n\
    \    }\n\n    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpd4xrh_av.rs:17:24\n\
    \   |\n17 |         let mut char = string[string.len() - 1];\n   |           \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0599]: no method named `insert` found for reference `&str` in the current\
    \ scope\n  --> /tmp/tmpd4xrh_av.rs:20:29\n   |\n20 |             reversed_string.insert(0,\
    \ char);\n   |                             ^^^^^^ method not found in `&str`\n\
    \nerror[E0599]: no method named `swap_remove` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpd4xrh_av.rs:21:20\n   |\n21 |             string.swap_remove(0);\n\
    \   |                    ^^^^^^^^^^^ method not found in `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpd4xrh_av.rs:23:20\n\
    \   |\n23 |             char = string[string.len() - 1];\n   |               \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_postfix_length = 0;\n\
    \    let mut longest_postfix = \"\";\n    for c in reversed_string.chars() {\n\
    \        if longest_postfix_length == 0 {\n            longest_postfix_length\
    \ = c.len_utf8();\n            longest_postfix = c.to_ascii_lowercase();\n   \
    \     } else if longest_postfix_length < c.len_utf8() {\n            longest_postfix_length\
    \ = c.len_utf8();\n            longest_postfix = c.to_ascii_lowercase();\n   \
    \     }\n    }\n    reversed_string.push_str(&longest_postfix);\n    reversed_string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz332a7c2.rs:18:31\n   |\n\
    18 |             longest_postfix = c.to_ascii_lowercase();\n   |             \
    \                  ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpz332a7c2.rs:21:31\n   |\n21 |             longest_postfix\
    \ = c.to_ascii_lowercase();\n   |                               ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found `char`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut palindrome = string;\n   \
    \ let mut suffix_length = 0;\n    let mut prefix_length = 0;\n    while palindrome.len()\
    \ > 0 {\n        let mut suffix_start = palindrome.len() - 1;\n        let mut\
    \ suffix_end = suffix_start;\n        while suffix_start >= 0 && palindrome[suffix_start]\
    \ == palindrome[suffix_end] {\n            suffix_start -= 1;\n            suffix_end\
    \ -= 1;\n        }\n        if suffix_start < 0 {\n            suffix_length +=\
    \ 1;\n            suffix_start = palindrome.len() - 1;\n        }\n        if\
    \ suffix_end < 0 {\n            suffix_length += 1;\n            suffix_end =\
    \ suffix_start;\n        }\n        if suffix_start >= 0 {\n            suffix_length\
    \ += 1;\n            palindrome = &palindrome[..suffix_start];\n        }\n  \
    \      if suffix_end >= 0 {\n            suffix_length += 1;\n            palindrome\
    \ = &palindrome[suffix_end..];\n        }\n        if suffix_length >= 2 {\n \
    \           prefix_length += 1;\n            palindrome = &palindrome[..prefix_length];\n\
    \        }\n        if suffix_length == 0 {\n            palindrome = &palindrome[..];\n\
    \        }\n    }\n    reversed_string += &palindrome[..prefix_length];\n    reversed_string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpso8qh4t0.rs:19:36\n\
    \   |\n19 |         while suffix_start >= 0 && palindrome[suffix_start] == palindrome[suffix_end]\
    \ {\n   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpso8qh4t0.rs:19:64\n   |\n19 |         while suffix_start\
    \ >= 0 && palindrome[suffix_start] == palindrome[suffix_end] {\n   |         \
    \                                                       ^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpso8qh4t0.rs:33:26\n\
    \   |\n33 |             palindrome = &palindrome[..suffix_start];\n   |      \
    \                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found\
    \ `&str`\n   |\nhelp: try using a conversion method\n   |\n33 |             palindrome\
    \ = (&palindrome[..suffix_start]).to_string();\n   |                         \
    \ +                           +++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpso8qh4t0.rs:37:26\n   |\n37 |             palindrome = &palindrome[suffix_end..];\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\nhelp: try using a conversion method\n   |\n37 |        \
    \     palindrome = (&palindrome[suffix_end..]).to_string();\n   |            \
    \              +                         +++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpso8qh4t0.rs:41:26\n   |\n41 |             palindrome =\
    \ &palindrome[..prefix_length];\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n41 |             palindrome = (&palindrome[..prefix_length]).to_string();\n\
    \   |                          +                            +++++++++++++\n\n\
    error[E0308]: mismatched types\n  --> /tmp/"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut reversed_string_len = 0;\n\
    \n    for c in string.chars() {\n        if *c != *reversed_string[reversed_string_len]\
    \ {\n            reversed_string = &c[..reversed_string_len];\n            reversed_string_len\
    \ = 0;\n        }\n        reversed_string_len += 1;\n    }\n\n    reversed_string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmphknir_1a.rs:16:12\n\
    \   |\n16 |         if *c != *reversed_string[reversed_string_len] {\n   |   \
    \         ^^\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmphknir_1a.rs:16:19\n   |\n16 |         if *c != *reversed_string[reversed_string_len]\
    \ {\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n\nerror[E0608]: cannot index into a value of type\
    \ `char`\n  --> /tmp/tmphknir_1a.rs:17:32\n   |\n17 |             reversed_string\
    \ = &c[..reversed_string_len];\n   |                                ^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0608, E0614.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut suffix_length = 0;\n    let\
    \ mut prefix_length = 0;\n    while suffix_length < string.len() {\n        let\
    \ mut suffix_start = suffix_length;\n        let mut suffix_end = suffix_length;\n\
    \        let mut suffix_char = string[suffix_end];\n        while suffix_end <\
    \ string.len() {\n            if suffix_char != string[suffix_end] {\n       \
    \         break;\n            }\n            suffix_end += 1;\n        }\n   \
    \     if suffix_end == string.len() {\n            break;\n        }\n       \
    \ let mut prefix_start = prefix_length;\n        let mut prefix_end = prefix_length;\n\
    \        let mut prefix_char = string[prefix_end];\n        while prefix_end <\
    \ string.len() {\n            if prefix_char != string[prefix_end] {\n       \
    \         break;\n            }\n            prefix_end += 1;\n        }\n   \
    \     if prefix_end == string.len() {\n            break;\n        }\n       \
    \ let mut reversed_suffix_char = string[suffix_end];\n        while reversed_suffix_char\
    \ != string[reversed_suffix_end] {\n            reversed_suffix_end += 1;\n  \
    \      }\n        if reversed_suffix_end == string.len() {\n            break;\n\
    \        }\n        let mut reversed_prefix_char = string[prefix_end];\n     \
    \   while reversed_prefix_char != string[reversed_prefix_end] {\n            reversed_prefix_end\
    \ += 1;\n        }\n        if reversed_prefix_end == string.len() {\n       \
    \     break;\n        }\n        reversed_string = string\n            .split_last_mut(suffix_end)\n\
    \            .next()\n            .unwrap()\n            .join() + reversed_string;\n\
    \        suffix_length += 1;\n        prefix_length += 1;\n    }\n    reversed_string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `reversed_suffix_end` in this scope\n \
    \ --> /tmp/tmp807jqgdz.rs:41:46\n   |\n41 |         while reversed_suffix_char\
    \ != string[reversed_suffix_end] {\n   |                                     \
    \         ^^^^^^^^^^^^^^^^^^^ help: a local variable with a similar name exists:\
    \ `reversed_suffix_char`\n\nerror[E0425]: cannot find value `reversed_suffix_end`\
    \ in this scope\n  --> /tmp/tmp807jqgdz.rs:42:13\n   |\n42 |             reversed_suffix_end\
    \ += 1;\n   |             ^^^^^^^^^^^^^^^^^^^ help: a local variable with a similar\
    \ name exists: `reversed_suffix_char`\n\nerror[E0425]: cannot find value `reversed_suffix_end`\
    \ in this scope\n  --> /tmp/tmp807jqgdz.rs:44:12\n   |\n44 |         if reversed_suffix_end\
    \ == string.len() {\n   |            ^^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `reversed_suffix_char`\n\nerror[E0425]: cannot find\
    \ value `reversed_prefix_end` in this scope\n  --> /tmp/tmp807jqgdz.rs:48:46\n\
    \   |\n48 |         while reversed_prefix_char != string[reversed_prefix_end]\
    \ {\n   |                                              ^^^^^^^^^^^^^^^^^^^ help:\
    \ a local variable with a similar name exists: `reversed_prefix_char`\n\nerror[E0425]:\
    \ cannot find value `reversed_prefix_end` in this scope\n  --> /tmp/tmp807jqgdz.rs:49:13\n\
    \   |\n49 |             reversed_prefix_end += 1;\n   |             ^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `reversed_prefix_char`\n\n\
    error[E0425]: cannot find value `reversed_prefix_end` in this scope\n  --> /tmp/tmp807jqgdz.rs:51:12\n\
    \   |\n51 |         if reversed_prefix_end == string.len() {\n   |           \
    \ ^^^^^^^^^^^^^^^^^^^ help: a local variable with a similar name exists: `reversed_prefix_char`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp807jqgdz.rs:18:31\n\
    \   |\n18 |         let mut suffix_char = string[suffix_end];\n   |          \
    \                     ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type "
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut prefix_length = 0;\n    while\
    \ !reversed_string.is_empty() {\n        let mut suffix_length = 0;\n        while\
    \ !reversed_string.starts_with(string[prefix_length..]) {\n            suffix_length\
    \ += 1;\n        }\n        reversed_string = reversed_string[..suffix_length];\n\
    \        prefix_length += 1;\n    }\n    reversed_string\n}\n\nfn main() {\n \
    \   let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmpsaltx8lt.rs:16:44\n   |\n16 |         while !reversed_string.starts_with(string[prefix_length..])\
    \ {\n   |                                            ^^^^^^^^^^^^^^^^^^^^^^^ doesn't\
    \ have a size known at compile-time\n   |\n   = help: the trait `Sized` is not\
    \ implemented for `str`\n\nerror[E0277]: expected a `FnMut<(char,)>` closure,\
    \ found `str`\n  --> /tmp/tmpsaltx8lt.rs:16:44\n   |\n16 |         while !reversed_string.starts_with(string[prefix_length..])\
    \ {\n   |                                            ^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                                            |\n   |                     \
    \                       expected an implementor of trait `Pattern<'_>`\n   | \
    \                                           help: consider borrowing here: `&string[prefix_length..]`\n\
    \   |\n   = note: the trait bound `str: Pattern<'_>` is not satisfied\n   = note:\
    \ required because of the requirements on the impl of `Pattern<'_>` for `str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsaltx8lt.rs:19:27\n   |\n19 |\
    \         reversed_string = reversed_string[..suffix_length];\n   |          \
    \                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                           |\n   |             \
    \              expected struct `String`, found `str`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut prefix_length = 0;\n    let\
    \ mut suffix_length = 0;\n    while !reversed_string.is_empty() {\n        let\
    \ mut current_char = reversed_string[0];\n        reversed_string = reversed_string.split_off(1).collect();\n\
    \        if current_char == current_char.to_string().rev() {\n            suffix_length\
    \ += 1;\n        } else {\n            prefix_length += 1;\n        }\n    }\n\
    \    let mut palindrome = string;\n    palindrome.push_str(&string[prefix_length..suffix_length]);\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmp92r2l98l.rs:16:32\n   |\n16 |         let mut current_char = reversed_string[0];\n\
    \   |                                ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n\nerror[E0599]: the method `collect` exists for struct `String`,\
    \ but its trait bounds were not satisfied\n   --> /tmp/tmp92r2l98l.rs:17:56\n\
    \    |\n17  |           reversed_string = reversed_string.split_off(1).collect();\n\
    \    |                                                          ^^^^^^^ method\
    \ cannot be called on `String` due to unsatisfied trait bounds\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `String: Iterator`\n\
    \            which is required by `&mut String: Iterator`\n            `str: Iterator`\n\
    \            which is required by `&mut str: Iterator`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = string;\n    let\
    \ mut last_char = 0;\n    while !string.is_empty() {\n        let mut current_char\
    \ = string.chars().next().unwrap();\n        if current_char == last_char {\n\
    \            reversed_string.push('_');\n        }\n        reversed_string.push(current_char);\n\
    \        last_char = current_char;\n    }\n    reversed_string\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpszdxsm7m.rs:17:28\n   |\n\
    17 |         if current_char == last_char {\n   |                            ^^^^^^^^^\
    \ expected `char`, found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpszdxsm7m.rs:21:21\n\
    \   |\n21 |         last_char = current_char;\n   |                     ^^^^^^^^^^^^\
    \ expected integer, found `char`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut prefix_length = 0;\n    let\
    \ mut suffix_length = 0;\n    let mut suffix_start = 0;\n    let mut suffix_end\
    \ = 0;\n    while suffix_end < string.len() {\n        suffix_start = suffix_end;\n\
    \        suffix_end = suffix_start + 1;\n        while suffix_end < string.len()\
    \ {\n            let mut suffix_char = string[suffix_end];\n            while\
    \ suffix_end < string.len() {\n                suffix_char = string[suffix_end];\n\
    \                suffix_end += 1;\n            }\n            if suffix_char ==\
    \ string[suffix_start - 1] {\n                suffix_length += 1;\n          \
    \      suffix_end -= 1;\n            } else {\n                break;\n      \
    \      }\n        }\n        if suffix_length >= reversed_string.len() {\n   \
    \         break;\n        }\n        let mut prefix_char = string[prefix_length];\n\
    \        while prefix_length < reversed_string.len() {\n            prefix_char\
    \ = string[prefix_length];\n            prefix_length += 1;\n        }\n     \
    \   reversed_string.push_str(&string[prefix_length..suffix_start]);\n        reversed_string.push_str(&string[suffix_start..suffix_end]);\n\
    \    }\n    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpp23_6zbb.rs:21:35\n\
    \   |\n21 |             let mut suffix_char = string[suffix_end];\n   |      \
    \                             ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpp23_6zbb.rs:23:31\n\
    \   |\n23 |                 suffix_char = string[suffix_end];\n   |          \
    \                     ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpp23_6zbb.rs:26:31\n\
    \   |\n26 |             if suffix_char == string[suffix_start - 1] {\n   |   \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpp23_6zbb.rs:36:31\n   |\n36 |         let mut prefix_char = string[prefix_length];\n\
    \   |                               ^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpp23_6zbb.rs:38:27\n   |\n38 |             prefix_char = string[prefix_length];\n\
    \   |                           ^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror: aborting due to 5 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_postfix_length = 0;\n\
    \    for pos in string.rfind('a') {\n        if pos == 0 {\n            break;\n\
    \        }\n        let mut postfix_length = pos - 1;\n        while postfix_length\
    \ >= 0 && reversed_string[postfix_length] != string[pos] {\n            postfix_length\
    \ -= 1;\n        }\n        if postfix_length >= 0 {\n            longest_postfix_length\
    \ = std::cmp::max(longest_postfix_length, postfix_length);\n        }\n    }\n\
    \    let mut result = string;\n    for pos in longest_postfix_length..string.len()\
    \ {\n        result = result.insert(pos, string[pos]);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp0jmkavwh.rs:19:38\n\
    \   |\n19 |         while postfix_length >= 0 && reversed_string[postfix_length]\
    \ != string[pos] {\n   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmp0jmkavwh.rs:19:73\n   |\n19 |         while\
    \ postfix_length >= 0 && reversed_string[postfix_length] != string[pos] {\n  \
    \ |                                                                         ^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmp0jmkavwh.rs:28:37\n   |\n28 |         result\
    \ = result.insert(pos, string[pos]);\n   |                                   \
    \  ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0jmkavwh.rs:28:18\n   |\n28 |         result = result.insert(pos,\
    \ string[pos]);\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found `()`\n   |\nnote: method `insert` modifies its receiver\
    \ in-place\n  --> /tmp/tmp0jmkavwh.rs:28:25\n   |\n28 |         result = result.insert(pos,\
    \ string[pos]);\n   |                  ------ ^^^^^^ this call modifies `result`\
    \ in-place\n   |                  |\n   |                  you probably want to\
    \ use this value after calling the method...\n   = note: ...instead of the `()`\
    \ output of method `insert`\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_postfix_length = 0;\n\
    \    for c in string.chars() {\n        if longest_postfix_length < c.len() {\n\
    \            longest_postfix_length = c.len();\n        }\n    }\n    let mut\
    \ postfix_length_to_append = longest_postfix_length;\n    while postfix_length_to_append\
    \ > 0 {\n        let mut postfix_length_to_append = postfix_length_to_append -\
    \ 1;\n        let mut postfix_to_append = String::new();\n        for c in string.chars()\
    \ {\n            if postfix_length_to_append == 0 {\n                postfix_to_append.push(c);\n\
    \            } else {\n                postfix_to_append.push(c);\n          \
    \      postfix_length_to_append = postfix_length_to_append - 1;\n            }\n\
    \        }\n        reversed_string.push_str(postfix_to_append);\n    }\n    reversed_string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpzl82qqr3.rs:15:39\n   |\n15 |         if longest_postfix_length\
    \ < c.len() {\n   |                                       ^^^ method not found\
    \ in `char`\n\nerror[E0599]: no method named `len` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpzl82qqr3.rs:16:40\n   |\n16 |             longest_postfix_length\
    \ = c.len();\n   |                                        ^^^ method not found\
    \ in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzl82qqr3.rs:31:34\n\
    \   |\n31 |         reversed_string.push_str(postfix_to_append);\n   |       \
    \                           ^^^^^^^^^^^^^^^^^\n   |                          \
    \        |\n   |                                  expected `&str`, found struct\
    \ `String`\n   |                                  help: consider borrowing here:\
    \ `&postfix_to_append`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_length_index = 0;\n\
    \    let mut longest_postfix_length_palindrome = 0;\n    let mut longest_postfix_length_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length = 0;\n    let mut\
    \ longest_postfix_length_palindrome_length_index = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_palindrome\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpo842343v.rs:35:53\n   |\n\
    35 |     let mut longest_postfix_length_palindrome_length\n   |              \
    \                                       ^ help: add `;` here\n36 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo842343v.rs:11:39\n \
    \  |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut reversed_string_len = 0;\n\
    \n    while !reversed_string.chars().next().unwrap().is_alphanumeric() {\n   \
    \     reversed_string_len += 1;\n        reversed_string = reversed_string[..reversed_string_len];\n\
    \    }\n\n    let mut reversed_string_len = reversed_string_len + 1;\n\n    while\
    \ !reversed_string.chars().next().unwrap().is_alphanumeric() {\n        reversed_string_len\
    \ += 1;\n        reversed_string = reversed_string[..reversed_string_len];\n \
    \   }\n\n    let mut reversed_string_len = reversed_string_len + 1;\n\n    while\
    \ !reversed_string.chars().next().unwrap().is_alphanumeric() {\n        reversed_string_len\
    \ += 1;\n        reversed_string = reversed_string[..reversed_string_len];\n \
    \   }\n\n    let mut reversed_string_len = reversed_string_len + 1;\n\n    while\
    \ !reversed_string.chars().next().unwrap().is_alphanumeric() {\n        reversed_string_len\
    \ += 1;\n        reversed_string = reversed_string[..reversed_string_len];\n \
    \   }\n\n    let mut reversed_string_len = reversed_string_len + 1;\n\n    while\
    \ !reversed_string.chars().next().unwrap().is_alphanumeric() {\n        reversed_string_len\
    \ += 1;\n        reversed_string = reversed_string[..reversed_string_len];\n \
    \   }\n\n    let mut reversed_string_len = reversed_string_len + 1;\n\n    while\
    \ !reversed_string.chars().next().unwrap().is_alphanumeric() {\n        reversed_string_len\
    \ += 1;\n        reversed_string = reversed_string[..reversed_string_len];\n \
    \   }\n\n    let mut reversed_string_len = reversed_string_len + 1;\n\n    while\
    \ !reversed_string.chars().next().unwrap().is_alphanumeric() {\n        reversed_string_len\
    \ += 1;\n        reversed_string = reversed_string[..reversed_string_len];\n \
    \   }\n\n    let mut reversed_string_len = reversed_string_len + 1;\n\n    while\
    \ !reversed_string.chars().next().unwrap().is_alphanumeric() {\n        reversed_string_len\
    \ += 1;\n        reversed_string = reversed_string[..reversed_string_len];\n \
    \   }\n\n    let mut reversed_string_len = reversed_string_len + 1;\n\n    while\
    \ !reversed_string.chars().next().unwrap().is_alphanumeric() {\n        reversed_string_len\
    \ += 1;\n        reversed_string = reversed_string[..reversed_string_len];\n \
    \   }\n\n    let mut reversed_string_len = reversed_string_len + 1;\n\n\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbcc3lsln.rs:17:27\n   |\n\
    17 |         reversed_string = reversed_string[..reversed_string_len];\n   | \
    \                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                           |\n   |\
    \                           expected struct `String`, found `str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbcc3lsln.rs:24:27\n   |\n24 |         reversed_string\
    \ = reversed_string[..reversed_string_len];\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \         |\n   |                           expected struct `String`, found `str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbcc3lsln.rs:31:27\n   |\n31 |\
    \         reversed_string = reversed_string[..reversed_string_len];\n   |    \
    \                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                           |\n   |\
    \                           expected struct `String`, found `str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbcc3lsln.rs:38:27\n   |\n38 |         reversed_string\
    \ = reversed_string[..reversed_string_len];\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \         |\n   |                           expected struct `String`, found `str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbcc3lsln.rs:45:27\n   |\n45 |\
    \         reversed_string = reversed_string[..reversed_string_len];\n   |    \
    \                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                           |\n   |\
    \                           expected struct `String`, found `str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbcc3lsln.rs:52:27\n   |\n52 |         reversed_string\
    \ = reversed_string[..reversed_string_len];\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try usi"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    let\
    \ mut longest_postfix_length_index = 0;\n    while longest_postfix_length < string.len()\
    \ {\n        let mut postfix_length = 0;\n        let mut postfix_index = 0;\n\
    \        while postfix_length < longest_postfix_length && postfix_index < string.len()\
    \ {\n            if string[postfix_index] != string[longest_postfix_length_index]\
    \ {\n                break;\n            }\n            postfix_length += 1;\n\
    \            postfix_index += 1;\n        }\n        if postfix_index == string.len()\
    \ {\n            break;\n        }\n        longest_postfix_length = postfix_length;\n\
    \        longest_postfix_index = postfix_index;\n        longest_postfix_length_index\
    \ += 1;\n    }\n    string = &string[longest_postfix_index..];\n    let mut reversed_string\
    \ = \"\";\n    let mut reversed_index = 0;\n    let mut reversed_length = 0;\n\
    \    while reversed_length < string.len() {\n        let mut reversed_char = 0;\n\
    \        let mut reversed_index = 0;\n        while reversed_index < reversed_length\
    \ && reversed_index < string.len() {\n            if string[reversed_index] !=\
    \ string[reversed_length] {\n                break;\n            }\n         \
    \   reversed_char ^= string[reversed_index];\n            reversed_index += 1;\n\
    \        }\n        if reversed_index == string.len() {\n            break;\n\
    \        }\n        reversed_string += &reversed_char;\n        reversed_length\
    \ += 1;\n    }\n    string = &string[0..longest_postfix_index];\n    string +=\
    \ &reversed_string;\n    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpe92oifo9.rs:21:16\n\
    \   |\n21 |             if string[postfix_index] != string[longest_postfix_length_index]\
    \ {\n   |                ^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpe92oifo9.rs:21:41\n\
    \   |\n21 |             if string[postfix_index] != string[longest_postfix_length_index]\
    \ {\n   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe92oifo9.rs:34:14\n\
    \   |\n34 |     string = &string[longest_postfix_index..];\n   |             \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n  \
    \ |\nhelp: try using a conversion method\n   |\n34 |     string = (&string[longest_postfix_index..]).to_string();\n\
    \   |              +                                +++++++++++++\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpe92oifo9.rs:42:16\n\
    \   |\n42 |             if string[reversed_index] != string[reversed_length] {\n\
    \   |                ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpe92oifo9.rs:42:42\n\
    \   |\n42 |             if string[reversed_index] != string[reversed_length] {\n\
    \   |                                          ^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpe92oifo9.rs:45:30\n   |\n45 |             reversed_char\
    \ ^= string[reversed_index];\n   |                              ^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   "
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = string;\n    let\
    \ mut longest_postfix_length = 0;\n    let mut longest_postfix_start = -1;\n \
    \   while !string.ends_with(&reversed_string) {\n        let mut postfix_length\
    \ = string.rfind(&reversed_string);\n        if postfix_length == -1 {\n     \
    \       break;\n        }\n        longest_postfix_length = postfix_length;\n\
    \        longest_postfix_start = postfix_length;\n        string = &string[postfix_length..];\n\
    \        reversed_string = &reversed_string[..postfix_length];\n    }\n    if\
    \ longest_postfix_length == 0 {\n        return string;\n    }\n    let mut reversed_string\
    \ = reversed_string;\n    let mut longest_postfix_start = longest_postfix_start;\n\
    \    while !reversed_string.starts_with(&string) {\n        let mut postfix_length\
    \ = reversed_string.find(&string);\n        if postfix_length == -1 {\n      \
    \      break;\n        }\n        longest_postfix_length = postfix_length;\n \
    \       longest_postfix_start = postfix_length;\n        reversed_string = &reversed_string[..postfix_length];\n\
    \    }\n    let mut reversed_string = reversed_string;\n    let mut longest_postfix_start\
    \ = longest_postfix_start;\n    while !reversed_string.starts_with(&string) {\n\
    \        let mut postfix_length = reversed_string.find(&string);\n        if postfix_length\
    \ == -1 {\n            break;\n        }\n        longest_postfix_length = postfix_length;\n\
    \        longest_postfix_start = postfix_length;\n        reversed_string = &reversed_string[..postfix_length];\n\
    \    }\n    let mut reversed_string = reversed_string;\n    let mut longest_postfix_start\
    \ = longest_postfix_start;\n    while !reversed_string.starts_with(&string) {\n\
    \        let mut postfix_length = reversed_string.find(&string);\n        if postfix_length\
    \ == -1 {\n            break;\n        }\n        longest_postfix_length = postfix_length;\n\
    \        longest_postfix_start = postfix_length;\n        reversed_string = &reversed_string[..postfix_length];\n\
    \    }\n    let mut reversed_string = reversed_string;\n    let mut longest_postfix_start\
    \ = longest_postfix_start;\n    while !reversed_string.starts_with(&string) {\n\
    \        let mut postfix_length = reversed_string.find(&string);\n        if postfix_length\
    \ == -1 {\n            break;\n        }\n        longest_postfix_length = postfix_length;\n\
    \        longest_postfix_start = postfix_length;\n        reversed_\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp37wwsj97.rs:81:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n64 |     while !reversed_string.starts_with(&string)\
    \ {\n   |                                                 - this delimiter might\
    \ not be properly closed...\n...\n72 | }\n   | - ...as it matches this but it\
    \ has different indentation\n...\n81 | }\n   |   ^\n\nerror[E0425]: cannot find\
    \ value `reversed_` in this scope\n  --> /tmp/tmp37wwsj97.rs:71:9\n   |\n71 |\
    \         reversed_\n   |         ^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp37wwsj97.rs:18:30\n   |\n18 |         if postfix_length\
    \ == -1 {\n   |                              ^^\n   |                        \
    \      |\n   |                              expected enum `Option`, found integer\n\
    \   |                              help: try using a variant of the expected enum:\
    \ `Some(-1)`\n   |\n   = note: expected enum `Option<usize>`\n              found\
    \ type `{integer}`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp37wwsj97.rs:21:34\n\
    \   |\n21 |         longest_postfix_length = postfix_length;\n   |           \
    \                       ^^^^^^^^^^^^^^ expected integer, found enum `Option`\n\
    \   |\n   = note: expected type `{integer}`\n              found enum `Option<usize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp37wwsj97.rs:22:33\n   |\n22 |\
    \         longest_postfix_start = postfix_length;\n   |                      \
    \           ^^^^^^^^^^^^^^ expected integer, found enum `Option`\n   |\n   = note:\
    \ expected type `{integer}`\n              found enum `Option<usize>`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `RangeFrom<Option<usize>>`\n  --> /tmp/tmp37wwsj97.rs:23:19\n\
    \   |\n23 |         string = &string[postfix_length..];\n   |                \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `RangeFrom<Option<usize>>`\n\
    \   |\n   = help: the trait `Index<RangeFrom<Option<usize>>>` is not implemented\
    \ for `String`\n\nerror[E0308]: mismatched types\n  -->"
  stdout: ''
  timestamp: 1659805826
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reverse = string;\n    let mut i =\
    \ 0;\n    while i < string.len() {\n        let mut j = i;\n        while j <\
    \ string.len() && string[j] != string[i - j] {\n            j = j + 1;\n     \
    \   }\n        reverse = reverse.insert(0, &string[i - j]);\n        i = j;\n\
    \    }\n    reverse\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpdbm_syky.rs:17:35\n\
    \   |\n17 |         while j < string.len() && string[j] != string[i - j] {\n \
    \  |                                   ^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpdbm_syky.rs:17:48\n\
    \   |\n17 |         while j < string.len() && string[j] != string[i - j] {\n \
    \  |                                                ^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpdbm_syky.rs:20:38\n   |\n20 |         reverse = reverse.insert(0,\
    \ &string[i - j]);\n   |                                      ^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdbm_syky.rs:20:37\n\
    \   |\n20 |         reverse = reverse.insert(0, &string[i - j]);\n   |       \
    \                              ^^^^^^^^^^^^^^ expected `char`, found reference\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\nhelp:\
    \ consider removing the borrow\n   |\n20 -         reverse = reverse.insert(0,\
    \ &string[i - j]);\n20 +         reverse = reverse.insert(0, string[i - j]);\n\
    \   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdbm_syky.rs:20:19\n  \
    \ |\n20 |         reverse = reverse.insert(0, &string[i - j]);\n   |         \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found `()`\n\
    \   |\nnote: method `insert` modifies its receiver in-place\n  --> /tmp/tmpdbm_syky.rs:20:27\n\
    \   |\n20 |         reverse = reverse.insert(0, &string[i - j]);\n   |       \
    \            ------- ^^^^^^ this call modifies `reverse` in-place\n   |      \
    \             |\n   |                   you probably want to use this value after\
    \ calling the method...\n   = note: ...instead of the `()` output of "
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut postfix = string;\n    let\
    \ mut suffix_length = 0;\n    while suffix_length < string.len() {\n        let\
    \ mut suffix_start = suffix_length;\n        let mut suffix_end = suffix_length;\n\
    \        let mut suffix_char = string.chars().nth(suffix_start).unwrap();\n  \
    \      while suffix_end < string.len() && suffix_char == string.chars().nth(suffix_end).unwrap()\
    \ {\n            suffix_end += 1;\n        }\n        let mut suffix_char = string.chars().nth(suffix_end).unwrap();\n\
    \        while suffix_start > 0 && suffix_char == string.chars().nth(suffix_start\
    \ - 1).unwrap() {\n            suffix_start -= 1;\n        }\n        let mut\
    \ suffix_char = string.chars().nth(suffix_start).unwrap();\n        let mut suffix_length\
    \ = suffix_end - suffix_start + 1;\n        if suffix_length == 0 {\n        \
    \    break;\n        }\n        let mut suffix_char = string.chars().nth(suffix_start).unwrap();\n\
    \        while suffix_length != 0 {\n            if suffix_char == string.chars().nth(suffix_length).unwrap()\
    \ {\n                suffix_length -= 1;\n            } else {\n             \
    \   break;\n            }\n            suffix_length += 1;\n            suffix_char\
    \ = string.chars().nth(suffix_length).unwrap();\n        }\n        postfix.push_str(&reversed_string[suffix_start..suffix_end]);\n\
    \        reversed_string.push_str(&string[suffix_start..suffix_end]);\n    }\n\
    \    postfix.push_str(&reversed_string);\n    reversed_string\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `suffix_char`\n  --> /tmp/tmpkxx2ic3l.rs:26:17\n\
    \   |\n26 |         let mut suffix_char = string.chars().nth(suffix_start).unwrap();\n\
    \   |                 ^^^^^^^^^^^ help: if this is intentional, prefix it with\
    \ an underscore: `_suffix_char`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nwarning: variable does not need to be mutable\n  --> /tmp/tmpkxx2ic3l.rs:14:9\n\
    \   |\n14 |     let mut suffix_length = 0;\n   |         ----^^^^^^^^^^^^^\n \
    \  |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nwarning: variable does not need to be mutable\n  --> /tmp/tmpkxx2ic3l.rs:18:13\n\
    \   |\n18 |         let mut suffix_char = string.chars().nth(suffix_start).unwrap();\n\
    \   |             ----^^^^^^^^^^^\n   |             |\n   |             help:\
    \ remove this `mut`\n\nwarning: variable does not need to be mutable\n  --> /tmp/tmpkxx2ic3l.rs:22:13\n\
    \   |\n22 |         let mut suffix_char = string.chars().nth(suffix_end).unwrap();\n\
    \   |             ----^^^^^^^^^^^\n   |             |\n   |             help:\
    \ remove this `mut`\n\nwarning: variable does not need to be mutable\n  --> /tmp/tmpkxx2ic3l.rs:26:13\n\
    \   |\n26 |         let mut suffix_char = string.chars().nth(suffix_start).unwrap();\n\
    \   |             ----^^^^^^^^^^^\n   |             |\n   |             help:\
    \ remove this `mut`\n\nerror[E0382]: use of moved value: `string`\n  --> /tmp/tmpkxx2ic3l.rs:13:23\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \       ------ move occurs because `string` has type `String`, which does not\
    \ implement the `Copy` trait\n12 |     let mut reversed_string = string;\n   |\
    \                               ------ value moved here\n13 |     let mut postfix\
    \ = string;\n   |                       ^^^^^^ value used here after move\n\n\
    error[E0382]: borrow of moved value: `string`\n  --> /tmp/tmpkxx2ic3l.rs:15:27\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \       ------ move occurs because `string` has type `String`, which does not\
    \ implement the `Copy` trait\n1"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reverse = string;\n    let mut longest\
    \ = 0;\n    let mut longest_index = 0;\n    while !string.is_empty() {\n     \
    \   let mut index = string.len();\n        while index > 0 {\n            let\
    \ mut char = string[--index];\n            if char == reverse {\n            \
    \    longest = char;\n                longest_index = index;\n               \
    \ break;\n            }\n        }\n        reverse = &string[longest_index..longest_index.reverse().len()];\n\
    \        string = &string[longest_index..];\n    }\n    string\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmpipvrc4qp.rs:19:36\n\
    \   |\n19 |             let mut char = string[--index];\n   |                \
    \                    ^^^^^^ cannot apply unary operator `-`\n   |\n   = note:\
    \ unsigned values cannot be negated\n\nerror[E0600]: cannot apply unary operator\
    \ `-` to type `usize`\n  --> /tmp/tmpipvrc4qp.rs:19:35\n   |\n19 |           \
    \  let mut char = string[--index];\n   |                                   ^^^^^^^\
    \ cannot apply unary operator `-`\n   |\n   = note: unsigned values cannot be\
    \ negated\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  -->\
    \ /tmp/tmpipvrc4qp.rs:19:28\n   |\n19 |             let mut char = string[--index];\n\
    \   |                            ^^^^^^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror[E0277]: can't compare `{integer}` with `String`\n  --> /tmp/tmpipvrc4qp.rs:20:21\n\
    \   |\n20 |             if char == reverse {\n   |                     ^^ no implementation\
    \ for `{integer} == String`\n   |\n   = help: the trait `PartialEq<String>` is\
    \ not implemented for `{integer}`\n\nerror[E0599]: no method named `reverse` found\
    \ for type `usize` in the current scope\n  --> /tmp/tmpipvrc4qp.rs:26:56\n   |\n\
    26 |         reverse = &string[longest_index..longest_index.reverse().len()];\n\
    \   |                                                        ^^^^^^^ method not\
    \ found in `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpipvrc4qp.rs:26:19\n\
    \   |\n26 |         reverse = &string[longest_index..longest_index.reverse().len()];\n\
    \   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n26 |         reverse = (&string[longest_index..longest_index.reverse().len()]).to_string();\n\
    \   |                   +                                                    \
    \ +++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpipvrc4qp.rs:27:18\n\
    \   |\n27 |         string = &string[longest_index..]"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    let\
    \ mut longest_postfix_index2 = 0;\n    let mut longest_postfix_index3 = 0;\n \
    \   let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5 =\
    \ 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut longest_postfix_index44 = 0;\n    let mut longest_postfix_index45\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp3v9v9aes.rs:59:36\n   |\n\
    59 |     let mut longest_postfix_index45\n   |                               \
    \     ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3v9v9aes.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reverse = string;\n    let mut i =\
    \ 0;\n    while i < string.len() {\n        let mut j = i;\n        while j +\
    \ 1 < string.len() && string[j] == string[j + 1] {\n            j += 1\n     \
    \   }\n        reverse = reverse.insert(j, string[i]);\n        i += 1;\n    }\n\
    \    reverse\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpumwfgbne.rs:17:39\n\
    \   |\n17 |         while j + 1 < string.len() && string[j] == string[j + 1] {\n\
    \   |                                       ^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n \
    \ --> /tmp/tmpumwfgbne.rs:17:52\n   |\n17 |         while j + 1 < string.len()\
    \ && string[j] == string[j + 1] {\n   |                                      \
    \              ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpumwfgbne.rs:20:37\n\
    \   |\n20 |         reverse = reverse.insert(j, string[i]);\n   |            \
    \                         ^^^^^^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpumwfgbne.rs:20:19\n   |\n20 |         reverse\
    \ = reverse.insert(j, string[i]);\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `()`\n   |\nnote: method `insert` modifies its\
    \ receiver in-place\n  --> /tmp/tmpumwfgbne.rs:20:27\n   |\n20 |         reverse\
    \ = reverse.insert(j, string[i]);\n   |                   ------- ^^^^^^ this\
    \ call modifies `reverse` in-place\n   |                   |\n   |           \
    \        you probably want to use this value after calling the method...\n   =\
    \ note: ...instead of the `()` output of method `insert`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut palindrome = string;\n   \
    \ let mut longest_postfix = string;\n    let mut longest_postfix_length = longest_postfix.len();\n\
    \    while !reversed_string.is_empty() {\n        let mut reversed_string = reversed_string.chars().collect::<String>();\n\
    \        let mut palindrome = palindrome.chars().collect::<String>();\n      \
    \  let mut longest_postfix = longest_postfix.chars().collect::<String>();\n  \
    \      let mut longest_postfix_length = longest_postfix.len();\n        while\
    \ !reversed_string.is_empty() {\n            let mut reversed_string = reversed_string.chars().collect::<String>();\n\
    \            let mut palindrome = palindrome.chars().collect::<String>();\n  \
    \          let mut longest_postfix = longest_postfix.chars().collect::<String>();\n\
    \            let mut longest_postfix_length = longest_postfix.len();\n       \
    \     if reversed_string.pop() != palindrome.pop() {\n                break;\n\
    \            }\n            longest_postfix.push(palindrome);\n            longest_postfix_length\
    \ = longest_postfix.len();\n        }\n        palindrome.push(reversed_string);\n\
    \        reversed_string = longest_postfix;\n    }\n    palindrome\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph0pl1nvh.rs:29:34\n   |\n\
    29 |             longest_postfix.push(palindrome);\n   |                     \
    \             ^^^^^^^^^^ expected `char`, found struct `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmph0pl1nvh.rs:32:25\n   |\n32 |         palindrome.push(reversed_string);\n\
    \   |                         ^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut reversed_string_len = 0;\n\
    \    let mut longest_palindrome = string;\n    let mut longest_palindrome_len\
    \ = 0;\n\n    while !reversed_string.is_empty() {\n        let mut reversed_string_len\
    \ = 0;\n        let mut longest_palindrome_len = 0;\n\n        for c in reversed_string.chars()\
    \ {\n            if c.is_whitespace() {\n                continue;\n         \
    \   }\n\n            let mut reversed_string_len = 0;\n            let mut longest_palindrome_len\
    \ = 0;\n\n            if c.is_lowercase() {\n                reversed_string_len\
    \ += 1;\n                longest_palindrome_len += 1;\n            }\n\n     \
    \       if c.is_uppercase() {\n                reversed_string_len += 1;\n   \
    \             longest_palindrome_len += 1;\n            }\n\n            if c.is_digit()\
    \ {\n                reversed_string_len += 1;\n                longest_palindrome_len\
    \ += 1;\n            }\n\n            if c.is_punctuation() {\n              \
    \  reversed_string_len += 1;\n                longest_palindrome_len += 1;\n \
    \           }\n\n            if c.is_symbol() {\n                reversed_string_len\
    \ += 1;\n                longest_palindrome_len += 1;\n            }\n\n     \
    \       if c.is_symbol() {\n                reversed_string_len += 1;\n      \
    \          longest_palindrome_len += 1;\n            }\n\n            if c.is_symbol()\
    \ {\n                reversed_string_len += 1;\n                longest_palindrome_len\
    \ += 1;\n            }\n\n            if c.is_symbol() {\n                reversed_string_len\
    \ += 1;\n                longest_palindrome_len += 1;\n            }\n\n     \
    \       if c.is_symbol() {\n                reversed_string_len += 1;\n      \
    \          longest_palindrome_len += 1;\n            }\n\n            if c.is_symbol()\
    \ {\n                reversed_string_len += 1;\n                longest_palindrome_len\
    \ += 1;\n            }\n\n            if c.is_symbol() {\n                reversed_string_len\
    \ += 1;\n                longest_palindrome_len += 1;\n            }\n\n     \
    \       if c.is_symbol() {\n                reversed_string_len += 1;\n      \
    \          longest_palindrome_len += 1;\n            }\n\n            if c.is_symbol()\
    \ {\n                reversed_string_len += 1;\n                longest_palindrome_len\
    \ += 1;\n            }\n\n            if c.is_symbol() {\n                reversed_string_len\
    \ += 1;\n                longest_palindrome_len += 1;\n            }\n\n     \
    \       if c.is_symbol() {\n                reversed_string_len += 1;\n      \
    \          longest_palindrome_len\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpfdqtj8qj.rs:111:3\n\
    \    |\n11  | fn make_palindrome(string: String) -> String {\n    |          \
    \                                    - unclosed delimiter\n...\n17  |     while\
    \ !reversed_string.is_empty() {\n    |                                       -\
    \ unclosed delimiter\n...\n21  |         for c in reversed_string.chars() {\n\
    \    |                                          - unclosed delimiter\n...\n99\
    \  |             if c.is_symbol() {\n    |                              - this\
    \ delimiter might not be properly closed...\n...\n102 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n111 | }\n    |   ^\n\nerror[E0061]:\
    \ this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpfdqtj8qj.rs:39:18\n\
    \    |\n39  |             if c.is_digit() {\n    |                  ^^^^^^^^-\
    \ supplied 0 arguments\n    |                  |\n    |                  expected\
    \ 1 argument\n    |\nnote: associated function defined here\n\nerror[E0599]: no\
    \ method named `is_punctuation` found for type `char` in the current scope\n \
    \ --> /tmp/tmpfdqtj8qj.rs:44:18\n   |\n44 |             if c.is_punctuation()\
    \ {\n   |                  ^^^^^^^^^^^^^^ method not found in `char`\n\nerror[E0599]:\
    \ no method named `is_symbol` found for type `char` in the current scope\n  -->\
    \ /tmp/tmpfdqtj8qj.rs:49:18\n   |\n49 |             if c.is_symbol() {\n   | \
    \                 ^^^^^^^^^ method not found in `char`\n\nerror[E0599]: no method\
    \ named `is_symbol` found for type `char` in the current scope\n  --> /tmp/tmpfdqtj8qj.rs:54:18\n\
    \   |\n54 |             if c.is_symbol() {\n   |                  ^^^^^^^^^ method\
    \ not found in `char`\n\nerror[E0599]: no method named `is_symbol` found for type\
    \ `char` in the current scope\n  --> /tmp/tmpfdqtj8qj.rs:59:18\n   |\n59 |   \
    \          if c.is_symbol() {\n   |                  ^^^^^^^^^ method not found\
    \ in `char`\n\nerror[E0599]: no method named `is_symbol` found for type `char`\
    \ in the current scope\n  --> /tmp/tmpfdqtj8qj.rs:64:18\n   |\n64 |          \
    \   if c.is_symbol() {\n   |          "
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = string;\n    let\
    \ mut palindrome = string;\n    let mut prefix_length = 0;\n    let mut suffix_length\
    \ = 0;\n    while !string.is_empty() {\n        let mut current_char = string.chars().next();\n\
    \        if current_char.is_none() {\n            break;\n        }\n        let\
    \ current_char = current_char.unwrap();\n        if current_char == char::from_u32(u32(current_char).rev())\
    \ {\n            suffix_length += 1;\n        } else {\n            prefix_length\
    \ += 1;\n        }\n        if suffix_length >= palindrome.len() {\n         \
    \   palindrome = palindrome.append(&reversed_string[prefix_length..]);\n     \
    \       suffix_length = 0;\n            prefix_length = 0;\n        }\n    }\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0423]: expected function, found builtin type `u32`\n  --> /tmp/tmpbf5y32_i.rs:23:43\n\
    \   |\n23 |         if current_char == char::from_u32(u32(current_char).rev())\
    \ {\n   |                                           ^^^ not a function\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbf5y32_i.rs:23:28\n   |\n23 |         if current_char\
    \ == char::from_u32(u32(current_char).rev()) {\n   |                         \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<char>`\n\
    \nerror[E0599]: no method named `append` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpbf5y32_i.rs:29:37\n   |\n29 |             palindrome =\
    \ palindrome.append(&reversed_string[prefix_length..]);\n   |                \
    \                     ^^^^^^ method not found in `String`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0423,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut reversed_string_reversed =\
    \ string;\n\n    while !reversed_string.is_empty() {\n        let mut index =\
    \ reversed_string.len() - 1;\n        while index >= 0 {\n            if reversed_string[index]\
    \ != reversed_string[index].chars().nth(1).unwrap() {\n                break;\n\
    \            }\n            index -= 1;\n        }\n        reversed_string =\
    \ reversed_string[..index + 1];\n        reversed_string_reversed = reversed_string_reversed.chars().rev().collect::<String>().reverse();\n\
    \    }\n\n    string + &reversed_string_reversed\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpirpczdo8.rs:18:16\n\
    \   |\n18 |             if reversed_string[index] != reversed_string[index].chars().nth(1).unwrap()\
    \ {\n   |                ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpirpczdo8.rs:18:42\n\
    \   |\n18 |             if reversed_string[index] != reversed_string[index].chars().nth(1).unwrap()\
    \ {\n   |                                          ^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpirpczdo8.rs:23:27\n\
    \   |\n23 |         reversed_string = reversed_string[..index + 1];\n   |    \
    \                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                           |\n   |             \
    \              expected struct `String`, found `str`\n\nerror[E0599]: no method\
    \ named `reverse` found for struct `String` in the current scope\n  --> /tmp/tmpirpczdo8.rs:24:95\n\
    \   |\n24 |         reversed_string_reversed = reversed_string_reversed.chars().rev().collect::<String>().reverse();\n\
    \   |                                                                        \
    \                       ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reverse = string;\n    let mut suffix\
    \ = 0;\n    while !string.is_empty() {\n        let mut i = suffix;\n        while\
    \ !string.is_empty() && string[i] != string[string.len() - 1 - i] {\n        \
    \    i += 1;\n        }\n        reverse.push_str(&string[..i]);\n        suffix\
    \ += i;\n        string = &string[i..];\n    }\n    reverse.push_str(&string[..suffix]);\n\
    \    reverse\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmppgja9s6_.rs:17:37\n   |\n17 |         while !string.is_empty() && string[i]\
    \ != string[string.len() - 1 - i] {\n   |                                    \
    \ ^^^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait\
    \ `Index<{integer}>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmppgja9s6_.rs:17:50\n   |\n\
    17 |         while !string.is_empty() && string[i] != string[string.len() - 1\
    \ - i] {\n   |                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppgja9s6_.rs:22:18\n\
    \   |\n22 |         string = &string[i..];\n   |                  ^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n22 |         string = (&string[i..]).to_string();\n   |               \
    \   +            +++++++++++++\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut palindrome = string;\n    let mut suffix = 0;\n    while palindrome.len()\
    \ > 0 {\n        let mut i = 0;\n        while i < palindrome.len() && palindrome[i]\
    \ == palindrome[suffix] {\n            i += 1;\n            suffix += 1;\n   \
    \     }\n        palindrome = &palindrome[i..];\n    }\n    palindrome\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpslln9u5k.rs:16:39\n\
    \   |\n16 |         while i < palindrome.len() && palindrome[i] == palindrome[suffix]\
    \ {\n   |                                       ^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpslln9u5k.rs:16:56\n   |\n16 |         while i < palindrome.len()\
    \ && palindrome[i] == palindrome[suffix] {\n   |                             \
    \                           ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpslln9u5k.rs:20:22\n   |\n20 |\
    \         palindrome = &palindrome[i..];\n   |                      ^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n20 |         palindrome = (&palindrome[i..]).to_string();\n   |       \
    \               +                +++++++++++++\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n\n    while\
    \ !string.is_empty() {\n        let mut index = string.len() - 1;\n        let\
    \ mut char = string[index];\n\n        while index >= 0 {\n            reversed_string.insert(0,\
    \ char);\n            index -= 1;\n            char = string[index];\n       \
    \ }\n        string = &string[index..];\n    }\n\n    reversed_string\n}\n\nfn\
    \ main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpat98wf4v.rs:17:24\n\
    \   |\n17 |         let mut char = string[index];\n   |                      \
    \  ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0599]: no method named\
    \ `insert` found for reference `&str` in the current scope\n  --> /tmp/tmpat98wf4v.rs:20:29\n\
    \   |\n20 |             reversed_string.insert(0, char);\n   |               \
    \              ^^^^^^ method not found in `&str`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpat98wf4v.rs:22:20\n   |\n22 |  \
    \           char = string[index];\n   |                    ^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpat98wf4v.rs:24:18\n\
    \   |\n24 |         string = &string[index..];\n   |                  ^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n24 |         string = (&string[index..]).to_string();\n   |           \
    \       +                +++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpat98wf4v.rs:27:5\n   |\n11 | fn make_palindrome(string: String) -> String\
    \ {\n   |                                       ------ expected `String` because\
    \ of return type\n...\n27 |     reversed_string\n   |     ^^^^^^^^^^^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 5 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    let\
    \ mut longest_postfix_index2 = 0;\n    let mut longest_postfix_index3 = 0;\n \
    \   let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5 =\
    \ 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut longest_postfix_index44 = 0;\n    let mut longest_postfix_index45\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp3v9v9aes.rs:59:36\n   |\n\
    59 |     let mut longest_postfix_index45\n   |                               \
    \     ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3v9v9aes.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_postfix = string;\n\
    \    let mut longest_postfix_len = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_end = 0;\n    let mut lon\n}\n\nfn main() {\n   \
    \ let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpaw7j3icf.rs:63:16\n   |\n\
    63 |     let mut lon\n   |                ^ help: add `;` here\n64 | }\n   | -\
    \ unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpaw7j3icf.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut suffix_length = 0;\n    let\
    \ mut prefix_length = 0;\n    while suffix_length != reversed_string.len() {\n\
    \        let mut suffix_start = 0;\n        let mut suffix_end = 0;\n        while\
    \ suffix_end != suffix_length {\n            suffix_end = suffix_start + 1;\n\
    \            let mut suffix_char = reversed_string[suffix_end];\n            while\
    \ suffix_end != suffix_length {\n                suffix_char = suffix_char.chars().next().unwrap();\n\
    \                suffix_end++;\n            }\n            if suffix_char == suffix_char.chars().next().unwrap()\
    \ {\n                suffix_start++;\n            } else {\n                break;\n\
    \            }\n        }\n        if suffix_start == suffix_end {\n         \
    \   suffix_length++;\n        } else {\n            break;\n        }\n    }\n\
    \    let mut prefix_start = 0;\n    let mut prefix_end = 0;\n    while prefix_end\
    \ != prefix_length {\n        prefix_end = prefix_start + 1;\n        let mut\
    \ prefix_char = reversed_string[prefix_end];\n        while prefix_end != prefix_length\
    \ {\n            prefix_char = prefix_char.chars().next().unwrap();\n        \
    \    prefix_end++;\n        }\n        if prefix_char == prefix_char.chars().next().unwrap()\
    \ {\n            prefix_start++;\n        } else {\n            break;\n     \
    \   }\n    }\n    reversed_string[prefix_start..prefix_end].to_owned()\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `+`\n  --> /tmp/tmpymhoj2bt.rs:23:28\n\
    \   |\n23 |                 suffix_end++;\n   |                            ^ expected\
    \ expression\n\nerror: expected expression, found `+`\n  --> /tmp/tmpymhoj2bt.rs:26:30\n\
    \   |\n26 |                 suffix_start++;\n   |                            \
    \  ^ expected expression\n\nerror: expected expression, found `+`\n  --> /tmp/tmpymhoj2bt.rs:32:27\n\
    \   |\n32 |             suffix_length++;\n   |                           ^ expected\
    \ expression\n\nerror: expected expression, found `+`\n  --> /tmp/tmpymhoj2bt.rs:44:24\n\
    \   |\n44 |             prefix_end++;\n   |                        ^ expected\
    \ expression\n\nerror: expected expression, found `+`\n  --> /tmp/tmpymhoj2bt.rs:47:26\n\
    \   |\n47 |             prefix_start++;\n   |                          ^ expected\
    \ expression\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpymhoj2bt.rs:20:35\n   |\n20 |             let mut suffix_char =\
    \ reversed_string[suffix_end];\n   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `{integer}`\n  --> /tmp/tmpymhoj2bt.rs:41:31\n   |\n41 |        \
    \ let mut prefix_char = reversed_string[prefix_end];\n   |                   \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \nerror: aborting due to 7 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix = \"\";\n    let mut longest_postfix_length = 0;\n    let mut\
    \ longest_postfix_index = 0;\n    let mut longest_postfix_length_index = 0;\n\
    \    let mut longest_postfix_index2 = 0;\n    let mut longest_postfix_length_index2\
    \ = 0;\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_length_index3\
    \ = 0;\n    let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_length_index4\
    \ = 0;\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_length_index5\
    \ = 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_length_index6\
    \ = 0;\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_length_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_length_index8\
    \ = 0;\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_length_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_length_index10\
    \ = 0;\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_length_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_length_index12\
    \ = 0;\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_length_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_length_index14\
    \ = 0;\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_length_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_length_index16\
    \ = 0;\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_length_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_length_index18\
    \ = 0;\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_length_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_length_index20\
    \ = 0;\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_length_index21\
    \ = 0;\n    let mut longest_\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpl6oqj21t.rs:58:21\n   |\n\
    58 |     let mut longest_\n   |                     ^ help: add `;` here\n59 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl6oqj21t.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut reversed_string_reversed =\
    \ string;\n    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length\
    \ = 0;\n    for index in 0..string.len() {\n        let mut current_char = &string[index];\n\
    \        let mut current_char_reversed = &string[string.len() - index - 1];\n\
    \        if current_char == current_char_reversed {\n            longest_postfix_length\
    \ = index + 1;\n            longest_postfix_index = index;\n        }\n      \
    \  if longest_postfix_length > reversed_string.len() {\n            reversed_string\
    \ = &string[longest_postfix_index..];\n            reversed_string_reversed =\
    \ &string[longest_postfix_index..];\n        }\n    }\n    longest_postfix_length\n\
    \        .to_string()\n        .into_owned()\n        + &string[longest_postfix_index..]\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpe1q2gxbh.rs:17:33\n\
    \   |\n17 |         let mut current_char = &string[index];\n   |             \
    \                    ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpe1q2gxbh.rs:18:42\n\
    \   |\n18 |         let mut current_char_reversed = &string[string.len() - index\
    \ - 1];\n   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe1q2gxbh.rs:24:31\n\
    \   |\n24 |             reversed_string = &string[longest_postfix_index..];\n\
    \   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n \
    \  |\n24 |             reversed_string = (&string[longest_postfix_index..]).to_string();\n\
    \   |                               +                                +++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpe1q2gxbh.rs:25:40\n   |\n25 |\
    \             reversed_string_reversed = &string[longest_postfix_index..];\n \
    \  |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n \
    \  |\n25 |             reversed_string_reversed = (&string[longest_postfix_index..]).to_string();\n\
    \   |                                        +                               \
    \ +++++++++++++\n\nerror[E0599]: no method named `into_owned` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpe1q2gxbh.rs:30:10\n   |\n30 | \
    \        .into_owned()\n   |          ^^^^^^^^^^ method not found in `String`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_palindrome = string;\n\
    \    let mut longest_palindrome_len = string.len();\n\n    while longest_palindrome_len\
    \ > 0 {\n        let mut longest_palindrome_start = longest_palindrome_len;\n\
    \        let mut longest_palindrome_end = longest_palindrome_len;\n\n        for\
    \ pos in longest_palindrome_start..longest_palindrome_end {\n            if longest_palindrome_start\
    \ == longest_palindrome_end {\n                longest_palindrome_start = longest_palindrome_start\
    \ + 1;\n                longest_palindrome_end = longest_palindrome_start + 1;\n\
    \                continue;\n            }\n\n            if longest_palindrome_start\
    \ > longest_palindrome_end {\n                longest_palindrome_start = longest_palindrome_start\
    \ + 1;\n                continue;\n            }\n\n            if longest_palindrome_start\
    \ == longest_palindrome_end {\n                longest_palindrome_end = longest_palindrome_end\
    \ - 1;\n                continue;\n            }\n\n            let mut current_char\
    \ = longest_palindrome_start..longest_palindrome_end;\n            let mut current_char_len\
    \ = longest_palindrome_end - longest_palindrome_start;\n\n            while current_char_len\
    \ > 0 {\n                let mut current_char_start = current_char[0];\n     \
    \           let mut current_char_end = current_char[current_char_len - 1];\n\n\
    \                while current_char_start < current_char_end {\n             \
    \       let mut current_char_char_start = current_char_start.chars();\n      \
    \              let mut current_char_char_end = current_char_end.chars();\n\n \
    \                   while current_char_char_start.next().unwrap() < current_char_char_end.next().unwrap()\
    \ {\n                        current_char_char_start.next().unwrap();\n      \
    \                  current_char_char_end.next().unwrap();\n                  \
    \  }\n\n                    current_char_char_start.next().unwrap();\n       \
    \             current_char_char_end.next().unwrap();\n\n                    current_char_char_start.next().unwrap();\n\
    \                    current_char_char_end.next().unwrap();\n\n              \
    \      current_char_char_start.next().unwrap();\n                    current_char_char_end.next().unwrap();\n\
    \n                    current_char_char_start.next().unwrap();\n             \
    \       current_char_char_end.next().unwrap();\n\n                    current_char_char_start.next().unwrap();\n\
    \                    current_char_char_end.next().unwrap();\n\n              \
    \      current_char_char_start.next().unwrap();\n                    current_char_char_end.next().unwrap();\n\
    \n                    current_char_char_start.next().unwrap();\n             \
    \       current_char_char_end.next().\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp4b2c8l90.rs:82:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n16 |     while longest_palindrome_len\
    \ > 0 {\n   |                                      - unclosed delimiter\n...\n\
    20 |         for pos in longest_palindrome_start..longest_palindrome_end {\n \
    \  |                                                                     - unclosed\
    \ delimiter\n...\n40 |             while current_char_len > 0 {\n   |        \
    \                                - unclosed delimiter\n...\n44 |             \
    \    while current_char_start < current_char_end {\n   |                     \
    \                                        - this delimiter might not be properly\
    \ closed...\n...\n73 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n82 | }\n   |   ^\n\nerror: unexpected token: `}`\n  --> /tmp/tmp4b2c8l90.rs:73:1\n\
    \   |\n73 | }\n   | ^\n\nerror[E0608]: cannot index into a value of type `std::ops::Range<usize>`\n\
    \  --> /tmp/tmp4b2c8l90.rs:41:46\n   |\n41 |                 let mut current_char_start\
    \ = current_char[0];\n   |                                              ^^^^^^^^^^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `std::ops::Range<usize>`\n \
    \ --> /tmp/tmp4b2c8l90.rs:42:44\n   |\n42 |                 let mut current_char_end\
    \ = current_char[current_char_len - 1];\n   |                                \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp4b2c8l90.rs:16:5\n   |\n11 |   fn make_palindrome(string: String)\
    \ -> String {\n   |                                         ------ expected `String`\
    \ because of return type\n...\n16 | /     while longest_palindrome_len > 0 {\n\
    17 | |         let mut longest_palindrome_start = longest_palindrome_len;\n18\
    \ | |         let mut longest_palindrome_end = longest_palindrome_len;\n19 | |\n\
    ...  |\n81 | |     assert_eq!(candidate(String::from(\"jerry\")), String::from(\"\
    jerryrrej\"));\n82 | | }\n   | |__^ expected struct `String`, found `("
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_postfix_len = string.len();\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_postfix = String::new();\n    let mut longest_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_start = -1;\n\
    \    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_start = -1;\n\
    \    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_start = -1;\n\
    \    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_start = -1;\n\
    \    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_start = -1;\n\
    \    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_start = -1;\n\
    \    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_start = -1;\n\
    \    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_start = -1;\n\
    \    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_start = -1;\n\
    \    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_start = -1;\n\
    \    let mut longest_postfix_postfix_end = -1;\n    let mut \n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpyylkxjen.rs:50:1\n\
    \   |\n50 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    while !string.is_empty() {\n        let mut\
    \ postfix_length = string.len();\n        while postfix_length >= longest_postfix_length\
    \ {\n            let mut postfix = string[..postfix_length];\n            let\
    \ mut reversed_postfix = reversed_string[..postfix_length];\n            reversed_postfix.reverse();\n\
    \            if postfix != reversed_postfix {\n                longest_postfix_length\
    \ = postfix_length;\n                string = string[..postfix_length];\n    \
    \            reversed_string = reversed_string[..postfix_length];\n          \
    \  }\n            postfix_length -= 1;\n        }\n        string += string[..longest_postfix_length];\n\
    \        reversed_string += reversed_string[..longest_postfix_length];\n    }\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmpony0yita.rs:18:17\n   |\n18 |             let mut postfix\
    \ = string[..postfix_length];\n   |                 ^^^^^^^^^^^ doesn't have a\
    \ size known at compile-time\n   |\n   = help: the trait `Sized` is not implemented\
    \ for `str`\n   = note: all local variables must have a statically known size\n\
    \   = help: unsized locals are gated as an unstable feature\nhelp: consider borrowing\
    \ here\n   |\n18 |             let mut postfix = &string[..postfix_length];\n\
    \   |                               +\n\nerror[E0599]: no method named `reverse`\
    \ found for type `str` in the current scope\n  --> /tmp/tmpony0yita.rs:20:30\n\
    \   |\n20 |             reversed_postfix.reverse();\n   |                    \
    \          ^^^^^^^ method not found in `str`\n\nerror[E0277]: the size for values\
    \ of type `str` cannot be known at compilation time\n  --> /tmp/tmpony0yita.rs:19:17\n\
    \   |\n19 |             let mut reversed_postfix = reversed_string[..postfix_length];\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n\
    \   |\n   = help: the trait `Sized` is not implemented for `str`\n   = note: all\
    \ local variables must have a statically known size\n   = help: unsized locals\
    \ are gated as an unstable feature\nhelp: consider borrowing here\n   |\n19 |\
    \             let mut reversed_postfix = &reversed_string[..postfix_length];\n\
    \   |                                        +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpony0yita.rs:23:26\n   |\n23 |                 string = string[..postfix_length];\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                          |\n   |              \
    \            expected struct `String`, found `str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpony0yita.rs:24:35\n   |\n24 |                 reversed_string\
    \ = reversed_string[..postfix_length];\n   |                                 \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |                                   |\n\
    \   |          "
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix = String::new();\n    let mut longest_postfix_length = 0;\n\
    \    let mut longest_postfix_index = 0;\n    while !string.is_empty() {\n    \
    \    let mut index = string.len();\n        while index > 0 {\n            let\
    \ mut char = string[index - 1];\n            reversed_string.push(char);\n   \
    \         index -= 1;\n        }\n        let mut index = longest_postfix_length;\n\
    \        while index > 0 {\n            let mut char = longest_postfix[index -\
    \ 1];\n            reversed_string.push(char);\n            index -= 1;\n    \
    \    }\n        let mut index = longest_postfix_length;\n        while index >\
    \ 0 {\n            let mut char = longest_postfix[index - 1];\n            reversed_string.push(char);\n\
    \            index -= 1;\n        }\n        let mut index = longest_postfix_length;\n\
    \        while index > 0 {\n            let mut char = longest_postfix[index -\
    \ 1];\n            reversed_string.push(char);\n            index -= 1;\n    \
    \    }\n        let mut index = longest_postfix_length;\n        while index >\
    \ 0 {\n            let mut char = longest_postfix[index - 1];\n            reversed_string.push(char);\n\
    \            index -= 1;\n        }\n        let mut index = longest_postfix_length;\n\
    \        while index > 0 {\n            let mut char = longest_postfix[index -\
    \ 1];\n            reversed_string.push(char);\n            index -= 1;\n    \
    \    }\n        let mut index = longest_postfix_length;\n        while index >\
    \ 0 {\n            let mut char = longest_postfix[index - 1];\n            reversed_string.push(char);\n\
    \            index -= 1;\n        }\n        let mut index = longest_postfix_length;\n\
    \        while index > 0 {\n            let mut char = longest_postfix[index -\
    \ 1];\n            reversed_string.push(char);\n            index -= 1;\n    \
    \    }\n        let mut index = longest_postfix_length;\n        while index >\
    \ 0 {\n            let mut char = longest_postfix[index - 1];\n            reversed_string.push(char);\n\
    \            index -= 1;\n        }\n        let mut index = longest_postfix_length;\n\
    \        while index > 0 {\n            let mut char = longest_postfix[index -\
    \ 1];\n            reversed_string.push(char);\n            index -= 1;\n    \
    \    }\n        let mut index = longest_postfix_length;\n        while index >\
    \ 0 {\n            let mut char = longest_postfix[index - 1];\n            reversed_string.push(char);\n\
    \            index -= 1;\n        }\n        let mut index = longest_postfix_length;\n\
    \        while index > 0 {\n            let mut char = longest_postfix\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpowzd_ocb.rs:96:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n17 |     while !string.is_empty()\
    \ {\n   |                              - unclosed delimiter\n...\n85 |       \
    \  while index > 0 {\n   |                         - this delimiter might not\
    \ be properly closed...\n86 |             let mut char = longest_postfix\n87 |\
    \ }\n   | - ...as it matches this but it has different indentation\n...\n96 |\
    \ }\n   |   ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpowzd_ocb.rs:86:43\n\
    \   |\n86 |             let mut char = longest_postfix\n   |                 \
    \                          ^ help: add `;` here\n87 | }\n   | - unexpected token\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpowzd_ocb.rs:20:28\n\
    \   |\n20 |             let mut char = string[index - 1];\n   |              \
    \              ^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0599]:\
    \ no method named `push` found for reference `&str` in the current scope\n  -->\
    \ /tmp/tmpowzd_ocb.rs:21:29\n   |\n21 |             reversed_string.push(char);\n\
    \   |                             ^^^^ method not found in `&str`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpowzd_ocb.rs:26:28\n\
    \   |\n26 |             let mut char = longest_postfix[index - 1];\n   |     \
    \                       ^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n\nerror[E0599]: no method named `push` found for reference `&str`\
    \ in the current scope\n  --> /tmp/tmpowzd_ocb.rs:27:29\n   |\n27 |          \
    \   reversed_string.push(char);\n   |                             ^^^^ method\
    \ not found in `&str`\n\nerror[E0277]: the type `String` cannot be indexed by\
    \ `{integer}`\n  --> /tmp/tmpowzd_ocb.rs:32:28\n   |\n32 |             let mut\
    \ char = longest_postfix[index - 1];"
  stdout: ''
  timestamp: 1659805826
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut palindrome = string;\n   \
    \ let mut prefix_length = 0;\n    while !reversed_string.starts_with(palindrome)\
    \ {\n        let mut prefix_length = prefix_length + 1;\n        if prefix_length\
    \ > string.len() {\n            break;\n        }\n        palindrome = &string[prefix_length..];\n\
    \    }\n    palindrome = &string[prefix_length..];\n    reversed_string.push_str(&palindrome);\n\
    \    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n  -->\
    \ /tmp/tmpaubfacqq.rs:15:40\n   |\n15 |     while !reversed_string.starts_with(palindrome)\
    \ {\n   |                                        ^^^^^^^^^^\n   |            \
    \                            |\n   |                                        expected\
    \ an implementor of trait `Pattern<'_>`\n   |                                \
    \        help: consider borrowing here: `&palindrome`\n   |\n   = note: the trait\
    \ bound `String: Pattern<'_>` is not satisfied\n   = note: required because of\
    \ the requirements on the impl of `Pattern<'_>` for `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpaubfacqq.rs:20:22\n   |\n20 |         palindrome\
    \ = &string[prefix_length..];\n   |                      ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n20 |         palindrome = (&string[prefix_length..]).to_string();\n   |\
    \                      +                        +++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpaubfacqq.rs:22:18\n   |\n22 |     palindrome\
    \ = &string[prefix_length..];\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n22 |     palindrome = (&string[prefix_length..]).to_string();\n   |   \
    \               +                        +++++++++++++\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut prefix_length = 0;\n    let\
    \ mut suffix_length = 0;\n    while !reversed_string.is_empty() {\n        let\
    \ mut current_char = reversed_string.chars().next().unwrap();\n        if current_char\
    \ == &mut 'a' {\n            prefix_length += 1;\n        }\n        if current_char\
    \ == &mut 'z' {\n            suffix_length += 1;\n        }\n        if current_char\
    \ == &mut 'A' {\n            prefix_length += 1;\n        }\n        if current_char\
    \ == &mut 'Z' {\n            suffix_length += 1;\n        }\n        if current_char\
    \ == &mut '0' {\n            suffix_length += 1;\n        }\n        if current_char\
    \ == &mut '9' {\n            suffix_length += 1;\n        }\n        if current_char\
    \ == &mut '.' {\n            suffix_length += 1;\n        }\n        if current_char\
    \ == &mut '_' {\n            suffix_length += 1;\n        }\n        if current_char\
    \ == &mut '-' {\n            suffix_length += 1;\n        }\n        if current_char\
    \ == &mut '+' {\n            suffix_length += 1;\n        }\n        if current_char\
    \ == &mut '/' {\n            suffix_length += 1;\n        }\n        if current_char\
    \ == &mut '*' {\n            suffix_length += 1;\n        }\n        if current_char\
    \ == &mut '+' {\n            suffix_length += 1;\n        }\n        if current_char\
    \ == &mut '-' {\n            suffix_length += 1;\n        }\n        if current_char\
    \ == &mut '_' {\n            suffix_length += 1;\n        }\n        if current_char\
    \ == &mut '.' {\n            suffix_length += 1;\n        }\n        if current_char\
    \ == &mut '0' {\n            suffix_length += 1;\n        }\n        if current_char\
    \ == &mut '9' {\n            suffix_length += 1;\n        }\n        if current_char\
    \ == &mut 'A' {\n            suffix_length += 1;\n        }\n        if current_char\
    \ == &mut 'Z' {\n            suffix_length += 1;\n        }\n        if current_char\
    \ == &mut 'a' {\n            suffix_length += 1;\n        }\n        if current_char\
    \ == &mut 'z' {\n            suffix_length += 1;\n        }\n        if current_char\
    \ == &mut '0' {\n            suffix_length += \n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpknselxfx.rs:94:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n15 |     while !reversed_string.is_empty()\
    \ {\n   |                                       - unclosed delimiter\n...\n83\
    \ |         if current_char == &mut '0' {\n   |                              \
    \       - this delimiter might not be properly closed...\n84 |             suffix_length\
    \ += \n85 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n94 | }\n   |   ^\n\nerror: expected expression, found `}`\n  --> /tmp/tmpknselxfx.rs:85:1\n\
    \   |\n85 | }\n   | ^ expected expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpknselxfx.rs:17:28\n   |\n17 |         if current_char == &mut 'a'\
    \ {\n   |                            ^^^^^^^^ expected `char`, found `&mut char`\n\
    \   |\nhelp: consider removing the borrow\n   |\n17 -         if current_char\
    \ == &mut 'a' {\n17 +         if current_char == 'a' {\n   | \n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpknselxfx.rs:20:28\n   |\n20 |         if current_char\
    \ == &mut 'z' {\n   |                            ^^^^^^^^ expected `char`, found\
    \ `&mut char`\n   |\nhelp: consider removing the borrow\n   |\n20 -         if\
    \ current_char == &mut 'z' {\n20 +         if current_char == 'z' {\n   | \n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpknselxfx.rs:23:28\n   |\n23 |  \
    \       if current_char == &mut 'A' {\n   |                            ^^^^^^^^\
    \ expected `char`, found `&mut char`\n   |\nhelp: consider removing the borrow\n\
    \   |\n23 -         if current_char == &mut 'A' {\n23 +         if current_char\
    \ == 'A' {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpknselxfx.rs:26:28\n\
    \   |\n26 |         if current_char == &mut 'Z' {\n   |                      \
    \      ^^^^^^^^ expected `char`, found `&mut char`\n   |\nhelp: consider removing\
    \ the borrow\n   |\n26 -         if current_char == &mut 'Z' {\n26 +         if\
    \ current_char == 'Z' {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpknselxfx.rs:29:28\n\
    \   |\n29 |     "
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    let\
    \ mut longest_postfix_index2 = 0;\n    let mut longest_postfix_index3 = 0;\n \
    \   let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5 =\
    \ 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut longest_postfix_index44 = 0;\n    let mut longest_postfix_index45\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp3v9v9aes.rs:59:36\n   |\n\
    59 |     let mut longest_postfix_index45\n   |                               \
    \     ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3v9v9aes.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    while\
    \ longest_postfix_length < string.len() {\n        let mut postfix_length = longest_postfix_length;\n\
    \        let mut postfix_index = 0;\n        while postfix_length < string.len()\
    \ {\n            let mut postfix_char = string[postfix_index];\n            let\
    \ mut postfix_char_length = postfix_char.len();\n            while postfix_char_length\
    \ >= longest_postfix_length {\n                postfix_char_length -= longest_postfix_length;\n\
    \                postfix_index += longest_postfix_length;\n            }\n   \
    \         if postfix_char_length == 0 {\n                break;\n            }\n\
    \            let mut postfix_char = string[postfix_index];\n            let mut\
    \ postfix_char_length = postfix_char.len();\n            while postfix_char_length\
    \ >= longest_postfix_length {\n                postfix_char_length -= longest_postfix_length;\n\
    \                postfix_index += longest_postfix_length;\n            }\n   \
    \         if postfix_char_length == 0 {\n                break;\n            }\n\
    \            reversed_string += postfix_char;\n            postfix_length += 1;\n\
    \        }\n        if postfix_length == 0 {\n            break;\n        }\n\
    \        longest_postfix_length = postfix_length;\n        longest_postfix_index\
    \ += 1;\n    }\n    string += reversed_string;\n    string\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmposqzvg13.rs:20:36\n   |\n20 |             let mut postfix_char = string[postfix_index];\n\
    \   |                                    ^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmposqzvg13.rs:29:36\n   |\n29 |             let mut\
    \ postfix_char = string[postfix_index];\n   |                                \
    \    ^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805826
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut reversed_string_len = string.len();\n\
    \    let mut palindrome = string;\n    let mut palindrome_len = string.len();\n\
    \    while reversed_string_len > 0 {\n        let mut current_char = reversed_string[reversed_string_len\
    \ - 1];\n        reversed_string[reversed_string_len - 1] = reversed_string[0];\n\
    \        reversed_string[0] = current_char;\n        reversed_string_len -= 1;\n\
    \        palindrome_len -= 1;\n        while palindrome_len > 0 {\n          \
    \  let mut current_char = palindrome[palindrome_len - 1];\n            palindrome[palindrome_len\
    \ - 1] = palindrome[0];\n            palindrome[0] = current_char;\n         \
    \   palindrome_len -= 1;\n        }\n    }\n    palindrome\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpvwjhn_41.rs:17:32\n\
    \   |\n17 |         let mut current_char = reversed_string[reversed_string_len\
    \ - 1];\n   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpvwjhn_41.rs:18:9\n   |\n18 |         reversed_string[reversed_string_len\
    \ - 1] = reversed_string[0];\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `{integer}`\n  --> /tmp/tmpvwjhn_41.rs:18:52\n   |\n18 |        \
    \ reversed_string[reversed_string_len - 1] = reversed_string[0];\n   |       \
    \                                             ^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `{integer}`\n  --> /tmp/tmpvwjhn_41.rs:19:9\n   |\n19 |         reversed_string[0]\
    \ = current_char;\n   |         ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpvwjhn_41.rs:23:36\n   |\n23 |             let mut current_char\
    \ = palindrome[palindrome_len - 1];\n   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpvwjhn_41.rs:24:13\n   |\n24 |            \
    \ palindrome[palindrome_len - 1] = palindrome[0];\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `Str"
  stdout: ''
  timestamp: 1659805826
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut reversed_string_len = string.len();\n\
    \    while reversed_string_len > 0 {\n        reversed_string.swap(0, reversed_string_len\
    \ - 1); // reverse the string\n        reversed_string_len -= 1;\n    }\n    reversed_string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmplnkh8tmp.rs:15:25\n   |\n15 |         reversed_string.swap(0,\
    \ reversed_string_len - 1); // reverse the string\n   |                      \
    \   ^^^^ method not found in `String`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659805826
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reverse = string;\n    let mut i =\
    \ 0;\n    while i < string.len() {\n        if string[i] != string[string.len()\
    \ - 1 - i] {\n            break;\n        }\n        reverse.push_str(&string[..i]);\n\
    \        i += 1;\n    }\n    reverse.push_str(&string[..i]);\n    reverse\n}\n\
    \nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp5_7t7tzj.rs:16:12\n\
    \   |\n16 |         if string[i] != string[string.len() - 1 - i] {\n   |     \
    \       ^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmp5_7t7tzj.rs:16:25\n   |\n\
    16 |         if string[i] != string[string.len() - 1 - i] {\n   |            \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805826
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_palindrome = 0;\n    let mut longest_palindrome_length = 0;\n    let\
    \ mut longest_palindrome_start = 0;\n    let mut longest_palindrome_end = 0;\n\
    \    let mut longest_palindrome_suffix = 0;\n    let mut longest_palindrome_suffix_length\
    \ = 0;\n    let mut longest_palindrome_suffix_start = 0;\n    let mut longest_palindrome_suffix_end\
    \ = 0;\n    let mut longest_palindrome_suffix_suffix = 0;\n    let mut longest_palindrome_suffix_suffix_length\
    \ = 0;\n    let mut longest_palindrome_suffix_suffix_start = 0;\n    let mut longest_palindrome_suffix_suffix_end\
    \ = 0;\n    let mut longest_palindrome_suffix_suffix_suffix = 0;\n    let mut\
    \ longest_palindrome_suffix_suffix_suffix_length = 0;\n    let mut longest_palindrome_suffix_suffix_suffix_start\
    \ = 0;\n    let mut longest_palindrome_suffix_suffix_suffix_end = 0;\n    let\
    \ mut longest_palindrome_suffix_suffix_suffix_suffix = 0;\n    let mut longest_palindrome_suffix_suffix_suffix_suffix_length\
    \ = 0;\n    let mut longest_palindrome_suffix_suffix_suffix_suffix_start = 0;\n\
    \    let mut longest_palindrome_suffix_suffix_suffix_suffix_end = 0;\n    let\
    \ mut longest_palindrome_suffix_suffix_suffix_suffix_suffix = 0;\n    let mut\
    \ longest_palindrome_suffix_suffix_suffix_suffix_suffix_length = 0;\n    let mut\
    \ longest_palindrome_suffix_suffix_suffix_suffix_suffix_start = 0;\n    let mut\
    \ longest_palindrome_suffix_suffix_suffix_suffix_suffix_end = 0;\n    let mut\
    \ longest_palindrome_suffix_suffix_suffix_suffix_suffix_suffix = 0;\n    let mut\
    \ longest_palindrome_suffix_suffix_suffix_suffix_suffix_suffix_length = 0;\n \
    \   let mut longest_palindrome_suffix_suffix_suffix_suffix_suffix_suffix_suffix_start\
    \ = 0;\n    let mut longest_palindrome_suffix_suffix_suffix_suffix_suffix_suffix_suffix_end\
    \ = 0;\n    let mut \n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpah580_q8.rs:43:1\n\
    \   |\n43 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    let\
    \ mut longest_postfix_index2 = 0;\n    let mut longest_postfix_index3 = 0;\n \
    \   let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5 =\
    \ 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut longest_postfix_index44 = 0;\n    let mut longest_postfix_index45\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp3v9v9aes.rs:59:36\n   |\n\
    59 |     let mut longest_postfix_index45\n   |                               \
    \     ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3v9v9aes.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_postfix = string;\n\
    \    let mut longest_postfix_len = 0;\n    let mut longest_postfix_start = -1;\n\
    \    for pos in string.char_indices() {\n        let mut postfix = &mut reversed_string[..pos];\n\
    \        let mut postfix_len = postfix.len();\n        if longest_postfix_len\
    \ < postfix_len {\n            longest_postfix_len = postfix_len;\n          \
    \  longest_postfix_start = pos;\n        }\n        if postfix.is_palindrome()\
    \ {\n            postfix.reverse();\n        }\n        longest_postfix = postfix.to_owned();\n\
    \    }\n    let mut postfix = &mut reversed_string[longest_postfix_start..];\n\
    \    let mut postfix_len = longest_postfix_len;\n    if longest_postfix_len >\
    \ 0 {\n        postfix.reverse();\n    }\n    longest_postfix = postfix.to_owned();\n\
    \    longest_postfix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `RangeTo<(usize, char)>`\n\
    \  --> /tmp/tmpoab9v2o_.rs:17:32\n   |\n17 |         let mut postfix = &mut reversed_string[..pos];\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `RangeTo<(usize, char)>`\n   |\n   = help: the trait `Index<RangeTo<(usize,\
    \ char)>>` is not implemented for `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpoab9v2o_.rs:21:37\n   |\n21 |             longest_postfix_start\
    \ = pos;\n   |                                     ^^^ expected integer, found\
    \ tuple\n   |\n   = note: expected type `{integer}`\n             found tuple\
    \ `(usize, char)`\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmpoab9v2o_.rs:15:37\n   |\n15 |     let mut longest_postfix_start\
    \ = -1;\n   |                                     ^^ the trait `Neg` is not implemented\
    \ for `usize`\n\nerror[E0599]: no method named `reverse` found for mutable reference\
    \ `&mut str` in the current scope\n  --> /tmp/tmpoab9v2o_.rs:31:17\n   |\n31 |\
    \         postfix.reverse();\n   |                 ^^^^^^^ method not found in\
    \ `&mut str`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805826
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reverse = string;\n    let mut i =\
    \ 0;\n    while i < string.len() {\n        let mut j = i;\n        while j +\
    \ 1 < string.len() {\n            if string[j] != string[j + 1] {\n          \
    \      break;\n            }\n            i += 1;\n            j += 1;\n     \
    \   }\n        if j == i {\n            break;\n        }\n        reverse.push_str(&string[i..j]);\n\
    \        i += 1;\n    }\n    reverse\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp55j1qube.rs:18:16\n\
    \   |\n18 |             if string[j] != string[j + 1] {\n   |                ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmp55j1qube.rs:18:29\n   |\n18 |            \
    \ if string[j] != string[j + 1] {\n   |                             ^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805826
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_postfix = string;\n\
    \    let mut longest_postfix_length = 0;\n    let mut longest_postfix_index =\
    \ 0;\n    while longest_postfix_length < longest_postfix.len() {\n        let\
    \ mut longest_postfix_length = longest_postfix.len();\n        let mut longest_postfix_index\
    \ = 0;\n        while longest_postfix_length < longest_postfix.len() {\n     \
    \       let mut longest_postfix_length = longest_postfix.len();\n            let\
    \ mut longest_postfix_index = 0;\n            while longest_postfix_length < longest_postfix.len()\
    \ {\n                let mut longest_postfix_length = longest_postfix.len();\n\
    \                let mut longest_postfix_index = 0;\n                while longest_postfix_length\
    \ < longest_postfix.len() {\n                    let mut longest_postfix_length\
    \ = longest_postfix.len();\n                    let mut longest_postfix_index\
    \ = 0;\n                    while longest_postfix_length < longest_postfix.len()\
    \ {\n                        let mut longest_postfix_length = longest_postfix.len();\n\
    \                        let mut longest_postfix_index = 0;\n                \
    \        while longest_postfix_length < longest_postfix.len() {\n            \
    \                let mut longest_postfix_length = longest_postfix.len();\n   \
    \                         let mut longest_postfix_index = 0;\n               \
    \             while longest_postfix_length < longest_postfix.len() {\n       \
    \                         let mut longest_postfix_length = longest_postfix.len();\n\
    \                                let mut longest_postfix_index = 0;\n        \
    \                        while longest_postfix_length < longest_postfix.len()\
    \ {\n                                    let mut longest_postfix_length = longest_postfix.len();\n\
    \                                    let mut longest_postfix_index = 0;\n    \
    \                                while longest_postfix_length < longest_postfix.len()\
    \ {\n                                        let mut longest_postfix_length =\
    \ longest_postfix.len();\n                                        let mut longest_postfix_index\
    \ = 0;\n                                    }\n                              \
    \  }\n                            }\n                        }\n             \
    \       }\n                }\n            }\n        }\n    }\n    longest_postfix.reverse();\n\
    \    longest_postfix.append(&reversed_string[longest_postfix_index..]);\n    longest_postfix\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpavqz4_xw.rs:52:21\n   |\n52 |     longest_postfix.reverse();\n\
    \   |                     ^^^^^^^ help: there is an associated function with a\
    \ similar name: `reserve`\n\nerror[E0599]: no method named `append` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmpavqz4_xw.rs:53:21\n   |\n\
    53 |     longest_postfix.append(&reversed_string[longest_postfix_index..]);\n\
    \   |                     ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659805826
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_postfix_len = string.len();\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_postfix = String::new();\n    let mut longest_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_start = -1;\n\
    \    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_start = -1;\n\
    \    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_start = -1;\n\
    \    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_start = -1;\n\
    \    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_start = -1;\n\
    \    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_start = -1;\n\
    \    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_start = -1;\n\
    \    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_start = -1;\n\
    \    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_start = -1;\n\
    \    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = String::new();\n    let mut longest_postfix_postfix_postfix_start = -1;\n\
    \    let mut longest_postfix_postfix_end = -1;\n    let mut \n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpyylkxjen.rs:50:1\n\
    \   |\n50 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_palindrome = 0;\n    let mut longest_palindrome_length = 0;\n    let\
    \ mut longest_palindrome_suffix = 0;\n    let mut longest_palindrome_suffix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_length = 0;\n    let mut longest_palindrome_prefix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_length = 0;\n    let mut longest_palindrome_prefix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_length = 0;\n    let mut longest_palindrome_prefix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_length = 0;\n    let mut longest_palindrome_prefix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_length = 0;\n    let mut longest_palindrome_prefix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_length = 0;\n    let mut longest_palindrome_prefix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_length = 0;\n    let mut longest_palindrome_prefix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_length = 0;\n    let mut longest_palindrome_prefix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_length = 0;\n    let mut longest_palindrome_prefix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_length = 0;\n    let mut longest_palindrome_prefix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_length = 0;\n    let mut longest_palindrome_prefix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_length = 0;\n    let mut longest_palindrome_prefix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_length = 0;\n    let mut longest_palindrome_prefix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_length = 0;\n    let mut longest_palindrome_prefix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_length = 0;\n    let mut longest_palindrome_prefix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_length = 0;\n    let mut longest_palindrome_prefix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_length = 0;\n    let mut longest_palindrome_prefix_length\
    \ = 0;\n    let mut longest_palin\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvidl1jt8.rs:52:26\n   |\n\
    52 |     let mut longest_palin\n   |                          ^ help: add `;`\
    \ here\n53 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpvidl1jt8.rs:11:39\n   |\n11 | fn make_palindrome(string: String) ->\
    \ String {\n   |    ---------------                    ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805826
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    let\
    \ mut longest_postfix_char = 0;\n    let mut longest_postfix_char_length = 0;\n\
    \    let mut longest_postfix_char_length_index = 0;\n    let mut longest_postfix_char_length_index_index\
    \ = 0;\n    let mut longest_postfix_char_length_index_index_index = 0;\n    let\
    \ mut longest_postfix_char_length_index_index_index_index = 0;\n    let mut longest_postfix_char_length_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_char_length_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_char_length_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_char_length_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_char_length_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_char_length_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_char_length_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_char_length_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_char_length_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_char_length_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_char_length_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_char_length_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_char_length_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_char_length_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_char_length_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_char_length_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_char_length_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_char_length_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_char_length_index_index_index_index_\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp279k7ebj.rs:40:65\n   |\n\
    40 |     let mut longest_postfix_char_length_index_index_index_index_\n   |  \
    \                                                               ^ help: add `;`\
    \ here\n41 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp279k7ebj.rs:11:39\n   |\n11 | fn make_palindrome(string: String) ->\
    \ String {\n   |    ---------------                    ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805826
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    let\
    \ mut longest_postfix_char: char;\n    let mut longest_postfix_char_length = 0;\n\
    \    let mut longest_postfix_char_length_index = 0;\n    let mut longest_postfix_char_length_index2\
    \ = 0;\n    let mut longest_postfix_char_length_index3 = 0;\n    let mut longest_postfix_char_length_index4\
    \ = 0;\n    let mut longest_postfix_char_length_index5 = 0;\n    let mut longest_postfix_char_length_index6\
    \ = 0;\n    let mut longest_postfix_char_length_index7 = 0;\n    let mut longest_postfix_char_length_index8\
    \ = 0;\n    let mut longest_postfix_char_length_index9 = 0;\n    let mut longest_postfix_char_length_index10\
    \ = 0;\n    let mut longest_postfix_char_length_index11 = 0;\n    let mut longest_postfix_char_length_index12\
    \ = 0;\n    let mut longest_postfix_char_length_index13 = 0;\n    let mut longest_postfix_char_length_index14\
    \ = 0;\n    let mut longest_postfix_char_length_index15 = 0;\n    let mut longest_postfix_char_length_index16\
    \ = 0;\n    let mut longest_postfix_char_length_index17 = 0;\n    let mut longest_postfix_char_length_index18\
    \ = 0;\n    let mut longest_postfix_char_length_index19 = 0;\n    let mut longest_postfix_char_length_index20\
    \ = 0;\n    let mut longest_postfix_char_length_index21 = 0;\n    let mut longest_postfix_char_length_index22\
    \ = 0;\n    let mut longest_postfix_char_length_index23 = 0;\n    let mut longest_postfix_char_length_index24\
    \ = 0;\n    let mut longest_postfix_char_length_index25 = 0;\n    let mut longest_postfix_char_length_index26\
    \ = 0;\n    let mut longest_postfix_char_length_index27 = 0;\n    let mut longest_postfix_char_length_index28\
    \ = 0;\n    let mut longest_postfix_char_length_index29 = 0;\n    let mut longest_postfix_char_length_index30\
    \ = 0;\n    let mut longest_postfix_char_length_index31 = 0;\n    let mut longest_postfix_char_length_index32\
    \ = 0;\n    let mut longest_postfix_char_length_index33 = 0;\n    let mut longest_postfix_char_length_index34\
    \ = 0;\n    let mut longest_postfix_char_length_index35 = 0;\n    let mut longest_\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp3n82f11x.rs:53:21\n   |\n\
    53 |     let mut longest_\n   |                     ^ help: add `;` here\n54 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3n82f11x.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805825
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n\n    while\
    \ !string.is_empty() {\n        let mut index = string.len() - 1;\n        let\
    \ mut char = string[index];\n\n        while index >= 0 {\n            if char\
    \ == string[index] {\n                index -= 1;\n            } else {\n    \
    \            break;\n            }\n        }\n\n        reversed_string.insert(0,\
    \ char);\n        string = &string[index..];\n    }\n\n    string + reversed_string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp2h2v2_9j.rs:17:24\n\
    \   |\n17 |         let mut char = string[index];\n   |                      \
    \  ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmp2h2v2_9j.rs:20:24\n   |\n20 |  \
    \           if char == string[index] {\n   |                        ^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0599]: no method named `insert` found\
    \ for reference `&str` in the current scope\n  --> /tmp/tmp2h2v2_9j.rs:27:25\n\
    \   |\n27 |         reversed_string.insert(0, char);\n   |                   \
    \      ^^^^^^ method not found in `&str`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp2h2v2_9j.rs:28:18\n   |\n28 |         string = &string[index..];\n\
    \   |                  ^^^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n\
    \   |\nhelp: try using a conversion method\n   |\n28 |         string = (&string[index..]).to_string();\n\
    \   |                  +                +++++++++++++\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805826
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_postfix = string;\n\
    \    let mut longest_postfix_length = 0;\n    let mut longest_postfix_index =\
    \ 0;\n    let mut longest_postfix_index2 = 0;\n    let mut longest_postfix_index3\
    \ = 0;\n    let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5\
    \ = 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut longest_postfix_index44 = 0;\n    let mut longest_\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpelw38971.rs:59:21\n   |\n\
    59 |     let mut longest_\n   |                     ^ help: add `;` here\n60 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpelw38971.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805826
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = string;\n    let\
    \ mut longest_postfix_index = 0;\n    let mut longest_postfix_length = 0;\n  \
    \  let mut longest_postfix_string = \"\";\n    let mut longest_postfix_reversed_string\
    \ = \"\";\n\n    while !string.is_empty() {\n        let mut postfix_index = string.rfind('\
    \ ').unwrap();\n        let mut postfix_length = string.len() - postfix_index;\n\
    \        let mut postfix_string = string;\n        let mut postfix_reversed_string\
    \ = \"\";\n\n        while !postfix_string.is_empty() {\n            let mut postfix_reversed_string\
    \ = postfix_string;\n            let mut postfix_reversed_index = postfix_string.rfind('\
    \ ').unwrap();\n            let mut postfix_reversed_length = postfix_string.len()\
    \ - postfix_reversed_index;\n\n            while postfix_reversed_length > longest_postfix_length\
    \ {\n                longest_postfix_length = postfix_reversed_length;\n     \
    \           longest_postfix_index = postfix_reversed_index;\n                longest_postfix_string\
    \ = postfix_string;\n                longest_postfix_reversed_string = postfix_reversed_string;\n\
    \                postfix_reversed_index += 1;\n                postfix_reversed_length\
    \ -= 1;\n            }\n\n            postfix_reversed_string += &string[postfix_reversed_index..postfix_reversed_index\
    \ + 1];\n            postfix_length -= 1;\n            postfix_string += &string[postfix_index..postfix_index\
    \ + 1];\n        }\n\n        longest_postfix_index += 1;\n        longest_postfix_length\
    \ += 1;\n        longest_postfix_string += &string[longest_postfix_index..longest_postfix_index\
    \ + 1];\n        longest_postfix_reversed_string += &string[longest_postfix_reversed_index..longest_postfix_reversed_index\
    \ + 1];\n        string += &string[longest_postfix_index..];\n    }\n\n    longest_postfix_reversed_string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `longest_postfix_reversed_index` in this\
    \ scope\n  --> /tmp/tmpejn980hg.rs:47:52\n   |\n47 |         longest_postfix_reversed_string\
    \ += &string[longest_postfix_reversed_index..longest_postfix_reversed_index +\
    \ 1];\n   |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `longest_postfix_reversed_string`\n\
    \nerror[E0425]: cannot find value `longest_postfix_reversed_index` in this scope\n\
    \  --> /tmp/tmpejn980hg.rs:47:84\n   |\n47 |         longest_postfix_reversed_string\
    \ += &string[longest_postfix_reversed_index..longest_postfix_reversed_index +\
    \ 1];\n   |                                                                  \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a local variable with\
    \ a similar name exists: `longest_postfix_reversed_string`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpejn980hg.rs:33:42\n   |\n33 |                 longest_postfix_string\
    \ = postfix_string;\n   |                                          ^^^^^^^^^^^^^^\n\
    \   |                                          |\n   |                       \
    \                   expected `&str`, found struct `String`\n   |             \
    \                             help: consider borrowing here: `&postfix_string`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpejn980hg.rs:34:51\n   |\n34 |\
    \                 longest_postfix_reversed_string = postfix_reversed_string;\n\
    \   |                                                   ^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                                                   |\n   |              \
    \                                     expected `&str`, found struct `String`\n\
    \   |                                                   help: consider borrowing\
    \ here: `&postfix_reversed_string`\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `&str`\n  --> /tmp/tmpejn980hg.rs:46:9\n   |\n\
    46 |         longest_postfix_string += &string[longest_postfix_index..longest_postfix_index\
    \ + 1];\n   |         ----------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659805826
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n\n    while\
    \ !string.is_empty() {\n        let mut index = string.len() - 1;\n        let\
    \ mut char = string[index];\n\n        while index >= 0 {\n            reversed_string\
    \ += char;\n            index -= 1;\n            char = string[index];\n     \
    \   }\n\n        string = string.clone();\n        reversed_string += char;\n\
    \    }\n\n    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsdjskxpd.rs:17:24\n\
    \   |\n17 |         let mut char = string[index];\n   |                      \
    \  ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpsdjskxpd.rs:20:13\n\
    \   |\n20 |             reversed_string += char;\n   |             ---------------^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `&str`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsdjskxpd.rs:22:20\n\
    \   |\n22 |             char = string[index];\n   |                    ^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `&str`\n  --> /tmp/tmpsdjskxpd.rs:26:9\n   |\n\
    26 |         reversed_string += char;\n   |         ---------------^^^^^^^^\n\
    \   |         |\n   |         cannot use `+=` on type `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsdjskxpd.rs:29:5\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |                                       ------ expected\
    \ `String` because of return type\n...\n29 |     reversed_string\n   |     ^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 5 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805826
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix = \"\";\n    let mut longest_postfix_len = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start2\
    \ = 0;\n    let mut longest_postfix_end2 = 0;\n    let mut longest_postfix_start3\
    \ = 0;\n    let mut longest_postfix_end3 = 0;\n    let mut longest_postfix_start4\
    \ = 0;\n    let mut longest_postfix_end4 = 0;\n    let mut longest_postfix_start5\
    \ = 0;\n    let mut longest_postfix_end5 = 0;\n    let mut longest_postfix_start6\
    \ = 0;\n    let mut longest_postfix_end6 = 0;\n    let mut longest_postfix_start7\
    \ = 0;\n    let mut longest_postfix_end7 = 0;\n    let mut longest_postfix_start8\
    \ = 0;\n    let mut longest_postfix_end8 = 0;\n    let mut longest_postfix_start9\
    \ = 0;\n    let mut longest_postfix_end9 = 0;\n    let mut longest_postfix_start10\
    \ = 0;\n    let mut longest_postfix_end10 = 0;\n    let mut longest_postfix_start11\
    \ = 0;\n    let mut longest_postfix_end11 = 0;\n    let mut longest_postfix_start12\
    \ = 0;\n    let mut longest_postfix_end12 = 0;\n    let mut longest_postfix_start13\
    \ = 0;\n    let mut longest_postfix_end13 = 0;\n    let mut longest_postfix_start14\
    \ = 0;\n    let mut longest_postfix_end14 = 0;\n    let mut longest_postfix_start15\
    \ = 0;\n    let mut longest_postfix_end15 = 0;\n    let mut longest_postfix_start16\
    \ = 0;\n    let mut longest_postfix_end16 = 0;\n    let mut longest_postfix_start17\
    \ = 0;\n    let mut longest_postfix_end17 = 0;\n    let mut longest_postfix_start18\
    \ = 0;\n    let mut longest_postfix_end18 = 0;\n    let mut longest_postfix_start19\
    \ = 0;\n    let mut longest_postfix_end19 = 0;\n    let mut longest_postfix_start20\
    \ = 0;\n    let mut longest_postfix_end20 = 0;\n    let mut longest_postfix_start21\
    \ = 0;\n    let mut longest_postfix_end21 = 0;\n    let mut longest_postfix_start22\
    \ = 0;\n    let mut longest_postfix_end22 = 0;\n    let mut lon\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9sdd_9qv.rs:60:16\n   |\n\
    60 |     let mut lon\n   |                ^ help: add `;` here\n61 | }\n   | -\
    \ unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9sdd_9qv.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805826
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reverse = string;\n    let mut i =\
    \ 0;\n    while i < string.len() {\n        let mut j = i;\n        while j +\
    \ 1 < string.len() && string[j] == string[j + 1] {\n            j += 1;\n    \
    \    }\n        reverse = reverse.insert(j, string[i]);\n        i += 1;\n   \
    \ }\n    reverse\n}\n\nfn main() {\n    let candidate = make_palindrome;\n   \
    \ assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpr59dw9fj.rs:17:39\n\
    \   |\n17 |         while j + 1 < string.len() && string[j] == string[j + 1] {\n\
    \   |                                       ^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n \
    \ --> /tmp/tmpr59dw9fj.rs:17:52\n   |\n17 |         while j + 1 < string.len()\
    \ && string[j] == string[j + 1] {\n   |                                      \
    \              ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpr59dw9fj.rs:20:37\n\
    \   |\n20 |         reverse = reverse.insert(j, string[i]);\n   |            \
    \                         ^^^^^^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpr59dw9fj.rs:20:19\n   |\n20 |         reverse\
    \ = reverse.insert(j, string[i]);\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `()`\n   |\nnote: method `insert` modifies its\
    \ receiver in-place\n  --> /tmp/tmpr59dw9fj.rs:20:27\n   |\n20 |         reverse\
    \ = reverse.insert(j, string[i]);\n   |                   ------- ^^^^^^ this\
    \ call modifies `reverse` in-place\n   |                   |\n   |           \
    \        you probably want to use this value after calling the method...\n   =\
    \ note: ...instead of the `()` output of method `insert`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805826
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    let\
    \ mut longest_postfix_string = \"\";\n    let mut longest_postfix_index2 = 0;\n\
    \    let mut longest_postfix_string2 = \"\";\n    let mut longest_postfix_index3\
    \ = 0;\n    let mut longest_postfix_string3 = \"\";\n    let mut longest_postfix_index4\
    \ = 0;\n    let mut longest_postfix_string4 = \"\";\n    let mut longest_postfix_index5\
    \ = 0;\n    let mut longest_postfix_string5 = \"\";\n    let mut longest_postfix_index6\
    \ = 0;\n    let mut longest_postfix_string6 = \"\";\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_string7 = \"\";\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_string8 = \"\";\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_string9 = \"\";\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_string10 = \"\";\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_string11 = \"\";\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_string12 = \"\";\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_string13 = \"\";\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_string14 = \"\";\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_string15 = \"\";\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_string16 = \"\";\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_string17 = \"\";\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_string18 = \"\";\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_string19 = \"\";\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_string20 = \"\";\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_string21 = \"\";\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_string22 = \"\";\n    let mut longest_postfix_index23\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpqw0q_a7y.rs:59:36\n   |\n\
    59 |     let mut longest_postfix_index23\n   |                               \
    \     ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqw0q_a7y.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805824
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = string;\n    let\
    \ mut longest_postfix = string;\n    let mut longest_postfix_length = string.len();\n\
    \    let mut longest_postfix_index = 0;\n    let mut longest_postfix_index2 =\
    \ 0;\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_index4\
    \ = 0;\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_index6\
    \ = 0;\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_index23 = 0;\n    let mut longest_postfix_index24\
    \ = 0;\n    let mut longest_postfix_index25 = 0;\n    let mut longest_postfix_index26\
    \ = 0;\n    let mut longest_postfix_index27 = 0;\n    let mut longest_postfix_index28\
    \ = 0;\n    let mut longest_postfix_index29 = 0;\n    let mut longest_postfix_index30\
    \ = 0;\n    let mut longest_postfix_index31 = 0;\n    let mut longest_postfix_index32\
    \ = 0;\n    let mut longest_postfix_index33 = 0;\n    let mut longest_postfix_index34\
    \ = 0;\n    let mut longest_postfix_index35 = 0;\n    let mut longest_postfix_index36\
    \ = 0;\n    let mut longest_postfix_index37 = 0;\n    let mut longest_postfix_index38\
    \ = 0;\n    let mut longest_postfix_index39 = 0;\n    let mut longest_postfix_index40\
    \ = 0;\n    let mut longest_postfix_index41 = 0;\n    let mut longest_postfix_index42\
    \ = 0;\n    let mut longest_postfix_index43 = 0;\n    let mut longest_postfix_index\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpjb9824ej.rs:59:34\n   |\n\
    59 |     let mut longest_postfix_index\n   |                                 \
    \ ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjb9824ej.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805826
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reverse = string;\n    let mut prefix = string;\n    let mut suffix\
    \ = string;\n    let mut longest_palindrome = string;\n    let mut longest_palindrome_len\
    \ = string.len();\n    let mut longest_palindrome_len_pre = string.len();\n  \
    \  let mut longest_palindrome_len_post = string.len();\n    let mut longest_palindrome_len_pre_post\
    \ = string.len();\n    let mut longest_palindrome_len_pre_post_len = string.len();\n\
    \    let mut longest_palindrome_len_pre_post_len_pre = string.len();\n    let\
    \ mut longest_palindrome_len_pre_post_len_post = string.len();\n    let mut longest_palindrome_len_pre_post_len_pre_post\
    \ = string.len();\n    let mut longest_palindrome_len_pre_post_len_pre_post_len\
    \ = string.len();\n    let mut longest_palindrome_len_pre_post_len_pre_post_len_pre\
    \ = string.len();\n    let mut longest_palindrome_len_pre_post_len_pre_post_len_post\
    \ = string.len();\n    let mut longest_palindrome_len_pre_post_len_pre_post_len_pre_post\
    \ = string.len();\n    let mut longest_palindrome_len_pre_post_len_pre_post_len_pre_post_len\
    \ = string.len();\n    let mut longest_palindrome_len_pre_post_len_pre_post_len_pre_post_len_pre\
    \ = string.len();\n    let mut longest_palindrome_len_pre_post_len_pre_post_len_pre_post_len_post\
    \ = string.len();\n    let mut longest_palindrome_len_pre_post_len_pre_post_len_pre_post_len_pre_post\
    \ = string.len();\n    let mut longest_palindrome_len_pre_post_len_pre_post_len_pre_post_len_pre_post_len\
    \ = string.len();\n    let mut longest_palindrome_len_pre_post_len_pre_post_len_pre_post_len_pre_post_len\
    \ = string.len();\n    let mut longest_palindrome_len_pre_post_len_pre_post_len_pre_post_len_pre_post_len_pre\
    \ = string.len();\n    let mut longest_palindrome_len_pre_post_len_pre_post_len_pre_post_len_pre_post_len_post\
    \ = string.len();\n    let mut longest_palindrome_len_pre_post_len_pre_post_len_pre_post_len_pre_post_len_post\
    \ = string.len();\n    let mut longest_palindrome_len_pre_post_len_pre_post_len_pre_post_len_pre_post_\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpbwaz6whr.rs:37:84\n   |\n\
    37 |     let mut longest_palindrome_len_pre_post_len_pre_post_len_pre_post_len_pre_post_\n\
    \   |                                                                        \
    \            ^ help: add `;` here\n38 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbwaz6whr.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805826
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    let\
    \ mut longest_postfix_index2 = 0;\n    let mut longest_postfix_index3 = 0;\n \
    \   let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5 =\
    \ 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut longest_postfix_index44 = 0;\n    let mut longest_postfix_index45\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp3v9v9aes.rs:59:36\n   |\n\
    59 |     let mut longest_postfix_index45\n   |                               \
    \     ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3v9v9aes.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_postfix = string;\n\
    \    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length =\
    \ 0;\n    while longest_postfix_index != longest_postfix_length {\n        let\
    \ mut postfix_index = longest_postfix_index;\n        let mut postfix_length =\
    \ longest_postfix_length;\n        while postfix_index != postfix_length {\n \
    \           let mut postfix_char = reversed_string[postfix_index];\n         \
    \   reversed_string = reversed_string[..postfix_index] + &postfix_char + reversed_string[postfix_index..];\n\
    \            postfix_length += 1;\n            postfix_index += 1;\n        }\n\
    \        longest_postfix_length = postfix_length;\n        longest_postfix = reversed_string;\n\
    \        longest_postfix_index += 1;\n    }\n    longest_postfix\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmppvmc33jy.rs:20:36\n   |\n20 |             let mut postfix_char = reversed_string[postfix_index];\n\
    \   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n\nerror[E0369]: cannot add `&_` to `str`\n\
    \  --> /tmp/tmppvmc33jy.rs:21:64\n   |\n21 |             reversed_string = reversed_string[..postfix_index]\
    \ + &postfix_char + reversed_string[postfix_index..];\n   |                  \
    \             -------------------------------- ^ ------------- &_\n   |      \
    \                         |\n   |                               str\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n  -->\
    \ /tmp/tmppvmc33jy.rs:21:80\n   |\n21 |             reversed_string = reversed_string[..postfix_index]\
    \ + &postfix_char + reversed_string[postfix_index..];\n   |                  \
    \                                                              ^ doesn't have\
    \ a size known at compile-time\n   |\n   = help: the trait `Sized` is not implemented\
    \ for `str`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805826
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut palindrome = string;\n    let mut reversed_string\
    \ = \"\";\n\n    while !string.is_empty() {\n        let mut index = string.len();\n\
    \        let mut char = string[string.len() - 1];\n        while index > 0 {\n\
    \            let mut char = string[index - 1];\n            reversed_string.insert(0,\
    \ char);\n            index -= 1;\n        }\n        palindrome = palindrome.rev();\n\
    \        palindrome.insert(0, char);\n        string = string.rev();\n    }\n\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp3vybd673.rs:18:24\n\
    \   |\n18 |         let mut char = string[string.len() - 1];\n   |           \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp3vybd673.rs:20:28\n\
    \   |\n20 |             let mut char = string[index - 1];\n   |              \
    \              ^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0599]:\
    \ no method named `insert` found for reference `&str` in the current scope\n \
    \ --> /tmp/tmp3vybd673.rs:21:29\n   |\n21 |             reversed_string.insert(0,\
    \ char);\n   |                             ^^^^^^ method not found in `&str`\n\
    \nerror[E0599]: the method `rev` exists for struct `String`, but its trait bounds\
    \ were not satisfied\n   --> /tmp/tmp3vybd673.rs:24:33\n    |\n24  |         \
    \  palindrome = palindrome.rev();\n    |                                   ^^^\
    \ method cannot be called on `String` due to unsatisfied trait bounds\n    |\n\
    \    = note: the following trait bounds were not satisfied:\n            `String:\
    \ Iterator`\n            which is required by `&mut String: Iterator`\n      \
    \      `str: Iterator`\n            which is required by `&mut str: Iterator`\n\
    \nerror[E0599]: the method `rev` exists for struct `String`, but its trait bounds\
    \ were not satisfied\n   --> /tmp/tmp3vybd673.rs:26:25\n    |\n26  |         \
    \  string = string.rev();\n    |                           ^^^ method cannot be\
    \ called on `String` due to unsatisfied trait bounds\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `String: Iterator`\n         \
    \   which is required by `&mut String: Iterator`\n            `str: Iterator`\n\
    \            which is required by `&mut str: Iterator`\n\nerror: aborting due\
    \ to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an er"
  stdout: ''
  timestamp: 1659805826
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reverse = string;\n    let mut i =\
    \ 0;\n    while i < string.len() {\n        let mut j = i;\n        while j +\
    \ 1 < string.len() && string[j + 1] == string[j] {\n            j += 1; // skip\
    \ over equal characters\n        }\n        if j == i {\n            break;\n\
    \        }\n        reverse = reverse.insert(j, string[i]);\n        i += 1;\n\
    \    }\n    reverse\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpapsb19nz.rs:17:39\n\
    \   |\n17 |         while j + 1 < string.len() && string[j + 1] == string[j] {\n\
    \   |                                       ^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n \
    \ --> /tmp/tmpapsb19nz.rs:17:56\n   |\n17 |         while j + 1 < string.len()\
    \ && string[j + 1] == string[j] {\n   |                                      \
    \                  ^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpapsb19nz.rs:23:37\n\
    \   |\n23 |         reverse = reverse.insert(j, string[i]);\n   |            \
    \                         ^^^^^^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpapsb19nz.rs:23:19\n   |\n23 |         reverse\
    \ = reverse.insert(j, string[i]);\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `()`\n   |\nnote: method `insert` modifies its\
    \ receiver in-place\n  --> /tmp/tmpapsb19nz.rs:23:27\n   |\n23 |         reverse\
    \ = reverse.insert(j, string[i]);\n   |                   ------- ^^^^^^ this\
    \ call modifies `reverse` in-place\n   |                   |\n   |           \
    \        you probably want to use this value after calling the method...\n   =\
    \ note: ...instead of the `()` output of method `insert`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805826
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    let\
    \ mut longest_postfix_index2 = 0;\n    let mut longest_postfix_index3 = 0;\n \
    \   let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5 =\
    \ 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut longest_postfix_index44 = 0;\n    let mut longest_postfix_index45\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp3v9v9aes.rs:59:36\n   |\n\
    59 |     let mut longest_postfix_index45\n   |                               \
    \     ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3v9v9aes.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut prefix_length = 0;\n    let\
    \ mut suffix_length = 0;\n    while !reversed_string.is_empty() {\n        let\
    \ mut suffix_length = reversed_string.len();\n        while suffix_length >= prefix_length\
    \ {\n            let mut prefix_length = suffix_length;\n            while prefix_length\
    \ >= 0 {\n                let mut char = reversed_string[prefix_length];\n   \
    \             reversed_string = reversed_string[prefix_length..].to_owned();\n\
    \                suffix_length -= 1;\n                prefix_length -= 1;\n  \
    \              reversed_string += char;\n            }\n        }\n    }\n   \
    \ reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n  \
    \  assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpy90mat5m.rs:20:32\n\
    \   |\n20 |                 let mut char = reversed_string[prefix_length];\n \
    \  |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805826
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_postfix = string;\n\
    \    let mut longest_postfix_len = 0;\n    let mut longest_postfix_start = -1;\n\
    \    for pos in string.char_indices() {\n        let mut postfix = &mut reversed_string[..pos];\n\
    \        let mut postfix_len = postfix.len();\n        while postfix_len > longest_postfix_len\
    \ {\n            longest_postfix_len = longest_postfix_len + 1;\n            longest_postfix_start\
    \ = pos;\n            postfix_len = postfix.len();\n        }\n        if postfix_len\
    \ == longest_postfix_len {\n            longest_postfix = postfix.reverse();\n\
    \        }\n    }\n    longest_postfix.push_str(&string[longest_postfix_start..]);\n\
    \    longest_postfix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `RangeTo<(usize, char)>`\n\
    \  --> /tmp/tmpa7_bhgdb.rs:17:32\n   |\n17 |         let mut postfix = &mut reversed_string[..pos];\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `RangeTo<(usize, char)>`\n   |\n   = help: the trait `Index<RangeTo<(usize,\
    \ char)>>` is not implemented for `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpa7_bhgdb.rs:21:37\n   |\n21 |             longest_postfix_start\
    \ = pos;\n   |                                     ^^^ expected integer, found\
    \ tuple\n   |\n   = note: expected type `{integer}`\n             found tuple\
    \ `(usize, char)`\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmpa7_bhgdb.rs:15:37\n   |\n15 |     let mut longest_postfix_start\
    \ = -1;\n   |                                     ^^ the trait `Neg` is not implemented\
    \ for `usize`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805826
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = string;\n    let\
    \ mut longest_postfix_length = 0;\n    let mut longest_postfix_start = -1;\n \
    \   let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start = \n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpry52n52p.rs:64:1\n\
    \   |\n64 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659805826
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix = String::new();\n    let mut longest_postfix_length = 0;\n\
    \    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length_index\
    \ = 0;\n    while let Some(index) = string.rfind('a') {\n        let postfix =\
    \ &string[index..];\n        let postfix_length = postfix.len();\n        if longest_postfix_length\
    \ < postfix_length {\n            longest_postfix_length = postfix_length;\n \
    \           longest_postfix_index = index;\n        }\n        if longest_postfix_length\
    \ == postfix_length {\n            longest_postfix = postfix;\n        }\n   \
    \     if longest_postfix_length == postfix_length {\n            reversed_string\
    \ += &string[longest_postfix_index..];\n        }\n    }\n    longest_postfix.reverse();\n\
    \    longest_postfix.push_str(&reversed_string);\n    longest_postfix\n}\n\nfn\
    \ main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvm9hf9h1.rs:26:31\n   |\n\
    26 |             longest_postfix = postfix;\n   |                            \
    \   ^^^^^^^- help: try using a conversion method: `.to_string()`\n   |       \
    \                        |\n   |                               expected struct\
    \ `String`, found `&str`\n\nerror[E0368]: binary assignment operation `+=` cannot\
    \ be applied to type `&str`\n  --> /tmp/tmpvm9hf9h1.rs:29:13\n   |\n29 |     \
    \        reversed_string += &string[longest_postfix_index..];\n   |          \
    \   ---------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |             |\n\
    \   |             cannot use `+=` on type `&str`\n\nerror[E0599]: no method named\
    \ `reverse` found for struct `String` in the current scope\n  --> /tmp/tmpvm9hf9h1.rs:32:21\n\
    \   |\n32 |     longest_postfix.reverse();\n   |                     ^^^^^^^ help:\
    \ there is an associated function with a similar name: `reserve`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0368,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805826
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut palindrome = string;\n    let mut reversed_palindrome = string;\n\
    \    let mut last_char: char;\n    let mut last_char_index = 0;\n    let mut last_char_length\
    \ = 0;\n    while !palindrome.is_empty() {\n        last_char = &palindrome[last_char_index..];\n\
    \        last_char_length = last_char.len();\n        last_char_index += last_char_length;\n\
    \        if last_char == &palindrome[..last_char_length] {\n            palindrome\
    \ = &palindrome[..last_char_index];\n            reversed_palindrome = &reversed_palindrome[..last_char_index];\n\
    \            last_char_index -= last_char_length;\n        }\n    }\n    String::from(reversed_palindrome)\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpymtkcryy.rs:18:21\n   |\n\
    18 |         last_char = &palindrome[last_char_index..];\n   |               \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&str`\n\nerror[E0599]:\
    \ no method named `len` found for type `char` in the current scope\n  --> /tmp/tmpymtkcryy.rs:19:38\n\
    \   |\n19 |         last_char_length = last_char.len();\n   |                \
    \                      ^^^ method not found in `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpymtkcryy.rs:21:25\n   |\n21 |         if last_char == &palindrome[..last_char_length]\
    \ {\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpymtkcryy.rs:22:26\n\
    \   |\n22 |             palindrome = &palindrome[..last_char_index];\n   |   \
    \                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\nhelp: try using a conversion method\n   |\n22 |        \
    \     palindrome = (&palindrome[..last_char_index]).to_string();\n   |       \
    \                   +                              +++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpymtkcryy.rs:23:35\n   |\n23 |             reversed_palindrome\
    \ = &reversed_palindrome[..last_char_index];\n   |                           \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found\
    \ `&str`\n   |\nhelp: try using a conversion method\n   |\n23 |             reversed_palindrome\
    \ = (&reversed_palindrome[..last_char_index]).to_string();\n   |             \
    \                      +                                       +++++++++++++\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805826
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = string;\n    let\
    \ mut palindrome = string;\n    let mut longest_postfix = string;\n    let mut\
    \ longest_postfix_len = string.len();\n    let mut longest_postfix_pos = 0;\n\
    \    let mut longest_postfix_pos = 0;\n    let mut longest_postfix_pos = 0;\n\
    \    let mut longest_postfix_pos = 0;\n    let mut longest_postfix_pos = 0;\n\
    \    let mut longest_postfix_pos = 0;\n    let mut longest_postfix_pos = 0;\n\
    \    let mut longest_postfix_pos = 0;\n    let mut longest_postfix_pos = 0;\n\
    \    let mut longest_postfix_pos = 0;\n    let mut longest_postfix_pos = 0;\n\
    \    let mut longest_postfix_pos = 0;\n    let mut longest_postfix_pos = 0;\n\
    \    let mut longest_postfix_pos = 0;\n    let mut longest_postfix_pos = 0;\n\
    \    let mut longest_postfix_pos = 0;\n    let mut longest_postfix_pos = 0;\n\
    \    let mut longest_postfix_pos = 0;\n    let mut longest_postfix_pos = 0;\n\
    \    let mut longest_postfix_pos = 0;\n    let mut longest_postfix_pos = 0;\n\
    \    let mut longest_postfix_pos = 0;\n    let mut longest_postfix_pos = 0;\n\
    \    let mut longest_postfix_pos = 0;\n    let mut longest_postfix_pos = 0;\n\
    \    let mut longest_postfix_pos = 0;\n    let mut longest_postfix_pos = 0;\n\
    \    let mut longest_postfix_pos = 0;\n    let mut longest_postfix_pos = 0;\n\
    \    let mut longest_postfix_pos = 0;\n    let mut longest_postfix_pos = 0;\n\
    \    let mut longest_postfix_pos = 0;\n    let mut longest_postfix_pos = 0;\n\
    \    let mut longest_postfix_pos = 0;\n    let mut longest_postfix_pos = 0;\n\
    \    let mut longest_postfix_pos = 0;\n    let mut longest_postfix_pos = 0;\n\
    \    let mut longest_postfix_pos = 0;\n    let mut longest_postfix_pos = 0;\n\
    \    let mut longest_postfix_pos = 0;\n    let mut longest_postfix_pos = 0;\n\
    \    let mut longest_postfix_pos = 0;\n    let mut longest_postfix_pos = 0;\n\
    \    let mut longest_postfix_pos = 0;\n    let mut longest_postfix_pos = 0;\n\
    \    let mut longest_postfix_pos = 0;\n    let mut longest_post\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvkhi8l56.rs:63:25\n   |\n\
    63 |     let mut longest_post\n   |                         ^ help: add `;` here\n\
    64 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvkhi8l56.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805826
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reverse = string;\n    let mut i =\
    \ 0;\n    while i < string.len() {\n        if string[i] != string[string.len()\
    \ - 1 - i] {\n            break;\n        }\n        reverse.push_str(&string[..i]);\n\
    \        reverse.push('_');\n        i += 1;\n    }\n    reverse.push_str(&string[..]);\n\
    \    reverse\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpnvkfvqgg.rs:16:12\n\
    \   |\n16 |         if string[i] != string[string.len() - 1 - i] {\n   |     \
    \       ^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmpnvkfvqgg.rs:16:25\n   |\n\
    16 |         if string[i] != string[string.len() - 1 - i] {\n   |            \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805826
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_postfix_length = 0;\n\
    \    for pos in string.char_indices() {\n        let mut postfix_length = pos.0;\n\
    \        if postfix_length > longest_postfix_length {\n            longest_postfix_length\
    \ = postfix_length;\n        }\n    }\n    let mut postfix_length = longest_postfix_length;\n\
    \    let mut postfix_chars = vec![];\n    let mut postfix_chars_start = -1;\n\
    \    let mut postfix_chars_end = -1;\n    while postfix_chars_start < postfix_chars.len()\
    \ {\n        let mut postfix_char = string[postfix_chars_start + postfix_chars_end];\n\
    \        if postfix_char == string[postfix_chars_end - 1] {\n            postfix_chars_end--;\n\
    \        } else {\n            postfix_chars.push(postfix_char);\n           \
    \ postfix_chars_end++;\n        }\n        if postfix_chars_end == postfix_chars.len()\
    \ - 1 {\n            postfix_chars_start = postfix_chars_end + 1;\n        }\n\
    \    }\n    let mut postfix_chars_reversed = vec![];\n    let mut postfix_chars_reversed_start\
    \ = -1;\n    let mut postfix_chars_reversed_end = -1;\n    while postfix_chars_reversed_start\
    \ < postfix_chars_reversed.len() {\n        let mut postfix_char_reversed = string[postfix_chars_reversed_start\
    \ + postfix_chars_reversed_end];\n        if postfix_char_reversed == string[postfix_chars_reversed_end\
    \ - 1] {\n            postfix_chars_reversed_end--;\n        } else {\n      \
    \      postfix_chars_reversed.push(postfix_char_reversed);\n            postfix_chars_reversed_end++;\n\
    \        }\n        if postfix_chars_reversed_end == postfix_chars_reversed.len()\
    \ - 1 {\n            postfix_chars_reversed_start = postfix_chars_reversed_end\
    \ + 1;\n        }\n    }\n    let mut postfix_chars_reversed_reversed = vec![];\n\
    \    let mut postfix_chars_reversed_reversed_start = -1;\n    let mut postfix_chars_reversed_reversed_end\
    \ = -1;\n    while postfix_chars_reversed_reversed_start < postfix_chars_reversed_reversed.len()\
    \ {\n        let mut postfix_char_reversed_reversed = string[postfix_chars_reversed_reversed_start\
    \ + postfix_chars_reversed_reversed_end];\n        if postfix_char_reversed_reversed\
    \ == string[postfix_chars_reverse\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpgj77ewn_.rs:66:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n54 |     while postfix_chars_reversed_reversed_start\
    \ < postfix_chars_reversed_reversed.len() {\n   |                            \
    \                                                             - this delimiter\
    \ might not be properly closed...\n...\n57 | }\n   | - ...as it matches this but\
    \ it has different indentation\n...\n66 | }\n   |   ^\n\nerror: expected expression,\
    \ found `+`\n  --> /tmp/tmpgj77ewn_.rs:30:31\n   |\n30 |             postfix_chars_end++;\n\
    \   |                               ^ expected expression\n\nerror: expected expression,\
    \ found `+`\n  --> /tmp/tmpgj77ewn_.rs:45:40\n   |\n45 |             postfix_chars_reversed_end++;\n\
    \   |                                        ^ expected expression\n\nerror: expected\
    \ `{`, found `}`\n  --> /tmp/tmpgj77ewn_.rs:57:1\n   |\n56 |         if postfix_char_reversed_reversed\
    \ == string[postfix_chars_reverse\n   |         -- this `if` expression has a\
    \ condition, but no block\n57 | }\n   | ^ expected `{`\n\nerror: mismatched closing\
    \ delimiter: `}`\n  --> /tmp/tmpgj77ewn_.rs:56:52\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |                                              - closing\
    \ delimiter possibly meant for this\n...\n56 |         if postfix_char_reversed_reversed\
    \ == string[postfix_chars_reverse\n   |                                      \
    \              ^ unclosed delimiter\n57 | }\n   | ^ mismatched closing delimiter\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpgj77ewn_.rs:22:35\n\
    \   |\n22 |     let mut postfix_chars_start = -1;\n   |                      \
    \             ^^ the trait `Neg` is not implemented for `usize`\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpgj77ewn_.rs:23:33\n\
    \   |\n23 |     let mut postfix_chars_end = -1;\n   |                        \
    \         ^^ the trait `Neg` is not implemented for `usize`\n\nerror[E0277]: the\
    \ typ"
  stdout: ''
  timestamp: 1659805826
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_postfix = string;\n\
    \    let mut longest_postfix_length = 0;\n    let mut longest_postfix_index =\
    \ 0;\n    let mut longest_postfix_length_index = 0;\n    let mut longest_postfix_length_length\
    \ = 0;\n    let mut longest_postfix_length_length_index = 0;\n    let mut longest_postfix_length_length_length_index\
    \ = 0;\n    let mut longest_postfix_length_length_length_length_index = 0;\n \
    \   let mut longest_postfix_length_length_length_length_length_index = 0;\n  \
    \  let mut longest_postfix_length_length_length_length_length_index = 0;\n   \
    \ let mut longest_postfix_length_length_length_length_length_length_index = 0;\n\
    \    let mut longest_postfix_length_length_length_length_length_length_length_index\
    \ = 0;\n    let mut longest_postfix_length_length_length_length_length_length_length_length_index\
    \ = 0;\n    let mut longest_postfix_length_length_length_length_length_length_length_length_index\
    \ = 0;\n    let mut longest_postfix_length_length_length_length_length_length_length_length_length_index\
    \ = 0;\n    let mut longest_postfix_length_length_length_length_length_length_length_length_length_index\
    \ = 0;\n    let mut longest_postfix_length_length_length_length_length_length_length_length_length_length_index\
    \ = 0;\n    let mut longest_postfix_length_length_length_length_length_length_length_length_length_length_length_index\
    \ = 0;\n    let mut longest_postfix_length_length_length_length_length_length_length_length_length_length_length_index\
    \ = 0;\n    let mut longest_postfix_length_length_length_length_length_length_length_length_length_length_length_length_index\
    \ = 0;\n    let mut longest_postfix_length_length_length_length_length_length_length_length_length_length_length_length_index\
    \ = 0;\n    let mut longest_postfix_length_length_length_length_length_length_length_length_length_length_length_length_index\
    \ = 0;\n    let mut longest_postfix_length_length_length_length_length_length_length_length_length_length_length_length_index\
    \ = 0;\n    let mut longest_postfix_length_length_length_length_length_length_length_length_length_length_length_length_index\
    \ = 0;\n    let mut longest_postfix_length_length_length_length_length_length_length_length_length_length_length_length_length_index\
    \ = 0;\n    let mut longest_postfix_length_length_length_length_length_length_length_length_length_length_length_length_length_index\
    \ = 0;\n    let mut longest_postfix_length_length_length_length_length_length_length_length_length_length_length_length_length_index\
    \ = 0;\n    let mut longest_postfix_length_length_length_length_length_length_length_length_length_length_length_length_length_index\
    \ = 0;\n    let mut longest_postfix_length_length_length_length_length_\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpsfe55_v7.rs:41:64\n   |\n\
    41 |     let mut longest_postfix_length_length_length_length_length_\n   |   \
    \                                                             ^ help: add `;`\
    \ here\n42 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpsfe55_v7.rs:11:39\n   |\n11 | fn make_palindrome(string: String) ->\
    \ String {\n   |    ---------------                    ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805826
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reverse = string;\n    let mut longest\
    \ = 0;\n    while !string.is_empty() {\n        let mut i = 0;\n        while\
    \ i < string.len() && string[i] == string[string.len() - i - 1] {\n          \
    \  i += 1;\n        }\n        if i == 0 {\n            break;\n        }\n  \
    \      let mut j = string.len() - 1;\n        while j > 0 && string[j] == string[string.len()\
    \ - j - 1] {\n            j -= 1;\n        }\n        if j == 0 {\n          \
    \  break;\n        }\n        if i > j {\n            longest = i;\n         \
    \   reverse = &string[j..];\n        } else {\n            longest = j;\n    \
    \        reverse = &string[i..];\n        }\n        string = &string[longest..];\n\
    \    }\n    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n \
    \   assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmph81hmadr.rs:17:35\n\
    \   |\n17 |         while i < string.len() && string[i] == string[string.len()\
    \ - i - 1] {\n   |                                   ^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmph81hmadr.rs:17:48\n   |\n17 |         while i < string.len() &&\
    \ string[i] == string[string.len() - i - 1] {\n   |                          \
    \                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n \
    \ --> /tmp/tmph81hmadr.rs:24:24\n   |\n24 |         while j > 0 && string[j] ==\
    \ string[string.len() - j - 1] {\n   |                        ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmph81hmadr.rs:24:37\n   |\n24 |         while j > 0\
    \ && string[j] == string[string.len() - j - 1] {\n   |                       \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmph81hmadr.rs:32:23\n   |\n32 |  \
    \           reverse = &string[j..];\n   |                       ^^^^^^^^^^^^ expected\
    \ struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n \
    \  |\n32 |             reverse = (&string[j..]).to_string();\n   |           \
    \            +            +++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmph81hmadr.rs:35:23\n   |\n35 |             reverse = &string[i..];\n\
    \   |                       ^^^^^^^^^^^^ expected struct `String`, found `&str`\n\
    \   |\nhelp: try using a conversion method\n   |\n35 |             reverse = (&string[i..]).to_string();\n\
    \   |                       "
  stdout: ''
  timestamp: 1659805826
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut reversed_string_len = 0;\n\
    \    let mut longest_postfix_len = 0;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut longest_postfix_start_index\
    \ = 0;\n    let mut longest_postfix_end_index = 0;\n    let mut \n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmps5lup5ec.rs:60:1\n\
    \   |\n60 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659805826
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n\n    while\
    \ !string.is_empty() {\n        let mut index = string.len() - 1;\n        let\
    \ mut char = string[index];\n\n        while index >= 0 {\n            reversed_string.insert(0,\
    \ char);\n            index -= 1;\n            char = string[index];\n       \
    \ }\n\n        string = string.chars().collect();\n    }\n\n    reversed_string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpitinmnee.rs:17:24\n\
    \   |\n17 |         let mut char = string[index];\n   |                      \
    \  ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n\nerror[E0599]: no method named\
    \ `insert` found for reference `&str` in the current scope\n  --> /tmp/tmpitinmnee.rs:20:29\n\
    \   |\n20 |             reversed_string.insert(0, char);\n   |               \
    \              ^^^^^^ method not found in `&str`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpitinmnee.rs:22:20\n   |\n22 |  \
    \           char = string[index];\n   |                    ^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpitinmnee.rs:28:5\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                          ------ expected `String` because of return type\n...\n\
    28 |     reversed_string\n   |     ^^^^^^^^^^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |     |\n   |     expected struct `String`, found\
    \ `&str`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805826
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut suffix_length = 0;\n    let\
    \ mut prefix_length = 0;\n    while suffix_length < string.len() {\n        let\
    \ mut suffix_start = suffix_length;\n        let mut suffix_end = suffix_length;\n\
    \        while suffix_end < string.len() {\n            if string[suffix_end]\
    \ != string[suffix_end - 1] {\n                suffix_end = suffix_end + 1;\n\
    \            } else {\n                break;\n            }\n        }\n    \
    \    if suffix_end == string.len() {\n            break;\n        }\n        let\
    \ mut prefix_start = prefix_length;\n        let mut prefix_end = prefix_length;\n\
    \        while prefix_end < suffix_end {\n            if string[prefix_end] !=\
    \ string[prefix_end - 1] {\n                prefix_end = prefix_end + 1;\n   \
    \         } else {\n                break;\n            }\n        }\n       \
    \ if prefix_end == suffix_end {\n            break;\n        }\n        reversed_string.push_str(&string[prefix_start..prefix_end]);\n\
    \        suffix_length = suffix_end - prefix_start + 1;\n        prefix_length\
    \ = prefix_end - prefix_start + 1;\n    }\n    reversed_string\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpbxtrx6u_.rs:19:16\n\
    \   |\n19 |             if string[suffix_end] != string[suffix_end - 1] {\n  \
    \ |                ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpbxtrx6u_.rs:19:38\n\
    \   |\n19 |             if string[suffix_end] != string[suffix_end - 1] {\n  \
    \ |                                      ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpbxtrx6u_.rs:31:16\n   |\n31 |             if string[prefix_end]\
    \ != string[prefix_end - 1] {\n   |                ^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpbxtrx6u_.rs:31:38\n   |\n31 |             if string[prefix_end]\
    \ != string[prefix_end - 1] {\n   |                                      ^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805826
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = string;\n    let\
    \ mut is_palindrome = true;\n\n    while !is_palindrome {\n        let mut i =\
    \ 0;\n        let mut j = string.len() - 1;\n        let mut is_palindrome = true;\n\
    \n        while i < j {\n            if string[i] != string[j] {\n           \
    \     is_palindrome = false;\n                break;\n            }\n        \
    \    i += 1;\n            j -= 1;\n        }\n\n        if !is_palindrome {\n\
    \            reversed_string = reversed_string[..i];\n        }\n\n        string\
    \ = reversed_string;\n    }\n\n    string\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpmw2j13uw.rs:22:16\n\
    \   |\n22 |             if string[i] != string[j] {\n   |                ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpmw2j13uw.rs:22:29\n   |\n22 |            \
    \ if string[i] != string[j] {\n   |                             ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmw2j13uw.rs:31:31\n\
    \   |\n31 |             reversed_string = reversed_string[..i];\n   |        \
    \                       ^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                               |\n   |                 \
    \              expected struct `String`, found `str`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805826
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    let\
    \ mut longest_postfix_index2 = 0;\n    let mut longest_postfix_index3 = 0;\n \
    \   let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5 =\
    \ 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut longest_postfix_index44 = 0;\n    let mut longest_postfix_index45\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp3v9v9aes.rs:59:36\n   |\n\
    59 |     let mut longest_postfix_index45\n   |                               \
    \     ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3v9v9aes.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut last_char = String::new();\n\
    \    let mut is_palindrome = true;\n\n    while !reversed_string.is_empty() {\n\
    \        let mut char = reversed_string.chars().next().unwrap();\n        last_char\
    \ = char.to_string();\n\n        if char == last_char {\n            is_palindrome\
    \ = true;\n        } else {\n            is_palindrome = false;\n        }\n\n\
    \        reversed_string = reversed_string.chars().collect::<String>().reverse().collect();\n\
    \    }\n\n    if is_palindrome {\n        reversed_string\n    } else {\n    \
    \    String::from(\"\")\n    }\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmtcp7d66.rs:20:20\n   |\n\
    20 |         if char == last_char {\n   |                    ^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror[E0599]: no method named `reverse` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpmtcp7d66.rs:26:71\n\
    \   |\n26 |         reversed_string = reversed_string.chars().collect::<String>().reverse().collect();\n\
    \   |                                                                       ^^^^^^^\
    \ help: there is an associated function with a similar name: `reserve`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805826
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_palindrome = string;\n\
    \    let mut longest_palindrome_length = 0;\n\n    for c in string.chars() {\n\
    \        if longest_palindrome_length == 0 {\n            longest_palindrome_length\
    \ = longest_palindrome.chars().filter(|c| c == c).count();\n        }\n\n    \
    \    if longest_palindrome_length == longest_palindrome.chars().filter(|c| c ==\
    \ c).count() {\n            longest_palindrome_length += 1;\n        } else {\n\
    \            longest_palindrome_length = 0;\n        }\n\n        if longest_palindrome_length\
    \ < longest_palindrome.chars().filter(|c| c == c).count() {\n            longest_palindrome\
    \ = longest_palindrome.chars().filter(|c| c == c).collect();\n            longest_palindrome_length\
    \ = longest_palindrome.chars().filter(|c| c == c).count();\n        }\n\n    \
    \    if longest_palindrome_length == 0 {\n            longest_palindrome = longest_palindrome.chars().filter(|c|\
    \ c == c).collect();\n            longest_palindrome_length = longest_palindrome.chars().filter(|c|\
    \ c == c).count();\n        }\n\n        if longest_palindrome_length == longest_palindrome.chars().filter(|c|\
    \ c == c).count() {\n            longest_palindrome_length += 1;\n        } else\
    \ {\n            longest_palindrome_length = 0;\n        }\n\n        if longest_palindrome_length\
    \ < longest_palindrome.chars().filter(|c| c == c).count() {\n            longest_palindrome\
    \ = longest_palindrome.chars().filter(|c| c == c).collect();\n            longest_palindrome_length\
    \ = longest_palindrome.chars().filter(|c| c == c).count();\n        }\n\n    \
    \    if longest_palindrome_length == longest_palindrome.chars().filter(|c| c ==\
    \ c).count() {\n            longest_palindrome_length += 1;\n        } else {\n\
    \            longest_palindrome_length = 0;\n        }\n\n        if longest_palindrome_length\
    \ < longest_palindrome.chars().filter(|c| c == c).count() {\n            longest_palindrome\
    \ = longest_palindrome.chars().filter(|c| c == c).collect();\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpy12_swo_.rs:65:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n16 |     for c in\
    \ string.chars() {\n   |                             - unclosed delimiter\n...\n\
    54 |         if longest_palindrome_length < longest_palindrome.chars().filter(|c|\
    \ c == c).count() {\n   |                                                    \
    \                                          - this delimiter might not be properly\
    \ closed...\n55 |             longest_palindrome = longest_palindrome.chars().filter(|c|\
    \ c == c).collect();\n56 | }\n   | - ...as it matches this but it has different\
    \ indentation\n...\n65 | }\n   |   ^\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpy12_swo_.rs:16:5\n   |\n11 |   fn make_palindrome(string: String) ->\
    \ String {\n   |                                         ------ expected `String`\
    \ because of return type\n...\n16 | /     for c in string.chars() {\n17 | |  \
    \       if longest_palindrome_length == 0 {\n18 | |             longest_palindrome_length\
    \ = longest_palindrome.chars().filter(|c| c == c).count();\n19 | |         }\n\
    ...  |\n64 | |     assert_eq!(candidate(String::from(\"jerry\")), String::from(\"\
    jerryrrej\"));\n65 | | }\n   | |__^ expected struct `String`, found `()`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805826
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut reverse_length = 0;\n\n  \
    \  while !reversed_string.is_empty() {\n        let mut reversed_char = reversed_string[0];\n\
    \        reversed_string.remove(0);\n        reverse_length += 1;\n\n        if\
    \ reversed_char == reversed_string[reverse_length - 1] {\n            return string.to_owned()\
    \ + &reversed_char.to_string();\n        }\n    }\n\n    string\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpvrcpf2nh.rs:16:33\n   |\n16 |         let mut reversed_char = reversed_string[0];\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpvrcpf2nh.rs:20:29\n   |\n20 |         if reversed_char == reversed_string[reverse_length\
    \ - 1] {\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805826
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = string;\n    let\
    \ mut longest = 0;\n    while !string.is_empty() {\n        let mut i = 0;\n \
    \       while i < string.len() {\n            if string[i] != string[string::len()\
    \ - i - 1] {\n                break;\n            }\n            i += 1;\n   \
    \     }\n        if i == 0 {\n            break;\n        }\n        let mut j\
    \ = string.len() - 1;\n        while j > 0 {\n            if string[j] != string[string::len()\
    \ - j - 1] {\n                break;\n            }\n            j -= 1;\n   \
    \     }\n        if j == 0 {\n            break;\n        }\n        if j > i\
    \ {\n            longest = i;\n            reversed_string = &string[longest..longest.reverse()];\n\
    \        }\n        string = &string[i..];\n    }\n    string.reverse();\n   \
    \ reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n  \
    \  assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `string`\n\
    \  --> /tmp/tmpflopm4gj.rs:18:36\n   |\n18 |             if string[i] != string[string::len()\
    \ - i - 1] {\n   |                                    ^^^^^^ use of undeclared\
    \ crate or module `string`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ crate or module `string`\n  --> /tmp/tmpflopm4gj.rs:28:36\n   |\n28 |      \
    \       if string[j] != string[string::len() - j - 1] {\n   |                \
    \                    ^^^^^^ use of undeclared crate or module `string`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpflopm4gj.rs:18:16\n\
    \   |\n18 |             if string[i] != string[string::len() - i - 1] {\n   |\
    \                ^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmpflopm4gj.rs:28:16\n\
    \   |\n28 |             if string[j] != string[string::len() - j - 1] {\n   |\
    \                ^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n\nerror[E0599]: no\
    \ method named `reverse` found for type `usize` in the current scope\n  --> /tmp/tmpflopm4gj.rs:38:56\n\
    \   |\n38 |             reversed_string = &string[longest..longest.reverse()];\n\
    \   |                                                        ^^^^^^^ method not\
    \ found in `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpflopm4gj.rs:38:31\n\
    \   |\n38 |             reversed_string = &string[longest..longest.reverse()];\n\
    \   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n \
    \  |\n38 |             reversed_string = (&string[longest..longest.reverse()]).to_string();\n\
    \   |                               +                                   +++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpflopm4gj.rs:40:18\n   |\n40 |\
    \         string = &string[i..];\n   |                  ^^^^^^^^^^^^ exp"
  stdout: ''
  timestamp: 1659805826
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = string;\n    let\
    \ mut longest_postfix_index = 0;\n    let mut longest_postfix_length = 0;\n  \
    \  let mut longest_postfix_string = \"\";\n    while !string.is_empty() {\n  \
    \      let mut postfix_length = string.len();\n        let mut postfix_string\
    \ = \"\";\n        while postfix_length >= longest_postfix_length {\n        \
    \    let mut postfix_char = string[longest_postfix_index];\n            while\
    \ postfix_char != string[longest_postfix_index] {\n                postfix_string\
    \ += postfix_char;\n                longest_postfix_index += 1;\n            \
    \    postfix_length -= 1;\n                postfix_char = string[longest_postfix_index];\n\
    \            }\n            longest_postfix_length += 1;\n        }\n        longest_postfix_string\
    \ += postfix_string;\n        longest_postfix_index += 1;\n        string += &string[longest_postfix_index..];\n\
    \        reversed_string += &string[longest_postfix_index..];\n    }\n    longest_postfix_string\
    \ + reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmp_tmyh1jt.rs:21:36\n   |\n21 |             let mut postfix_char = string[longest_postfix_index];\n\
    \   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `{integer}`\n  --> /tmp/tmp_tmyh1jt.rs:22:35\n   |\n22 |        \
    \     while postfix_char != string[longest_postfix_index] {\n   |            \
    \                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `&str`\n  --> /tmp/tmp_tmyh1jt.rs:23:17\n   |\n23 |                \
    \ postfix_string += postfix_char;\n   |                 --------------^^^^^^^^^^^^^^^^\n\
    \   |                 |\n   |                 cannot use `+=` on type `&str`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp_tmyh1jt.rs:26:32\n\
    \   |\n26 |                 postfix_char = string[longest_postfix_index];\n  \
    \ |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n\nerror[E0368]: binary assignment operation `+=`\
    \ cannot be applied to type `&str`\n  --> /tmp/tmp_tmyh1jt.rs:30:9\n   |\n30 |\
    \         longest_postfix_string += postfix_string;\n   |         ----------------------^^^^^^^^^^^^^^^^^^\n\
    \   |         |\n   |         cannot use `+=` on type `&str`\n\nerror[E0369]:\
    \ cannot add `String` to `&str`\n  --> /tmp/tmp_tmyh1jt.rs:35:28\n   |\n35 | \
    \    longest_postfix_string + reversed_string\n   |     ----------------------\
    \ ^ --------------- String\n   |     |                      |\n   |     |    \
    \                  `+` cannot be used to concatenate a `&str` with a `String`\n\
    \   |     &str\n   |\nhelp: `to_owned()` can be used to create an owned `St"
  stdout: ''
  timestamp: 1659805826
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = string;\n    let\
    \ mut i = 0;\n    while i < string.len() {\n        let mut j = i;\n        while\
    \ j + 1 < string.len() && string[j] == string[j + 1] {\n            j += 1\n \
    \       }\n        reversed_string.push_str(&string[i..j]);\n        i = j;\n\
    \    }\n    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_8ancjgn.rs:17:39\n\
    \   |\n17 |         while j + 1 < string.len() && string[j] == string[j + 1] {\n\
    \   |                                       ^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n \
    \ --> /tmp/tmp_8ancjgn.rs:17:52\n   |\n17 |         while j + 1 < string.len()\
    \ && string[j] == string[j + 1] {\n   |                                      \
    \              ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805824
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n\n    while\
    \ !string.is_empty() {\n        let mut index = string.len() - 1;\n        let\
    \ mut char = &string[index];\n\n        while index >= 0 {\n            if char\
    \ != &string[index] {\n                break;\n            }\n\n            index\
    \ -= 1;\n        }\n\n        reversed_string.push_str(&string[index..]);\n  \
    \      string.push_str(&char);\n    }\n\n    reversed_string\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_w5t24vk.rs:17:25\n\
    \   |\n17 |         let mut char = &string[index];\n   |                     \
    \    ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmp_w5t24vk.rs:20:25\n   |\n\
    20 |             if char != &string[index] {\n   |                         ^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0599]: no method named `push_str`\
    \ found for reference `&str` in the current scope\n  --> /tmp/tmp_w5t24vk.rs:27:25\n\
    \   |\n27 |         reversed_string.push_str(&string[index..]);\n   |        \
    \                 ^^^^^^^^ method not found in `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_w5t24vk.rs:31:5\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |                                       ------ expected\
    \ `String` because of return type\n...\n31 |     reversed_string\n   |     ^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805826
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut palindrome = string;\n    let mut prefix_len = 0;\n    let mut suffix_len\
    \ = 0;\n    while palindrome.len() > 0 {\n        let mut prefix_len = palindrome.len();\n\
    \        while prefix_len > 0 {\n            let mut suffix_len = palindrome.len();\n\
    \            while suffix_len > 0 {\n                let mut index = palindrome.find('a',\
    \ prefix_len);\n                if index == -1 {\n                    break;\n\
    \                }\n                let mut suffix = palindrome[index..].chars().collect::<String>();\n\
    \                suffix.reverse();\n                palindrome = &palindrome[..index]\
    \ + &suffix + &palindrome[index..];\n                suffix_len -= 1;\n      \
    \      }\n            prefix_len -= 1;\n        }\n        palindrome = &palindrome[..palindrome.len()]\
    \ + &palindrome[palindrome.len()..];\n    }\n    palindrome\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpk1ohrb4k.rs:20:44\n     |\n20   |                 let mut index\
    \ = palindrome.find('a', prefix_len);\n     |                                \
    \            ^^^^ ---  ---------- supplied 2 arguments\n     |               \
    \                             |\n     |                                      \
    \      expected 1 argument\n     |\nnote: associated function defined here\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpk1ohrb4k.rs:21:29\n   |\n21 |  \
    \               if index == -1 {\n   |                             ^^\n   |  \
    \                           |\n   |                             expected enum\
    \ `Option`, found integer\n   |                             help: try using a\
    \ variant of the expected enum: `Some(-1)`\n   |\n   = note: expected enum `Option<usize>`\n\
    \              found type `{integer}`\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `RangeFrom<Option<usize>>`\n  --> /tmp/tmpk1ohrb4k.rs:24:34\n\
    \   |\n24 |                 let mut suffix = palindrome[index..].chars().collect::<String>();\n\
    \   |                                  ^^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `RangeFrom<Option<usize>>`\n   |\n   = help: the trait `Index<RangeFrom<Option<usize>>>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `RangeTo<Option<usize>>`\n  --> /tmp/tmpk1ohrb4k.rs:26:31\n   |\n\
    26 |                 palindrome = &palindrome[..index] + &suffix + &palindrome[index..];\n\
    \   |                               ^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `RangeTo<Option<usize>>`\n   |\n   = help: the trait `Index<RangeTo<Option<usize>>>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `RangeFrom<Option<usize>>`\n  --> /tmp/tmpk1ohrb4k.rs:26:64\n   |\n\
    26 |                 palindrome = &palindrome[..index] + &suffix + &palindrome[index..];\n\
    \   |                                                                ^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `RangeFrom<Option<usize>>`\n   |\n "
  stdout: ''
  timestamp: 1659805826
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix = \"\";\n    let mut longest_postfix_len = 0;\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_index2 = 0;\n    let mut longest_postfix_index3\
    \ = 0;\n    let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5\
    \ = 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut longest_postfix_index44 = 0;\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt0n0hdrg.rs:11:39\n   |\n\
    11 | fn make_palindrome(string: String) -> String {\n   |    --------------- \
    \                   ^^^^^^ expected struct `String`, found `()`\n   |    |\n \
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805824
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix = \"\";\n    let mut longest_postfix_len = 0;\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_index2 = 0;\n    let mut longest_postfix_index3\
    \ = 0;\n    let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5\
    \ = 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut longest_postfix_index44 = 0;\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt0n0hdrg.rs:11:39\n   |\n\
    11 | fn make_palindrome(string: String) -> String {\n   |    --------------- \
    \                   ^^^^^^ expected struct `String`, found `()`\n   |    |\n \
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659805824
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reverse = string;\n    let mut i =\
    \ 0;\n    while i < string.len() {\n        let mut j = i;\n        while j <\
    \ string.len() {\n            if string[j] != string[i] {\n                break;\n\
    \            }\n            i += 1;\n            j = i;\n        }\n        if\
    \ j == i {\n            break;\n        }\n        reverse.push_str(&string[j..i]);\n\
    \    }\n    reverse\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpmhwfjtij.rs:18:16\n\
    \   |\n18 |             if string[j] != string[i] {\n   |                ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpmhwfjtij.rs:18:29\n   |\n18 |            \
    \ if string[j] != string[i] {\n   |                             ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659805826
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut suffix_length = 0;\n    let\
    \ mut prefix_length = 0;\n    while suffix_length != string.length {\n       \
    \ let mut suffix_start = suffix_length;\n        let mut suffix_end = suffix_length;\n\
    \        let mut prefix_start = prefix_length;\n        let mut prefix_end = prefix_length;\n\
    \        while suffix_start != suffix_end {\n            if suffix_start == suffix_end\
    \ {\n                suffix_start += 1;\n                suffix_end += 1;\n  \
    \          } else {\n                suffix_start += 1;\n            }\n     \
    \   }\n        while prefix_start != prefix_end {\n            if prefix_start\
    \ == prefix_end {\n                prefix_start += 1;\n                prefix_end\
    \ += 1;\n            } else {\n                prefix_start += 1;\n          \
    \  }\n        }\n        if suffix_start == suffix_end {\n            suffix_length\
    \ += 1;\n        } else {\n            suffix_length += 1;\n            suffix_start\
    \ = suffix_end;\n        }\n        if prefix_start == prefix_end {\n        \
    \    prefix_length += 1;\n        } else {\n            prefix_length += 1;\n\
    \            prefix_start = prefix_end;\n        }\n    }\n    reversed_string.push_str(&string[prefix_length..]);\n\
    \    reversed_string.push_str(&string[..suffix_length]);\n    reversed_string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `length` on type `String`\n  --> /tmp/tmp4jjxlqe2.rs:15:35\n\
    \   |\n15 |     while suffix_length != string.length {\n   |                 \
    \                  ^^^^^^ unknown field\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0609`.\n"
  stdout: ''
  timestamp: 1659805826
