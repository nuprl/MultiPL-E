name: HumanEval_90_next_smallest
language: rs
prompt: "/// You are given a vector of integers.\n/// Write a function next_smallest()\
  \ that returns the 2nd smallest element of the vector.\n/// Return None if there\
  \ is no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// 2\n/// >>>\
  \ next_smallest(vec![5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(vec![])\n///\
  \ None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
  \ -> Option<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!(candidate(vec![1,\
  \ 2, 3, 4, 5]), Some(2));\n    assert_eq!(candidate(vec![5, 1, 4, 3, 2]), Some(2));\n\
  \    assert_eq!(candidate(Vec::<isize>::new()), None);\n    assert_eq!(candidate(vec![1,\
  \ 1]), None);\n    assert_eq!(candidate(vec![1, 1, 1, 1, 0]), Some(1));\n    assert_eq!(candidate(vec![1,\
  \ 1]), None);\n    assert_eq!(candidate(vec![-35, 34, 12, -45]), Some(-35));\n}\n"
completions: ["    let mut smallest = lst[0];\n    let mut smallest_index = 0;\n \
    \   for &i in lst {\n        if i < smallest {\n            smallest = i;\n  \
    \          smallest_index = 1;\n        }\n        if i == smallest {\n      \
    \      smallest_index += 1;\n        }\n    }\n    Some(smallest)", "    let mut\
    \ smallest = vec![0; lst.len()];\n    let mut smallest_idx = 0;\n    let mut smallest_val\
    \ = lst.iter().min().unwrap();\n    for &v in lst {\n        if v < smallest_val\
    \ {\n            smallest_val = v;\n            smallest_idx = lst.iter().position(|&x|\
    \ x == smallest_val).unwrap();\n        }\n        smallest[smallest_idx] = v;\n\
    \    }\n    smallest\n        .iter()\n        .position(|&x| x == smallest_val)\n\
    \        .map(|idx| smallest[smallest_idx])", "    if lst.is_empty() {\n     \
    \   return None;\n    }\n    let mut smallest = lst.iter().min().unwrap();\n \
    \   let mut smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \    if smallest_index == lst.len() - 1 {\n        return Some(smallest);\n  \
    \  }\n    let mut smallest_value = lst.iter().nth(smallest_index + 1).unwrap();\n\
    \    if smallest_value == smallest {\n        smallest_value = lst.iter().nth(smallest_index).unwrap();\n\
    \    }\n    Some(smallest_value)", '    lst.iter().cloned().enumerate().find(|(_,
    elem)| elem < lst.iter().next().unwrap()).map(|(_, elem)| elem)', "    if lst.len()\
    \ == 0 {\n        return None;\n    }\n\n    let mut smallest = lst.iter().min().unwrap();\n\
    \    let mut smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \    if smallest_index == lst.len() - 1 {\n        smallest_index = 0;\n    }\n\
    \n    Some(smallest)", "    let mut smallest = lst[0];\n    let mut smallest_index\
    \ = 0;\n    for &i in lst {\n        if i < smallest {\n            smallest =\
    \ i;\n            smallest_index = 1;\n        }\n        if i == smallest {\n\
    \            smallest_index += 1;\n        }\n    }\n    if smallest_index ==\
    \ lst.len() {\n        return None;\n    }\n    Some(smallest)", "    let mut\
    \ smallest = vec![std::i32::MAX; 2];\n    for elt in lst {\n        if smallest[0]\
    \ < elt {\n            smallest[0] = elt;\n        }\n        if smallest[1] <\
    \ elt {\n            smallest[1] = elt;\n        }\n    }\n    if smallest[0]\
    \ == std::i32::MAX {\n        None\n    } else {\n        Some(smallest[1])\n\
    \    }", "    let mut smallest = lst[0];\n    let mut smallest_idx = 1;\n    for\
    \ &x in lst {\n        if x < smallest {\n            smallest = x;\n        \
    \    smallest_idx = 1;\n        } else if x == smallest {\n            smallest_idx\
    \ += 1;\n        }\n    }\n    Some(smallest)", '    lst.iter().cloned().enumerate().find(|(_,
    i)| i < lst.len() - 2)', "    if lst.len() == 0 {\n        return None;\n    }\n\
    \    let mut smallest = lst[0];\n    let mut smallest_index = 1;\n    for &i in\
    \ lst {\n        if i < smallest {\n            smallest = i;\n            smallest_index\
    \ = 1;\n        } else if i == smallest {\n            smallest_index += 1;\n\
    \        }\n    }\n    Some(smallest + smallest_index * 2)", "    let mut smallest\
    \ = lst.iter().min().unwrap();\n    if smallest == lst.len() {\n        return\
    \ None;\n    }\n    let mut smallest_index = smallest;\n    for index in lst.iter().rev()\
    \ {\n        if index == smallest_index {\n            continue;\n        }\n\
    \        if index < smallest_index {\n            smallest_index = index;\n  \
    \      }\n    }\n    Some(smallest_index)", "    let mut smallest = vec![0; lst.len()];\n\
    \    let mut smallest_index = 0;\n    let mut smallest_value = lst.iter().min().unwrap();\n\
    \    for &x in lst {\n        if x < smallest_value {\n            smallest_value\
    \ = x;\n            smallest_index = 0;\n        }\n        if x == smallest_value\
    \ {\n            smallest_index += 1;\n        }\n        smallest[smallest_index]\
    \ = x;\n    }\n    smallest.iter().nth(1).cloned()", "    let mut smallest = lst.iter().min().unwrap();\n\
    \    let mut smallest_idx = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \    if smallest_idx == lst.len() {\n        return None;\n    }\n    smallest\
    \ = lst.iter().nth(smallest_idx + 1).unwrap();\n    Some(smallest)", "    let\
    \ mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index = lst.iter().position(|&x|\
    \ x == smallest).unwrap();\n    if smallest_index == lst.len() {\n        return\
    \ None;\n    }\n    let mut smallest_value = lst.iter().nth(smallest_index).unwrap();\n\
    \    if smallest_index == 0 {\n        smallest_index = 1;\n    }\n    while smallest_index\
    \ != 0 {\n        if smallest_value < lst.iter().nth(smallest_index - 1).unwrap()\
    \ {\n            smallest_value = lst.iter().nth(smallest_index).unwrap();\n \
    \           smallest_index = smallest_index - 1;\n        } else {\n         \
    \   smallest_index = 0;\n        }\n    }\n    Some(smallest_value)", "    let\
    \ mut smallest = vec![std::i32::MAX; 2];\n    for &x in lst {\n        if x <\
    \ smallest[0] {\n            smallest[0] = x;\n        }\n        if x > smallest[1]\
    \ {\n            smallest[1] = x;\n        }\n    }\n    if smallest[0] == smallest[1]\
    \ {\n        None\n    } else {\n        Some(smallest[1])\n    }", '    lst.iter().cloned().enumerate().find(|(_,
    elem)| elem < lst.iter().next().unwrap()).map(|(_, elem)| elem)', "    if lst.len()\
    \ <= 1 {\n        return None;\n    }\n    let mut smallest = vec![0; lst.len()];\n\
    \    smallest[0] = lst[0];\n    smallest[1] = lst[1];\n    for i in 2..lst.len()\
    \ {\n        if smallest[i] > smallest[i - 1] {\n            smallest[i] = smallest[i\
    \ - 1];\n        }\n    }\n    smallest\n        .iter()\n        .next()\n  \
    \      .cloned()\n        .ok_or(Error::NoSuchElement)", "    if lst.len() ==\
    \ 0 {\n        return None;\n    }\n    let mut smallest = lst.iter().min().unwrap();\n\
    \    let mut smallest_index = lst.iter().position(|x| x == smallest).unwrap();\n\
    \    if smallest_index == lst.len() - 1 {\n        smallest_index = 0;\n    }\n\
    \    Some(smallest[smallest_index + 1])", "    if lst.len() == 0 {\n        return\
    \ None;\n    }\n    let mut smallest = lst.iter().min().unwrap();\n    let mut\
    \ smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n    if smallest_index\
    \ == lst.len() - 1 {\n        return Some(smallest);\n    }\n    let mut smallest_value\
    \ = lst.iter().nth(smallest_index).unwrap();\n    let mut smallest_index = lst.iter().position(|x|\
    \ *x == smallest_value).unwrap();\n    if smallest_index == lst.len() - 1 {\n\
    \        return Some(smallest);\n    }\n    let mut smallest_value = lst.iter().nth(smallest_index).unwrap();\n\
    \    let mut smallest_index = lst.iter().position(|x| *x == smallest_value).unwrap();\n\
    \    if smallest_index == lst.len() - 1 {\n        return Some(smallest);\n  \
    \  }\n    let mut smallest_value = lst.iter().nth(smallest_index).unwrap();\n\
    \    let mut smallest_index = lst.iter().position(|x| *x == smallest_value).unwrap();\n\
    \    if smallest_index == lst.len() - 1 {\n        return Some(smallest);\n  \
    \  }\n    let mut smallest_value = lst.iter().nth(smallest_index).unwrap();\n\
    \    let mut smallest_index = lst.iter().position(|x| *x == smallest_value).unwrap();\n\
    \    if smallest_index == lst.len() - 1 {\n        return Some(smallest);\n  \
    \  }\n    let mut smallest_value = lst.iter().nth(smallest_index).unwrap();\n\
    \    let mut smallest_index = lst.iter().position(|x| *x == smallest_value).unwrap();\n\
    \    if smallest_index == lst.len() - 1 {\n        return Some(smallest);\n  \
    \  }\n    let mut smallest_value = lst.iter().nth(smallest_index).unwrap();\n\
    \    let mut smallest_index = lst.iter().position(|x| *x == smallest_value).unwrap();\n\
    \    if smallest_index == lst.len() - 1 {\n        return Some(smallest);\n  \
    \  }\n    let mut smallest_value = lst.iter().nth(smallest_index).unwrap();\n\
    \    let mut smallest_index = lst.iter().position(|x| *x == smallest_value).unwrap();\n\
    \    if smallest_index == lst.len() - 1 {\n        return Some(smallest);\n  \
    \  }\n    let mut smallest_value = lst.iter().", "    if lst.len() == 0 {\n  \
    \      return None;\n    }\n    let mut smallest = vec![0; lst.len()];\n    let\
    \ mut smallest_idx = 1;\n    let mut smallest_val = lst[0];\n    for &i in lst\
    \ {\n        if smallest[smallest_idx] < i {\n            smallest[smallest_idx]\
    \ = i;\n            smallest_idx = smallest_idx + 1;\n        }\n    }\n    if\
    \ smallest_idx == lst.len() {\n        return None;\n    }\n    Some(smallest[smallest_idx])"]
stop_tokens:
- "\n}"
