name: HumanEval_17_parse_music
language: rs
results:
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  for c in music_string.chars() {\n        if c.is_ascii() {\n            current_note\
    \ += c.to_string();\n        } else {\n            if current_note.len() == 1\
    \ {\n                beats.push(current_beat);\n                current_beat =\
    \ 0;\n                current_note = String::new();\n            }\n         \
    \   current_note += c.to_string();\n        }\n    }\n    beats.push(current_beat);\n\
    \    current_beat = 0;\n    current_note.len()\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptjecruyd.rs:16:29\n   |\n\
    16 |             current_note += c.to_string();\n   |                        \
    \     ^^^^^^^^^^^^^\n   |                             |\n   |                \
    \             expected `&str`, found struct `String`\n   |                   \
    \          help: consider borrowing here: `&c.to_string()`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmptjecruyd.rs:23:29\n   |\n23 |             current_note\
    \ += c.to_string();\n   |                             ^^^^^^^^^^^^^\n   |    \
    \                         |\n   |                             expected `&str`,\
    \ found struct `String`\n   |                             help: consider borrowing\
    \ here: `&c.to_string()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptjecruyd.rs:28:5\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |       \
    \                                  ---------- expected `Vec<isize>` because of\
    \ return type\n...\n28 |     current_note.len()\n   |     ^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \                found type `usize`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_index = 0;\n    let mut current_note_length = 0;\n   \
    \ let mut current_note_length_index = 0;\n    let mut current_note_length_value\
    \ = 0;\n    let mut current_note_length_value_index = 0;\n    let mut current_note_length_value_value\
    \ = 0;\n    let mut current_note_length_value_value_index = 0;\n    let mut current_note_length_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ \n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpqbwv8sxp.rs:57:1\n  \
    \ |\n57 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat: isize = 0;\n    let mut current_note =\
    \ String::new();\n    let mut current_octave: isize = 0;\n    let mut current_note_len:\
    \ isize = 0;\n    let mut current_note_octave: isize = 0;\n    let mut current_note_octave_len:\
    \ isize = 0;\n    let mut current_note_octave_octave: isize = 0;\n    let mut\
    \ current_note_octave_octave_len: isize = 0;\n    let mut current_note_octave_octave_octave:\
    \ isize = 0;\n    let mut current_note_octave_octave_octave_len: isize = 0;\n\
    \    let mut current_note_octave_octave_octave_octave: isize = 0;\n    let mut\
    \ current_note_octave_octave_octave_octave_len: isize = 0;\n    let mut current_note_octave_octave_octave_octave_octave:\
    \ isize = 0;\n    let mut current_note_octave_octave_octave_octave_octave_len:\
    \ isize = 0;\n    let mut current_note_octave_octave_octave_octave_octave_octave:\
    \ isize = 0;\n    let mut current_note_octave_octave_octave_octave_octave_len:\
    \ isize = 0;\n    let mut current_note_octave_octave_octave_octave_octave_octave_len:\
    \ isize = 0;\n    let mut current_note_octave_octave_octave_octave_octave_octave_len:\
    \ isize = 0;\n    let mut current_note_octave_octave_octave_octave_octave_octave_len:\
    \ isize = 0;\n    let mut current_note_octave_octave_octave_octave_octave_octave_len:\
    \ isize = 0;\n    let mut current_note_octave_octave_octave_octave_octave_octave_len:\
    \ isize = 0;\n    let mut current_note_octave_octave_octave_octave_octave_octave_len:\
    \ isize = 0;\n    let mut current_note_octave_octave_octave_octave_octave_octave_octave_len:\
    \ isize = 0;\n    let mut current_note_\n}\n\nfn main() {\n    let candidate =\
    \ parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpm4oa0ida.rs:35:26\n   |\n\
    35 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n36 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpm4oa0ida.rs:10:41\n   |\n10 | fn parse_music(music_string: String) ->\
    \ Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_type = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = \n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp72a27wew.rs:58:1\n\
    \   |\n58 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats_vec: Vec<isize>\
    \ = Vec::new();\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    for c in music_string {\n        if c == 'o' {\n            if current_beat\
    \ > 0 {\n                beats_vec.push(current_beat);\n                current_beat\
    \ = 0;\n            }\n            current_note = String::new();\n        } else\
    \ if c == '|' {\n            if current_note.is_empty() {\n                println!(\"\
    Invalid music string\");\n                break;\n            }\n            beats_vec.push(current_beat);\n\
    \            current_beat = 0;\n            current_note = String::new();\n  \
    \      } else if c == '.' {\n            if current_note.is_empty() {\n      \
    \          println!(\"Invalid music string\");\n                break;\n     \
    \       }\n            beats_vec.push(current_beat);\n            current_beat\
    \ = 0;\n            current_note = String::new();\n        } else {\n        \
    \    current_note.push(c);\n            current_beat += 1;\n        }\n    }\n\
    \    if current_beat > 0 {\n        beats_vec.push(current_beat);\n    }\n   \
    \ beats_vec\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp3em3lwo3.rs:14:14\n\
    \   |\n14 |     for c in music_string {\n   |              ^^^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  for c in music_string.chars() {\n        if c.is_ascii() {\n            if\
    \ c.to_ascii_lowercase() == 'o' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            } else if c.to_ascii_lowercase() == 'o' {\n                current_beat\
    \ += 1;\n            } else if c.to_ascii_lowercase() == '.' {\n             \
    \   current_beat += 1;\n            } else {\n                current_note +=\
    \ c.to_ascii_lowercase();\n            }\n        } else {\n            current_note\
    \ += c.to_ascii_lowercase();\n        }\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4kax25qq.rs:25:33\n   |\n\
    25 |                 current_note += c.to_ascii_lowercase();\n   |           \
    \                      ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp4kax25qq.rs:28:29\n   |\n28 |  \
    \           current_note += c.to_ascii_lowercase();\n   |                    \
    \         ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_to_beat = 0;\n    let mut current_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length = 0;\n    let\
    \ mut current_note_length_to_beat_with_note_length_to_beat = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_n1b7pib.rs:32:96\n   |\n\
    32 |     let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_\n\
    \   |                                                                        \
    \                        ^ help: add `;` here\n33 | }\n   | - unexpected token\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_n1b7pib.rs:10:41\n   |\n10 |\
    \ fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------  \
    \                        ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |  \
    \  |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut notes: Vec<&str> = music_string.split_whitespace().collect();\n\
    \    let mut last_note = String::from(\"\");\n    let mut last_beat = 0;\n   \
    \ let mut last_beat_index = 0;\n    let mut last_beat_index2 = 0;\n    let mut\
    \ last_beat_index3 = 0;\n    let mut last_beat_index4 = 0;\n    let mut last_beat_index5\
    \ = 0;\n    let mut last_beat_index6 = 0;\n    let mut last_beat_index7 = 0;\n\
    \    let mut last_beat_index8 = 0;\n    let mut last_beat_index9 = 0;\n    let\
    \ mut last_beat_index10 = 0;\n    let mut last_beat_index11 = 0;\n    let mut\
    \ last_beat_index12 = 0;\n    let mut last_beat_index13 = 0;\n    let mut last_beat_index14\
    \ = 0;\n    let mut last_beat_index15 = 0;\n    let mut last_beat_index16 = 0;\n\
    \    let mut last_beat_index17 = 0;\n    let mut last_beat_index18 = 0;\n    let\
    \ mut last_beat_index19 = 0;\n    let mut last_beat_index20 = 0;\n    let mut\
    \ last_beat_index21 = 0;\n    let mut last_beat_index22 = 0;\n    let mut last_beat_index23\
    \ = 0;\n    let mut last_beat_index24 = 0;\n    let mut last_beat_index25 = 0;\n\
    \    let mut last_beat_index26 = 0;\n    let mut last_beat_index27 = 0;\n    let\
    \ mut last_beat_index28 = 0;\n    let mut last_beat_index29 = 0;\n    let mut\
    \ last_beat_index30 = 0;\n    let mut last_beat_index31 = 0;\n    let mut last_beat_index32\
    \ = 0;\n    let mut last_beat_index33 = 0;\n    let mut last_beat_index34 = 0;\n\
    \    let mut last_beat_index35 = 0;\n    let mut last_beat_index36 = 0;\n    let\
    \ mut last_beat_index37 = 0;\n    let mut last_beat_index38 = 0;\n    let mut\
    \ last_beat_index39 = 0;\n    let mut last_beat_index40 = 0;\n    let mut last_beat_index41\
    \ = 0;\n    let mut last_beat_index42 = 0;\n    let mut last_beat_index43 = 0;\n\
    \    let mut last_beat_index44 = 0;\n    let mut last_beat_index45 = 0;\n    let\
    \ mut last_beat_index46 = 0;\n    let mut last_beat_index47 = 0;\n    let mut\
    \ last_beat_index48 = 0;\n    let mut last_beat_index49 = 0;\n    let mut last_beat_index50\
    \ = 0;\n    let mut last_beat_index51 = 0;\n    let mut last_beat\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwe7lv08w.rs:66:22\n   |\n\
    66 |     let mut last_beat\n   |                      ^ help: add `;` here\n67\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwe7lv08w.rs:10:41\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = Vec::new();\n\
    \    let mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 1;\n    let mut current_note_length_index42\
    \ = 1;\n    let mut current_note_length_index43 = 1;\n    let mut current_note_length_index44\
    \ = 1;\n    let mut current_note_length_index45 = 1;\n    let mut current_note_length_index46\
    \ = 1;\n    let mut current_note_length_index47 = 1;\n    let mut current_note_length_index48\
    \ = 1;\n    let mut \n}\n\nfn main() {\n    let candidate = parse_music;\n   \
    \ assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpettriq6r.rs:64:1\n\
    \   |\n64 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let \n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp7sfaoq0w.rs:59:1\n  \
    \ |\n59 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut notes: Vec<&str> = music_string.split_whitespace().collect();\n\
    \    let mut current_note = notes.clone();\n    let mut current_beat = 0;\n  \
    \  while current_note.is_not_empty() {\n        let note = current_note.clone();\n\
    \        let beat = current_beat;\n        if note == \"o\" {\n            beats.push(beat);\n\
    \            current_beat += 4;\n        } else if note == \"o|\" {\n        \
    \    beats.push(beat);\n            current_beat += 2;\n        } else if note\
    \ == \".|\" {\n            beats.push(beat);\n            current_beat += 1;\n\
    \        } else {\n            beats.push(beat);\n            current_beat +=\
    \ 1;\n        }\n        current_note.pop();\n    }\n    beats\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_not_empty` found for struct `Vec<&str>`\
    \ in the current scope\n  --> /tmp/tmpdnp9z8zc.rs:15:24\n   |\n15 |     while\
    \ current_note.is_not_empty() {\n   |                        ^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `is_empty`\n\nerror[E0277]:\
    \ can't compare `Vec<&str>` with `&str`\n  --> /tmp/tmpdnp9z8zc.rs:18:17\n   |\n\
    18 |         if note == \"o\" {\n   |                 ^^ no implementation for\
    \ `Vec<&str> == &str`\n   |\n   = help: the trait `PartialEq<&str>` is not implemented\
    \ for `Vec<&str>`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n             <Vec<T, A> as\
    \ PartialEq<&[U; N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n         \
    \    <Vec<T, A> as PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<[U]>>\n\nerror[E0277]: can't compare\
    \ `Vec<&str>` with `&str`\n  --> /tmp/tmpdnp9z8zc.rs:21:24\n   |\n21 |       \
    \  } else if note == \"o|\" {\n   |                        ^^ no implementation\
    \ for `Vec<&str> == &str`\n   |\n   = help: the trait `PartialEq<&str>` is not\
    \ implemented for `Vec<&str>`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n\
    \             <Vec<T, A> as PartialEq<&[U; N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n\
    \             <Vec<T, A> as PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<[U]>>\n\nerror[E0277]: can't compare\
    \ `Vec<&str>` with `&str`\n  --> /tmp/tmpdnp9z8zc.rs:24:24\n   |\n24 |       \
    \  } else if note == \".|\" {\n   |                        ^^ no implementation\
    \ for `Vec<&str> == &str`\n   |\n   = help: the trait `PartialEq<&str>` is not\
    \ implemented for `Vec<&str>`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n\
    \             <Vec<T, A> as PartialEq<&[U; N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n\
    \             <Vec<T, A"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut notes: Vec<&str> = music_string.split_whitespace().collect();\n\
    \    let mut current_note = 0;\n    let mut current_beat = 0;\n    let mut current_beats:\
    \ isize = 0;\n    while notes.len() > 0 {\n        let note = notes.remove(0);\n\
    \        note = note.chars().next().unwrap();\n        if note == 'o' {\n    \
    \        beats.push(current_beats);\n            current_beats += 4;\n       \
    \     current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_beat\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpj6my49f0.rs:90:3\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |       \
    \                                             - unclosed delimiter\n...\n16 |\
    \     while notes.len() > 0 {\n   |                           - unclosed delimiter\n\
    ...\n19 |         if note == 'o' {\n   |                        - this delimiter\
    \ might not be properly closed...\n...\n81 | }\n   | - ...as it matches this but\
    \ it has different indentation\n...\n90 | }\n   |   ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpj6my49f0.rs:18:16\n   |\n17 |         let note = notes.remove(0);\n\
    \   |                    --------------- expected due to this value\n18 |    \
    \     note = note.chars().next().unwrap();\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found `char`\n\nerror[E0277]: can't compare `&str` with `char`\n\
    \  --> /tmp/tmpj6my49f0.rs:19:17\n   |\n19 |         if note == 'o' {\n   |  \
    \               ^^ no implementation for `&str == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&str`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj6my49f0.rs:80:13\n\
    \   |\n19 | /         if note == 'o' {\n20 | |             beats.push(current_beats);\n\
    21 | |             current_beats += 4;\n22 | |             current_beats += current_beats;\n\
    ...  |\n80 | |             current_beat\n   | |             ^^^^^^^^^^^^ expected\
    \ `()`, found integer\n81 | | }\n   | |_- expected this to be `()`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpj6my49f0.rs:16:5\n   |\n10 |   fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n   |                   "
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_note_length = 0;\n    let mut current_note_length_index =\
    \ 0;\n    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut current_note_length_index45\
    \ = 0;\n    let mut current_note_length_index46 = 0;\n    let mut current_note_length_index47\
    \ = 0;\n    let mut current_note_\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpi0rwqg7u.rs:62:26\n   |\n\
    62 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n63 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpi0rwqg7u.rs:10:41\n   |\n10 | fn parse_music(music_string: String) ->\
    \ Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = 0;\n    for c in music_string.chars() {\n   \
    \     if c.is_ascii() {\n            if c.to_ascii_lowercase() == 'o' {\n    \
    \            beats.push(current_beat);\n                current_beat = 0;\n  \
    \              current_note = String::new();\n                current_note_length\
    \ = 0;\n            } else if c.to_ascii_lowercase() == 'o' {\n              \
    \  current_note_length += 1;\n            } else if c.to_ascii_lowercase() ==\
    \ '|' {\n                current_beat += 1;\n            } else if c.to_ascii_lowercase()\
    \ == '.' {\n                current_beat += 1;\n            }\n        } else\
    \ {\n            current_note.push(c);\n            current_note_length += 1;\n\
    \        }\n    }\n    beats.push(current_beat);\n    current_beat = 0;\n    current_note\
    \ = String::new();\n    current_note_length = 0;\n    for c in music_string.chars()\
    \ {\n        if c.is_ascii() {\n            if c.to_ascii_lowercase() == 'o' {\n\
    \                beats.push(current_beat);\n                current_beat = 0;\n\
    \                current_note = String::new();\n                current_note_length\
    \ = 0;\n            } else if c.to_ascii_lowercase() == 'o' {\n              \
    \  current_note_length += 1;\n            } else if c.to_ascii_lowercase() ==\
    \ '|' {\n                current_beat += 1;\n            } else if c.to_ascii_lowercase()\
    \ == '.' {\n                current_beat += 1;\n            }\n        } else\
    \ {\n            current_note.push(c);\n            current_note_length += 1;\n\
    \        }\n    }\n    beats.push(current_beat);\n    current_beat = 0;\n    current_note\
    \ = String::new();\n    current_note_length = 0;\n    for c in music_string.chars()\
    \ {\n        if c.is_ascii() {\n            if c.to_ascii_lowercase() == 'o' {\n\
    \                beats.push(current_beat);\n                current_beat = 0;\n\
    \                current_note = String::new();\n                current_note_length\
    \ = 0;\n            } else if c.to_ascii_lowercase() == 'o' {\n              \
    \  current_note_length += 1;\n            } else if c.to_ascii_lowercase() ==\
    \ '|' {\n                current_beat += 1;\n            } else if c.to_ascii_lowercase()\
    \ == '.' {\n                current_beat += 1;\n            }\n        } else\
    \ {\n            current_note.push(c);\n            current_note_length += 1;\n\
    \        }\n    }\n    beats.push(current_beat);\n    current_beat = 0;\n    current_note\
    \ = String::new();\n    current_note_length = 0;\n    for c in music_string.chars()\
    \ {\n        if c.is_ascii() {\n            if c.to_ascii_lowercase() == 'o' {\n\
    \                beats.push(current_beat);\n                current_beat = 0;\n\
    \                current_note = String\n}\n\nfn main() {\n    let candidate =\
    \ parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpw9a6dwhe.rs:99:3\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |       \
    \                                             - unclosed delimiter\n...\n84 |\
    \     for c in music_string.chars() {\n   |                                  \
    \ - unclosed delimiter\n85 |         if c.is_ascii() {\n   |                 \
    \        - unclosed delimiter\n86 |             if c.to_ascii_lowercase() == 'o'\
    \ {\n   |                                              - this delimiter might\
    \ not be properly closed...\n...\n90 | }\n   | - ...as it matches this but it\
    \ has different indentation\n...\n99 | }\n   |   ^\n\nerror[E0423]: expected value,\
    \ found struct `String`\n   --> /tmp/tmpw9a6dwhe.rs:89:32\n    |\n89  |      \
    \             current_note = String\n    |                                  ^^^^^^\
    \ help: use struct literal syntax instead: `String { vec: val }`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpw9a6dwhe.rs:84:5\n   |\n10 |   fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n   |                                           ----------\
    \ expected `Vec<isize>` because of return type\n...\n84 | /     for c in music_string.chars()\
    \ {\n85 | |         if c.is_ascii() {\n86 | |             if c.to_ascii_lowercase()\
    \ == 'o' {\n87 | |                 beats.push(current_beat);\n...  |\n98 | | \
    \    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o o|\")), vec![2, 1,\
    \ 2, 1, 4, 2, 4, 2]);\n99 | | }\n   | |__^ expected struct `Vec`, found `()`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0423.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let \n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmptaryoovv.rs:59:1\n  \
    \ |\n59 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut notes: Vec<&str> = vec![];\n    let mut current_note\
    \ = String::from(\"\");\n    let mut current_beat = 0;\n    let mut current_octave\
    \ = 0;\n    let mut current_length = 0;\n    let mut current_length_index = 0;\n\
    \    let mut current_length_index2 = 0;\n    let mut current_length_index3 = 0;\n\
    \    let mut current_length_index4 = 0;\n    let mut current_length_index5 = 0;\n\
    \    let mut current_length_index6 = 0;\n    let mut current_length_index7 = 0;\n\
    \    let mut current_length_index8 = 0;\n    let mut current_length_index9 = 0;\n\
    \    let mut current_length_index10 = 0;\n    let mut current_length_index11 =\
    \ 0;\n    let mut current_length_index12 = 0;\n    let mut current_length_index13\
    \ = 0;\n    let mut current_length_index14 = 0;\n    let mut current_length_index15\
    \ = 0;\n    let mut current_length_index16 = 0;\n    let mut current_length_index17\
    \ = 0;\n    let mut current_length_index18 = 0;\n    let mut current_length_index19\
    \ = 0;\n    let mut current_length_index20 = 0;\n    let mut current_length_index21\
    \ = 0;\n    let mut current_length_index22 = 0;\n    let mut current_length_index23\
    \ = 0;\n    let mut current_length_index24 = 0;\n    let mut current_length_index25\
    \ = 0;\n    let mut current_length_index26 = 0;\n    let mut current_length_index27\
    \ = 0;\n    let mut current_length_index28 = 0;\n    let mut current_length_index29\
    \ = 0;\n    let mut current_length_index30 = 0;\n    let mut current_length_index31\
    \ = 0;\n    let mut current_length_index32 = 0;\n    let mut current_length_index33\
    \ = 0;\n    let mut current_length_index34 = 0;\n    let mut current_length_index35\
    \ = 0;\n    let mut current_length_index36 = 0;\n    let mut current_length_index37\
    \ = 0;\n    let mut current_length_index38 = 0;\n    let mut current_length_index39\
    \ = 0;\n    let mut current_length_index40 = 0;\n    let mut current_length_index41\
    \ = 0;\n    let mut current_length_index42 = 0;\n    let mut current_length_index43\
    \ = 0;\n    let mut current_length_index44 = 0;\n    let mut current_length_index45\
    \ = 0;\n    let mut current_length_index46 = 0;\n    let mut current_length_index47\
    \ = 0;\n    let mut current_length_index48 = 0;\n    let mut current_length_index49\
    \ = 0;\n    let mut current_length_index50 = 0;\n    let mut current_\n}\n\nfn\
    \ main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpql4rf1zi.rs:67:21\n   |\n\
    67 |     let mut current_\n   |                     ^ help: add `;` here\n68 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpql4rf1zi.rs:10:41\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut notes: Vec<&str> = vec![];\n    let mut current_note\
    \ = String::new();\n    let mut current_beat = 0;\n    let mut current_note_length\
    \ = 0;\n    for c in music_string.chars() {\n        if c == 'o' {\n         \
    \   if current_note_length == 0 {\n                notes.push(current_note);\n\
    \                current_note = String::new();\n                current_beat =\
    \ 0;\n                current_note_length = 0;\n            }\n            current_note_length\
    \ += 1;\n        } else if c == '|' {\n            if current_note_length == 0\
    \ {\n                notes.push(current_note);\n                current_note =\
    \ String::new();\n                current_beat = 0;\n                current_note_length\
    \ = 0;\n            }\n            current_note_length += 1;\n        } else if\
    \ c == ' ' {\n            if current_note_length == 0 {\n                notes.push(current_note);\n\
    \                current_note = String::new();\n                current_beat =\
    \ 0;\n                current_note_length = 0;\n            }\n            current_note_length\
    \ += 1;\n        } else {\n            if current_note_length == 0 {\n       \
    \         notes.push(current_note);\n                current_note = String::new();\n\
    \                current_beat = 0;\n                current_note_length = 0;\n\
    \            }\n            current_note_length += 1;\n            current_note.push_str(&c);\n\
    \        }\n    }\n    for note in notes {\n        beats.push(current_beat +\
    \ 4);\n    }\n    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnrv0omhw.rs:19:28\n   |\n\
    19 |                 notes.push(current_note);\n   |                         \
    \   ^^^^^^^^^^^^\n   |                            |\n   |                    \
    \        expected `&str`, found struct `String`\n   |                        \
    \    help: consider borrowing here: `&current_note`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnrv0omhw.rs:27:28\n   |\n27 |                 notes.push(current_note);\n\
    \   |                            ^^^^^^^^^^^^\n   |                          \
    \  |\n   |                            expected `&str`, found struct `String`\n\
    \   |                            help: consider borrowing here: `&current_note`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnrv0omhw.rs:35:28\n   |\n35 |\
    \                 notes.push(current_note);\n   |                            ^^^^^^^^^^^^\n\
    \   |                            |\n   |                            expected `&str`,\
    \ found struct `String`\n   |                            help: consider borrowing\
    \ here: `&current_note`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnrv0omhw.rs:43:28\n\
    \   |\n43 |                 notes.push(current_note);\n   |                  \
    \          ^^^^^^^^^^^^\n   |                            |\n   |             \
    \               expected `&str`, found struct `String`\n   |                 \
    \           help: consider borrowing here: `&current_note`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnrv0omhw.rs:49:35\n   |\n49 |             current_note.push_str(&c);\n\
    \   |                                   ^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 5 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let \n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp7fguayyd.rs:59:1\n  \
    \ |\n59 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut notes: Vec<&'static str> = vec![];\n    let mut last_note\
    \ = String::new();\n    let mut last_beat = 0;\n    let mut last_beat_size = 0;\n\
    \    let mut last_beat_length = 0;\n    let mut last_beat_length_size = 0;\n \
    \   let mut last_beat_length_length = 0;\n    let mut last_beat_length_length_size\
    \ = 0;\n    let mut last_beat_length_length_length = 0;\n    let mut last_beat_length_length_length_size\
    \ = 0;\n    let mut last_beat_length_length_length_length = 0;\n    let mut last_beat_length_length_length_length_size\
    \ = 0;\n    let mut last_beat_length_length_length_length_length = 0;\n    let\
    \ mut last_beat_length_length_length_length_length_size = 0;\n    let mut last_beat_length_length_length_length_length_size\
    \ = 0;\n    let mut last_beat_length_length_length_length_length_length = 0;\n\
    \    let mut last_beat_length_length_length_length_length_size = 0;\n    let mut\
    \ last_beat_length_length_length_length_length_size = 0;\n    let mut last_beat_length_length_length_length_length_length\
    \ = 0;\n    let mut last_beat_length_length_length_length_length_size = 0;\n \
    \   let mut last_beat_length_length_length_length_length_length_size = 0;\n  \
    \  let mut last_beat_length_length_length_length_length_length = 0;\n    let mut\
    \ last_beat_length_length_length_length_length_size = 0;\n    let mut last_beat_length_length_length_length_length_length\
    \ = 0;\n    let mut last_beat_length_length_length_length_length_size = 0;\n \
    \   let mut last_beat_length_length_length_length_length_length = 0;\n    let\
    \ mut last_beat_length_length_length_length_length_size = 0;\n    let mut last_beat_length_length_length_length_length_length\
    \ = 0;\n    let mut last_beat_length_length_length_length_length_size = 0;\n \
    \   let mut last_beat_length_length_length_length_length_length = 0;\n    let\
    \ mut last_beat_length_length_length_length_length_size = 0;\n    let mut last_beat_length_length_length_length_length_length\
    \ = 0;\n    let mut last_beat_length_length_length_length_length_size = 0;\n \
    \   let mut last_beat_length_length_length_length_length_length = 0;\n    let\
    \ mut last_beat_length_length_length_length_length_size = 0;\n    let mut last_beat_length_length_length_length_length_length\
    \ = 0;\n    let mut last_beat_length_length_length_length_length_size = 0;\n \
    \   let mut last_beat_length_length_length_length_length_length = 0;\n    let\
    \ mu\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmps9am9alz.rs:50:11\n   |\n\
    50 |     let mu\n   |           ^ help: add `;` here\n51 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps9am9alz.rs:10:41\n \
    \  |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return vector\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat: isize = 0;\n    let mut current_note =\
    \ String::new();\n    for c in music_string.chars() {\n        if c.is_ascii()\
    \ {\n            if c.to_ascii_lowercase() == 'o' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            } else {\n                current_note += c.to_ascii_lowercase();\n\
    \            }\n        } else {\n            if current_note.is_empty() {\n \
    \               println!(\"Invalid music string\");\n                return beats;\n\
    \            }\n            beats.push(current_beat);\n            current_beat\
    \ = 0;\n            current_note = String::new();\n        }\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoq54im34.rs:21:33\n   |\n\
    21 |                 current_note += c.to_ascii_lowercase();\n   |           \
    \                      ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
